import {
  s as s2
} from "./chunk-VDJL72FK.js";
import {
  i,
  o as o3
} from "./chunk-HS4TEGJW.js";
import "./chunk-GHN4GWVN.js";
import {
  t as t3
} from "./chunk-P3B4Y6UN.js";
import "./chunk-5QM72RFD.js";
import "./chunk-TJIA4U42.js";
import "./chunk-WQXGIEVZ.js";
import {
  v as v2
} from "./chunk-T3EGKTN6.js";
import "./chunk-ZFPMGEAK.js";
import "./chunk-4SCJM64G.js";
import "./chunk-DABQKFI5.js";
import "./chunk-67V5AGVJ.js";
import {
  $,
  W,
  as
} from "./chunk-DBK2ELNZ.js";
import {
  d as d4
} from "./chunk-DFCSCNHQ.js";
import "./chunk-2ERGO64O.js";
import "./chunk-RP2GKJCD.js";
import "./chunk-QL5HR3YL.js";
import {
  t as t2
} from "./chunk-D3AKDIJC.js";
import {
  h as h3
} from "./chunk-Y37SHKPH.js";
import "./chunk-MD2IQSSQ.js";
import "./chunk-VS26W5Y5.js";
import {
  h as h2
} from "./chunk-PVO5NM6Q.js";
import {
  E
} from "./chunk-L4AYSXFJ.js";
import "./chunk-DM4WHMQY.js";
import {
  y as y2
} from "./chunk-6MR4UDDL.js";
import "./chunk-5YIMTGEC.js";
import {
  e as e4
} from "./chunk-O2DTA3XK.js";
import "./chunk-ZE47C44H.js";
import "./chunk-5GIS2C3K.js";
import "./chunk-XCOHDMBF.js";
import "./chunk-6XGV55XZ.js";
import "./chunk-HOH445RO.js";
import "./chunk-N4KQPPPI.js";
import "./chunk-4OGGMTIH.js";
import "./chunk-NQVBBKAN.js";
import "./chunk-DY7FJHTG.js";
import "./chunk-BQZBOYBD.js";
import "./chunk-TYQXPPSP.js";
import "./chunk-TRSGUVSM.js";
import "./chunk-U3MA63JX.js";
import "./chunk-WYKKCLBI.js";
import "./chunk-PFMGJTQM.js";
import "./chunk-DWASPXVI.js";
import "./chunk-HD65DNIO.js";
import "./chunk-4KWLMXIA.js";
import "./chunk-BIUXKPKA.js";
import "./chunk-634JLXD4.js";
import "./chunk-Y3EDGYWG.js";
import "./chunk-UF6JOUSJ.js";
import "./chunk-T5JGQSO3.js";
import "./chunk-CIW3KHOW.js";
import "./chunk-J55F4AC2.js";
import "./chunk-IQLBZKUD.js";
import "./chunk-7MZZCQ64.js";
import "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import "./chunk-6A7CWJED.js";
import {
  c as c2
} from "./chunk-JM7HAEY6.js";
import {
  p,
  z
} from "./chunk-LJEOBI2I.js";
import {
  t
} from "./chunk-2OMCGIU4.js";
import "./chunk-3RRMLFFN.js";
import "./chunk-DR5TVNEL.js";
import "./chunk-HT2T6PUB.js";
import "./chunk-K64AAM77.js";
import "./chunk-6EUVKE22.js";
import "./chunk-OKJHJ3CY.js";
import "./chunk-XTVPEVHA.js";
import "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import {
  o as o2
} from "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import "./chunk-DZALMCYL.js";
import "./chunk-K226GFDN.js";
import "./chunk-4ZZRP4MA.js";
import "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-HJJIIYFF.js";
import {
  j
} from "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import {
  a as a2,
  c
} from "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import "./chunk-NYQ5CYNR.js";
import {
  _
} from "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import {
  o
} from "./chunk-AXVPJBVW.js";
import {
  n
} from "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import {
  A,
  C,
  P,
  d as d3,
  v
} from "./chunk-6WHTZNUH.js";
import "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import {
  d as d2
} from "./chunk-XNUH25NY.js";
import "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e as e3
} from "./chunk-4Z5SGKRM.js";
import {
  S
} from "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3 as a
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import {
  d,
  h,
  k,
  s
} from "./chunk-HJY2YILU.js";
import {
  e as e2,
  l
} from "./chunk-7DA6A5LD.js";
import {
  e
} from "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import "./chunk-WYIDUUN2.js";
import {
  O
} from "./chunk-DXLOWWK7.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/tileUtils.js
function a3(r, e5) {
  return $(e5.extent, c3), as(c3, o(n2, r.x, r.y, 0));
}
var c3 = W();
var n2 = n();

// ../../../node_modules/@arcgis/core/views/2d/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiles2D.js
var p2 = class extends S {
  get tiles() {
    const e5 = this.tilesCoveringView, t4 = null != this.pointOfInterest ? this.pointOfInterest : this.view.center;
    return e5.sort((e6, i2) => a3(t4, e6) - a3(t4, i2)), e5;
  }
  _scaleEnabled() {
    return t2(this.view.scale, this.layer.minScale || 0, this.layer.maxScale || 0);
  }
  get tilesCoveringView() {
    if (!this.view.ready || !this.view.featuresTilingScheme || !this.view.state || null == this.tileInfo) return [];
    if (!this._scaleEnabled) return [];
    const {
      spans: e5,
      lodInfo: t4
    } = this.view.featuresTilingScheme.getTileCoverage(this.view.state, 0), {
      level: i2
    } = t4, r = [];
    for (const {
      row: o4,
      colFrom: s3,
      colTo: n4
    } of e5) for (let e6 = s3; e6 <= n4; e6++) {
      const s4 = t4.normalizeCol(e6), n5 = new t(null, i2, o4, s4);
      this.tileInfo.updateTileInfo(n5), r.push(n5);
    }
    return r;
  }
  get tileInfo() {
    return this.view.featuresTilingScheme?.tileInfo ?? null;
  }
  get tileSize() {
    return null != this.tileInfo ? this.tileInfo.size[0] : 256;
  }
  constructor(e5) {
    super(e5), this.pointOfInterest = null;
  }
  initialize() {
    this.addHandles(d3(() => this.view?.state?.viewpoint, () => this.notifyChange("tilesCoveringView"), C));
  }
};
e3([y({
  readOnly: true
})], p2.prototype, "tiles", null), e3([y({
  readOnly: true
})], p2.prototype, "_scaleEnabled", null), e3([y({
  readOnly: true
})], p2.prototype, "tilesCoveringView", null), e3([y({
  readOnly: true
})], p2.prototype, "tileInfo", null), e3([y({
  readOnly: true
})], p2.prototype, "tileSize", null), e3([y({
  constructOnly: true
})], p2.prototype, "view", void 0), e3([y({
  constructOnly: true
})], p2.prototype, "layer", void 0), e3([y()], p2.prototype, "pointOfInterest", void 0), p2 = e3([a("esri.views.2d.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles2D")], p2);

// ../../../node_modules/@arcgis/core/views/3d/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiles3D.js
var p3 = class extends S {
  get tiles() {
    const e5 = this.tilesCoveringView, t4 = this._effectivePointOfInterest;
    if (null != t4) {
      const r = e5.map((e6) => a3(t4, e6));
      for (let i2 = 1; i2 < r.length; i2++) if (r[i2 - 1] > r[i2]) return e5.sort((e6, r2) => a3(t4, e6) - a3(t4, r2)), e5.slice();
    }
    return e5;
  }
  get tilesCoveringView() {
    return this._filterTiles(this.view.featureTiles?.tiles?.toArray()).map(u);
  }
  get tileInfo() {
    return this.view.featureTiles?.tilingScheme?.toTileInfo() ?? null;
  }
  get tileSize() {
    return this.view.featureTiles?.tileSize ?? 256;
  }
  get _effectivePointOfInterest() {
    const e5 = this.pointOfInterest;
    return null != e5 ? e5 : this.view.pointsOfInterest?.focus.location;
  }
  constructor(e5) {
    super(e5), this.pointOfInterest = null;
  }
  initialize() {
    this.addHandles(d3(() => this.view.featureTiles, (e5) => {
      this.removeHandles(f), e5 && this.addHandles(e5.addClient(), f);
    }, P));
  }
  _filterTiles(e5) {
    if (null == e5) return [];
    return e5.filter((e6) => {
      const t4 = e6.measures;
      if (t4.visibility === s2.VISIBLE_ON_SURFACE) {
        const e7 = t4.screenRect;
        return Math.abs(e7[3] - e7[1]) > a4;
      }
      return false;
    });
  }
};
function u({
  lij: [e5, t4, r],
  extent: i2
}) {
  return new t(`${e5}/${t4}/${r}`, e5, t4, r, i2);
}
e3([y({
  readOnly: true
})], p3.prototype, "tiles", null), e3([y({
  readOnly: true
})], p3.prototype, "tilesCoveringView", null), e3([y({
  readOnly: true
})], p3.prototype, "tileInfo", null), e3([y({
  readOnly: true
})], p3.prototype, "tileSize", null), e3([y({
  constructOnly: true
})], p3.prototype, "view", void 0), e3([y()], p3.prototype, "pointOfInterest", void 0), e3([y()], p3.prototype, "_effectivePointOfInterest", null), p3 = e3([a("esri.views.3d.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles3D")], p3);
var a4 = 50;
var f = "feature-tiles";

// ../../../node_modules/@arcgis/core/views/interactive/snapping/featureSources/WorkerTileTreeDebugger.js
var n3 = class extends d4 {
  constructor(e5) {
    super(e5);
  }
  initialize() {
    const e5 = setInterval(() => this._fetchDebugInfo(), 2e3);
    this.addHandles(e2(() => clearInterval(e5)));
  }
  getTiles() {
    if (!this._debugInfo) return [];
    const e5 = /* @__PURE__ */ new Map(), t4 = /* @__PURE__ */ new Map();
    this._debugInfo.storedTiles.forEach((t5) => {
      e5.set(t5.data.id, t5.featureCount);
    }), this._debugInfo.pendingTiles.forEach((r2) => {
      e5.set(r2.data.id, r2.featureCount), t4.set(r2.data.id, r2.state);
    });
    const r = (r2) => {
      const o5 = t4.get(r2), s3 = e5.get(r2) ?? "?";
      return o5 ? `${o5}:${s3}
${r2}` : `store:${s3}
${r2}`;
    }, o4 = /* @__PURE__ */ new Map();
    return this._debugInfo.storedTiles.forEach((e6) => {
      o4.set(e6.data.id, e6.data);
    }), this._debugInfo.pendingTiles.forEach((e6) => {
      o4.set(e6.data.id, e6.data);
    }), Array.from(o4.values()).map((e6) => ({
      lij: [e6.level, e6.row, e6.col],
      geometry: j.fromExtent(c(e6.extent, this.view.spatialReference)),
      label: r(e6.id)
    }));
  }
  _fetchDebugInfo() {
    this.handle.getDebugInfo(null).then((e5) => {
      this._debugInfo = e5, this.update();
    });
  }
};
e3([y({
  constructOnly: true
})], n3.prototype, "handle", void 0), n3 = e3([a("esri.views.interactive.snapping.featureSources.WorkerTileTreeDebugger")], n3);

// ../../../node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorkerHandle.js
var h4 = class extends S {
  get updating() {
    return this._updatingHandles.updating || this._workerHandleUpdating;
  }
  constructor(e5) {
    super(e5), this._updatingHandles = new h2(), this._suspendController = null, this.schedule = null, this.hasZ = false, this.elevationAlignPointsInFeatures = (e6) => __async(this, null, function* () {
      const t4 = [];
      for (const {
        points: i2
      } of e6.pointsInFeatures) for (const {
        z: e7
      } of i2) t4.push(e7);
      return {
        elevations: t4,
        drapedObjectIds: /* @__PURE__ */ new Set(),
        failedObjectIds: /* @__PURE__ */ new Set()
      };
    }), this.queryForSymbologySnapping = () => __async(this, null, function* () {
      return {
        candidates: [],
        sourceCandidateIndices: []
      };
    }), this.availability = 0, this._workerHandleUpdating = true, this._editId = 0, this.updateOutFields = k((e6, t4) => __async(this, null, function* () {
      yield this._updatingHandles.addPromise(this._workerHandle.invokeMethod("updateOutFields", [...e6], t4)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t4));
    }));
  }
  destroy() {
    this._suspendController = e(this._suspendController), this._workerHandle.destroy(), this._updatingHandles.destroy();
  }
  initialize() {
    this._workerHandle = new g(this.schedule, {
      alignElevation: (_0, _1) => __async(this, [_0, _1], function* (e5, {
        signal: t4
      }) {
        return {
          result: yield this.elevationAlignPointsInFeatures(e5.query, t4)
        };
      }),
      getSymbologyCandidates: (_0, _1) => __async(this, [_0, _1], function* (e5, {
        signal: t4
      }) {
        return {
          result: yield this.queryForSymbologySnapping(e5, t4)
        };
      })
    }), this.addHandles([this._workerHandle.on("notify-updating", ({
      updating: e5
    }) => this._workerHandleUpdating = e5), this._workerHandle.on("notify-availability", ({
      availability: e5
    }) => this._set("availability", e5))]);
  }
  setup(e5, t4) {
    return __async(this, null, function* () {
      const i2 = y3(e5.layer);
      if (null == i2) return;
      const o4 = {
        configuration: c4(e5.configuration),
        serviceInfo: i2,
        spatialReference: e5.spatialReference.toJSON(),
        hasZ: this.hasZ,
        elevationInfo: e5.layer.elevationInfo?.toJSON()
      };
      yield this._updatingHandles.addPromise(this._workerHandle.invokeMethod("setup", o4, t4)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t4));
    });
  }
  configure(e5, t4) {
    return __async(this, null, function* () {
      const i2 = c4(e5);
      yield this._updatingHandles.addPromise(this._workerHandle.invokeMethod("configure", i2, t4)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t4));
    });
  }
  refresh(e5) {
    return __async(this, null, function* () {
      yield this._updatingHandles.addPromise(this._workerHandle.invokeMethod("refresh", {}, e5)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, e5));
    });
  }
  fetchCandidates(e5, t4) {
    return __async(this, null, function* () {
      const {
        point: i2,
        filter: o4,
        coordinateHelper: n4
      } = e5, a6 = __spreadProps(__spreadValues({}, e5), {
        point: e4(i2[0], i2[1], i2[2], n4.spatialReference.toJSON()),
        filter: o4?.toJSON()
      });
      return this._workerHandle.invoke(a6, t4);
    });
  }
  updateTiles(e5, t4) {
    return __async(this, null, function* () {
      const i2 = {
        tiles: e5.tiles,
        tileInfo: null != e5.tileInfo ? e5.tileInfo.toJSON() : null,
        tileSize: e5.tileSize
      };
      yield this._updatingHandles.addPromise(this._workerHandle.invokeMethod("updateTiles", i2, t4)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t4));
    });
  }
  applyEdits(e5, t4) {
    return __async(this, null, function* () {
      const o4 = this._editId++, n4 = {
        id: o4
      };
      yield this._updatingHandles.addPromise(this._workerHandle.invokeMethod("beginApplyEdits", n4, t4));
      const s3 = yield this._updatingHandles.addPromise(h(e5.result, t4)), r = {
        id: o4,
        edits: {
          addedFeatures: s3.addedFeatures?.map(({
            objectId: e6
          }) => e6).filter(O) ?? [],
          deletedFeatures: s3.deletedFeatures?.map(({
            objectId: e6,
            globalId: t5
          }) => ({
            objectId: e6,
            globalId: t5
          })) ?? [],
          updatedFeatures: s3.updatedFeatures?.map(({
            objectId: e6
          }) => e6).filter(O) ?? []
        }
      };
      yield this._updatingHandles.addPromise(this._workerHandle.invokeMethod("endApplyEdits", r, t4)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t4));
    });
  }
  getDebugInfo(e5) {
    return this._workerHandle.invokeMethod("getDebugInfo", {}, e5);
  }
  notifyElevationSourceChange() {
    return __async(this, null, function* () {
      yield this._workerHandle.invokeMethod("notifyElevationSourceChange", {});
    });
  }
  notifySymbologyChange() {
    return __async(this, null, function* () {
      yield this._workerHandle.invokeMethod("notifySymbologyChange", {});
    });
  }
  setSymbologySnappingSupported(e5) {
    return __async(this, null, function* () {
      yield this._workerHandle.invokeMethod("setSymbologySnappingSupported", e5);
    });
  }
  setSuspended(e5) {
    return __async(this, null, function* () {
      this._suspendController?.abort(), this._suspendController = new AbortController(), yield this._workerHandle.invokeMethod("setSuspended", e5, this._suspendController.signal);
    });
  }
};
function c4(e5) {
  return {
    filter: null != e5.filter ? e5.filter.toJSON() : null,
    customParameters: e5.customParameters,
    viewType: e5.viewType
  };
}
function y3(e5) {
  return "multipatch" === e5.geometryType || "mesh" === e5.geometryType ? null : {
    url: e5.parsedUrl?.path ?? "",
    fieldsIndex: e5.fieldsIndex.toJSON(),
    geometryType: o2.toJSON(e5.geometryType),
    capabilities: e5.capabilities,
    objectIdField: e5.objectIdField,
    globalIdField: e5.globalIdField,
    spatialReference: e5.spatialReference.toJSON(),
    timeInfo: e5.timeInfo?.toJSON()
  };
}
e3([y({
  constructOnly: true
})], h4.prototype, "schedule", void 0), e3([y({
  constructOnly: true
})], h4.prototype, "hasZ", void 0), e3([y({
  constructOnly: true
})], h4.prototype, "elevationAlignPointsInFeatures", void 0), e3([y({
  constructOnly: true
})], h4.prototype, "queryForSymbologySnapping", void 0), e3([y({
  readOnly: true
})], h4.prototype, "updating", null), e3([y({
  readOnly: true
})], h4.prototype, "availability", void 0), e3([y()], h4.prototype, "_workerHandleUpdating", void 0), h4 = e3([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorkerHandle")], h4);
var g = class extends h3 {
  constructor(e5, t4) {
    super("FeatureServiceSnappingSourceWorker", "fetchCandidates", {}, e5, {
      strategy: "dedicated",
      client: t4
    });
  }
};

// ../../../node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTilesSimple.js
var a5 = class extends S {
  get tiles() {
    return [new t("0/0/0", 0, 0, 0, a2(-1e8, -1e8, 1e8, 1e8))];
  }
  get tileInfo() {
    return new z({
      origin: new _({
        x: -1e8,
        y: 1e8,
        spatialReference: this.layer.spatialReference
      }),
      size: [512, 512],
      lods: [new p({
        level: 0,
        scale: 1,
        resolution: 390625
      })],
      spatialReference: this.layer.spatialReference
    });
  }
  get tileSize() {
    return this.tileInfo.size[0];
  }
  constructor(e5) {
    super(e5), this.pointOfInterest = null;
  }
};
e3([y({
  readOnly: true
})], a5.prototype, "tiles", null), e3([y({
  readOnly: true
})], a5.prototype, "tileInfo", null), e3([y({
  readOnly: true
})], a5.prototype, "tileSize", null), e3([y({
  constructOnly: true
})], a5.prototype, "layer", void 0), e3([y()], a5.prototype, "pointOfInterest", void 0), a5 = e3([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTilesSimple")], a5);

// ../../../node_modules/@arcgis/core/views/interactive/snapping/featureSources/FeatureServiceSnappingSource.js
var F = class extends S {
  get _updateTilesParameters() {
    return {
      tiles: this._tilesOfInterest.tiles,
      tileInfo: this._tilesOfInterest.tileInfo,
      tileSize: this._tilesOfInterest.tileSize
    };
  }
  get _layerView() {
    return this.view?.allLayerViews.find((e5) => e5.layer === this._layer);
  }
  get _isSuspended() {
    if (c2(this._layer)) {
      if (!this.layerSource.sublayerSources.some((e5) => e5.enabled && e5.layer.visible)) return true;
    }
    return !!this.view && (false !== this._layerView?.suspended || !this.layerSource.enabled);
  }
  get updating() {
    return this._workerHandle?.updating || this._updatingHandles.updating;
  }
  get _outFields() {
    const {
      view: e5,
      _layerView: t4,
      layerSource: r
    } = this, {
      layer: i2
    } = r, {
      fieldsIndex: s3,
      timeInfo: o4,
      floorInfo: a6,
      subtypeField: n4
    } = i2, l2 = t4 && "filter" in t4 ? t4.filter : null, d5 = l2?.where && "1=1" !== l2.where ? this._getOrLoadWhereFields(l2.where, s3) : [];
    if (l2?.timeExtent && o4) {
      const {
        startField: e6,
        endField: t5
      } = o4, r2 = s3.get(e6)?.name ?? e6, i3 = s3.get(t5)?.name ?? t5;
      r2 && d5.push(r2), i3 && d5.push(i3);
    }
    if (e5?.map && v2(e5.map) && e5.map.utilityNetworks?.find((e6) => e6.isUtilityLayer(i2))) {
      const e6 = i2.fieldsIndex.get("assetGroup")?.name, t5 = i2.fieldsIndex.get("assetType")?.name;
      e6 && t5 && (d5.push(e6), d5.push(t5));
    }
    if (i2 && a6?.floorField && e5?.floors?.length) {
      const e6 = s3.get(a6.floorField)?.name ?? a6.floorField;
      e6 && d5.push(e6);
    }
    if (n4) {
      const e6 = s3.get(n4)?.name ?? n4;
      e6 && d5.push(e6);
    }
    return new Set(d5);
  }
  get configuration() {
    const {
      view: e5
    } = this, {
      apiKey: t4,
      customParameters: r
    } = this._layer, i2 = null != e5 ? e5.type : "2d";
    return {
      filter: this._layer.createQuery(),
      customParameters: t4 ? __spreadProps(__spreadValues({}, r), {
        token: t4
      }) : r,
      viewType: i2
    };
  }
  get availability() {
    return this._workerHandle?.availability ?? 0;
  }
  get _layer() {
    return this.layerSource.layer;
  }
  constructor(e5) {
    super(e5), this._updatingHandles = new h2(), this._workerHandle = null, this._debug = null, this._memoizedMakeGetGroundElevation = t3(i);
  }
  initialize() {
    let e5;
    const t4 = this.view;
    if (null == t4 || t4.destroyed) this._tilesOfInterest = new a5({
      layer: this._layer
    }), e5 = this._workerHandle = new h4();
    else switch (t4.type) {
      case "2d":
        this._tilesOfInterest = new p2({
          view: t4,
          layer: this._layer
        }), e5 = this._workerHandle = new h4();
        break;
      case "3d": {
        const {
          resourceController: r
        } = t4, i2 = this._layer;
        this._tilesOfInterest = new p3({
          view: t4
        }), e5 = this._workerHandle = new h4({
          schedule: (e6) => r.immediate.schedule(e6),
          hasZ: this._layer.hasZ && (this._layer.returnZ ?? true),
          elevationAlignPointsInFeatures: (e6, r2) => __async(this, null, function* () {
            const s3 = yield t4.whenLayerView(i2);
            return s(r2), s3.elevationAlignPointsInFeatures(e6, r2);
          }),
          queryForSymbologySnapping: (e6, r2) => __async(this, null, function* () {
            const s3 = yield t4.whenLayerView(i2);
            return s(r2), s3.queryForSymbologySnapping(e6, r2);
          })
        }), this.addHandles([t4.elevationProvider.on("elevation-change", ({
          context: t5
        }) => {
          const {
            elevationInfo: r2
          } = i2;
          y2(t5, r2) && d(e5.notifyElevationSourceChange());
        }), d3(() => i2.elevationInfo, () => d(e5.notifyElevationSourceChange()), P), d3(() => this._layerView?.layer?.renderer, () => d(e5.notifySymbologyChange()), P), d3(() => this._layerView?.symbologySnappingSupported ?? false, (t5) => d(e5.setSymbologySnappingSupported(t5)), P), v(() => this._layerView?.layer, ["edits", "apply-edits", "graphic-update"], () => e5.notifySymbologyChange())]);
        break;
      }
    }
    this.addHandles([l(e5)]), d(e5.setup({
      layer: this._layer,
      spatialReference: this.spatialReference,
      configuration: this.configuration
    }, null)), this._updatingHandles.add(() => this._updateTilesParameters, () => d(e5.updateTiles(this._updateTilesParameters, null)), P), this.addHandles([d3(() => this.configuration, (t5) => d(e5.configure(t5, null)), C), d3(() => this._outFields, (t5) => d(e5.updateOutFields(t5)), P), d3(() => this._isSuspended, (t5) => d(e5.setSuspended(t5)), A)]), null != t4 && this.addHandles(d3(() => E.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES, (r) => {
      r && !this._debug ? (this._debug = new n3({
        view: t4,
        handle: e5
      }), this.addHandles(l(this._debug), "debug")) : !r && this._debug && this.removeHandles("debug");
    }, P)), this.addHandles(this.layerSource.layer.on("apply-edits", (t5) => {
      d(e5.applyEdits(t5, null));
    }));
  }
  destroy() {
    this._updatingHandles.destroy();
  }
  refresh() {
    this._workerHandle?.refresh(null);
  }
  fetchCandidates(e5, t4) {
    return __async(this, null, function* () {
      const {
        coordinateHelper: r,
        point: i2
      } = e5;
      this._tilesOfInterest.pointOfInterest = r.arrayToPoint(i2);
      const s3 = this._memoizedMakeGetGroundElevation(this.view, r.spatialReference);
      return (yield this._workerHandle.fetchCandidates(__spreadValues({}, e5), t4)).candidates.map((e6) => o3(e6, s3));
    });
  }
  getDebugInfo(e5) {
    return this._workerHandle.getDebugInfo(e5);
  }
  _getOrLoadWhereFields(e5, t4) {
    const {
      _whereModule: i2
    } = this;
    if (!this._loadWhereModuleTask && !i2) {
      const e6 = d2(() => __async(this, null, function* () {
        const e7 = yield import("./WhereClause-AUPNQENK.js");
        return this._whereModule = e7.WhereClause, this._whereModule;
      }));
      return this._loadWhereModuleTask = e6, this._updatingHandles.addPromise(e6.promise), [];
    }
    if (!i2) return [];
    try {
      return i2.create(e5, t4).fieldNames;
    } catch (s3) {
      return [];
    }
  }
};
e3([y({
  constructOnly: true
})], F.prototype, "spatialReference", void 0), e3([y({
  constructOnly: true
})], F.prototype, "layerSource", void 0), e3([y({
  constructOnly: true
})], F.prototype, "view", void 0), e3([y()], F.prototype, "_tilesOfInterest", void 0), e3([y({
  readOnly: true
})], F.prototype, "_updateTilesParameters", null), e3([y()], F.prototype, "_layerView", null), e3([y()], F.prototype, "_isSuspended", null), e3([y({
  readOnly: true
})], F.prototype, "updating", null), e3([y()], F.prototype, "_outFields", null), e3([y({
  readOnly: true
})], F.prototype, "configuration", null), e3([y({
  readOnly: true
})], F.prototype, "availability", null), e3([y()], F.prototype, "_loadWhereModuleTask", void 0), e3([y()], F.prototype, "_whereModule", void 0), F = e3([a("esri.views.interactive.snapping.featureSources.FeatureServiceSnappingSource")], F);
export {
  F as FeatureServiceSnappingSource
};
//# sourceMappingURL=FeatureServiceSnappingSource-FLIBGV6B.js.map
