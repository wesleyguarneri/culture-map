import {
  e as e7,
  o as o5
} from "./chunk-UBENSR3Y.js";
import {
  N,
  u2 as u4
} from "./chunk-7VSW2U7Y.js";
import "./chunk-IVKE5IFG.js";
import "./chunk-T32ZZS7S.js";
import {
  s as s4
} from "./chunk-NZNCWPFS.js";
import {
  e as e6
} from "./chunk-CKTLSI27.js";
import {
  e as e5
} from "./chunk-4YFNKQX7.js";
import {
  _ as _3,
  f as f4,
  m,
  v
} from "./chunk-P2HSMFQ7.js";
import {
  D
} from "./chunk-UOKMPU6Y.js";
import "./chunk-QXRVL2BR.js";
import "./chunk-2RBDM2DS.js";
import {
  M,
  g as g2,
  j as j3,
  w,
  y as y2
} from "./chunk-MNNI2X2N.js";
import "./chunk-2SHZAJ7S.js";
import {
  h as h5
} from "./chunk-SBMU7RBF.js";
import {
  p
} from "./chunk-EU7GCI2A.js";
import {
  f as f2,
  i
} from "./chunk-WE6VW4MG.js";
import {
  s as s3
} from "./chunk-ZRC4V45K.js";
import {
  r as r7,
  t as t4
} from "./chunk-CGERANZG.js";
import {
  f as f3
} from "./chunk-XLRVEQZV.js";
import {
  a as a3
} from "./chunk-T35SJNQV.js";
import "./chunk-2CPAIFT3.js";
import "./chunk-DABQKFI5.js";
import "./chunk-S2OEQYU7.js";
import {
  h as h4
} from "./chunk-APWDCJIJ.js";
import "./chunk-NEPAFG4J.js";
import "./chunk-E7VVOB2F.js";
import "./chunk-DOYOAB3G.js";
import "./chunk-DDIAZD6H.js";
import "./chunk-GFPWBDCO.js";
import "./chunk-MQUE5HQL.js";
import "./chunk-TKHURHLF.js";
import "./chunk-U7YHNT5S.js";
import "./chunk-UW23RIEM.js";
import "./chunk-R6CAUNOR.js";
import "./chunk-6BPYXCCQ.js";
import "./chunk-TMIIQZKR.js";
import "./chunk-ROVEMBDA.js";
import "./chunk-ZIDRXKSJ.js";
import "./chunk-DBK2ELNZ.js";
import "./chunk-JMV2M56E.js";
import "./chunk-S2UCXOWF.js";
import "./chunk-VI6HLZLR.js";
import "./chunk-MYKOM3G6.js";
import "./chunk-6FZS4YUQ.js";
import "./chunk-JRZPZOI3.js";
import "./chunk-GW7WMRYJ.js";
import "./chunk-Z52R7W33.js";
import {
  gt
} from "./chunk-O7OCS6XP.js";
import "./chunk-BFWLPS7M.js";
import "./chunk-67LE7VNQ.js";
import "./chunk-ZVEHH7XL.js";
import "./chunk-BJM7H6OC.js";
import "./chunk-5MM5MT6Q.js";
import "./chunk-SCLVG2SO.js";
import "./chunk-557LD7Q2.js";
import "./chunk-X5UPCJEP.js";
import "./chunk-2ONAF54K.js";
import "./chunk-NE4OJEWH.js";
import "./chunk-6YA72G7G.js";
import "./chunk-W6GMJ4SS.js";
import {
  s as s2
} from "./chunk-IIVUY2T7.js";
import "./chunk-GHUJU3NS.js";
import "./chunk-7HBD4CJ3.js";
import "./chunk-K2LTET4M.js";
import "./chunk-WG5JLPNN.js";
import "./chunk-25PMMPR7.js";
import "./chunk-7XAWCQ7R.js";
import {
  E as E3
} from "./chunk-RASN5P76.js";
import "./chunk-5L3YXBNN.js";
import {
  A as A2,
  c as c4
} from "./chunk-IFUKJDOU.js";
import "./chunk-LD5YIQXD.js";
import {
  t as t3
} from "./chunk-J7KF6IEI.js";
import "./chunk-GOKBAMCG.js";
import "./chunk-E3P3LIVT.js";
import "./chunk-HUX6Y26H.js";
import "./chunk-LN4EMOLP.js";
import "./chunk-A6XTYETO.js";
import "./chunk-4TJAOUC3.js";
import "./chunk-CILAEMQM.js";
import "./chunk-TEOUFCJA.js";
import "./chunk-GTZOXRB5.js";
import "./chunk-3WPOFZBT.js";
import "./chunk-PPMHRAOP.js";
import "./chunk-75N5YDQB.js";
import {
  r as r4,
  r2 as r5,
  t as t2
} from "./chunk-XGDLE7WK.js";
import "./chunk-QMUS26QM.js";
import {
  t
} from "./chunk-GDEAPZ64.js";
import "./chunk-TCQSUQ7Y.js";
import "./chunk-GOOZVNO4.js";
import "./chunk-5RHKQDDL.js";
import "./chunk-BG32AOSQ.js";
import "./chunk-PEZTN5WV.js";
import {
  r as r6
} from "./chunk-FHW2TG7X.js";
import "./chunk-33LKI2Y7.js";
import "./chunk-YCQXFVJL.js";
import "./chunk-ZAP7ZEWR.js";
import {
  c2 as c3,
  h as h3,
  u2 as u3
} from "./chunk-YAGNWBGU.js";
import "./chunk-DE6MQ5XE.js";
import "./chunk-LQTSBE7P.js";
import "./chunk-GCFUJXGH.js";
import "./chunk-MBMY7SS6.js";
import "./chunk-ICUHXX2J.js";
import {
  o as o3
} from "./chunk-VIIVMRRO.js";
import "./chunk-ZKSEQXDM.js";
import "./chunk-675UQNXB.js";
import "./chunk-DXGCBLDW.js";
import "./chunk-Z3FHX4FD.js";
import "./chunk-SUUOAZQT.js";
import "./chunk-TGHJVD7I.js";
import "./chunk-OZG2NNUW.js";
import "./chunk-KTRZHJ2M.js";
import "./chunk-KOIKSJSQ.js";
import "./chunk-VUVXW4AC.js";
import {
  S as S2,
  _ as _2,
  o as o4
} from "./chunk-LKHUGH5W.js";
import "./chunk-ACZYDHB3.js";
import "./chunk-JXVDTUGR.js";
import "./chunk-HAO4WCNW.js";
import "./chunk-X2OAE75B.js";
import "./chunk-UCPBGEQD.js";
import "./chunk-SIZK72CP.js";
import "./chunk-SLCHZ6DD.js";
import "./chunk-6A3XUATG.js";
import "./chunk-ZVFENZUF.js";
import "./chunk-N3S77FRG.js";
import "./chunk-YYETZJJB.js";
import "./chunk-MD2IQSSQ.js";
import "./chunk-C7VF4AR2.js";
import "./chunk-P7OSFLIX.js";
import "./chunk-ZDC4PV4Y.js";
import "./chunk-DLRYNII2.js";
import "./chunk-66QAJ2MI.js";
import "./chunk-WN3YAMRZ.js";
import {
  H
} from "./chunk-NWICVENM.js";
import "./chunk-A4RKV2C7.js";
import "./chunk-WU7FVYT7.js";
import "./chunk-SYYDVGKY.js";
import "./chunk-6HBAAUBO.js";
import {
  E as E2,
  O as O2
} from "./chunk-YLE5AYZV.js";
import "./chunk-62WUYJJN.js";
import "./chunk-JNWMZ6EJ.js";
import {
  j as j2
} from "./chunk-VS26W5Y5.js";
import "./chunk-LM2N2I5R.js";
import "./chunk-YFQ32AQX.js";
import "./chunk-L4AYSXFJ.js";
import "./chunk-POQ3T5EH.js";
import "./chunk-DM4WHMQY.js";
import "./chunk-6MR4UDDL.js";
import "./chunk-KE2YMCJC.js";
import "./chunk-L7ZKWTWL.js";
import "./chunk-O2DTA3XK.js";
import "./chunk-3UOXF3CT.js";
import "./chunk-PA7WZX2U.js";
import "./chunk-GPUGMSHU.js";
import "./chunk-AIS5CSUZ.js";
import "./chunk-52UEU7LG.js";
import {
  o as o2
} from "./chunk-WJKYGQOY.js";
import "./chunk-GY52WOQZ.js";
import "./chunk-GAYJ4YPJ.js";
import "./chunk-PPMDUJ4E.js";
import "./chunk-ZTT6ENBS.js";
import "./chunk-MFZTGYUJ.js";
import "./chunk-R5ZE5A4K.js";
import "./chunk-24CN3HDP.js";
import "./chunk-SZWWBMQN.js";
import "./chunk-ZE47C44H.js";
import "./chunk-5GIS2C3K.js";
import "./chunk-XCOHDMBF.js";
import "./chunk-R3F4JMNC.js";
import "./chunk-7B5YPLFX.js";
import "./chunk-RDQF44TE.js";
import "./chunk-KKD7A2GN.js";
import "./chunk-ZWCV4HKG.js";
import {
  c as c2
} from "./chunk-N4KQPPPI.js";
import "./chunk-4OGGMTIH.js";
import "./chunk-NQVBBKAN.js";
import {
  E,
  F,
  G,
  P as P2,
  R,
  q
} from "./chunk-TCPN7AEH.js";
import {
  e as e4
} from "./chunk-4MMTPKY4.js";
import "./chunk-DY7FJHTG.js";
import "./chunk-Q4KYZS3X.js";
import "./chunk-KVKFHRJ3.js";
import "./chunk-VWML4J2J.js";
import "./chunk-JYODC3YQ.js";
import {
  e as e3
} from "./chunk-BQZBOYBD.js";
import "./chunk-TYQXPPSP.js";
import "./chunk-SWPHGZYB.js";
import "./chunk-N6TJI25E.js";
import "./chunk-CIW3KHOW.js";
import "./chunk-J55F4AC2.js";
import {
  n as n3,
  r as r3
} from "./chunk-IMVP5ADD.js";
import {
  a as a2
} from "./chunk-H7WPOTQH.js";
import "./chunk-DUTZNK67.js";
import "./chunk-IN6BQCWS.js";
import "./chunk-3RRMLFFN.js";
import "./chunk-HT2T6PUB.js";
import "./chunk-K64AAM77.js";
import "./chunk-XTVPEVHA.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import "./chunk-K226GFDN.js";
import "./chunk-4ZZRP4MA.js";
import {
  s,
  x as x2
} from "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-A4VVDRCH.js";
import "./chunk-CQDYITZC.js";
import "./chunk-YVULORT6.js";
import {
  h
} from "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-EDSMXTFO.js";
import {
  f
} from "./chunk-MNLT652N.js";
import "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-ONPREQKF.js";
import "./chunk-7RMVJCDW.js";
import "./chunk-GTY5NXA4.js";
import "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import "./chunk-NYQ5CYNR.js";
import "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import {
  c,
  h as h2
} from "./chunk-3ZXOUEQG.js";
import {
  K,
  O,
  Y,
  _,
  e as e2,
  g,
  o,
  r as r2,
  u as u2,
  x,
  z
} from "./chunk-AXVPJBVW.js";
import {
  n as n2
} from "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import {
  J,
  j
} from "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import {
  A,
  P,
  d
} from "./chunk-6WHTZNUH.js";
import "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import "./chunk-XNUH25NY.js";
import "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e
} from "./chunk-4Z5SGKRM.js";
import {
  S,
  r
} from "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3 as a
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import {
  u
} from "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  n2 as n
} from "./chunk-WYIDUUN2.js";
import "./chunk-DXLOWWK7.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/views/3d/analysis/DirectLineMeasurement/DirectLineMeasurementController.js
var m2 = class extends S {
  constructor(e8) {
    super(e8);
  }
  initialize() {
    this.addHandles([d(() => ({
      viewData: this.viewData,
      startPoint: this.analysis.startPoint
    }), ({
      viewData: e8,
      startPoint: t5
    }) => {
      e8.elevationAlignedStartPoint = this._applyProjectionAndElevationAlignment(t5);
    }, A), d(() => ({
      viewData: this.viewData,
      endPoint: this.analysis.endPoint
    }), ({
      viewData: e8,
      endPoint: t5
    }) => {
      e8.elevationAlignedEndPoint = this._applyProjectionAndElevationAlignment(t5);
    }, A), d(() => ({
      result: this._computedResult,
      viewData: this.viewData
    }), ({
      result: e8,
      viewData: t5
    }) => {
      t5.result = e8;
    }, A)]);
  }
  _applyProjectionAndElevationAlignment(e8) {
    if (null == e8) return e8;
    const {
      spatialReference: t5,
      elevationProvider: o6
    } = this.view, r8 = r7(e8, t5, o6);
    return r8 ?? (t4(this.analysis, e8.spatialReference, n.getLogger(this)), null);
  }
  get _computedResult() {
    const {
      elevationAlignedStartPoint: e8,
      elevationAlignedEndPoint: t5,
      measurementMode: i2
    } = this.viewData;
    if (null == e8 || null == t5) return null;
    const o6 = h5(e8, t5), r8 = f2(e8, t5);
    if (null == o6) return null;
    let s5, n4;
    switch (i2) {
      case e6.Auto:
        n4 = null != r8 ? "geodesic" : "euclidean", s5 = r8 ?? o6.horizontal;
        break;
      case e6.Geodesic:
        if (null == r8) return null;
        n4 = "geodesic", s5 = r8;
        break;
      case e6.Euclidean:
        n4 = "euclidean", s5 = o6.horizontal;
    }
    return {
      mode: n4,
      directDistance: o6.direct,
      horizontalDistance: s5,
      verticalDistance: o6.vertical,
      distance: i2 === e6.Euclidean || o6.horizontal.value <= i ? o6.direct : r8 ?? o6.horizontal
    };
  }
};
e([y()], m2.prototype, "view", void 0), e([y()], m2.prototype, "analysis", void 0), e([y()], m2.prototype, "viewData", void 0), e([y()], m2.prototype, "_computedResult", null), m2 = e([a("esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementController")], m2);

// ../../../node_modules/@arcgis/core/views/3d/webgl-engine/shaders/MeasurementArrowTechnique.js
var g3 = class _g extends r4 {
  constructor(e8, r8, t5) {
    super(e8, r8, t5);
  }
  initializeProgram(e8) {
    return new r5(e8.rctx, _g.shader.get().build(this.configuration), y3);
  }
  _setPipelineState(e8) {
    const r8 = e8 === o3.NONE, t5 = this.configuration;
    return S2({
      blending: t5.transparent ? r8 ? A2 : c4(e8) : null,
      polygonOffset: this.configuration.polygonOffsetEnabled ? {
        factor: 0,
        units: -4
      } : null,
      depthTest: {
        func: O2.LESS
      },
      depthWrite: o4,
      colorWrite: _2
    });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
  get primitiveType() {
    return E2.TRIANGLE_STRIP;
  }
};
g3.shader = new t2(s4, () => import("./MeasurementArrow.glsl-TJ6VXH65.js"));
var T = class extends t3 {
  constructor() {
    super(...arguments), this.polygonOffsetEnabled = false, this.transparent = false, this.transparencyPassType = o3.NONE;
  }
};
e([r6()], T.prototype, "polygonOffsetEnabled", void 0), e([r6()], T.prototype, "transparent", void 0), e([r6({
  count: o3.COUNT
})], T.prototype, "transparencyPassType", void 0);
var y3 = /* @__PURE__ */ new Map([[e4.POSITION, 0], [e4.NORMAL, 1], [e4.UV0, 2], [e4.LENGTH, 3]]);

// ../../../node_modules/@arcgis/core/views/3d/webgl-engine/materials/MeasurementArrowMaterial.js
var O3 = class extends c3 {
  constructor(t5) {
    super(t5, new A3()), this._vertexAttributeLocations = y3, this.produces = /* @__PURE__ */ new Map([[E3.OPAQUE_MATERIAL, (t6) => !this._transparent && t6 === o2.Color], [E3.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL, (t6) => this._transparent && t6 === o2.Color]]), this._configuration = new T();
  }
  getConfiguration(t5, e8) {
    return this._configuration.polygonOffsetEnabled = this.parameters.polygonOffset, this._configuration.transparent = this._transparent, this._configuration.transparencyPassType = e8.transparencyPassType, this._configuration;
  }
  intersect() {
  }
  createGLMaterial(t5) {
    return new _4(t5);
  }
  createBufferWriter() {
    return new j4();
  }
  get _transparent() {
    const {
      parameters: t5
    } = this;
    return t5.outlineColor[3] < 1 || t5.stripeEvenColor[3] < 1 || t5.stripeOddColor[3] < 1;
  }
};
var _4 = class extends t {
  beginSlot(t5) {
    return this.ensureTechnique(g3, t5);
  }
};
var A3 = class extends u3 {
  constructor() {
    super(...arguments), this.width = 32, this.outlineSize = 0.2, this.outlineColor = r3(1, 0.5, 0, 1), this.stripeEvenColor = r3(1, 1, 1, 1), this.stripeOddColor = r3(1, 0.5, 0, 1), this.stripeLength = 1, this.polygonOffset = false;
  }
};
var T2 = H().vec3f(e4.POSITION).vec3f(e4.NORMAL).vec2f(e4.UV0).f32(e4.LENGTH);
var L = n2();
var v2 = n2();
var E4 = n2();
var I = n2();
var M2 = n2();
var j4 = class {
  constructor() {
    this.vertexBufferLayout = T2;
  }
  elementCount(t5) {
    return 2 * (t5.attributes.get(e4.POSITION).indices.length / 2 + 1);
  }
  write(n4, a4, c5, l, u5) {
    const {
      data: p3,
      indices: f5
    } = c5.attributes.get(e4.POSITION), h6 = c5.attributes.get(e4.NORMAL).data, g4 = p3.length / 3;
    f5 && f5.length !== 2 * (g4 - 1) && console.warn("MeasurementArrowMaterial does not support indices");
    const d2 = L, b2 = v2, O4 = E4, _5 = I, A4 = M2, T3 = l.position, j6 = l.normal, w2 = l.uv0;
    let y6 = 0;
    for (let m3 = 0; m3 < g4; ++m3) {
      const c6 = 3 * m3;
      if (o(d2, p3[c6], p3[c6 + 1], p3[c6 + 2]), m3 < g4 - 1) {
        const o6 = 3 * (m3 + 1);
        o(b2, p3[o6], p3[o6 + 1], p3[o6 + 2]), o(A4, h6[o6], h6[o6 + 1], h6[o6 + 2]), z(A4, A4), e2(O4, b2, d2), z(O4, O4), _(_5, A4, O4), z(_5, _5);
      }
      const l2 = x(d2, b2);
      n4 && a4 && (O(d2, d2, n4), O(b2, b2, n4), O(_5, _5, a4));
      const f6 = u5 + 2 * m3, L2 = f6 + 1;
      T3.setVec(f6, d2), T3.setVec(L2, d2), j6.setVec(f6, _5), j6.setVec(L2, _5), w2.set(f6, 0, y6), w2.set(f6, 1, -1), w2.set(L2, 0, y6), w2.set(L2, 1, 1), m3 < g4 - 1 && (y6 += l2);
    }
    const C = l.length;
    for (let t5 = 0; t5 < 2 * g4; ++t5) C.set(u5 + t5, y6);
  }
};

// ../../../node_modules/@arcgis/core/views/3d/interactive/visualElements/MeasurementArrowVisualElement.js
var y4 = class extends a3 {
  constructor(e8) {
    super(e8), this._arrowWidth = 16, this._arrowSubdivisions = 128, this._origin = n2(), this._originTransform = e3(), this._arrowCenter = n2(), this._renderOccluded = h3.OccludeAndTransparent, this._geometry = null, this._stripeLength = 1, this._stripesEnabled = true, this._color = n3(), this._contrastColor = n3(), this.applyProperties(e8);
  }
  get renderOccluded() {
    return this._renderOccluded;
  }
  set renderOccluded(e8) {
    e8 !== this._renderOccluded && (this._renderOccluded = e8, this._arrowMaterial && this._arrowMaterial.setParameters({
      renderOccluded: e8
    }));
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(e8) {
    this._geometry = e8, this._geometryChanged();
  }
  get stripeLength() {
    return this._stripeLength;
  }
  set stripeLength(e8) {
    this._stripeLength = e8, this.attached && this._arrowMaterial.setParameters({
      stripeLength: this._stripeLength
    });
  }
  get stripesEnabled() {
    return this._stripesEnabled;
  }
  set stripesEnabled(e8) {
    if (this._stripesEnabled = e8, this.attached) {
      const e9 = this._stripesEnabled ? this._contrastColor : this._color;
      this._arrowMaterial.setParameters({
        stripeEvenColor: e9
      });
    }
  }
  get color() {
    return this._color;
  }
  set color(t5) {
    P2(t5, this._color) || (a2(this._color, t5), this._updateArrowColor());
  }
  get contrastColor() {
    return this._contrastColor;
  }
  set contrastColor(t5) {
    P2(t5, this._color) || (a2(this._contrastColor, t5), this._updateArrowColor());
  }
  createExternalResources() {
    const e8 = this._color, r8 = this._contrastColor, o6 = this._stripesEnabled ? r8 : e8;
    this._arrowMaterial = new O3({
      outlineColor: e8,
      stripeEvenColor: o6,
      stripeOddColor: e8,
      renderOccluded: this.renderOccluded,
      polygonOffset: true,
      isDecoration: this.isDecoration
    }), this._handles = new r(), this._handles.add(d(() => this.view.state.camera, () => {
      this._viewChanged();
    }));
  }
  destroyExternalResources() {
    this._arrowMaterial = null, this._handles = u(this._handles);
  }
  forEachExternalMaterial(e8) {
    e8(this._arrowMaterial);
  }
  createGeometries(e8) {
    if (null == this._geometry?.startRenderSpace || null == this._geometry.endRenderSpace) return;
    const t5 = this._createArrowGeometry(this._geometry.startRenderSpace, this._geometry.endRenderSpace, this._origin, this._geometry);
    t5.transformation = this._originTransform, e8.addGeometry(t5), this._viewChanged();
  }
  _createArrowGeometry(e8, t5, r8, s5) {
    const o6 = this.view, a4 = o6.renderCoordsHelper, n4 = [], l = [], c5 = (e9, t6) => {
      const s6 = c2.get();
      e2(s6, e9, r8), n4.push(s6), l.push(t6);
    };
    if ("euclidean" === s5.type) {
      s5.eval(0.5, this._arrowCenter);
      const r9 = c2.get();
      if (a4.worldUpAtPosition(this._arrowCenter, r9), b(e8, t5, r9)) {
        const {
          heading: t6,
          tilt: s6
        } = o6.camera, {
          direction: a5
        } = N(o6, e8, t6, s6, j5);
        r2(r9, a5);
      }
      c5(e8, r9), c5(t5, r9);
    } else {
      s5.eval(0.5, this._arrowCenter);
      const e9 = this._arrowSubdivisions + 1 & -2;
      for (let t6 = 0; t6 < e9; ++t6) {
        const r9 = t6 / (e9 - 1), o7 = c2.get(), i2 = c2.get();
        s5.eval(r9, o7), a4.worldUpAtPosition(o7, i2), c5(o7, i2);
      }
    }
    return gt(this._arrowMaterial, n4, l);
  }
  _geometryChanged() {
    this.recreateGeometry();
  }
  _viewChanged() {
    if (this.view.ready && this.attached && null != this._geometry) {
      const e8 = this.view.state.camera.computeScreenPixelSizeAt(this._arrowCenter);
      this._arrowMaterial.setParameters({
        width: this._arrowWidth * e8
      });
    }
  }
  _updateArrowColor() {
    if (!this.attached) return;
    const e8 = this._color, t5 = this._contrastColor, r8 = this._stripesEnabled ? t5 : e8, s5 = e8, o6 = e8;
    this._arrowMaterial.setParameters({
      stripeEvenColor: r8,
      outlineColor: s5,
      stripeOddColor: o6
    });
  }
};
function b(e8, t5, r8) {
  const s5 = K(v3, t5, e8), o6 = _(v3, s5, r8);
  return 0 === Y(o6);
}
var v3 = n2();
var j5 = u4();

// ../../../node_modules/@arcgis/core/views/3d/analysis/DirectLineMeasurement/DirectLineMeasurementVisualization.js
var W = class extends S {
  get _parameters() {
    const e8 = this.view.effectiveTheme, {
      accentColor: t5,
      textColor: l
    } = e8, a4 = E(t5), c5 = F(t5, 0.75), d2 = E(G(t5)), h6 = G(l, q.Low);
    return {
      accentColor: a4,
      contrastColor: d2,
      translucentAccentColor: c5,
      triangleLineWidth: 3,
      geodesicProjectionLineWidth: 2,
      guideLineWidth: 2,
      guideStippleLengthPixels: 3,
      directLabelFontSize: 16,
      horizontalLabelFontSize: 12,
      verticalLabelFontSize: 12,
      textColor: l,
      textBackgroundColor: R(h6, 0.6),
      textCalloutColor: R(h6, 0.5)
    };
  }
  get visible() {
    return this.analysisView.visible;
  }
  get viewMode() {
    const {
      elevationAlignedStartPoint: e8,
      elevationAlignedEndPoint: t5
    } = this.analysisView;
    if (null == e8 || null == t5 || e8.equals(t5)) return e7.None;
    const i2 = this.analysisView.result;
    if (null == i2) return e7.Direct;
    if ("geodesic" === this.actualVisualizedMeasurement) return this._requiresGeodesicGuideAt(this._startPosition) || this._requiresGeodesicGuideAt(this._endPosition) ? e7.ProjectedGeodesic : e7.Direct;
    const {
      verticalDistance: s5,
      horizontalDistance: n4
    } = i2, o6 = s5.value, r8 = n4.value;
    return Math.min(o6 / r8, r8 / o6) < this.triangleCollapseRatioThreshold ? e7.Direct : e7.Triangle;
  }
  get actualVisualizedMeasurement() {
    const {
      measurementMode: e8,
      result: t5
    } = this.analysisView;
    switch (e8) {
      case e6.Auto:
        return null != t5 && t5.horizontalDistance.value > i ? "geodesic" : "euclidean";
      case e6.Euclidean:
        return "euclidean";
      case e6.Geodesic:
        return "geodesic";
    }
  }
  get allowVisualElementsOrientationChange() {
    return null == this._triangleOrientationOverride;
  }
  set allowVisualElementsOrientationChange(e8) {
    null == this._triangleOrientationOverride !== e8 && (null == this._triangleOrientationOverride ? this._triangleOrientationOverride = this._actualVisualElementsOrientation : this._triangleOrientationOverride = null);
  }
  get labels() {
    return "geodesic" === this.actualVisualizedMeasurement ? {
      direct: null,
      horizontal: this._segmentLabel,
      vertical: this._verticalLabel
    } : {
      direct: this._segmentLabel,
      horizontal: this._horizontalLabel,
      vertical: this._verticalLabel
    };
  }
  constructor(e8) {
    super(e8), this._segmentVisualElement = null, this._triangleVisualElement = null, this._rightAngleQuad = null, this._projectedGeodesicLine = null, this._geodesicStartHint = null, this._geodesicEndHint = null, this._segmentLabel = null, this._verticalLabel = null, this._horizontalLabel = null, this._startPosition = n2(), this._endPosition = n2(), this._cornerPosition = n2(), this._startPositionAtSeaLevel = n2(), this._endPositionAtSeaLevel = n2(), this._triangleOrientationOverride = null, this.messages = null, this.loadingMessages = true, this.visualElementOrientation = o5.Auto, this.triangleCollapseRatioThreshold = 0.03;
  }
  initialize() {
    const e8 = this._parameters, t5 = {
      attached: true,
      view: this.view,
      isDecoration: true
    }, {
      guideLineWidth: i2,
      guideStippleLengthPixels: s5,
      triangleLineWidth: n4,
      geodesicProjectionLineWidth: o6,
      directLabelFontSize: r8,
      verticalLabelFontSize: l,
      horizontalLabelFontSize: a4
    } = e8;
    this._segmentVisualElement = new y4(__spreadProps(__spreadValues({}, t5), {
      geometry: null,
      renderOccluded: h3.OccludeAndTransparent
    })), this._triangleVisualElement = new f3(__spreadProps(__spreadValues({}, t5), {
      width: n4,
      renderOccluded: h3.OccludeAndTransparent
    })), this._rightAngleQuad = new D(__spreadProps(__spreadValues({}, t5), {
      renderOccluded: h3.OccludeAndTransparent
    }));
    const c5 = __spreadProps(__spreadValues({}, t5), {
      polygonOffset: true,
      renderOccluded: h3.OccludeAndTransparent
    });
    this._projectedGeodesicLine = new f3(__spreadProps(__spreadValues({}, c5), {
      width: o6,
      stipplePattern: h4(s5)
    })), this._geodesicStartHint = new f3(__spreadProps(__spreadValues({}, c5), {
      width: i2,
      stipplePattern: h4(s5)
    })), this._geodesicEndHint = new f3(__spreadProps(__spreadValues({}, c5), {
      width: i2,
      stipplePattern: h4(s5)
    })), this._segmentLabel = new f4(__spreadProps(__spreadValues({}, t5), {
      fontSize: r8
    })), this._verticalLabel = new f4(__spreadProps(__spreadValues({}, t5), {
      fontSize: l
    })), this._horizontalLabel = new f4(__spreadProps(__spreadValues({}, t5), {
      fontSize: a4
    })), this.addHandles([d(() => {
      const {
        elevationAlignedStartPoint: e9,
        elevationAlignedEndPoint: t6
      } = this.analysisView, i3 = this.view;
      return {
        view: i3,
        camera: i3.state.camera,
        viewMode: this.viewMode,
        elevationAlignedStartPoint: e9,
        elevationAlignedEndPoint: t6,
        orientation: this._actualVisualElementsOrientation,
        visualizedMeasurement: this.actualVisualizedMeasurement,
        stripeLength: this._measurementArrowStripeLength
      };
    }, (e9) => this._updateGeometryAndViewMode(e9), A), d(() => ({
      visible: this.visible,
      viewMode: this.viewMode
    }), (e9) => this._updateVisualElementVisibility(e9), A), d(() => ({
      text: this._labelsText,
      visualizedMeasurement: this.actualVisualizedMeasurement
    }), (e9) => this._updateLabelText(e9), A), d(() => ({
      visible: this.visible,
      viewMode: this.viewMode
    }), (e9) => this._updateLabelVisibility(e9), A), d(() => this._measurementArrowStripeLength, (e9) => this._updateSegmentStripeLength(e9), A), f(() => __async(this, null, function* () {
      return this._updateMessageBundle();
    })), d(() => this._parameters, ({
      textBackgroundColor: e9,
      textCalloutColor: t6,
      textColor: i3,
      translucentAccentColor: s6,
      accentColor: n5,
      contrastColor: o7
    }) => {
      const {
        _segmentLabel: r9,
        _verticalLabel: l2,
        _horizontalLabel: a5,
        _triangleVisualElement: c6,
        _rightAngleQuad: d2,
        _projectedGeodesicLine: h6,
        _geodesicStartHint: u5,
        _geodesicEndHint: m3,
        _segmentVisualElement: g4
      } = this;
      r9.backgroundColor = e9, r9.calloutColor = t6, r9.textColor = i3, l2.backgroundColor = e9, l2.calloutColor = t6, l2.textColor = i3, a5.backgroundColor = e9, a5.calloutColor = t6, a5.textColor = i3, c6.color = s6, d2.color = s6, h6.color = s6, u5.color = s6, m3.color = s6, g4.color = n5, g4.contrastColor = o7;
    }, P)]), this._updateMessageBundle();
  }
  destroy() {
    this._segmentVisualElement = u(this._segmentVisualElement), this._triangleVisualElement = u(this._triangleVisualElement), this._rightAngleQuad = u(this._rightAngleQuad), this._projectedGeodesicLine = u(this._projectedGeodesicLine), this._geodesicStartHint = u(this._geodesicStartHint), this._geodesicEndHint = u(this._geodesicEndHint), this._segmentLabel = u(this._segmentLabel), this._verticalLabel = u(this._verticalLabel), this._horizontalLabel = u(this._horizontalLabel), this.set("view", null);
  }
  _updateVisualElementVisibility({
    visible: e8,
    viewMode: t5
  }) {
    if (this._segmentVisualElement.visible = false, this._triangleVisualElement.visible = false, this._rightAngleQuad.visible = false, this._projectedGeodesicLine.visible = false, this._geodesicStartHint.visible = false, this._geodesicEndHint.visible = false, e8) switch (t5) {
      case e7.None:
        break;
      case e7.Direct:
        this._segmentVisualElement.visible = true;
        break;
      case e7.Triangle:
        this._segmentVisualElement.visible = true, this._triangleVisualElement.visible = true, this._rightAngleQuad.visible = true;
        break;
      case e7.ProjectedGeodesic:
        this._segmentVisualElement.visible = true, this._projectedGeodesicLine.visible = true, this._geodesicStartHint.visible = true, this._geodesicEndHint.visible = true;
    }
  }
  _updateGeometryAndViewMode({
    view: e8,
    camera: t5,
    viewMode: i2,
    elevationAlignedStartPoint: s5,
    elevationAlignedEndPoint: n4,
    orientation: o6,
    visualizedMeasurement: r8,
    stripeLength: l
  }) {
    const a4 = e8.renderCoordsHelper;
    if (null == a4 || null == s5 || null == n4 || s5.equals(n4)) return;
    let c5 = this._startPosition, d2 = this._endPosition;
    a4.toRenderCoords(s5, c5), a4.toRenderCoords(n4, d2);
    const h6 = o6 === o5.AboveSegment ? 1 : -1, u5 = h6 * (a4.getAltitude(d2) - a4.getAltitude(c5));
    u5 < 0 && (c5 = this._endPosition, d2 = this._startPosition);
    const m3 = "geodesic" === r8 ? new _3(this._startPosition, this._endPosition, a4.spatialReference) : new m(this._startPosition, this._endPosition);
    switch (this._segmentVisualElement.geometry = m3, this._updateSegmentStripeLength(l), i2) {
      case e7.Direct:
        this._updateSegment(m3, o6);
        break;
      case e7.Triangle:
        this._updateSegmentAndTriangle({
          view: e8,
          camera: t5,
          segment: m3,
          orientation: o6,
          startPosition: c5,
          endPosition: d2,
          deltaSign: h6,
          altitudeDelta: u5
        });
        break;
      case e7.ProjectedGeodesic:
        this._updateSegmentAndProjection({
          view: e8,
          orientation: o6,
          startPosition: c5,
          endPosition: d2
        });
    }
  }
  _updateSegment(e8, t5) {
    this._segmentLabel.anchor = t5 === o5.AboveSegment ? "top" : "bottom", this._segmentLabel.geometry = {
      type: "segment",
      segment: e8,
      sampleLocation: "center"
    };
  }
  _updateSegmentAndTriangle({
    view: {
      renderCoordsHelper: e8
    },
    camera: t5,
    segment: i2,
    orientation: s5,
    startPosition: n4,
    endPosition: o6,
    deltaSign: r8,
    altitudeDelta: l
  }) {
    const a4 = this._cornerPosition;
    e8.worldUpAtPosition(n4, a4), g(a4, a4, r8 * Math.abs(l)), u2(a4, a4, n4), this._triangleVisualElement.geometry = [[[n4[0], n4[1], n4[2]], [a4[0], a4[1], a4[2]], [o6[0], o6[1], o6[2]]]], this._rightAngleQuad.geometry = {
      previous: n4,
      center: a4,
      next: o6
    };
    const c5 = new m(n4, a4), d2 = new m(a4, o6), h6 = N2(n4, o6, a4, s5, t5);
    this._segmentLabel.anchor = h6.segment, this._segmentLabel.geometry = {
      type: "segment",
      segment: i2,
      sampleLocation: "center"
    }, this._verticalLabel.geometry = {
      type: "segment",
      segment: c5,
      sampleLocation: "center"
    }, this._verticalLabel.anchor = h6.vertical, this._horizontalLabel.geometry = {
      type: "segment",
      segment: d2,
      sampleLocation: "center"
    }, this._horizontalLabel.anchor = h6.horizontal;
  }
  _updateSegmentAndProjection({
    view: {
      renderCoordsHelper: e8
    },
    orientation: t5,
    startPosition: i2,
    endPosition: s5
  }) {
    e8.setAltitude(this._startPositionAtSeaLevel, 0, i2), e8.setAltitude(this._endPositionAtSeaLevel, 0, s5);
    const n4 = new _3(this._startPositionAtSeaLevel, this._endPositionAtSeaLevel, e8.spatialReference);
    this._projectedGeodesicLine.setGeometryFromSegment(n4), this._geodesicStartHint.setGeometryFromSegment(new m(this._startPositionAtSeaLevel, i2)), this._geodesicEndHint.setGeometryFromSegment(new m(this._endPositionAtSeaLevel, s5)), this._segmentLabel.geometry = {
      type: "segment",
      segment: n4,
      sampleLocation: "center"
    }, this._segmentLabel.anchor = t5 === o5.AboveSegment ? "top" : "bottom";
  }
  _updateLabelText({
    text: e8,
    visualizedMeasurement: t5
  }) {
    null != e8 ? (this._segmentLabel.text = "euclidean" === t5 ? e8.directDistance : e8.horizontalDistance, this._horizontalLabel.text = e8.horizontalDistance, this._verticalLabel.text = e8.verticalDistance) : (this._segmentLabel.text = null, this._horizontalLabel.text = null, this._verticalLabel.text = null), this.notifyChange("labels");
  }
  _updateLabelVisibility({
    visible: e8,
    viewMode: t5
  }) {
    const i2 = this._segmentLabel, s5 = this._horizontalLabel, n4 = this._verticalLabel;
    if (i2.visible = false, s5.visible = false, n4.visible = false, e8) switch (t5) {
      case e7.Direct:
        i2.visible = true;
        break;
      case e7.Triangle:
        i2.visible = true, s5.visible = true, n4.visible = true;
        break;
      case e7.ProjectedGeodesic:
        i2.visible = true;
      case e7.None:
    }
  }
  get _labelsText() {
    if (this.destroyed) return null;
    const e8 = this.messages, t5 = this.analysisView.result;
    if (null == t5 || null == e8) return null;
    const {
      directDistance: i2,
      horizontalDistance: s5,
      verticalDistance: n4
    } = t5, o6 = this.analysisView.unit, r8 = (e9) => __spreadValues({
      directDistance: "",
      horizontalDistance: "",
      verticalDistance: ""
    }, e9);
    switch (o6) {
      case "metric":
        return r8({
          directDistance: i2 && M(e8, i2),
          horizontalDistance: s5 && M(e8, s5),
          verticalDistance: n4 && w(e8, n4)
        });
      case "imperial":
        return r8({
          directDistance: i2 && y2(e8, i2),
          horizontalDistance: s5 && y2(e8, s5),
          verticalDistance: n4 && j3(e8, n4)
        });
      default:
        return r8({
          directDistance: i2 && g2(e8, i2, o6),
          horizontalDistance: s5 && g2(e8, s5, o6),
          verticalDistance: n4 && g2(e8, n4, o6)
        });
    }
  }
  _updateSegmentStripeLength(e8) {
    const t5 = this._segmentVisualElement;
    null != e8 ? (t5.stripeLength = e8, t5.stripesEnabled = true) : t5.stripesEnabled = false;
  }
  get _actualVisualElementsOrientation() {
    if (null != this._triangleOrientationOverride) return this._triangleOrientationOverride;
    const e8 = this.visualElementOrientation;
    return e8 === o5.Auto ? this.view.state.camera.aboveGround ? o5.AboveSegment : o5.BelowSegment : e8;
  }
  _requiresGeodesicGuideAt(e8) {
    const t5 = this.view;
    if (!t5?.state) return false;
    const i2 = t5.state.camera, s5 = t5.renderCoordsHelper;
    if (!s5) return false;
    const n4 = i2.computeScreenPixelSizeAt(e8);
    return s5.getAltitude(e8) / n4 >= 10;
  }
  get _measurementArrowStripeLength() {
    const {
      result: e8,
      unit: t5
    } = this.analysisView;
    if (null == e8) return null;
    let i2 = null;
    const s5 = e8.directDistance;
    switch (t5) {
      case "metric":
        i2 = s5 && s2(s5, "meters");
        break;
      case "imperial":
        i2 = s5 && s2(s5, J(s5.value, s5.unit));
        break;
      default:
        i2 = s5 && s2(s5, t5);
    }
    if (null == i2) return null;
    return c(i2.value / 30) * j(1, i2.unit, "meters");
  }
  _updateMessageBundle() {
    this.loadingMessages = true, h("esri/core/t9n/Units").then((e8) => {
      this.messages = e8;
    }).finally(() => {
      this.loadingMessages = false;
    });
  }
  get testData() {
  }
};
function N2(e8, t5, i2, s5, n4) {
  const o6 = J2, r8 = K2;
  n4.projectToRenderScreen(i2, o6), n4.projectToRenderScreen(t5, r8);
  const l = {
    segment: "bottom",
    horizontal: "top",
    vertical: o6[0] < r8[0] ? "left" : "right"
  };
  {
    const s6 = X, o7 = Y2;
    if (p(e8, i2, n4, s6), p(e8, t5, n4, o7), j2(s6, o7) >= I2) {
      const e9 = Math.sign(s6[1]) === Math.sign(o7[1]);
      l.segment = e9 ? v(l.vertical) : l.vertical;
    } else {
      const e9 = Z;
      p(i2, t5, n4, e9), j2(e9, o7) >= I2 && (l.segment = Math.sign(e9[0]) === Math.sign(o7[0]) ? v(l.horizontal) : l.horizontal);
    }
  }
  if (s5 === o5.BelowSegment) {
    const e9 = (e10) => "top" === e10 ? "bottom" : "top";
    l.segment = e9(l.segment), l.horizontal = e9(l.horizontal), l.vertical = e9(l.vertical);
  }
  return l;
}
e([y()], W.prototype, "_parameters", null), e([y()], W.prototype, "_triangleOrientationOverride", void 0), e([y()], W.prototype, "messages", void 0), e([y()], W.prototype, "view", void 0), e([y()], W.prototype, "analysis", void 0), e([y()], W.prototype, "analysisView", void 0), e([y()], W.prototype, "loadingMessages", void 0), e([y()], W.prototype, "visible", null), e([y()], W.prototype, "viewMode", null), e([y()], W.prototype, "actualVisualizedMeasurement", null), e([y()], W.prototype, "visualElementOrientation", void 0), e([y()], W.prototype, "triangleCollapseRatioThreshold", void 0), e([y()], W.prototype, "allowVisualElementsOrientationChange", null), e([y()], W.prototype, "labels", null), e([y()], W.prototype, "_labelsText", null), e([y()], W.prototype, "_actualVisualElementsOrientation", null), e([y()], W.prototype, "_measurementArrowStripeLength", null), W = e([a("esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementVisualization")], W);
var I2 = Math.cos(h2(12));
var J2 = x2();
var K2 = x2();
var X = s();
var Y2 = s();
var Z = s();

// ../../../node_modules/@arcgis/core/views/3d/analysis/DirectLineMeasurementAnalysisView3D.js
var p2 = class extends s3(S) {
  constructor(t5) {
    super(t5), this.type = "direct-line-measurement-view-3d", this.analysis = null, this.result = null, this.measurementMode = e6.Auto, this.elevationAlignedStartPoint = null, this.elevationAlignedEndPoint = null;
  }
  initialize() {
    const t5 = this.view, e8 = this.analysis;
    this._analysisVisualization = new W({
      view: t5,
      analysis: e8,
      analysisView: this
    }), this._analysisController = new m2({
      view: t5,
      analysis: e8,
      viewData: this
    });
  }
  destroy() {
    this._analysisController = u(this._analysisController), this._analysisVisualization = u(this._analysisVisualization);
  }
  get updating() {
    return !!this._analysisVisualization?.loadingMessages;
  }
  get viewMode() {
    return this._analysisVisualization.viewMode;
  }
  get actualVisualizedMeasurement() {
    return this._analysisVisualization.actualVisualizedMeasurement;
  }
  get visualElementOrientation() {
    return this._analysisVisualization.visualElementOrientation;
  }
  set visualElementOrientation(t5) {
    this._analysisVisualization.visualElementOrientation = t5;
  }
  get allowVisualElementsOrientationChange() {
    return this._analysisVisualization.allowVisualElementsOrientationChange;
  }
  set allowVisualElementsOrientationChange(t5) {
    this._analysisVisualization.allowVisualElementsOrientationChange = t5;
  }
  get triangleCollapseRatioThreshold() {
    return this._analysisVisualization.triangleCollapseRatioThreshold;
  }
  set triangleCollapseRatioThreshold(t5) {
    this._analysisVisualization.triangleCollapseRatioThreshold = t5;
  }
  get directLabelText() {
    return this._analysisVisualization.labels.direct?.text ?? "";
  }
  get horizontalLabelText() {
    return this._analysisVisualization.labels.horizontal?.text ?? "";
  }
  get verticalLabelText() {
    return this._analysisVisualization.labels.vertical?.text ?? "";
  }
  get unit() {
    return this.analysis.unit ?? this._defaultUnit;
  }
  get testData() {
  }
};
e([y()], p2.prototype, "updating", null), e([y({
  readOnly: true
})], p2.prototype, "type", void 0), e([y({
  constructOnly: true,
  nonNullable: true
})], p2.prototype, "analysis", void 0), e([y()], p2.prototype, "result", void 0), e([y()], p2.prototype, "measurementMode", void 0), e([y()], p2.prototype, "elevationAlignedStartPoint", void 0), e([y()], p2.prototype, "elevationAlignedEndPoint", void 0), e([y({
  readOnly: true
})], p2.prototype, "viewMode", null), e([y({
  readOnly: true
})], p2.prototype, "actualVisualizedMeasurement", null), e([y()], p2.prototype, "visualElementOrientation", null), e([y()], p2.prototype, "allowVisualElementsOrientationChange", null), e([y()], p2.prototype, "triangleCollapseRatioThreshold", null), e([y({
  readOnly: true
})], p2.prototype, "directLabelText", null), e([y({
  readOnly: true
})], p2.prototype, "horizontalLabelText", null), e([y({
  readOnly: true
})], p2.prototype, "verticalLabelText", null), e([y()], p2.prototype, "_analysisVisualization", void 0), e([y()], p2.prototype, "_analysisController", void 0), e([y()], p2.prototype, "unit", null), e([y(e5)], p2.prototype, "_defaultUnit", void 0), p2 = e([a("esri.views.3d.analysis.DirectLineMeasurementAnalysisView3D")], p2);
var y5 = p2;
export {
  y5 as default
};
//# sourceMappingURL=DirectLineMeasurementAnalysisView3D-BMETURTQ.js.map
