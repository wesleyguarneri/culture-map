import {
  v
} from "./chunk-YFC23HKN.js";
import "./chunk-KBAXMVAM.js";
import "./chunk-6N3CFEVA.js";
import {
  p as p2
} from "./chunk-GP22YFQD.js";
import "./chunk-XVR4FEAF.js";
import "./chunk-NLEBYD5G.js";
import "./chunk-MOCGEINB.js";
import "./chunk-NSSWLGUQ.js";
import {
  l as l2
} from "./chunk-CITBGG5A.js";
import "./chunk-6HTAUV5K.js";
import {
  u
} from "./chunk-7O52V6IT.js";
import {
  A,
  _,
  c,
  f,
  l,
  m,
  p
} from "./chunk-XS2MWMEF.js";
import "./chunk-EOYCWFZW.js";
import {
  r as r2
} from "./chunk-WTF7K3GK.js";
import {
  i
} from "./chunk-UQMQLPLV.js";
import {
  y as y2
} from "./chunk-5JJ6GBOU.js";
import "./chunk-D4LAF4TH.js";
import "./chunk-QL5HR3YL.js";
import "./chunk-D3AKDIJC.js";
import {
  t
} from "./chunk-BAAB562I.js";
import "./chunk-R27BBJA3.js";
import "./chunk-GOOZVNO4.js";
import "./chunk-5RHKQDDL.js";
import "./chunk-ZAP7ZEWR.js";
import "./chunk-675UQNXB.js";
import "./chunk-X2OAE75B.js";
import "./chunk-UCPBGEQD.js";
import "./chunk-SIZK72CP.js";
import "./chunk-P7OSFLIX.js";
import "./chunk-ZDC4PV4Y.js";
import {
  se
} from "./chunk-6E7LFKP2.js";
import "./chunk-SYYDVGKY.js";
import {
  L
} from "./chunk-YLE5AYZV.js";
import "./chunk-PVO5NM6Q.js";
import "./chunk-2N3BR7QT.js";
import "./chunk-N3IR233K.js";
import "./chunk-PPMDUJ4E.js";
import "./chunk-R5ZE5A4K.js";
import "./chunk-24CN3HDP.js";
import "./chunk-SZWWBMQN.js";
import "./chunk-R3F4JMNC.js";
import "./chunk-KKD7A2GN.js";
import "./chunk-4MMTPKY4.js";
import "./chunk-DY7FJHTG.js";
import "./chunk-HD65DNIO.js";
import "./chunk-4KWLMXIA.js";
import "./chunk-BIUXKPKA.js";
import "./chunk-634JLXD4.js";
import "./chunk-Y3EDGYWG.js";
import "./chunk-UF6JOUSJ.js";
import "./chunk-T5JGQSO3.js";
import "./chunk-CIW3KHOW.js";
import "./chunk-J55F4AC2.js";
import "./chunk-IQLBZKUD.js";
import "./chunk-7MZZCQ64.js";
import "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import "./chunk-WPPFJVPN.js";
import "./chunk-6A7CWJED.js";
import "./chunk-DUTZNK67.js";
import "./chunk-IN6BQCWS.js";
import "./chunk-CRNUMTSV.js";
import "./chunk-JM7HAEY6.js";
import "./chunk-LJEOBI2I.js";
import "./chunk-2OMCGIU4.js";
import "./chunk-DR5TVNEL.js";
import "./chunk-HT2T6PUB.js";
import "./chunk-6EUVKE22.js";
import "./chunk-OKJHJ3CY.js";
import "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import "./chunk-DZALMCYL.js";
import "./chunk-K226GFDN.js";
import "./chunk-4ZZRP4MA.js";
import "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import "./chunk-NYQ5CYNR.js";
import "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import "./chunk-AXVPJBVW.js";
import "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import {
  w
} from "./chunk-6WHTZNUH.js";
import "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import "./chunk-XNUH25NY.js";
import "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e
} from "./chunk-4Z5SGKRM.js";
import "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3 as a
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import {
  r
} from "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  s2 as s
} from "./chunk-WYIDUUN2.js";
import "./chunk-DXLOWWK7.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/views/3d/terrain/RasterTile.js
var u2 = {
  bandCount: 3,
  outMin: 0,
  outMax: 1,
  minCutOff: [0, 0, 0],
  maxCutOff: [255, 255, 255],
  factor: [1 / 255, 1 / 255, 1 / 255],
  useGamma: false,
  gamma: [1, 1, 1],
  gammaCorrection: [1, 1, 1],
  colormap: null,
  colormapOffset: null,
  stretchType: "none",
  type: "stretch"
};
var m2 = class {
  constructor(t2, e2, r3 = null, s2 = null) {
    this.lij = t2, this.type = "raster-tile", this._memoryUsed = null, this._source = null, this._symbolizerParameters = null, this._bandIds = null, this._interpolation = null, this._dirty = false, this._transformGrid = null, this.isRendereredSource = false, this.symbolizerRenderer = null, this.rawPixelData = null, this.opacity = 1, this.source = e2, this.width = r3 || e2.width, this.height = s2 || e2.height;
  }
  get source() {
    return this._source;
  }
  set source(e2) {
    this._source = e2, this._rasterTexture = r(this._rasterTexture), this._memoryUsed = null;
  }
  get symbolizerParameters() {
    return this.isRendereredSource ? __spreadProps(__spreadValues({}, u2), {
      maxCutOff: [1, 1, 1],
      factor: [1, 1, 1]
    }) : this._symbolizerParameters || u2;
  }
  set symbolizerParameters(t2) {
    this._symbolizerParameters = t2;
  }
  get bandIds() {
    return this._bandIds;
  }
  set bandIds(t2) {
    if (null != t2 && t2.length > 0) {
      this._bandIds && t2.every((t3, e2) => !!this._bandIds?.[e2] && t3 === this._bandIds[e2]) || (this._bandIds = t2, this._dirty = true);
    } else this._bandIds = null;
  }
  get interpolation() {
    return this._interpolation || "nearest";
  }
  set interpolation(t2) {
    if (this._interpolation = t2, null != this._rasterTexture) {
      const e2 = this._getRasterTextureInterpolation(t2);
      this._rasterTexture.setSamplingMode("bilinear" === e2 ? L.LINEAR : L.NEAREST);
    }
  }
  get transformGrid() {
    return this._transformGrid;
  }
  set transformGrid(e2) {
    this._transformGrid = e2, this._transformGridTexture = r(this._transformGridTexture), this._memoryUsed = null;
  }
  bind(t2) {
    return !!(this.source && this.source.pixels && this.source.pixels.length > 0) && ((null == this._rasterTexture || this._dirty) && this._updateRasterTexture(t2, this.bandIds), null != this._rasterTexture && (this._updateColormapTexture(t2), this.transformGrid && null == this._transformGridTexture && (this._transformGridTexture = c(t2, this.transformGrid))), true);
  }
  getUniforms() {
    const {
      symbolizerParameters: t2,
      transformGrid: r3,
      width: s2,
      height: h,
      opacity: n
    } = this, u4 = l(r3, [s2, h], [this.source.width, this.source.height], n), m3 = _(t2.colormap, t2.colormapOffset), d = "stretch" === this.symbolizerParameters.type ? p(this.symbolizerParameters) : null, _2 = "hillshade" === this.symbolizerParameters.type ? A(this.symbolizerParameters) : null;
    return new v(u4, m3, d || _2, this._rasterTexture, this._transformGridTexture, this._colormapTexture);
  }
  get isBilinearWithStretchColorRamp() {
    const {
      symbolizerParameters: t2
    } = this;
    return "bilinear" === this.interpolation && null != t2.colormap && "stretch" === t2.type;
  }
  get memoryUsage() {
    if (null == this._memoryUsed) {
      const t2 = [this._rasterTexture, this._transformGridTexture, this._colormapTexture];
      this._memoryUsed = t2.map((t3) => null != t3 ? t3.descriptor.width * t3.descriptor.height * 4 : 0).reduce((t3, e2) => t3 + e2, 0);
    }
    return this._memoryUsed;
  }
  release() {
    return this._rasterTexture = r(this._rasterTexture), this._transformGridTexture = r(this._transformGridTexture), this._colormapTexture = r(this._colormapTexture), this.source = null, this.transformGrid = null, this.rawPixelData = null, true;
  }
  _updateRasterTexture(e2, r3) {
    const s2 = this.source ? this.source.extractBands(r3) : null;
    if (!(s2?.pixels && s2.pixels.length > 0)) return void (this._rasterTexture = r(this._rasterTexture));
    const i2 = null == r3 && null == this.bandIds || null != r3 && null != this.bandIds && r3.join("") === this.bandIds.join("");
    if (null != this._rasterTexture && i2) return;
    this._rasterTexture = r(this._rasterTexture);
    const o = this._getRasterTextureInterpolation(this.interpolation);
    this._rasterTexture = f(e2, s2, o, this.isRendereredSource || this.hasStretchTypeNone());
  }
  hasStretchTypeNone() {
    return "stretchType" in this.symbolizerParameters && "none" === this.symbolizerParameters.stretchType && !this.symbolizerParameters.useGamma && "u8" === this.source.pixelType;
  }
  _getRasterTextureInterpolation(t2) {
    return "lut" === this.symbolizerParameters.type || "nearest" === t2 || "majority" === t2 || this.isBilinearWithStretchColorRamp ? "nearest" : "bilinear";
  }
  _updateColormapTexture(e2) {
    const r3 = this._colormap, s2 = this.symbolizerParameters.colormap;
    return s2 ? r3 ? s2.length !== r3.length || s2.some((t2, e3) => t2 !== r3[e3]) ? (this._colormapTexture = r(this._colormapTexture), this._colormapTexture = m(e2, s2), void (this._colormap = s2)) : void 0 : (this._colormapTexture = m(e2, s2), void (this._colormap = s2)) : (this._colormapTexture = r(this._colormapTexture), void (this._colormap = null));
  }
};

// ../../../node_modules/@arcgis/core/views/3d/layers/ImageryTileLayerView3D.js
var y3 = class extends u(i(p2(l2(y2)))) {
  constructor() {
    super(...arguments), this.type = "imagery-tile-3d", this._isAlignedMapTile = true;
  }
  initialize() {
    this.layer.increaseRasterJobHandlerUsage(), null == this.fullExtent && this.addResolvingPromise(Promise.reject(new s("layerview:spatial-reference-incompatible", "The layer extent cannot be projected to the view's spatial reference", {
      layer: this.layer
    })));
    const e2 = w(() => this.view?.basemapTerrain?.tilingSchemeLocked).then(() => {
      const e3 = this.view.basemapTerrain.tilingScheme, t2 = this.layer.tileInfo;
      this._isAlignedMapTile = ["png", "png24", "png32", "jpg", "mixed"].includes(t2.format) && e3.compatibleWith(t2), this.tileInfo = this._isAlignedMapTile ? t2 : e3.toTileInfo(), this._updatingHandles.add(() => [this.layer.renderer, this.layer.interpolation, this.layer.bandIds, this.layer.multidimensionalDefinition, this.layer.multidimensionalSubset, this.layer.rasterFunction, this.timeExtent], () => this.refresh());
    });
    this.addResolvingPromise(e2);
  }
  destroy() {
    this.layer.decreaseRasterJobHandlerUsage();
  }
  get _blankTile() {
    const e2 = document.createElement("canvas"), t2 = e2.getContext("2d"), [r3, i2] = this.tileInfo.size;
    return e2.width = r3, e2.height = i2, t2.clearRect(0, 0, r3, i2), t2.getImageData(0, 0, r3, i2);
  }
  get imageFormatIsOpaque() {
    return "jpg" === this.layer.tileInfo.format;
  }
  get hasMixedImageFormats() {
    return "mixed" === this.layer.tileInfo.format;
  }
  get dataLevelRange() {
    const e2 = this.layer.tileInfo, t2 = this.tileInfo.lodAt(0)?.scale, r3 = this.layer.tileInfo.lodAt(e2.lods.length - 1)?.scale;
    return this.levelRangeFromScaleRange(t2, r3);
  }
  _getfullExtent() {
    return se(this.layer.serviceRasterInfo, this.view.basemapTerrain?.spatialReference ?? this.view.spatialReference);
  }
  fetchTile(e2, t2) {
    return __async(this, null, function* () {
      const r3 = this.tileInfo, i2 = this._canSymbolizeInWebGL(), s2 = {
        tileInfo: r3,
        requestRawData: i2,
        signal: t2.signal,
        timeExtent: this.timeExtent,
        requestAsImageElement: this._isAlignedMapTile,
        noClip: false
      }, {
        layer: a2
      } = this, [l3, n, m3] = e2, p3 = yield a2.fetchTile(l3, n, m3, s2);
      if (p3 instanceof HTMLImageElement) return p3;
      let h = p3?.pixelBlock;
      if (null == h) return this._blankTile;
      if (!i2 && (h = yield a2.applyRenderer(p3), null == h)) return this._blankTile;
      const c2 = new m2([l3, n, m3], h, r3.size[0], r3.size[1]);
      return i2 ? (c2.symbolizerRenderer = a2.symbolizer.rendererJSON, c2.symbolizerParameters = a2.symbolizer.generateWebGLParameters(this._getSymbolizerOptions(l3)), c2.transformGrid = p3.transformGrid, c2.bandIds = a2.bandIds) : (c2.isRendereredSource = true, c2.bandIds = null), c2.interpolation = a2.interpolation, c2;
    });
  }
  _getSymbolizerOptions(e2) {
    const t2 = this.tileInfo.lodAt(e2).resolution;
    return {
      pixelBlock: null,
      isGCS: null != this.view.basemapTerrain?.spatialReference ? this.view.basemapTerrain.spatialReference.isGeographic : this.view.spatialReference.isGeographic,
      resolution: {
        x: t2,
        y: t2
      },
      bandIds: this.layer.bandIds
    };
  }
  ensureSymbolizerParameters(e2) {
    this._canSymbolizeInWebGL() && JSON.stringify(e2.symbolizerRenderer) !== JSON.stringify(this.layer.symbolizer.rendererJSON) && (e2.symbolizerParameters = this.layer.symbolizer.generateWebGLParameters(this._getSymbolizerOptions(e2.lij[0])));
  }
  createFetchPopupFeaturesQueryGeometry(e2, t2) {
    return r2(e2, t2, this.view);
  }
  refresh() {
    this.emit("data-changed");
  }
  doRefresh() {
    return __async(this, null, function* () {
      this.suspended || this.emit("data-changed");
    });
  }
  _canSymbolizeInWebGL() {
    const e2 = t(), {
      symbolizer: t2
    } = this.layer, r3 = t2.lookup?.colormapLut?.indexedColormap, i2 = !!this.layer.rasterFunction?.hasClipFunction, s2 = r3 && r3.length > 4 * (e2.maxTextureSize || 4906);
    return t2.canRenderInWebGL && !s2 && !i2;
  }
};
e([y({
  readOnly: true
})], y3.prototype, "_blankTile", null), e([y({
  readOnly: true
})], y3.prototype, "imageFormatIsOpaque", null), e([y({
  readOnly: true
})], y3.prototype, "hasMixedImageFormats", null), e([y({
  readOnly: true
})], y3.prototype, "dataLevelRange", null), y3 = e([a("esri.views.3d.layers.ImageryTileLayerView3D")], y3);
var u3 = y3;
export {
  u3 as default
};
//# sourceMappingURL=ImageryTileLayerView3D-GTVYUHFN.js.map
