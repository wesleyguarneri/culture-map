{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/chunks/Fog.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { invertOrIdentity as e } from \"../core/libs/gl-matrix-2/math/mat4.js\";\nimport { create as r } from \"../core/libs/gl-matrix-2/factories/mat4f64.js\";\nimport { create as a } from \"../core/libs/gl-matrix-2/factories/vec3f64.js\";\nimport { TextureCoordinateAttribute as o, TextureCoordinateAttributeType as t } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";\nimport { ReadLinearDepth as i } from \"../views/3d/webgl-engine/core/shaderLibrary/output/ReadDepth.glsl.js\";\nimport { Gamma as s } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl.js\";\nimport { Float2PassUniform as n } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float3PassUniform as d } from \"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";\nimport { FloatPassUniform as m } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { NoParameters as c, glsl as l } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as f } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { ShaderBuilder as g } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as p } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nimport { VertexAttribute as v } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nclass u extends c {\n  constructor() {\n    super(...arguments), this.fogColor = a(), this.fogStrength = 4e-6, this.atmosphereC = 1, this.fogAmount = 0;\n  }\n}\nfunction h() {\n  const r = new g();\n  r.attributes.add(v.POSITION, \"vec2\"), r.include(o, {\n    textureCoordinateType: t.Default\n  }), r.varyings.add(\"worldRay\", \"vec3\"), r.varyings.add(\"eyeDir\", \"vec3\");\n  const {\n    vertex: a,\n    fragment: c\n  } = r;\n  return a.uniforms.add(new f(\"inverseProjectionMatrix\", (e, r) => r.camera.inverseProjectionMatrix), new f(\"inverseViewMatrix\", (r, a) => e(w, a.camera.viewMatrix))), a.code.add(l`void main(void) {\nvec3 posViewNear = (inverseProjectionMatrix * vec4(position, -1, 1)).xyz;\neyeDir = posViewNear;\nworldRay = (inverseViewMatrix * vec4(posViewNear, 0)).xyz;\nforwardTextureCoordinates();\ngl_Position = vec4(position, 1, 1);\n}`), c.uniforms.add(new m(\"atmosphereC\", e => e.atmosphereC), new d(\"cameraPosition\", (e, r) => r.camera.eye), new n(\"nearFar\", (e, r) => r.camera.nearFar), new p(\"depthTexture\", e => e.depthTexture), new m(\"fogStrength\", e => e.fogStrength), new m(\"fogAmount\", e => e.fogAmount), new d(\"fogColor\", e => e.fogColor)), r.include(s), c.include(i), c.code.add(l`vec2 sphereIntersect(vec3 start, vec3 dir) {\nfloat a = dot(dir, dir);\nfloat b = 2.0 * dot(dir, start);\nfloat d = (b * b) - 4.0 * a * atmosphereC;\nif (d < 0.0) {\nreturn vec2(1e5, -1e5);\n}\nreturn vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));\n}`), c.code.add(l`vec4 applyFog(float dist, vec3 rayDir){\nif(dist == -1.0){\nvec2 rayAtmosphereIntersect = sphereIntersect(cameraPosition, rayDir);\ndist = 0.055 * rayAtmosphereIntersect.y;\n}\nfloat fogAmount = fogAmount * (1.0 - exp(-dist * fogStrength));\nreturn vec4(fogAmount * fogColor, fogAmount);\n}`), c.code.add(l`vec3 tonemapACES(vec3 x) {\nreturn clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\nvoid main() {\nvec3 rayDir = normalize(worldRay);\nfloat terrainDepth = -1.0;\nfloat depthSample = texture(depthTexture, vuv0).r;\nfloat zNorm = 2.0 * depthSample - 1.0;\nfloat linDepth = 2.0 * nearFar[0] * nearFar[1] / (nearFar[1] + nearFar[0] - zNorm * (nearFar[1] - nearFar[0]));\nif(depthSample < 1.0 && depthSample > 0.0){\nvec3 cameraSpaceRay = normalize(eyeDir);\ncameraSpaceRay /= cameraSpaceRay.z;\ncameraSpaceRay *= linDepth;\nterrainDepth = max(0.0, length(cameraSpaceRay));\n}\nvec4 fog = applyFog(terrainDepth, rayDir);\nfragColor = delinearizeGamma(vec4(tonemapACES(fog.rgb), fog.a));\n}`), r;\n}\nconst w = r(),\n  b = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    FogPassParameters: u,\n    build: h\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { u as F, b as a, h as b };"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA,IAAM,IAAN,cAAgBA,GAAE;AAAA,EAChB,cAAc;AACZ,UAAM,GAAG,SAAS,GAAG,KAAK,WAAW,EAAE,GAAG,KAAK,cAAc,MAAM,KAAK,cAAc,GAAG,KAAK,YAAY;AAAA,EAC5G;AACF;AACA,SAAS,IAAI;AACX,QAAM,IAAI,IAAIC,GAAE;AAChB,IAAE,WAAW,IAAIC,GAAE,UAAU,MAAM,GAAG,EAAE,QAAQD,IAAG;AAAA,IACjD,uBAAuB,EAAE;AAAA,EAC3B,CAAC,GAAG,EAAE,SAAS,IAAI,YAAY,MAAM,GAAG,EAAE,SAAS,IAAI,UAAU,MAAM;AACvE,QAAM;AAAA,IACJ,QAAQ;AAAA,IACR,UAAU;AAAA,EACZ,IAAI;AACJ,SAAO,EAAE,SAAS,IAAI,IAAIC,GAAE,2BAA2B,CAACA,IAAGC,OAAMA,GAAE,OAAO,uBAAuB,GAAG,IAAID,GAAE,qBAAqB,CAACC,IAAGC,OAAM,EAAE,GAAGA,GAAE,OAAO,UAAU,CAAC,CAAC,GAAG,EAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMjL,GAAG,EAAE,SAAS,IAAI,IAAIH,GAAE,eAAe,CAAAC,OAAKA,GAAE,WAAW,GAAG,IAAIA,GAAE,kBAAkB,CAACA,IAAGC,OAAMA,GAAE,OAAO,GAAG,GAAG,IAAID,GAAE,WAAW,CAACA,IAAGC,OAAMA,GAAE,OAAO,OAAO,GAAG,IAAI,EAAE,gBAAgB,CAAAD,OAAKA,GAAE,YAAY,GAAG,IAAID,GAAE,eAAe,CAAAC,OAAKA,GAAE,WAAW,GAAG,IAAID,GAAE,aAAa,CAAAC,OAAKA,GAAE,SAAS,GAAG,IAAIA,GAAE,YAAY,CAAAA,OAAKA,GAAE,QAAQ,CAAC,GAAG,EAAE,QAAQA,EAAC,GAAG,EAAE,QAAQ,CAAC,GAAG,EAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQnW,GAAG,EAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOd,GAAG,EAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBd,GAAG;AACL;AACA,IAAM,IAAIA,GAAE;AAAZ,IACE,IAAI,OAAO,OAAO,OAAO,eAAe;AAAA,EACtC,WAAW;AAAA,EACX,mBAAmB;AAAA,EACnB,OAAO;AACT,GAAG,OAAO,aAAa;AAAA,EACrB,OAAO;AACT,CAAC,CAAC;",
  "names": ["n", "o", "e", "r", "a"]
}
