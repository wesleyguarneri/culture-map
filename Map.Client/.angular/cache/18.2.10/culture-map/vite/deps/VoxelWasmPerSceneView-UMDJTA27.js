import {
  c as c2,
  o
} from "./chunk-AQH46KWJ.js";
import {
  v,
  z
} from "./chunk-Z4AXZULQ.js";
import {
  c
} from "./chunk-UJF7LPVD.js";
import "./chunk-S2OEQYU7.js";
import "./chunk-U7YHNT5S.js";
import {
  u
} from "./chunk-ROVEMBDA.js";
import {
  G,
  e as e2,
  i
} from "./chunk-ZIDRXKSJ.js";
import "./chunk-DBK2ELNZ.js";
import "./chunk-7HBD4CJ3.js";
import {
  E
} from "./chunk-RASN5P76.js";
import "./chunk-LN4EMOLP.js";
import {
  g,
  j2 as j
} from "./chunk-YYETZJJB.js";
import "./chunk-MD2IQSSQ.js";
import {
  I,
  N,
  O
} from "./chunk-YLE5AYZV.js";
import "./chunk-POQ3T5EH.js";
import "./chunk-L7ZKWTWL.js";
import "./chunk-O2DTA3XK.js";
import "./chunk-WJKYGQOY.js";
import "./chunk-ZE47C44H.js";
import "./chunk-5GIS2C3K.js";
import "./chunk-XCOHDMBF.js";
import "./chunk-7B5YPLFX.js";
import "./chunk-RDQF44TE.js";
import {
  l
} from "./chunk-KKD7A2GN.js";
import "./chunk-ZWCV4HKG.js";
import "./chunk-N4KQPPPI.js";
import "./chunk-4OGGMTIH.js";
import "./chunk-NQVBBKAN.js";
import "./chunk-DY7FJHTG.js";
import "./chunk-Q4KYZS3X.js";
import "./chunk-KVKFHRJ3.js";
import "./chunk-VWML4J2J.js";
import "./chunk-JYODC3YQ.js";
import "./chunk-BQZBOYBD.js";
import "./chunk-TYQXPPSP.js";
import {
  d as d2
} from "./chunk-HD65DNIO.js";
import "./chunk-4KWLMXIA.js";
import "./chunk-BIUXKPKA.js";
import "./chunk-634JLXD4.js";
import "./chunk-Y3EDGYWG.js";
import "./chunk-UF6JOUSJ.js";
import "./chunk-T5JGQSO3.js";
import "./chunk-CIW3KHOW.js";
import "./chunk-J55F4AC2.js";
import "./chunk-IQLBZKUD.js";
import "./chunk-7MZZCQ64.js";
import "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import "./chunk-6A7CWJED.js";
import "./chunk-DUTZNK67.js";
import "./chunk-IN6BQCWS.js";
import "./chunk-HT2T6PUB.js";
import "./chunk-6EUVKE22.js";
import {
  m
} from "./chunk-OKJHJ3CY.js";
import "./chunk-XTVPEVHA.js";
import "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import "./chunk-DZALMCYL.js";
import "./chunk-K226GFDN.js";
import "./chunk-4ZZRP4MA.js";
import "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import "./chunk-NYQ5CYNR.js";
import "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import {
  x
} from "./chunk-AXVPJBVW.js";
import {
  n as n3
} from "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import {
  n as n2
} from "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import {
  U
} from "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import {
  P,
  d
} from "./chunk-6WHTZNUH.js";
import "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import "./chunk-XNUH25NY.js";
import "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e
} from "./chunk-4Z5SGKRM.js";
import "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3 as a
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import {
  b
} from "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  n2 as n
} from "./chunk-WYIDUUN2.js";
import {
  has
} from "./chunk-DXLOWWK7.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/libs/vxl/enums.js
var e3;
var i2;
var t;
var n4;
var a2;
var o2;
!function(e5) {
  e5[e5.Binary = 0] = "Binary", e5[e5.JSON = 1] = "JSON";
}(e3 || (e3 = {})), function(e5) {
  e5[e5.TreeIndex = 0] = "TreeIndex", e5[e5.TreeStats = 1] = "TreeStats", e5[e5.TreeData = 2] = "TreeData", e5[e5.BrickBundles = 3] = "BrickBundles", e5[e5.Section = 4] = "Section", e5[e5.VariableStats = 5] = "VariableStats";
}(i2 || (i2 = {})), function(e5) {
  e5[e5.None = 1] = "None", e5[e5.Front = 2] = "Front", e5[e5.Back = 3] = "Back";
}(t || (t = {})), function(e5) {
  e5[e5.Low = 0] = "Low", e5[e5.Medium = 1] = "Medium", e5[e5.High = 2] = "High";
}(n4 || (n4 = {})), function(e5) {
  e5[e5.None = 0] = "None", e5[e5.StaticSections = 1] = "StaticSections", e5[e5.Slices = 2] = "Slices", e5[e5.DynamicSections = 4] = "DynamicSections", e5[e5.GhostShell = 8] = "GhostShell", e5[e5.Isosurface = 16] = "Isosurface", e5[e5.Quality = 32] = "Quality", e5[e5.SunLocation = 64] = "SunLocation", e5[e5.StaticSectionSelection = 128] = "StaticSectionSelection", e5[e5.ExaggerationAndOffset = 256] = "ExaggerationAndOffset", e5[e5.CurrentTime = 512] = "CurrentTime", e5[e5.CurrentVariable = 1024] = "CurrentVariable", e5[e5.DeleteIsosurface = 2048] = "DeleteIsosurface", e5[e5.ContainerVisibility = 4096] = "ContainerVisibility", e5[e5.RenderMode = 8192] = "RenderMode", e5[e5.Optimization = 16384] = "Optimization", e5[e5.VariableStyles = 32768] = "VariableStyles", e5[e5.VolumeStyles = 65536] = "VolumeStyles", e5[e5.AnalysisSlice = 131072] = "AnalysisSlice";
}(a2 || (a2 = {})), function(e5) {
  e5[e5.Isosurfaces = 0] = "Isosurfaces", e5[e5.DynamicSections = 1] = "DynamicSections", e5[e5.StaticSections = 2] = "StaticSections";
}(o2 || (o2 = {}));

// ../../../node_modules/@arcgis/core/libs/vxl/VxlModule.js
function e4(t2) {
  return new Promise((e5) => import("./vxlLayer-ZWDRPFSX.js").then((t3) => t3.v).then(({
    default: n5
  }) => {
    const r = n5({
      locateFile: i3,
      preinitializedWebGLContext: t2,
      onRuntimeInitialized: () => e5(r)
    });
  })).catch((t3) => {
    throw t3;
  });
}
function i3(e5) {
  return n2(`esri/libs/vxl/${e5}`);
}

// ../../../node_modules/@arcgis/core/layers/VoxelWasmPerSceneView.js
var U2;
!function(e5) {
  e5[e5.Lifetime = 1] = "Lifetime", e5[e5.RequestResponse = 2] = "RequestResponse", e5[e5.Rendering = 3] = "Rendering", e5[e5.Error = 4] = "Error";
}(U2 || (U2 = {}));
var k = class extends u {
  constructor(e5) {
    super(e5), this._halfIntTexturesAvailable = false, this._textureFloatLinearAvailable = false, this._havePreparedWithAllLayers = false, this._renderPluginContext = null, this._vxlPromise = null, this._vxl = null, this._pluginIsActive = false, this._moreToLoad = false, this._viewportWidth = -1, this._viewportHeight = -1, this._newLayers = [], this._layers = /* @__PURE__ */ new Map(), this._rctx = null, this._renderTargetToRestore = null, this._lastFrameWasStationary = false, this._wasmMemBlockSizes = [512, 1024, 2048, 4096, 8192, 16384, 32768, 65536], this._wasmMemBlocks = /* @__PURE__ */ new Map(), this._dbgFlags = /* @__PURE__ */ new Set(), this._captureFrustum = false, this._frustum = null, this._frustumRenderableId = -1, this._renderCoordsHelper = null, this.produces = /* @__PURE__ */ new Map([[E.VOXEL, () => !!this._vxl && "local" === this.view.viewingMode]]), this.type = i.VOXEL, this.slicePlaneEnabled = true, this.isGround = false, this.layerUid = [];
  }
  _dbg(e5, t2) {
    this._dbgFlags.has(e5) && (e5 === U2.Error ? n.getLogger(this).error(t2) : n.getLogger(this).warn(t2));
  }
  _removeRenderPlugin() {
    this._pluginIsActive && this.view._stage && (this._dbg(U2.Lifetime, "--removeRenderPlugin--"), this.view._stage.removeRenderPlugin(this)), this._pluginIsActive = false;
  }
  initialize() {
    this._dbg(U2.Lifetime, "--initialize--");
    for (const e5 of this._wasmMemBlockSizes) this._wasmMemBlocks.set(e5, 0);
    this.addHandles([d(() => this.view.ready, (e5) => {
      e5 && "local" === this.view.viewingMode ? (this._dbg(U2.Lifetime, "view ready status changed to ready on a local view, calling addRenderPlugin"), this.view._stage.addRenderPlugin(this), this._pluginIsActive = true) : (this._dbg(U2.Lifetime, "view ready status changed, not ready or not a local view!"), this._removeRenderPlugin());
    }, P), d(() => this.view?.qualityProfile, (e5) => {
      this._dbg(U2.Rendering, "qualityProfile changed to " + e5), this._vxl && this._vxl.set_quality(this._toWasmQuality(e5));
    }, P), d(() => this.view?.timeExtent, () => {
      if (this._vxl) {
        const e5 = this._getTimeArgs(this.view?.timeExtent);
        this._dbg(U2.Rendering, "sceneView timeExtent changed to useTime=" + e5.hasTime + " st=" + e5.startTime + " et=" + e5.endTime), this._vxl.set_scene_time_extent(e5.startTime, e5.endTime, e5.hasTime), this._renderPluginContext.requestRender();
      }
    }, P), d(() => this.view?.stationary, (e5) => {
      this._vxl && e5 && !this._lastFrameWasStationary && this._renderPluginContext.requestRender();
    })]);
  }
  initializeRenderContext(e5) {
    this._dbg(U2.Lifetime, "--initializeRenderContext--");
    const t2 = e5.renderContext.rctx;
    this._renderPluginContext = e5, this._rctx = e5.renderContext.rctx, this._halfIntTexturesAvailable = !!this._rctx.capabilities.textureNorm16, this._textureFloatLinearAvailable = this._rctx.capabilities.textureFloatLinear, this._initializeWasm(t2.gl);
  }
  uninitializeRenderContext() {
    this._renderPluginContext = null, this._rctx = null, this._dbg(U2.Lifetime, "--uninitializeRenderContext--");
  }
  _restoreFramebuffer() {
    if (!this._renderTargetToRestore) return;
    const e5 = this._renderTargetToRestore.fbo;
    if (!!!this._rctx) return void this._dbg(U2.Error, "no context in restoreFramebuffer!");
    this._rctx.bindFramebuffer(e5, true);
    const t2 = this._renderTargetToRestore.viewport;
    this._rctx.setViewport(t2.x, t2.y, t2.width, t2.height);
  }
  _bindPreviousDepthToSlot(e5, t2) {
    const s = !!this._rctx, r = !!this._renderTargetToRestore;
    if (!s || !r) return 0;
    const i4 = this._renderTargetToRestore.fbo.depthStencilTexture;
    return i4 ? (0 === t2 ? this._rctx.bindTexture(null, e5, true) : this._rctx.bindTexture(i4, e5, true), 1) : (this._dbg(U2.Error, "no depth/stencil texture exists!"), 0);
  }
  _modifyResourceCount(e5, t2, s) {
    if (!this._rctx) return void this._dbg(U2.Error, "modifyAllocation callback has no rendering context!");
    const r = e5;
    1 === s ? this._rctx.instanceCounter.increment(r, t2) : this._rctx.instanceCounter.decrement(r, t2);
  }
  _setBlendState(e5, t2, s, r) {
    this._rctx ? (this._rctx.setBlendingEnabled(1 === e5), this._rctx.setBlendFunction(t2, s), this._rctx.setBlendEquation(r)) : this._dbg(U2.Error, "setBlendState callback has no rendering context!");
  }
  _setFrontFace(e5) {
    this._rctx ? this._rctx.setFrontFace(e5) : this._dbg(U2.Error, "setFrontFace callback has no rendering context!");
  }
  _setDepthStencilStateFunction(e5, t2, s) {
    this._rctx ? (this._rctx.setDepthFunction(s), this._rctx.setDepthTestEnabled(1 === e5), this._rctx.setDepthWriteEnabled(1 === t2), this._rctx.setStencilTestEnabled(false), this._rctx.setStencilFunction(O.ALWAYS, 0, 255), this._rctx.setStencilOpSeparate(N.FRONT, I.KEEP, I.INCR, I.KEEP), this._rctx.setStencilOpSeparate(N.BACK, I.KEEP, I.DECR, I.KEEP)) : this._dbg(U2.Error, "setDepthStencilStateFunction callback has no rendering context!");
  }
  _setRasterizerState(e5) {
    if (this._rctx) switch (e5) {
      case t.None:
        this._rctx.setFaceCullingEnabled(false);
        break;
      case t.Back:
        this._rctx.setCullFace(N.BACK), this._rctx.setFaceCullingEnabled(true);
        break;
      case t.Front:
        this._rctx.setCullFace(N.FRONT), this._rctx.setFaceCullingEnabled(true);
    }
    else this._dbg(U2.Error, "setRasterizerState callback has no rendering context!");
  }
  _setViewport(e5, t2, s, r) {
    this._rctx ? this._rctx.setViewport(e5, t2, s, r) : this._dbg(U2.Error, "setViewport callback has no rendering context!");
  }
  _updateMemoryUsage() {
    this._layers.forEach((e5, t2) => {
      if (e5.needMemoryUsageUpdate) {
        const s = this._vxl.estimate_memory_usage(t2);
        s >= 0 && (e5.needMemoryUsageUpdate = false, e5.layerView.setUsedMemory(s));
      }
    });
  }
  _syncRequestsResponses() {
    this._layers.forEach((e5, t2) => {
      const r = [];
      e5.responses.forEach((s, i4) => {
        r.push(i4), this._dbg(U2.RequestResponse, "responding for requestID:" + i4 + " size:" + s.size), this._vxl.respond(t2, i4, s), s.requestType !== i2.TreeIndex && s.requestType !== i2.Section || (e5.needMemoryUsageUpdate = true);
      });
      const a3 = e5.responses;
      for (const s of r) a3.delete(s);
      const n5 = this._vxl.get_new_requests(t2), o3 = e5.abortController.signal;
      for (const l2 in n5) {
        e5.outstandingRequestCount += 1, 1 === e5.outstandingRequestCount && e5.layerView.updatingFlagChanged();
        const t3 = n5[l2], r2 = {
          responseType: "array-buffer",
          signal: o3,
          query: __spreadProps(__spreadValues({}, e5.layerView.layer.customParameters), {
            token: e5.layerView.layer.apiKey
          })
        };
        this._dbg(U2.RequestResponse, "making requestID:" + l2 + " url:" + t3.url), U(t3.url, r2).then((s) => {
          e5.outstandingRequestCount -= 1, 0 === e5.outstandingRequestCount && e5.layerView.updatingFlagChanged(), this._dbg(U2.RequestResponse, "have response for requestID:" + l2);
          let r3 = 0;
          if (s.data.byteLength > 0) {
            r3 = this._vxl._malloc(s.data.byteLength);
            const e6 = new Uint8Array(this._vxl.HEAPU8.buffer, r3, s.data.byteLength), t4 = new Uint8Array(s.data);
            for (let r4 = 0; r4 < s.data.byteLength; ++r4) e6[r4] = t4[r4];
          }
          a3.set(+l2, {
            responseType: t3.responseType,
            ptr: r3,
            size: s.data.byteLength,
            success: true,
            requestType: t3.requestType
          });
        }).catch((s) => {
          e5.outstandingRequestCount -= 1, 0 === e5.outstandingRequestCount && e5.layerView.updatingFlagChanged(), b(s) || (this._dbg(U2.Error, `requestID:${l2} failed, error=${s.toString()}`), a3.set(+l2, {
            responseType: t3.responseType,
            ptr: 0,
            size: 0,
            success: false,
            requestType: t3.requestType
          }));
        });
      }
    });
  }
  updateWasmCamera(e5) {
    this._vxl.set_projection_matrix.apply(this._vxl, e5.projectionMatrix), this._vxl.set_view_matrix.apply(this._vxl, e5.viewMatrix), this._vxl.set_near_far(e5.near, e5.far);
  }
  isUpdating(e5) {
    if (!this._vxl && this._vxlPromise) return true;
    const t2 = this._layers.get(e5);
    return !!t2 && t2.outstandingRequestCount > 0;
  }
  getLayerTimes(e5) {
    const t2 = [];
    return this._layers.forEach((s, r) => {
      if (s.layerView.wasmLayerId === e5.wasmLayerId) {
        const s2 = this._vxl.get_layer_epoch_times(r, e5.layer.currentVariableId);
        for (let e6 = 0; e6 < s2.length; ++e6) t2.push(s2[e6]);
      }
    }), t2;
  }
  getCurrentLayerTimeIndex(e5) {
    let t2 = 0;
    return this._layers.forEach((s, r) => {
      s.layerView.wasmLayerId === e5.wasmLayerId && (t2 = this._vxl.get_layer_current_time_id(r));
    }), t2;
  }
  setEnabled(e5, t2) {
    this._layers.forEach((s, r) => {
      s.layerView.wasmLayerId === e5.wasmLayerId && (this._vxl.set_enabled(r, t2), s.needMemoryUsageUpdate = true, this._renderPluginContext.requestRender());
    });
  }
  setIsInScaleRange(e5, t2) {
    const s = this._layers.get(e5.wasmLayerId);
    s && t2 !== s.isInScaleRange && (s.isInScaleRange = t2, this._vxl.set_is_in_scale_range(e5.wasmLayerId, t2), s.needMemoryUsageUpdate = !t2, this._renderPluginContext.requestRender());
  }
  setStaticSections(e5, t2) {
    const s = {
      mask: a2.StaticSections,
      staticSections: t2
    };
    return this._doMaskedUIUpdate(e5, s, true);
  }
  setCurrentVariable(e5, t2) {
    const s = {
      mask: a2.CurrentVariable,
      currentVariable: t2
    };
    return this._doMaskedUIUpdate(e5, s, true);
  }
  setRenderMode(e5, t2) {
    const s = {
      mask: a2.RenderMode,
      renderMode: t2
    };
    return this._doMaskedUIUpdate(e5, s, true);
  }
  setVerticalExaggerationAndOffset(e5, t2, s, r) {
    const i4 = {
      mask: a2.ExaggerationAndOffset,
      volStyleDesc: {
        volumeId: t2,
        verticalExaggeration: s,
        verticalOffset: r
      }
    };
    return this._doMaskedUIUpdate(e5, i4, true);
  }
  setVariableStyles(e5, t2) {
    const s = {
      mask: a2.VariableStyles,
      variableStyles: t2
    };
    return this._doMaskedUIUpdate(e5, s, true);
  }
  setVolumeStyles(e5, t2) {
    const s = {
      mask: a2.VolumeStyles,
      volumeStyles: t2
    };
    return this._doMaskedUIUpdate(e5, s, true);
  }
  setEnableDynamicSections(e5, t2) {
    const s = {
      mask: a2.ContainerVisibility,
      containerIsVisible: t2,
      container: o2.DynamicSections
    };
    return this._doMaskedUIUpdate(e5, s, true);
  }
  setEnableIsosurfaces(e5, t2) {
    const s = {
      mask: a2.ContainerVisibility,
      containerIsVisible: t2,
      container: o2.Isosurfaces
    };
    return this._doMaskedUIUpdate(e5, s, true);
  }
  setEnableSections(e5, t2) {
    const s = {
      mask: a2.ContainerVisibility,
      containerIsVisible: t2,
      container: o2.StaticSections
    };
    return this._doMaskedUIUpdate(e5, s, true);
  }
  setAnalysisSlice(e5, t2, s, r) {
    const i4 = {
      mask: a2.AnalysisSlice,
      analysisSlice: {
        point: s,
        normal: r,
        enabled: t2
      }
    };
    return this._doMaskedUIUpdate(e5, i4, true);
  }
  updateLayerTimeProperties(e5) {
    if (!this._vxl) return;
    const t2 = this._layers.get(e5.wasmLayerId);
    if (t2) {
      const s = t2.layerView.layer;
      let r = 0;
      s.timeOffset && (r = m(s.timeOffset.value, s.timeOffset.unit, "seconds"));
      const i4 = this._getTimeArgs(s.timeExtent);
      this._vxl.set_layer_time_properties(e5.wasmLayerId, i4.startTime, i4.endTime, i4.hasTime, s.useViewTime, r), this._renderPluginContext.requestRender();
    }
  }
  _doMaskedUIUpdate(e5, t2, s) {
    if (!this._vxl) return false;
    let r = false;
    return this._layers.forEach((s2, i4) => {
      if (s2.layerView.wasmLayerId === e5.wasmLayerId) {
        const e6 = {
          str: JSON.stringify(t2),
          byteCount: 0,
          ptr: 0,
          isReusable: false
        };
        this._allocateBlock(e6) && (r = 1 === this._vxl.handle_masked_ui_update(i4, e6.ptr, e6.byteCount), e6.isReusable || this._vxl._free(e6.ptr));
      }
    }), r && s && this._renderPluginContext.requestRender(), r;
  }
  _addTriangleToWasmBuffer(e5, t2, s, r, i4) {
    return e5[3 * t2] = s[0], e5[3 * t2 + 1] = s[1], e5[3 * t2 + 2] = s[2], e5[3 * (t2 += 1)] = r[0], e5[3 * t2 + 1] = r[1], e5[3 * t2 + 2] = r[2], e5[3 * (t2 += 1)] = i4[0], e5[3 * t2 + 1] = i4[1], e5[3 * t2 + 2] = i4[2], t2 += 1;
  }
  _addNormalToWasmBuffer(e5, t2, s) {
    return e5[3 * t2] = s[0], e5[3 * t2 + 1] = s[1], e5[3 * t2 + 2] = s[2], t2 += 1;
  }
  _doCaptureFrustum() {
    if (!this._vxl) return;
    const e5 = 36, t2 = e5 / 3, s = this._vxl._malloc(3 * e5 * Float32Array.BYTES_PER_ELEMENT), r = new Float32Array(this._vxl.HEAPF32.buffer, s, 3 * e5), i4 = this._vxl._malloc(3 * t2 * Float32Array.BYTES_PER_ELEMENT), a3 = new Float32Array(this._vxl.HEAPF32.buffer, i4, e5), n5 = this._frustum.points[g.NEAR_BOTTOM_LEFT], o3 = this._frustum.points[g.NEAR_BOTTOM_RIGHT], l2 = this._frustum.points[g.NEAR_TOP_RIGHT], h = this._frustum.points[g.NEAR_TOP_LEFT], d3 = this._frustum.points[g.FAR_BOTTOM_LEFT], u2 = this._frustum.points[g.FAR_BOTTOM_RIGHT], _ = this._frustum.points[g.FAR_TOP_RIGHT], g2 = this._frustum.points[g.FAR_TOP_LEFT];
    let f = 0, p = 0;
    const x2 = this._frustum.planes[j.NEAR];
    f = this._addTriangleToWasmBuffer(r, f, l2, o3, n5), p = this._addNormalToWasmBuffer(a3, p, x2), f = this._addTriangleToWasmBuffer(r, f, n5, h, l2), p = this._addNormalToWasmBuffer(a3, p, x2);
    const y2 = this._frustum.planes[j.FAR];
    f = this._addTriangleToWasmBuffer(r, f, d3, u2, _), p = this._addNormalToWasmBuffer(a3, p, y2), f = this._addTriangleToWasmBuffer(r, f, _, g2, d3), p = this._addNormalToWasmBuffer(a3, p, y2);
    const v2 = this._frustum.planes[j.TOP];
    f = this._addTriangleToWasmBuffer(r, f, _, l2, h), p = this._addNormalToWasmBuffer(a3, p, v2), f = this._addTriangleToWasmBuffer(r, f, h, g2, _), p = this._addNormalToWasmBuffer(a3, p, v2);
    const b2 = this._frustum.planes[j.BOTTOM];
    f = this._addTriangleToWasmBuffer(r, f, n5, o3, u2), p = this._addNormalToWasmBuffer(a3, p, b2), f = this._addTriangleToWasmBuffer(r, f, u2, d3, n5), p = this._addNormalToWasmBuffer(a3, p, b2);
    const w = this._frustum.planes[j.LEFT];
    f = this._addTriangleToWasmBuffer(r, f, h, n5, d3), p = this._addNormalToWasmBuffer(a3, p, w), f = this._addTriangleToWasmBuffer(r, f, d3, g2, h), p = this._addNormalToWasmBuffer(a3, p, w);
    const T = this._frustum.planes[j.RIGHT];
    f = this._addTriangleToWasmBuffer(r, f, l2, _, u2), p = this._addNormalToWasmBuffer(a3, p, T), f = this._addTriangleToWasmBuffer(r, f, u2, o3, l2), p = this._addNormalToWasmBuffer(a3, p, T), -1 !== this._frustumRenderableId && this._vxl.remove_generic_mesh(this._frustumRenderableId), this._frustumRenderableId = this._vxl.add_generic_mesh(s, 3 * e5, i4, e5, 255, 0, 0, 64), this._vxl._free(s), this._vxl._free(i4), this._captureFrustum = false, this._renderPluginContext.requestRender();
  }
  captureFrustum() {
    null === this._renderCoordsHelper && (this._renderCoordsHelper = v.create(l.Local, z(false, this.view.spatialReference))), null === this._frustum && (this._frustum = new c2(this._renderCoordsHelper)), this._captureFrustum = true, null !== this._renderPluginContext && this._renderPluginContext.requestRender();
  }
  toggleFullVolumeExtentDraw(e5) {
    this._vxl && this._layers.forEach((t2, s) => {
      t2.layerView.wasmLayerId === e5.wasmLayerId && (this._vxl.toggle_full_volume_extent_draw(s), this._renderPluginContext.requestRender());
    });
  }
  addVoxelLayer(e5) {
    if (!this._vxl) {
      const t3 = {
        layerView: e5,
        resolveCallback: null,
        rejectCallback: null
      }, s = new Promise((e6, s2) => {
        t3.resolveCallback = e6, t3.rejectCallback = s2;
      });
      return this._newLayers.push(t3), s;
    }
    const t2 = this._addVoxelLayer(e5);
    return t2 < 0 ? Promise.reject(-1) : Promise.resolve(t2);
  }
  removeVoxelLayer(e5) {
    if (!this._vxl) {
      const t3 = this._newLayers.findIndex((t4) => e5.uid === t4.layerView.uid);
      t3 >= 0 && (this._newLayers[t3].resolveCallback(-1), this._newLayers.splice(t3, 1));
      const s2 = this._newLayers.length;
      return 0 === s2 && (this._dbg(U2.Lifetime, " no voxel layers left after removing a layer, removing RenderPlugin and destroying"), this.destroy()), s2;
    }
    let t2 = -1;
    this._layers.forEach((s2, r) => {
      if (s2.layerView.wasmLayerId === e5.wasmLayerId) {
        t2 = r, s2.abortController.abort(), this._vxl.remove_layer(t2);
        const i4 = this.layerUid.indexOf(e5.layer.uid);
        -1 !== i4 && this.layerUid.splice(i4, 1);
      }
    }), t2 >= 0 && this._layers.delete(t2);
    const s = this._layers.size;
    return 0 === s && (this._dbg(U2.Lifetime, " no voxel layers left after removing a layer, removing RenderPlugin and destroying"), this.destroy()), s;
  }
  _getBlockSize(e5) {
    for (const t2 of this._wasmMemBlockSizes) if (e5 < t2) return t2;
    return -1;
  }
  _allocateBlock(e5) {
    e5.byteCount = this._vxl.lengthBytesUTF8(e5.str) + 1;
    const t2 = this._getBlockSize(e5.byteCount);
    return t2 < 0 ? (e5.isReusable = false, e5.ptr = this._vxl._malloc(e5.byteCount)) : (e5.isReusable = true, e5.ptr = this._wasmMemBlocks.get(t2), 0 === e5.ptr && (e5.ptr = this._vxl._malloc(t2), this._wasmMemBlocks.set(t2, e5.ptr))), 0 !== e5.ptr && (this._vxl.stringToUTF8(e5.str, e5.ptr, e5.byteCount), true);
  }
  _getTimeArgs(e5) {
    let t2 = -Number.MAX_VALUE, s = Number.MAX_VALUE, r = false;
    return null != e5 && (e5.isAllTime ? r = true : (null != e5.start && (r = true, t2 = e5.start.getTime() / 1e3), null != e5.end && (r = true, s = e5.end.getTime() / 1e3))), {
      startTime: t2,
      endTime: s,
      hasTime: r
    };
  }
  _addVoxelLayer(e5) {
    const t2 = e5.layer;
    let s = -1;
    const i4 = t2.getConfiguration();
    if (i4.length < 1) return -1;
    const a3 = {
      str: i4,
      byteCount: 0,
      ptr: 0,
      isReusable: false
    };
    if (!this._allocateBlock(a3)) return -1;
    const n5 = this._getTimeArgs(t2.timeExtent), l2 = this.view.spatialReference.isWGS84 && t2.spatialReference.isWGS84 ? 111319.49079327357 : 1;
    let h = 0;
    if (t2.timeOffset && (h = m(t2.timeOffset.value, t2.timeOffset.unit, "seconds")), s = this._vxl.add_layer(t2.serviceRoot, a3.ptr, a3.byteCount, l2, l2, n5.startTime, n5.endTime, n5.hasTime, t2.useViewTime, h, this._toWasmQuality(this.view.qualityProfile)), a3.isReusable || this._vxl._free(a3.ptr), s >= 0) {
      t2.test?.constantUpscaling && (this._setUpscalingLimits(0, 0.25, 0.25), this._setUpscalingLimits(1, 0.5, 0.5), this._setUpscalingLimits(2, 0.75, 0.75));
      const i5 = new AbortController();
      if (this._layers.set(s, {
        layerView: e5,
        responses: /* @__PURE__ */ new Map(),
        outstandingRequestCount: 0,
        abortController: i5,
        needMemoryUsageUpdate: false,
        isInScaleRange: true
      }), this.layerUid.push(e5.layer.uid), !this._halfIntTexturesAvailable || has("mac")) {
        const t3 = [];
        let s2 = "";
        for (const r of e5.layer.variables) "Int16" !== r.renderingFormat.type && "UInt16" !== r.renderingFormat.type || (t3.push(r.name), r.id === e5.layer.currentVariableId && (s2 = r.name));
        "" !== s2 && n.getLogger(this).error("#addVoxelLayer_error()", e5.layer, `The voxel layer '${e5.layer.title}' cannot render the current variable '${s2}' in this browser`), t3.length > 0 && n.getLogger(this).warn("#addVoxelLayer_warning()", e5.layer, `The voxel layer '${e5.layer.title}' cannot render the variables '${t3.toString()}' in this browser`);
      }
      if (!this._textureFloatLinearAvailable) {
        const t3 = [];
        let s2 = "";
        for (const r of e5.layer.variables) "Float32" === r.renderingFormat.type && (t3.push(r.name), r.id === e5.layer.currentVariableId && (s2 = r.name));
        "" !== s2 && n.getLogger(this).error("#addVoxelLayer_error()", e5.layer, `The voxel layer '${e5.layer.title}' cannot render the current variable '${s2}' in this browser`), t3.length > 0 && n.getLogger(this).warn("#addVoxelLayer_warning()", e5.layer, `The voxel layer '${e5.layer.title}' cannot render the variables '${t3.toString()}' in this browser`);
      }
      return has("esri-mobile") && n.getLogger(this).warnOnce("Mobile support differs across devices. Voxel layer might not display as expected."), s;
    }
    return -1;
  }
  prepareRender(e5) {
    if (!this._vxl) return;
    const t2 = e5.bindParameters.camera.viewForward, s = e5.bindParameters.camera.eye;
    this._vxl.update_camera_pos_and_direction(s[0], s[1], s[2], t2[0], t2[1], t2[2]);
    const r = this._vxl.cull();
    this._dbg(U2.RequestResponse, "missingResourceCount=" + r), this._moreToLoad = r > 0, this._havePreparedWithAllLayers = 0 === this._newLayers.length, this._updateMemoryUsage();
  }
  renderNode(e5) {
    if (!this._vxl) return;
    for (const s of this._newLayers) {
      const e6 = this._addVoxelLayer(s.layerView);
      -1 === e6 ? s.rejectCallback(-1) : s.resolveCallback(e6);
    }
    if (this._newLayers = [], 0 === this._layers.size) return void this._dbg(U2.Error, "No voxel layers but RenderPlugin instance is being asked to render!");
    this._lastFrameWasStationary = this.view.stationary, this._syncRequestsResponses(), this._beforeDraw(), this._vxl.begin_color_frame(!this.view._stage.renderer.isFeatureEnabled(o.HighResolutionVoxel), e5.bindParameters.lighting.mainLight.direction[0], e5.bindParameters.lighting.mainLight.direction[1], e5.bindParameters.lighting.mainLight.direction[2]);
    const t2 = this._renderTargetToRestore.viewport;
    t2.width === this._viewportWidth && t2.height === this._viewportHeight || (this._viewportWidth = t2.width, this._viewportHeight = t2.height, this._vxl.set_viewport(t2.width, t2.height), this._layers.forEach((e6) => {
      e6.needMemoryUsageUpdate = true;
    })), 0 === t2.x && 0 === t2.y || this._dbg(U2.Error, "Unsupported viewport parameters detected!"), this.updateWasmCamera(e5.bindParameters.camera), this._captureFrustum && (this._frustum.update(e5.bindParameters.camera), this._doCaptureFrustum()), this._vxl.draw(), this._afterDraw(), (this._moreToLoad || !this._havePreparedWithAllLayers && this._layers.size > 0) && this._renderPluginContext.requestRender();
  }
  destroy() {
    this._dbg(U2.Lifetime, "--destroy--"), this._removeRenderPlugin(), this._vxl && (this._layers.forEach((e5) => {
      e5.abortController.abort();
    }), this._wasmMemBlocks.forEach((e5) => {
      0 !== e5 && this._vxl._free(e5);
    }), this._vxl.uninitialize_voxel_wasm(), this._vxl = null);
  }
  _initializeWasm(e5) {
    return this._vxl ? Promise.resolve() : (this._vxlPromise || (this._vxlPromise = e4(e5).then((e6) => {
      if (this._vxl = e6, this._vxlPromise = null, this._newLayers.length <= 0) return this._dbg(U2.Lifetime, " no voxel layers left after WASM downloaded, removing RenderPlugin and destroying"), void this.destroy();
      const t2 = this._getTimeArgs(this.view?.timeExtent), s = this._vxl.addFunction(this._restoreFramebuffer.bind(this), "v"), r = this._vxl.addFunction(this._setBlendState.bind(this), "viiii"), i4 = this._vxl.addFunction(this._setFrontFace.bind(this), "vi"), a3 = this._vxl.addFunction(this._setRasterizerState.bind(this), "vi"), n5 = this._vxl.addFunction(this._setDepthStencilStateFunction.bind(this), "viii"), o3 = this._vxl.addFunction(this._setViewport.bind(this), "viiii"), l2 = this._vxl.addFunction(this._bindPreviousDepthToSlot.bind(this), "iii"), h = this._vxl.addFunction(this._modifyResourceCount.bind(this), "viii"), d3 = this._halfIntTexturesAvailable && !has("mac"), u2 = this._textureFloatLinearAvailable;
      this._vxl.initialize_voxel_wasm(s, r, i4, a3, n5, o3, l2, h, t2.startTime, t2.endTime, t2.hasTime, d3, u2), this._renderPluginContext && this._renderPluginContext.requestRender();
    }).catch(() => {
      for (const e6 of this._newLayers) e6.rejectCallback(-2);
      this._dbg(U2.Error, " WASM failed to download, removing RenderPlugin and destroying"), this.destroy();
    })), this._vxlPromise);
  }
  pickDepth(e5, t2, s) {
    if (!this._vxl || !this._rctx || 0 === this._layers.size) return null;
    const r = s.viewport[3] - t2;
    if (e5 < 0 || e5 > s.viewport[2] || t2 < 0 || t2 > s.viewport[3]) return this._dbg(U2.Error, `[js] pickDepth: outOfRange, screenXY=[${e5.toFixed(0)}, ${r.toFixed(0)}]]`), null;
    this._beforeDraw();
    const i4 = s.viewForward, a3 = s.eye;
    this._vxl.update_camera_pos_and_direction(a3[0], a3[1], a3[2], i4[0], i4[1], i4[2]), this.updateWasmCamera(s), this._vxl.begin_frame();
    const n5 = this._vxl.pick_depth(e5, r);
    if (this._afterDraw(), n5.success) {
      return n5.distanceToCamera;
    }
    return null;
  }
  pickObject(e5, t2, s, r) {
    if (!this._vxl || !this._rctx || 0 === this._layers.size) return null;
    const i4 = Math.round(e5), a3 = Math.round(t2);
    if (i4 < 0 || i4 > s.viewport[2] || a3 < 0 || a3 > s.viewport[3]) return this._dbg(U2.Error, `[js] pickObject: outOfRange, screenXY=[${i4}, ${a3}], vp=[${s.viewport.toString()}]`), null;
    this._beforeDraw();
    const n5 = s.viewForward, o3 = s.eye;
    this._vxl.update_camera_pos_and_direction(o3[0], o3[1], o3[2], n5[0], n5[1], n5[2]), this.updateWasmCamera(s), this._vxl.begin_frame();
    let l2 = null;
    if (0 === r.length) l2 = this._vxl.pick_object(i4, a3, 0, 0);
    else {
      const e6 = {
        str: JSON.stringify({
          layerIds: r
        }),
        byteCount: 0,
        ptr: 0,
        isReusable: false
      };
      this._allocateBlock(e6) && (l2 = this._vxl.pick_object(i4, a3, e6.ptr, e6.byteCount), e6.isReusable || this._vxl._free(e6.ptr));
    }
    return this._afterDraw(), l2;
  }
  _beforeDraw() {
    this._renderTargetToRestore = {
      fbo: this._rctx.getBoundFramebufferObject(),
      viewport: this._rctx.getViewport()
    }, this._rctx.setPolygonOffsetFillEnabled(false), this._rctx.setScissorTestEnabled(false), this._rctx.setColorMask(true, true, true, true);
  }
  _afterDraw() {
    this._renderTargetToRestore.fbo = null, this._rctx.externalTextureUnitUpdate(this._vxl.get_texture_units_bound_in_frame(), this._vxl.get_active_texture_unit()), this._rctx.externalVertexArrayObjectUpdate(), this._rctx.externalVertexBufferUpdate(), this._rctx.externalProgramUpdate();
  }
  intersect(e5, t2, s, r, i4) {
    if (!this._vxl || !this._rctx || 0 === this._layers.size || !e5.options.selectionMode || e5.options.isFiltered) return;
    if (null == i4 || i4[0] < 0 || i4[0] > e5.camera.viewport[2] || i4[1] < 0 || i4[1] > e5.camera.viewport[3]) return this._dbg(U2.Error, `[js] VoxelWasmPerScene.intersect: outOfRange, screenXY=[${i4[0].toFixed(0)}, ${i4[1].toFixed(0)}]`), null;
    const a3 = [];
    this._layers.forEach((t3) => {
      e5.options.filteredLayerUids.includes(t3.layerView.layer.uid) && a3.push(t3.layerView.wasmLayerId);
    });
    const n5 = this.pickObject(i4[0], i4[1], e5.camera, a3);
    if (null == n5 || -1 === n5.layerId) return;
    const o3 = this._layers.get(n5.layerId);
    if (o3) {
      const t3 = o3.layerView.layer.uid, i5 = n5.distanceToCamera / x(s, r), a4 = n3();
      a4[0] = n5.worldX, a4[1] = n5.worldY, a4[2] = n5.worldZ;
      const l2 = {};
      if (null != n5.continuousValue && null != n5.continuousValueUnits ? l2["Voxel.ServiceValue"] = `${n5.continuousValue.toLocaleString()} ${n5.continuousValueUnits}` : null != n5.uniqueValueLabel && null != n5.uniqueValue ? l2["Voxel.ServiceValue"] = `${n5.uniqueValueLabel} (${n5.uniqueValue})` : null != n5.uniqueValue && (l2["Voxel.ServiceValue"] = `${n5.uniqueValue}`), l2["Voxel.ServiceVariableLabel"] = n5.variableLabel, l2["Voxel.Position"] = n5.voxelSpacePosition, null != n5.epochTime && null != n5.nativeTime && null != n5.nativeTimeUnits) {
        const e6 = new Date(n5.epochTime);
        l2["Voxel.ServiceLocalTime"] = e6.toString(), l2["Voxel.ServiceNativeTime"] = `${n5.nativeTime.toLocaleString()} ${n5.nativeTimeUnits}`;
      }
      null != n5.depth && null != n5.depthUnits && (l2["Voxel.ServiceDepth"] = `${n5.depth.toLocaleString()} ${n5.depthUnits}`);
      const h = n5.faceNormal;
      l2["Voxel.WorldPosition"] = `[${a4[0]}, ${a4[1]}, ${a4[2]}]`;
      const _ = (e6) => {
        const s2 = new c(a4, t3, () => this._createVoxelGraphic(o3.layerView.layer, l2));
        e6.set(this.type, s2, i5, h);
      }, c3 = e5.results, m2 = e5.options.store === e2.ALL;
      if ((null == c3.min.dist || i5 < c3.min.dist) && _(c3.min), (null == c3.max.dist || i5 > c3.max.dist) && _(c3.max), m2) {
        const t4 = G(e5.ray);
        _(t4), e5.results.all.push(t4);
      }
    }
  }
  _createVoxelGraphic(e5, s) {
    return new d2({
      layer: e5,
      sourceLayer: e5,
      attributes: s
    });
  }
  _toWasmQuality(e5) {
    switch (e5) {
      case "low":
        return 0;
      case "medium":
        return 1;
      case "high":
        return 2;
    }
  }
  _setUpscalingLimits(e5, t2, s) {
    this._vxl && this._vxl.set_upscaling_limits(e5, t2, s);
  }
};
e([y({
  constructOnly: true
})], k.prototype, "view", void 0), k = e([a("esri.layers.VoxelWasmPerSceneView")], k);
var B = k;
export {
  B as default
};
//# sourceMappingURL=VoxelWasmPerSceneView-UMDJTA27.js.map
