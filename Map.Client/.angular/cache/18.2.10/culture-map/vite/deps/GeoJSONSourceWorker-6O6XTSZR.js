import {
  E,
  I,
  N
} from "./chunk-NH2TONNG.js";
import {
  d as d2,
  f,
  j as j2,
  p as p2,
  y
} from "./chunk-L6LZ5TYL.js";
import {
  c,
  i as i3,
  o
} from "./chunk-7PCL3GUC.js";
import "./chunk-BO5GTO4F.js";
import {
  m
} from "./chunk-ROATEOHC.js";
import "./chunk-BIWDYV6F.js";
import {
  $
} from "./chunk-4MXR7W7N.js";
import "./chunk-6UYQMUGI.js";
import "./chunk-D3XZUGMN.js";
import "./chunk-YFQ32AQX.js";
import "./chunk-L4AYSXFJ.js";
import "./chunk-POQ3T5EH.js";
import {
  j,
  x
} from "./chunk-LPEFONL3.js";
import "./chunk-SSMSHZ2C.js";
import "./chunk-DM4WHMQY.js";
import "./chunk-DON3YPGT.js";
import {
  et,
  nt,
  ot,
  rt,
  tt
} from "./chunk-C7NRYPDG.js";
import "./chunk-Z3GMSC63.js";
import "./chunk-F35MWZH7.js";
import "./chunk-ED7UGR2X.js";
import "./chunk-YA5CTHMT.js";
import "./chunk-4QBFFLOC.js";
import "./chunk-O437BSYE.js";
import "./chunk-YZNT6QWD.js";
import "./chunk-YVOGHYE3.js";
import "./chunk-IBOZJLSO.js";
import {
  Z
} from "./chunk-Q7SRMLJZ.js";
import "./chunk-PQ4T66BG.js";
import "./chunk-SWPHGZYB.js";
import {
  i as i2
} from "./chunk-DWASPXVI.js";
import "./chunk-4U5GUJRA.js";
import "./chunk-J55F4AC2.js";
import "./chunk-LNRZHZOQ.js";
import "./chunk-DI6VABAK.js";
import "./chunk-5EBAJR7X.js";
import "./chunk-5JA2JHV3.js";
import "./chunk-FUKSTKFU.js";
import "./chunk-MIQZ6UDY.js";
import "./chunk-JOJZ6YC5.js";
import "./chunk-L4TOCXR5.js";
import "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import "./chunk-7WP676SE.js";
import "./chunk-SGSUM5YO.js";
import "./chunk-SG5TCCCK.js";
import "./chunk-6A7CWJED.js";
import "./chunk-DUTZNK67.js";
import "./chunk-IN6BQCWS.js";
import "./chunk-JM7HAEY6.js";
import "./chunk-A3NNJ7XA.js";
import "./chunk-OKJHJ3CY.js";
import "./chunk-XTVPEVHA.js";
import {
  H2 as H,
  K
} from "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import {
  p
} from "./chunk-S3IO7V4Q.js";
import "./chunk-4ZZRP4MA.js";
import "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import {
  i
} from "./chunk-CVB43GGP.js";
import "./chunk-XWXBNAOW.js";
import "./chunk-GWC3DAGP.js";
import "./chunk-EODIWR2E.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-FYAEQPUY.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-7RMVJCDW.js";
import "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import "./chunk-NYQ5CYNR.js";
import "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import "./chunk-AXVPJBVW.js";
import "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import {
  G,
  g2 as g
} from "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import {
  U
} from "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import "./chunk-6WHTZNUH.js";
import "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import {
  d
} from "./chunk-XNUH25NY.js";
import "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import "./chunk-4Z5SGKRM.js";
import "./chunk-ANKOCGE2.js";
import "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import {
  b
} from "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-WYIDUUN2.js";
import "./chunk-DXLOWWK7.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/layers/graphics/sources/geojson/GeoJSONSourceWorker.js
var D = {
  hasAttachments: false,
  capabilities: "query, editing, create, delete, update",
  useStandardizedQueries: true,
  supportsCoordinatesQuantization: true,
  supportsReturningQueryGeometry: true,
  advancedQueryCapabilities: {
    supportsQueryAttachments: false,
    supportsStatistics: true,
    supportsPercentileStatistics: true,
    supportsReturningGeometryCentroid: true,
    supportsQueryWithDistance: true,
    supportsDistinct: true,
    supportsReturningQueryExtent: true,
    supportsReturningGeometryProperties: false,
    supportsHavingClause: true,
    supportsOrderBy: true,
    supportsPagination: true,
    supportsQueryWithResultType: false,
    supportsSqlExpression: true,
    supportsDisjointSpatialRel: true
  }
};
var Q = class {
  constructor() {
    this._queryEngine = null, this._snapshotFeatures = (e) => __async(this, null, function* () {
      const t = yield this._fetch(e);
      return this._createFeatures(t);
    });
  }
  destroy() {
    this._queryEngine?.destroy(), this._queryEngine = this._createDefaultAttributes = null;
  }
  load(_0) {
    return __async(this, arguments, function* (e, t = {}) {
      this._loadOptions = {
        url: e.url,
        customParameters: e.customParameters
      };
      const i4 = [], [r] = yield Promise.all([e.url ? this._fetch(t?.signal) : null, this._checkProjection(e.spatialReference)]), n2 = I(r, {
        geometryType: e.geometryType
      }), o2 = e.fields || n2.fields || [], l = null != e.hasZ ? e.hasZ : n2.hasZ, u = n2.geometryType;
      let d3 = e.objectIdField || n2.objectIdFieldName || "__OBJECTID";
      const p3 = e.spatialReference || g;
      let c2 = e.timeInfo;
      o2 === n2.fields && n2.unknownFields.length > 0 && i4.push({
        name: "geojson-layer:unknown-field-types",
        message: "Some fields types couldn't be inferred from the features and were dropped",
        details: {
          unknownFields: n2.unknownFields
        }
      });
      const y2 = new Z(o2);
      let h = y2.get(d3);
      h ? ("esriFieldTypeString" !== h.type && (h.type = "esriFieldTypeOID"), h.editable = false, h.nullable = false, d3 = h.name) : (h = {
        alias: d3,
        name: d3,
        type: "string" === n2.objectIdFieldType ? "esriFieldTypeString" : "esriFieldTypeOID",
        editable: false,
        nullable: false
      }, o2.unshift(h));
      const _ = {};
      for (const a of o2) {
        if (null == a.name && (a.name = a.alias), null == a.alias && (a.alias = a.name), !a.name) throw new s("geojson-layer:invalid-field-name", "field name is missing", {
          field: a
        });
        if (!i2.jsonValues.includes(a.type)) throw new s("geojson-layer:invalid-field-type", `invalid type for field "${a.name}"`, {
          field: a
        });
        if (a.name !== h.name) {
          const e2 = H(a);
          void 0 !== e2 && (_[a.name] = e2);
        }
        null == a.length && (a.length = K(a));
      }
      if (c2) {
        if (c2.startTimeField) {
          const e2 = y2.get(c2.startTimeField);
          e2 ? (c2.startTimeField = e2.name, e2.type = "esriFieldTypeDate") : c2.startTimeField = null;
        }
        if (c2.endTimeField) {
          const e2 = y2.get(c2.endTimeField);
          e2 ? (c2.endTimeField = e2.name, e2.type = "esriFieldTypeDate") : c2.endTimeField = null;
        }
        if (c2.trackIdField) {
          const e2 = y2.get(c2.trackIdField);
          e2 ? c2.trackIdField = e2.name : (c2.trackIdField = null, i4.push({
            name: "geojson-layer:invalid-timeInfo-trackIdField",
            message: "trackIdField is missing",
            details: {
              timeInfo: c2
            }
          }));
        }
        c2.startTimeField || c2.endTimeField || (i4.push({
          name: "geojson-layer:invalid-timeInfo",
          message: "startTimeField and endTimeField are missing",
          details: {
            timeInfo: c2
          }
        }), c2 = null);
      }
      const F = u ? o(u) : void 0, b2 = y2.dateFields.length ? {
        timeZoneIANA: i
      } : null, T = {
        warnings: i4,
        featureErrors: [],
        layerDefinition: __spreadProps(__spreadValues({}, D), {
          drawingInfo: F ?? void 0,
          templates: c(_),
          extent: void 0,
          geometryType: u,
          objectIdField: d3,
          fields: o2,
          hasZ: !!l,
          timeInfo: c2,
          dateFieldsTimeReference: b2
        })
      };
      this._queryEngine = new $({
        fieldsIndex: Z.fromLayerJSON({
          fields: o2,
          timeInfo: c2,
          dateFieldsTimeReference: b2
        }),
        geometryType: u,
        hasM: false,
        hasZ: l,
        objectIdField: d3,
        spatialReference: p3,
        timeInfo: c2,
        featureStore: new m({
          geometryType: u,
          hasM: false,
          hasZ: l
        }),
        cacheSpatialQueries: true
      });
      const w = this._queryEngine.fieldsIndex.requiredFields.indexOf(h);
      w > -1 && this._queryEngine.fieldsIndex.requiredFields.splice(w, 1), this._createDefaultAttributes = i3(_, d3);
      const q = yield this._createFeatures(r);
      this._objectIdGenerator = this._createObjectIdGenerator(this._queryEngine, q);
      const x2 = this._normalizeFeatures(q, T.featureErrors);
      this._queryEngine.featureStore.addMany(x2);
      const {
        fullExtent: Q2,
        timeExtent: v
      } = yield this._queryEngine.fetchRecomputedExtents();
      if (T.layerDefinition.extent = Q2, v) {
        const {
          start: e2,
          end: t2
        } = v;
        T.layerDefinition.timeInfo.timeExtent = [e2, t2];
      }
      return T;
    });
  }
  applyEdits(e) {
    return __async(this, null, function* () {
      const {
        spatialReference: t,
        geometryType: s2
      } = this._queryEngine;
      return yield Promise.all([j2(t, s2), x(e.adds, t), x(e.updates, t)]), yield this._waitSnapshotComplete(), this._applyEdits(e);
    });
  }
  queryFeatures() {
    return __async(this, arguments, function* (e = {}, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
    });
  }
  queryFeatureCount() {
    return __async(this, arguments, function* (e = {}, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
    });
  }
  queryObjectIds() {
    return __async(this, arguments, function* (e = {}, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t.signal);
    });
  }
  queryExtent() {
    return __async(this, arguments, function* (e = {}, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
    });
  }
  querySnapping(_0) {
    return __async(this, arguments, function* (e, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e, t.signal);
    });
  }
  refresh(e) {
    return __async(this, null, function* () {
      this._loadOptions.customParameters = e, this._snapshotTask?.abort(), this._snapshotTask = d(this._snapshotFeatures), this._snapshotTask.promise.then((e2) => {
        this._queryEngine.featureStore.clear(), this._objectIdGenerator = this._createObjectIdGenerator(this._queryEngine, e2);
        const t = this._normalizeFeatures(e2);
        t && this._queryEngine.featureStore.addMany(t);
      }, (e2) => {
        this._queryEngine.featureStore.clear(), b(e2) || n.getLogger("esri.layers.GeoJSONLayer").error(new s("geojson-layer:refresh", "An error occurred during refresh", {
          error: e2
        }));
      }), yield this._waitSnapshotComplete();
      const {
        fullExtent: n2,
        timeExtent: a
      } = yield this._queryEngine.fetchRecomputedExtents();
      return {
        extent: n2,
        timeExtent: a
      };
    });
  }
  _createFeatures(e) {
    return __async(this, null, function* () {
      if (null == e) return [];
      const {
        geometryType: t,
        hasZ: s2,
        objectIdField: i4
      } = this._queryEngine, r = N(e, {
        geometryType: t,
        hasZ: s2,
        objectIdField: i4
      });
      if (!G(this._queryEngine.spatialReference, g)) for (const n2 of r) null != n2.geometry && (n2.geometry = ot(j(rt(n2.geometry, this._queryEngine.geometryType, this._queryEngine.hasZ, false), g, this._queryEngine.spatialReference)));
      return r;
    });
  }
  _waitSnapshotComplete() {
    return __async(this, null, function* () {
      if (this._snapshotTask && !this._snapshotTask.finished) {
        try {
          yield this._snapshotTask.promise;
        } catch {
        }
        return this._waitSnapshotComplete();
      }
    });
  }
  _fetch(t) {
    return __async(this, null, function* () {
      const {
        url: s2,
        customParameters: i4
      } = this._loadOptions, r = (yield U(s2 ?? "", {
        responseType: "json",
        query: __spreadValues({}, i4),
        signal: t
      })).data;
      return E(r), r;
    });
  }
  _normalizeFeatures(e, t) {
    const {
      objectIdField: s2,
      fieldsIndex: i4
    } = this._queryEngine, r = [];
    for (const n2 of e) {
      const e2 = this._createDefaultAttributes(), a = p2(i4, e2, n2.attributes, true);
      a ? t?.push(a) : (this._assignObjectId(e2, n2.attributes, true), n2.attributes = e2, n2.objectId = e2[s2], r.push(n2));
    }
    return r;
  }
  _applyEdits(e) {
    return __async(this, null, function* () {
      const {
        adds: t,
        updates: s2,
        deletes: i4
      } = e, r = {
        addResults: [],
        deleteResults: [],
        updateResults: [],
        uidToObjectId: {}
      };
      if (t?.length && this._applyAddEdits(r, t), s2?.length && this._applyUpdateEdits(r, s2), i4?.length) {
        for (const e2 of i4) r.deleteResults.push(d2(e2));
        this._queryEngine.featureStore.removeManyById(i4);
      }
      const {
        fullExtent: n2,
        timeExtent: a
      } = yield this._queryEngine.fetchRecomputedExtents();
      return {
        extent: n2,
        timeExtent: a,
        featureEditResults: r
      };
    });
  }
  _applyAddEdits(e, t) {
    const {
      addResults: s2
    } = e, {
      geometryType: i4,
      hasM: r,
      hasZ: a,
      objectIdField: o2,
      spatialReference: l,
      featureStore: u,
      fieldsIndex: p3
    } = this._queryEngine, c2 = [];
    for (const d3 of t) {
      if (d3.geometry && i4 !== p(d3.geometry)) {
        s2.push(f("Incorrect geometry type."));
        continue;
      }
      const t2 = this._createDefaultAttributes(), r2 = p2(p3, t2, d3.attributes);
      if (r2) s2.push(r2);
      else {
        if (this._assignObjectId(t2, d3.attributes), d3.attributes = t2, null != d3.uid) {
          const t3 = d3.attributes[o2];
          e.uidToObjectId[d3.uid] = t3;
        }
        if (null != d3.geometry) {
          const e2 = d3.geometry.spatialReference ?? l;
          d3.geometry = j(y(d3.geometry, e2), e2, l);
        }
        c2.push(d3), s2.push(d2(d3.attributes[o2]));
      }
    }
    u.addMany(et([], c2, i4, a, r, o2));
  }
  _applyUpdateEdits({
    updateResults: e
  }, t) {
    const {
      geometryType: s2,
      hasM: i4,
      hasZ: r,
      objectIdField: a,
      spatialReference: o2,
      featureStore: l,
      fieldsIndex: u
    } = this._queryEngine;
    for (const d3 of t) {
      const {
        attributes: t2,
        geometry: m2
      } = d3, y2 = t2?.[a];
      if (null == y2) {
        e.push(f(`Identifier field ${a} missing`));
        continue;
      }
      if (!l.has(y2)) {
        e.push(f(`Feature with object id ${y2} missing`));
        continue;
      }
      const f2 = nt(l.getFeature(y2), s2, r, i4);
      if (null != m2) {
        if (s2 !== p(m2)) {
          e.push(f("Incorrect geometry type."));
          continue;
        }
        const t3 = m2.spatialReference ?? o2;
        f2.geometry = j(y(m2, t3), t3, o2);
      }
      if (t2) {
        const s3 = p2(u, f2.attributes, t2);
        if (s3) {
          e.push(s3);
          continue;
        }
      }
      l.add(tt(f2, s2, r, i4, a)), e.push(d2(y2));
    }
  }
  _createObjectIdGenerator(e, t) {
    const s2 = e.fieldsIndex.get(e.objectIdField);
    if ("esriFieldTypeString" === s2.type) return () => s2.name + "-" + Date.now().toString(16);
    let i4 = Number.NEGATIVE_INFINITY;
    for (const r of t) r.objectId && (i4 = Math.max(i4, r.objectId));
    return i4 = Math.max(0, i4) + 1, () => i4++;
  }
  _assignObjectId(e, t, s2 = false) {
    const i4 = this._queryEngine.objectIdField;
    e[i4] = s2 && i4 in t ? t[i4] : this._objectIdGenerator();
  }
  _checkProjection(e) {
    return __async(this, null, function* () {
      try {
        yield x(g, e);
      } catch {
        throw new s("geojson-layer", "Projection not supported");
      }
    });
  }
};
export {
  Q as default
};
//# sourceMappingURL=GeoJSONSourceWorker-6O6XTSZR.js.map
