import {
  h as h5
} from "./chunk-4OY6E7VR.js";
import {
  U
} from "./chunk-YPWIGR43.js";
import {
  h as h4
} from "./chunk-3HMMJFFQ.js";
import {
  e as e5
} from "./chunk-WU45X43Z.js";
import {
  i as i3
} from "./chunk-GSCGHCGH.js";
import {
  f
} from "./chunk-43JJA43P.js";
import {
  i,
  p as p3
} from "./chunk-NGSE7GKF.js";
import {
  i as i2
} from "./chunk-XL7IZWA5.js";
import {
  G,
  T,
  V as V2,
  u as u2
} from "./chunk-HUMP672Y.js";
import {
  h as h3,
  r
} from "./chunk-ZYQL5F6K.js";
import "./chunk-Q6IZWY56.js";
import {
  l as l2
} from "./chunk-JBQJ3BUL.js";
import "./chunk-I5SWBGDW.js";
import "./chunk-YY43ZHCK.js";
import "./chunk-3FSYWRTQ.js";
import "./chunk-WMR65EYY.js";
import "./chunk-PPQDPHZN.js";
import {
  c as c3,
  m as m3
} from "./chunk-KYB3KTOZ.js";
import "./chunk-B4LRUYYJ.js";
import {
  e as e4
} from "./chunk-6VVHYTZ7.js";
import "./chunk-MNNI2X2N.js";
import "./chunk-2SHZAJ7S.js";
import {
  R
} from "./chunk-SBMU7RBF.js";
import "./chunk-QRVAQWLH.js";
import "./chunk-TMPIWG43.js";
import "./chunk-WE6VW4MG.js";
import {
  E2 as E,
  P as P2
} from "./chunk-Q666VSL3.js";
import "./chunk-P3B4Y6UN.js";
import "./chunk-TJIA4U42.js";
import "./chunk-ZFPMGEAK.js";
import {
  p as p2
} from "./chunk-4SCJM64G.js";
import "./chunk-DABQKFI5.js";
import "./chunk-67V5AGVJ.js";
import "./chunk-FLWLBYXO.js";
import "./chunk-WTF7K3GK.js";
import {
  _ as _2
} from "./chunk-2ERGO64O.js";
import "./chunk-RP2GKJCD.js";
import "./chunk-D3AKDIJC.js";
import "./chunk-3JEG7JG5.js";
import "./chunk-VTRNFNJR.js";
import "./chunk-W6GMJ4SS.js";
import {
  h as h2
} from "./chunk-IIVUY2T7.js";
import {
  h
} from "./chunk-GT3AQDRW.js";
import "./chunk-5APMY2AQ.js";
import "./chunk-GHUJU3NS.js";
import "./chunk-25PMMPR7.js";
import "./chunk-SLCHZ6DD.js";
import "./chunk-TQYVLRAH.js";
import "./chunk-6A3XUATG.js";
import "./chunk-MD2IQSSQ.js";
import "./chunk-SNHPS7NU.js";
import "./chunk-L3F4XA4B.js";
import "./chunk-CZQYBYHB.js";
import "./chunk-Q5ZRUB2Y.js";
import "./chunk-VS26W5Y5.js";
import "./chunk-LM2N2I5R.js";
import "./chunk-DM4WHMQY.js";
import "./chunk-6MR4UDDL.js";
import "./chunk-L7ZKWTWL.js";
import "./chunk-O2DTA3XK.js";
import "./chunk-XCOHDMBF.js";
import "./chunk-HOH445RO.js";
import {
  l
} from "./chunk-KKD7A2GN.js";
import "./chunk-ZWCV4HKG.js";
import "./chunk-N4KQPPPI.js";
import "./chunk-4OGGMTIH.js";
import "./chunk-NQVBBKAN.js";
import "./chunk-DY7FJHTG.js";
import "./chunk-Q4KYZS3X.js";
import "./chunk-VWML4J2J.js";
import "./chunk-BQZBOYBD.js";
import "./chunk-TYQXPPSP.js";
import "./chunk-T2S5VXNP.js";
import "./chunk-4U5GUJRA.js";
import {
  d as d3
} from "./chunk-HD65DNIO.js";
import "./chunk-4KWLMXIA.js";
import "./chunk-BIUXKPKA.js";
import "./chunk-N6TJI25E.js";
import "./chunk-634JLXD4.js";
import "./chunk-Y3EDGYWG.js";
import "./chunk-UF6JOUSJ.js";
import "./chunk-T5JGQSO3.js";
import "./chunk-CIW3KHOW.js";
import "./chunk-J55F4AC2.js";
import "./chunk-IQLBZKUD.js";
import {
  y as y2
} from "./chunk-7MZZCQ64.js";
import "./chunk-DI6VABAK.js";
import "./chunk-5EBAJR7X.js";
import "./chunk-5JA2JHV3.js";
import "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import "./chunk-SGSUM5YO.js";
import "./chunk-SG5TCCCK.js";
import "./chunk-6A7CWJED.js";
import "./chunk-DUTZNK67.js";
import "./chunk-IN6BQCWS.js";
import "./chunk-JM7HAEY6.js";
import "./chunk-OUKUASAF.js";
import "./chunk-V5RMUGJJ.js";
import "./chunk-D2NB6D6N.js";
import "./chunk-UWJIHV6Q.js";
import "./chunk-M2NS3MSU.js";
import "./chunk-HMNBB7ED.js";
import "./chunk-3RRMLFFN.js";
import "./chunk-DR5TVNEL.js";
import "./chunk-HT2T6PUB.js";
import "./chunk-K64AAM77.js";
import "./chunk-6EUVKE22.js";
import "./chunk-A3NNJ7XA.js";
import "./chunk-OKJHJ3CY.js";
import "./chunk-XTVPEVHA.js";
import "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import "./chunk-DZALMCYL.js";
import "./chunk-K226GFDN.js";
import "./chunk-4ZZRP4MA.js";
import {
  c as c2
} from "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-VDB6Y4TZ.js";
import "./chunk-WYMXVOAT.js";
import "./chunk-K7TO5IIO.js";
import "./chunk-A4VVDRCH.js";
import "./chunk-CQDYITZC.js";
import "./chunk-5I6J67HP.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-FYAEQPUY.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-ONPREQKF.js";
import "./chunk-7RMVJCDW.js";
import "./chunk-GTY5NXA4.js";
import {
  m2
} from "./chunk-T6GCUITX.js";
import {
  c,
  e as e3,
  m
} from "./chunk-TUIGM7TV.js";
import "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import "./chunk-NYQ5CYNR.js";
import {
  _
} from "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import "./chunk-AXVPJBVW.js";
import "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import {
  A,
  C,
  P,
  d as d2,
  p
} from "./chunk-6WHTZNUH.js";
import {
  V
} from "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import {
  d
} from "./chunk-XNUH25NY.js";
import {
  o as o2
} from "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e as e2
} from "./chunk-4Z5SGKRM.js";
import "./chunk-YPWMP2VK.js";
import "./chunk-23E6RT3O.js";
import "./chunk-RCBGISRX.js";
import "./chunk-2P72IR2Y.js";
import "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3 as a
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import "./chunk-HJY2YILU.js";
import {
  o
} from "./chunk-7DA6A5LD.js";
import {
  e,
  n as n2,
  u
} from "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-WYIDUUN2.js";
import "./chunk-DXLOWWK7.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/views/interactive/tooltip/infos/TranslateVertexTooltipInfo.js
var i4 = class extends r {
  constructor(t) {
    super(t), this.type = "translate-vertex", this.distance = h2, this.elevation = null, this.area = null, this.totalLength = null;
  }
  clear() {
    this.distance = h2, this.elevation = null, this.area = null, this.totalLength = null;
  }
};
e2([y()], i4.prototype, "type", void 0), e2([y()], i4.prototype, "distance", void 0), e2([y()], i4.prototype, "elevation", void 0), e2([y()], i4.prototype, "area", void 0), e2([y()], i4.prototype, "totalLength", void 0), i4 = e2([a("esri.views.interactive.tooltip.infos.TranslateVertexTooltipInfo")], i4);

// ../../../node_modules/@arcgis/core/views/draw/support/reshapeTooltipUtils.js
function h6(t) {
  const e6 = {
    sketchOptions: t,
    viewType: "2d"
  };
  return {
    movePoint: new i(e6),
    selectedVertex: new p3(e6),
    translateGraphic: new i2(e6),
    translateVertices: new i4(e6)
  };
}
function d4(e6, r2) {
  let c4 = false;
  function a2() {
    const t = r2(), e7 = t.sketchOptions.tooltips.effectiveEnabled ? t.activeTooltipInfo : null;
    return __spreadProps(__spreadValues({}, t), {
      activeTooltipInfo: e7
    });
  }
  return o([d2(() => {
    const t = a2();
    return {
      context: t,
      geometry: t.graphic?.geometry,
      vertexGeometry: t.selectedVertex?.geometry
    };
  }, ({
    context: t
  }) => {
    c4 = true, x(t), e6.info = t.activeTooltipInfo, c4 = false;
  }, A), d2(() => {
    const t = a2(), {
      activeTooltipInfo: e7
    } = t;
    if (e7 && "key" in e7) return {
      context: t,
      key: e7.key
    };
  }, (t, e7) => {
    t && !c4 && e7 && t.key !== e7.key && w(t.context);
  }, C), T(e6)]);
}
function x(t) {
  const e6 = t.activeTooltipInfo;
  if (e6) {
    switch (e6?.type) {
      case "move-point":
        return T2(e6, t);
      case "selected-vertex":
        return j(e6, t);
    }
    e6.sketchOptions = t.sketchOptions;
  }
}
function T2(t, {
  graphic: e6
}) {
  k(t, e6, e6?.geometry);
}
function j(t, {
  graphic: e6,
  selectedVertex: o3
}) {
  k(t, e6, o3?.geometry);
  const n3 = e6?.geometry;
  switch (n3?.type) {
    case "polygon":
      t.geometryType = "polygon", t.totalLength.visible = false, t.area.actual = u2(n3);
      break;
    case "polyline":
      t.geometryType = "polyline", t.totalLength.actual = c3(n3), t.area.visible = false;
  }
}
function k(t, e6, o3) {
  e6 && "point" === o3?.type && (t.setLocationFromPoint(o3), t.elevation.actual = R(o3), t.elevation.visible = !!e6.geometry?.hasZ, t.elevation.readOnly = false, t.elevation.showAsZ = true);
}
function w(t) {
  function e6(e7, o4) {
    const n4 = o4?.geometry;
    if (!n4 || "point" !== n4.type) return;
    const {
      dx: i6,
      dy: r2,
      dz: s2
    } = V2(e7, n4);
    if (0 === i6 && 0 === r2 && 0 === s2) return;
    const {
      x: l3,
      y: p4,
      z: m4,
      m: f2,
      spatialReference: u3
    } = n4, y3 = new _({
      x: l3 + i6,
      y: p4 + r2,
      z: null != m4 ? m4 + s2 : void 0,
      m: f2,
      spatialReference: u3
    });
    t.updateGeometry(o4, y3, n4, i6, r2);
  }
  const {
    activeTooltipInfo: o3,
    graphic: n3,
    selectedVertex: i5
  } = t;
  switch (o3?.type) {
    case "move-point":
      return e6(o3, n3);
    case "selected-vertex":
      return e6(o3, i5);
  }
}
function I(t, e6, o3) {
  t.clear(), V3(t, e6, o3);
}
function U2(t, e6, o3, n3) {
  t.clear(), "polygon" === o3?.type ? t.area = u2(o3) : "polyline" === o3?.type && (t.totalLength = c3(o3)), V3(t, e6, n3);
}
function V3(t, o3, n3) {
  if (!n3) return;
  const {
    x: i5,
    y: c4
  } = n3.origin, s2 = o3.toMap(n3), a2 = o3.toMap(c2(i5, c4)), l3 = m3(a2, s2);
  t.distance = null != l3 ? l3 : h2;
}

// ../../../node_modules/@arcgis/core/views/draw/support/Reshape.js
var F = class {
  constructor(e6, t, i5) {
    this.graphic = e6, this.mover = t, this.selected = i5, this.type = "reshape-start";
  }
};
var P3 = class {
  constructor(e6, t, i5) {
    this.graphic = e6, this.mover = t, this.selected = i5, this.type = "reshape";
  }
};
var Z = class {
  constructor(e6, t, i5) {
    this.graphic = e6, this.mover = t, this.selected = i5, this.type = "reshape-stop";
  }
};
var X = class {
  constructor(e6, t, i5) {
    this.mover = e6, this.dx = t, this.dy = i5, this.type = "move-start";
  }
};
var Y = class {
  constructor(e6, t, i5) {
    this.mover = e6, this.dx = t, this.dy = i5, this.type = "move";
  }
};
var K = class {
  constructor(e6, t, i5) {
    this.mover = e6, this.dx = t, this.dy = i5, this.type = "move-stop";
  }
};
var N = class {
  constructor(e6) {
    this.added = e6, this.type = "vertex-select";
  }
};
var q = class {
  constructor(e6) {
    this.removed = e6, this.type = "vertex-deselect";
  }
};
var B = class {
  constructor(e6, t, i5, s2) {
    this.added = e6, this.graphic = t, this.oldGraphic = i5, this.vertices = s2, this.type = "vertex-add";
  }
};
var J = class {
  constructor(e6, t, i5, s2) {
    this.removed = e6, this.graphic = t, this.oldGraphic = i5, this.vertices = s2, this.type = "vertex-remove";
  }
};
var Q = h5.reshapeGraphics;
var W = {
  vertices: {
    default: new y2({
      style: "circle",
      size: Q.vertex.size,
      color: Q.vertex.color,
      outline: {
        color: Q.vertex.outlineColor,
        width: 1
      }
    }),
    hover: new y2({
      style: "circle",
      size: Q.vertex.hoverSize,
      color: Q.vertex.hoverColor,
      outline: {
        color: Q.vertex.hoverOutlineColor,
        width: 1
      }
    }),
    selected: new y2({
      style: "circle",
      size: Q.selected.size,
      color: Q.selected.color,
      outline: {
        color: Q.selected.outlineColor,
        width: 1
      }
    })
  },
  midpoints: {
    default: new y2({
      style: "circle",
      size: Q.midpoint.size,
      color: Q.midpoint.color,
      outline: {
        color: Q.midpoint.outlineColor,
        width: 1
      }
    }),
    hover: new y2({
      style: "circle",
      size: Q.midpoint.size,
      color: Q.midpoint.color,
      outline: {
        color: Q.midpoint.outlineColor,
        width: 1
      }
    })
  }
};
var $ = class extends o2.EventedAccessor {
  constructor(e6) {
    super(e6), this._activeOperationInfo = null, this._editGeometryOperations = null, this._graphicAttributes = {
      esriSketchTool: "box"
    }, this._mover = null, this._snappingContext = null, this._snappingGraphicsLayer = null, this._hoverGraphic = null, this._snappingTask = null, this._stagedVertex = null, this.tooltip = null, this.activeTooltipInfo = null, this.callbacks = {
      onReshapeStart() {
      },
      onReshape() {
      },
      onReshapeStop() {
      },
      onMoveStart() {
      },
      onMove() {
      },
      onMoveStop() {
      },
      onGraphicClick() {
      }
    }, this.enableMidpoints = true, this.enableMovement = true, this.enableVertices = true, this.graphic = null, this.layer = null, this.midpointGraphics = new V(), this.midpointSymbol = new y2({
      style: "circle",
      size: 6,
      color: [200, 200, 200],
      outline: {
        color: [100, 100, 100],
        width: 1
      }
    }), this.selectedVertices = new V(), this.snappingManager = null, this.symbols = W, this.sketchOptions = new l2(), this.type = "reshape", this.vertexGraphics = new V(), this.view = null;
  }
  initialize() {
    const e6 = this.view;
    this._highlightHelper = new h4({
      view: e6
    }), this._setup(), this.tooltip = new h3({
      view: this.view
    }), this.tooltipInfos = h6(this.sketchOptions), this.addHandles([p(() => e6?.ready, () => {
      const {
        layer: e7,
        view: t
      } = this;
      e5(t, e7), this.addHandles(t.on("key-down", (e8) => this._keyDownHandler(e8), _2.TOOL));
    }, {
      once: true,
      initial: true
    }), d2(() => this.graphic, () => this.refresh()), d2(() => this.layer, (e7, t) => {
      t && (this._clearSelection(), this._resetGraphics(t)), this.refresh();
    }), d2(() => this.enableMidpoints, () => this.refresh()), d4(this.tooltip, () => this._tooltipsContext), d2(() => this.view.effectiveTheme.accentColor, () => this._updateSymbolsForTheme(), P)]), this._updateTooltip();
  }
  destroy() {
    this._reset(), this._mover?.destroy(), this._mover = null, this.tooltip = u(this.tooltip);
  }
  get _coordinateHelper() {
    return this._editGeometryOperations?.data.coordinateHelper ?? P2(!!this.graphic.geometry?.hasZ, !!this.graphic.geometry?.hasM, this.view.spatialReference);
  }
  get _selectedVertex() {
    return 1 === this.selectedVertices.length ? this.selectedVertices.at(0) : void 0;
  }
  get _tooltipsContext() {
    return {
      sketchOptions: this.sketchOptions,
      activeTooltipInfo: this.activeTooltipInfo,
      graphic: this.graphic,
      selectedVertex: this._selectedVertex,
      updateGeometry: (e6, t, i5, s2, o3) => {
        this._setUpGeometryHelper();
        const r2 = e6 === this.graphic;
        r2 ? this._emitMoveStartEvent(0, 0) : this._emitReshapeStartEvent(e6);
        const n3 = true;
        if (this._syncGeometryAfterVertexMove(e6, t, s2, o3, n3), r2) {
          const {
            view: e7
          } = this, s3 = e7.toScreen(i5), o4 = e7.toScreen(t), r3 = (o4?.x ?? 0) - (s3?.x ?? 0), n4 = (o4?.y ?? 0) - (s3?.y ?? 0);
          this._emitMoveEvent(r3, n4), this._emitMoveStopEvent(r3, n4);
        } else this._emitReshapeEvent(e6), this._emitReshapeStopEvent(e6);
        this._editGeometryOperations = u(this._editGeometryOperations);
      }
    };
  }
  set highlightsEnabled(e6) {
    this._highlightHelper?.removeAll(), this._set("highlightsEnabled", e6), this._setUpHighlights();
  }
  get state() {
    const e6 = this.view.ready, t = !(!this.graphic || !this.layer);
    return e6 && t ? "active" : e6 ? "ready" : "disabled";
  }
  isUIGraphic(e6) {
    const t = [];
    return this.graphic && t.push(this.graphic), t.concat(this.vertexGraphics.items, this.midpointGraphics.items), t.length > 0 && t.includes(e6);
  }
  refresh() {
    this._reset(), this._setup();
  }
  reset() {
    this.graphic = null;
  }
  clearSelection() {
    this._clearSelection();
  }
  removeSelectedVertices() {
    const {
      selectedVertices: e6
    } = this;
    e6.length && this._removeVertices(e6);
  }
  _setup() {
    const {
      graphic: e6,
      layer: t
    } = this;
    if (!t || null == e6?.geometry) return;
    const i5 = e6.geometry;
    "mesh" !== i5.type && "extent" !== i5.type ? ("polygon" === i5.type && m(i5), this._setUpHighlights(), this._setupGraphics(), this._setupMover()) : this._logGeometryTypeError();
  }
  _setUpHighlights() {
    this.highlightsEnabled && this.graphic && this._highlightHelper?.add(this.graphic);
  }
  _setUpGeometryHelper() {
    const e6 = this.graphic.geometry;
    if (null == e6 || "mesh" === e6.type || "extent" === e6.type) return void this._logGeometryTypeError();
    const t = "multipoint" === e6.type ? new m2({
      paths: e6.points,
      spatialReference: e6.spatialReference
    }) : e6;
    this._editGeometryOperations = E.fromGeometry(t, l.Local);
  }
  _saveSnappingContextForHandle(e6, t) {
    this._snappingGraphicsLayer = new h({
      listMode: "hide",
      internal: true,
      title: "Reshape snapping layer"
    }), this.view.map.layers.add(this._snappingGraphicsLayer);
    const i5 = this._editGeometryOperations;
    n2(i5), this._snappingContext = new e4({
      editGeometryOperations: i5,
      elevationInfo: {
        mode: "on-the-ground",
        offset: 0
      },
      pointer: t.viewEvent?.pointerType || "mouse",
      excludeFeature: this.graphic,
      feature: this.graphic,
      visualizer: new f(this._snappingGraphicsLayer),
      vertexHandle: this._getVertexFromEditGeometry(e6)
    });
  }
  _reset() {
    this._clearSelection(), this._highlightHelper?.removeAll(), this._updateTooltip(), this._resetGraphics(), this._resetSnappingStateVars(), this._activeOperationInfo = null, this._mover && this._mover.destroy(), this._mover = null, this.view.cursor = "default";
  }
  _resetSnappingStateVars() {
    null != this.snappingManager && this.snappingManager.doneSnapping(), null != this._snappingGraphicsLayer && (this.view?.map && this.view.map.layers.remove(this._snappingGraphicsLayer), this._snappingGraphicsLayer.destroy()), this._editGeometryOperations = u(this._editGeometryOperations), this._snappingTask = e(this._snappingTask), this._snappingTask = null, this._snappingContext = null, this._stagedVertex = null;
  }
  _resetGraphics(e6) {
    this._removeMidpointGraphics(e6), this._removeVertexGraphics(e6), this.selectedVertices.removeAll(), this._updateTooltip();
  }
  _removeMidpointGraphics(e6) {
    const t = e6 || this.layer;
    t && t.removeMany(this.midpointGraphics.items), this.midpointGraphics.items.forEach((e7) => e7.destroy()), this.midpointGraphics.removeAll();
  }
  _removeVertexGraphics(e6) {
    const t = e6 || this.layer;
    t && t.removeMany(this.vertexGraphics.items), this.vertexGraphics.items.forEach((e7) => e7.destroy()), this.vertexGraphics.removeAll();
  }
  _setupGraphics() {
    const e6 = this.graphic.geometry;
    if (null != e6 && ("polyline" === e6.type || "polygon" === e6.type)) {
      const t = ee(e6);
      this.enableMidpoints && this._setUpMidpointGraphics(t), this.enableVertices && this._setUpVertexGraphics(t);
    }
  }
  _setUpMidpointGraphics(e6) {
    this._removeMidpointGraphics();
    const t = this._createMidpointGraphics(e6);
    this.midpointGraphics.addMany(t), this.layer.addMany(t);
  }
  _setUpVertexGraphics(e6) {
    this._removeVertexGraphics();
    const t = this._createVertexGraphics(e6);
    this.vertexGraphics.addMany(t), this._storeRelatedVertexIndices(), this.layer.addMany(t);
  }
  _createVertexGraphics(e6) {
    const {
      _graphicAttributes: i5,
      symbols: s2
    } = this, o3 = [];
    return e6?.forEach((e7, r2) => {
      e7.forEach((e8, n3) => {
        o3.push(new d3({
          geometry: this._coordinateHelper.arrayToPoint(e8),
          symbol: s2?.vertices?.default,
          attributes: __spreadProps(__spreadValues({}, i5), {
            pathIndex: r2,
            pointIndex: n3
          })
        }));
      });
    }), o3;
  }
  _createMidpointGraphics(e6) {
    const {
      _graphicAttributes: i5,
      symbols: s2
    } = this, o3 = [];
    for (let r2 = 0; r2 < e6.length; r2++) {
      const n3 = e6[r2];
      for (let e7 = 0; e7 < n3.length; e7++) {
        const h7 = (e7 + 1) % n3.length;
        if ("polyline" === this.graphic.geometry?.type && 0 === h7) continue;
        const p4 = n3[e7], a2 = n3[h7], c4 = this._getMidpoint(p4, a2);
        o3.push(new d3({
          geometry: c4,
          symbol: s2.midpoints.default,
          attributes: __spreadProps(__spreadValues({}, i5), {
            pathIndex: r2,
            pointIndexStart: e7,
            pointIndexEnd: h7
          })
        }));
      }
    }
    return o3;
  }
  _updateSymbolsForTheme() {
    const e6 = this.view.effectiveTheme.accentColor;
    this.symbols = {
      vertices: __spreadProps(__spreadValues({}, this.symbols.vertices), {
        default: this.symbols.vertices.default.clone().set("color", e6),
        hover: this.symbols.vertices.hover?.clone().set("color", e6)
      }),
      midpoints: __spreadValues({}, this.symbols.midpoints)
    };
    for (const t of this.vertexGraphics) this._isSelected(t) ? t.symbol = this.symbols.vertices.selected : this._hoverGraphic === t ? t.symbol = this.symbols.vertices.hover : t.symbol = this.symbols.vertices.default;
  }
  _storeRelatedVertexIndices() {
    const e6 = this.vertexGraphics.items;
    if (!e6) return;
    const t = e6.map(({
      geometry: e7
    }) => ({
      x: e7.x,
      y: e7.y
    }));
    for (let i5 = 0; i5 < t.length; i5++) {
      const s2 = [];
      for (let e7 = 0; e7 < t.length; e7++) {
        if (i5 === e7) continue;
        const o3 = t[i5], r2 = t[e7];
        o3.x === r2.x && o3.y === r2.y && s2.push(e7);
      }
      e6[i5].attributes.relatedGraphicIndices = s2;
    }
  }
  _setupMover() {
    const {
      enableMovement: e6,
      graphic: t,
      midpointGraphics: i5,
      vertexGraphics: s2,
      view: o3
    } = this, r2 = s2.concat(i5).items;
    e6 && r2.push(t), this._mover = new U({
      enableMoveAllGraphics: false,
      highlightsEnabled: false,
      indicatorsEnabled: false,
      graphics: r2,
      view: o3,
      callbacks: {
        onGraphicClick: (e7) => this._onGraphicClickCallback(e7),
        onGraphicMoveStart: (e7) => this._onGraphicMoveStartCallback(e7),
        onGraphicMove: (e7) => this._onGraphicMoveCallback(e7),
        onGraphicMoveStop: (e7) => this._onGraphicMoveStopCallback(e7),
        onGraphicPointerOver: (e7) => this._onGraphicPointerOverCallback(e7),
        onGraphicPointerOut: (e7) => this._onGraphicPointerOutCallback(e7)
      }
    });
  }
  _onGraphicClickCallback(e6) {
    e6.viewEvent.stopPropagation();
    const t = e6.graphic;
    if (t === this.graphic) this.clearSelection(), this.emit("graphic-click", e6), this.callbacks.onGraphicClick?.(e6);
    else if (this._isMidpoint(t)) {
      if (2 === e6.viewEvent.button) return;
      const i5 = this.graphic.clone(), s2 = this._createVertexFromMidpoint(t);
      this.refresh(), this._emitVertexAddEvent([t], i5, s2);
    } else if (this._isVertex(t)) if (e6.viewEvent.stopPropagation(), 2 === e6.viewEvent.button) this._removeVertices(t);
    else {
      e6.viewEvent.native.shiftKey || this._clearSelection(), this.selectedVertices.includes(t) ? this._removeFromSelection(t, true) : this._addToSelection(t);
    }
  }
  _setUpOperation(e6) {
    const {
      graphic: t,
      dx: i5,
      dy: s2
    } = e6, o3 = t === this.graphic;
    this._resetSnappingStateVars(), this._setUpGeometryHelper(), this._saveSnappingContextForHandle(t, e6), this._activeOperationInfo = {
      target: this.graphic,
      mover: t,
      operationType: o3 ? "move" : "reshape",
      totalDx: i5,
      totalDy: s2
    };
  }
  _onGraphicMoveStartCallback(e6) {
    const {
      dx: t,
      dy: i5,
      graphic: s2
    } = e6;
    if (s2 === this.graphic) {
      const {
        geometry: o3
      } = s2;
      return this._setUpOperation(e6), this._emitMoveStartEvent(t, i5), void (null != o3 && "point" === o3.type && this._onHandleMove(s2, t, i5, e6, () => {
        this._updateTooltip(this.graphic, e6.viewEvent), this._emitMoveEvent(t, i5);
      }));
    }
    if (!this.selectedVertices.includes(s2)) {
      if (this._clearSelection(), this._isMidpoint(s2)) {
        const e7 = this.graphic.clone(), t2 = this._createVertexFromMidpoint(s2);
        this._emitVertexAddEvent([s2], e7, t2);
      }
      this._addToSelection(s2);
    }
    this._setUpOperation(e6), this._emitReshapeStartEvent(s2), this._onHandleMove(s2, t, i5, e6, () => {
      this._updateTooltip(s2, e6.viewEvent), this._emitReshapeEvent(s2);
    });
  }
  _onGraphicMoveCallback(e6) {
    const t = this._activeOperationInfo;
    if (!t) return;
    const {
      dx: i5,
      dy: s2,
      graphic: o3
    } = e6;
    t.totalDx += i5, t.totalDy += s2;
    const {
      operationType: r2
    } = t, {
      geometry: n3
    } = o3;
    if (null != n3) {
      if ("move" !== r2) this._onHandleMove(o3, i5, s2, e6, () => {
        this._updateTooltip(o3, e6.viewEvent), this._emitReshapeEvent(o3);
      });
      else if ("point" === n3.type) this._onHandleMove(o3, i5, s2, e6, () => {
        this._updateTooltip(this.graphic, e6.viewEvent), this._emitMoveEvent(i5, s2);
      });
      else if ("polyline" === n3.type || "polygon" === n3.type) {
        const t2 = ee(n3);
        this._updateVertexGraphicLocations(t2), this._updateTooltip(this.graphic, e6.viewEvent), this._emitMoveEvent(i5, s2);
      }
    }
  }
  _onGraphicMoveStopCallback(e6) {
    const t = this._activeOperationInfo;
    if (!t) return;
    const {
      dx: i5,
      dy: s2,
      graphic: o3
    } = e6, {
      operationType: r2
    } = t;
    t.totalDx += i5, t.totalDy += s2, this._onHandleMove(o3, i5, s2, e6, () => "move" === r2 ? this._emitMoveStopEvent() : this._emitReshapeStopEvent(o3)), this._isMidpoint(o3) ? this.refresh() : (this._updateTooltip(this._isVertex(o3) ? o3 : null), this._resetSnappingStateVars(), this._activeOperationInfo = null);
  }
  _updateVertexGraphicLocations(e6) {
    const {
      _coordinateHelper: t
    } = this;
    for (const i5 of this.vertexGraphics) {
      const {
        pathIndex: s2,
        pointIndex: o3
      } = i5.attributes;
      i5.geometry = t.arrayToPoint(e6[s2][o3]);
    }
    this._updateMidpointGraphicLocations(e6);
  }
  _updateMidpointGraphicLocations(e6) {
    for (const t of this.midpointGraphics) {
      const {
        pathIndex: i5,
        pointIndexStart: s2,
        pointIndexEnd: o3
      } = t.attributes, r2 = e6[i5];
      t.geometry = this._getMidpoint(r2[s2], r2[o3]);
    }
  }
  _getMidpoint(e6, t) {
    const {
      _coordinateHelper: i5
    } = this, s2 = i5.arrayToVector(e6), o3 = i5.arrayToVector(t), r2 = i5.toXYZ(s2), n3 = i5.toXYZ(o3), [h7, p4, a2] = c(r2, n3), c4 = i5.hasM() ? 0 : void 0;
    return new _({
      x: h7,
      y: p4,
      z: a2,
      m: c4,
      spatialReference: i5.spatialReference
    });
  }
  _getVertexFromEditGeometry(e6) {
    const [t, i5] = te(e6);
    return n2(this._editGeometryOperations), this._editGeometryOperations.data.components[t].vertices[i5];
  }
  _onHandleMove(e6, t, s2, o3, r2) {
    e(this._snappingTask);
    const n3 = this._snappingContext;
    if (!n3) return;
    const h7 = e6.geometry, p4 = "graphic-move-stop" === o3.type;
    if (null != this.snappingManager && this.selectedVertices.length < 2 && !p4) {
      const o4 = this.snappingManager;
      this._stagedVertex = o4.update({
        point: h7,
        context: n3
      }), this._syncGeometryAfterVertexMove(e6, new _(this._stagedVertex), t, s2, p4), r2(), this._snappingTask = d((i5) => __async(this, null, function* () {
        const a2 = yield o4.snap({
          point: h7,
          context: n3,
          signal: i5
        });
        a2.valid && (this._stagedVertex = a2.apply(), this._syncGeometryAfterVertexMove(e6, new _(this._stagedVertex), t, s2, p4), r2());
      }));
    } else {
      const i5 = null != this._stagedVertex ? new _(this._stagedVertex) : h7;
      this._syncGeometryAfterVertexMove(e6, i5, t, s2, p4), r2();
    }
  }
  _syncGeometryAfterVertexMove(e6, t, i5, s2, o3 = false) {
    const r2 = this._editGeometryOperations?.data.geometry;
    if (r2) if ("point" === r2.type) e6.geometry = t;
    else if ("mesh" === r2.type) e6.geometry = r2.centerAt(t);
    else {
      const {
        _coordinateHelper: n3
      } = this, [h7, p4] = te(e6);
      let a2 = e3(r2);
      const c4 = a2[h7].length - 1, l3 = n3.pointToArray(t);
      a2[h7][p4] = l3, "polygon" === r2.type && (0 === p4 ? a2[h7][c4] = l3 : p4 === c4 && (a2[h7][0] = l3)), this._isVertex(e6) && (a2 = this._moveRelatedCoordinates(a2, e6, l3), a2 = this._moveSelectedHandleCoordinates(a2, e6, i5, s2, "polygon" === r2.type), this._updateMidpointGraphicLocations(a2)), this.graphic.geometry = r2.clone();
      const d5 = n3.pointToVector(t), m4 = this._getVertexFromEditGeometry(e6), v = n3.getZ(d5), y3 = d5[0] - m4.pos[0], _3 = d5[1] - m4.pos[1], u3 = null != v ? v - m4.pos[2] : 0;
      this._editGeometryOperations?.moveVertices([m4], y3, _3, u3), o3 && (this._mover ? this._mover.updateGeometry(this._mover.graphics.indexOf(e6), t) : e6.geometry = t);
    }
  }
  _moveRelatedCoordinates(e6, t, i5) {
    const {
      relatedGraphicIndices: s2
    } = t.attributes;
    for (const o3 of s2) {
      const s3 = this.vertexGraphics.at(o3), {
        pathIndex: r2,
        pointIndex: n3
      } = s3.attributes;
      e6[r2][n3] = i5, s3.geometry = t.geometry;
    }
    return e6;
  }
  _moveSelectedHandleCoordinates(e6, t, i5, s2, o3) {
    for (const r2 of this.selectedVertices) if (r2 !== t) {
      const {
        pathIndex: t2,
        pointIndex: n3,
        relatedGraphicIndices: h7
      } = r2.attributes, p4 = i3(r2.geometry, i5, s2, this.view), a2 = e3(p4), c4 = e6[t2].length - 1;
      e6[t2][n3] = a2, r2.geometry = p4, o3 && (0 === n3 ? e6[t2][c4] = a2 : n3 === c4 && (e6[t2][0] = a2));
      for (const i6 of h7) {
        const t3 = this.vertexGraphics.at(i6), {
          pathIndex: s3,
          pointIndex: o4
        } = t3.attributes;
        e6[s3][o4] = a2, t3.geometry = p4;
      }
    }
    return e6;
  }
  _onGraphicPointerOverCallback(e6) {
    const t = e6.graphic;
    this._hoverGraphic = t;
    const i5 = this._isVertex(t);
    i5 && !this._isSelected(t) && (t.symbol = this.symbols.vertices.hover), this._updateTooltip(i5 ? t : null), this._updateHoverCursor(t);
  }
  _onGraphicPointerOutCallback(e6) {
    const t = e6.graphic;
    this._hoverGraphic = null, this._isVertex(t) && !this._isSelected(t) && (t.symbol = this.symbols.vertices.default), this.view.cursor = "default", this._updateTooltip();
  }
  _createVertexFromMidpoint(e6) {
    const {
      _graphicAttributes: t,
      graphic: i5
    } = this, s2 = i5.geometry;
    if (null == s2 || "polygon" !== s2.type && "polyline" !== s2.type) return [];
    const o3 = s2.clone(), r2 = [], {
      pathIndex: n3,
      pointIndexStart: h7,
      pointIndexEnd: p4
    } = e6.attributes, a2 = e3(e6.geometry), c4 = 0 === p4 ? h7 + 1 : p4, l3 = e3(o3);
    return l3[n3].splice(c4, 0, a2), e6.attributes = __spreadProps(__spreadValues({}, t), {
      pathIndex: n3,
      pointIndex: c4,
      relatedGraphicIndices: []
    }), r2.push({
      coordinates: l3[n3][c4],
      componentIndex: n3,
      vertexIndex: c4
    }), this.graphic.geometry = o3, r2;
  }
  _addToSelection(e6) {
    e6.symbol = this.symbols.vertices.selected, this.selectedVertices.add(e6), this._emitSelectEvent([e6]), this._updateTooltip(e6);
  }
  _removeFromSelection(e6, t) {
    const {
      vertices: i5
    } = this.symbols, s2 = t ? i5.hover : i5.default;
    this.selectedVertices.remove(e6), e6.symbol = s2, this._emitDeselectEvent([e6]), this._updateTooltip();
  }
  _clearSelection() {
    const e6 = this.selectedVertices.toArray();
    if (e6.length > 0) {
      for (const t of e6) t.set("symbol", this.symbols.vertices.default);
      this.selectedVertices.removeAll(), this._emitDeselectEvent(e6), this._updateTooltip();
    }
  }
  _keyDownHandler(e6) {
    null == this._activeOperationInfo && G(e6, this.tooltip) || p2.delete.includes(e6.key) && !e6.repeat && this.selectedVertices.length && this._removeVertices(this.selectedVertices);
  }
  _removeVertices(e6) {
    const t = this.graphic.geometry;
    if (null == t || "polygon" !== t.type && "polyline" !== t.type) return;
    if ("polygon" === t.type && this.vertexGraphics.length < 4 || this.vertexGraphics.length < 3) return;
    const i5 = this.graphic.clone(), s2 = t.clone();
    let o3 = e3(s2);
    const r2 = [], n3 = ie(e6);
    for (const h7 of n3) {
      const {
        x: e7,
        y: t2
      } = h7.geometry;
      for (let i6 = 0; i6 < o3.length; i6++) {
        const s3 = o3[i6];
        for (let n4 = 0; n4 < s3.length; n4++) {
          const [h8, p4] = s3[n4];
          e7 === h8 && t2 === p4 && (r2.push({
            coordinates: o3[i6][n4],
            componentIndex: i6,
            vertexIndex: n4
          }), o3[i6].splice(Number(n4), 1));
        }
      }
    }
    if ("polygon" === s2.type) o3 = o3.filter((e7) => {
      if (e7.length < 2) return false;
      const [t2, i6] = e7[0], [s3, o4] = e7[e7.length - 1];
      return (2 !== e7.length || t2 !== s3 || i6 !== o4) && (t2 === s3 && i6 === o4 || e7.push(e7[0]), true);
    }), s2.rings = o3;
    else {
      for (const e7 of o3) 1 === e7.length && o3.splice(o3.indexOf(e7), 1);
      s2.paths = o3;
    }
    this.graphic.geometry = s2, this.refresh(), this._emitVertexRemoveEvent(n3, i5, r2);
  }
  _isVertex(e6) {
    return this.vertexGraphics.includes(e6);
  }
  _isSelected(e6) {
    return this._isVertex(e6) && this.selectedVertices.includes(e6);
  }
  _isMidpoint(e6) {
    return this.midpointGraphics.includes(e6);
  }
  _updateHoverCursor(e6) {
    this.view.cursor = this._isMidpoint(e6) ? "copy" : "move";
  }
  _updateTooltip(e6, t) {
    let i5 = null;
    const {
      graphic: s2,
      view: o3,
      tooltipInfos: r2
    } = this, n3 = s2?.geometry;
    "point" === n3?.type ? i5 = r2.movePoint : this._selectedVertex ? i5 = r2.selectedVertex : e6 === this.graphic ? (i5 = r2.translateGraphic, I(i5, o3, t)) : e6 && this.selectedVertices.length > 1 && (i5 = r2.translateVertices, U2(i5, o3, n3, t)), this.activeTooltipInfo = i5;
  }
  _emitMoveStartEvent(e6, t) {
    const i5 = new X(this.graphic, e6, t);
    this.emit("move-start", i5), this.callbacks.onMoveStart?.(i5);
  }
  _emitMoveEvent(e6, t) {
    const i5 = new Y(this.graphic, e6, t);
    this.emit("move", i5), this.callbacks.onMove?.(i5);
  }
  _emitMoveStopEvent(e6, t) {
    if (null == e6 || null == t) {
      const i6 = this._activeOperationInfo;
      if (!i6) return;
      e6 = i6.totalDx, t = i6.totalDy;
    }
    const i5 = new K(this.graphic, e6, t);
    this.emit("move-stop", i5), this.callbacks.onMoveStop?.(i5);
  }
  _emitReshapeStartEvent(e6) {
    const t = new F(this.graphic, e6, this.selectedVertices.toArray());
    this.emit("reshape-start", t), this.callbacks.onReshapeStart?.(t);
  }
  _emitReshapeEvent(e6) {
    const t = new P3(this.graphic, e6, this.selectedVertices.toArray());
    this.emit("reshape", t), this.callbacks.onReshape?.(t);
  }
  _emitReshapeStopEvent(e6) {
    const t = new Z(this.graphic, e6, this.selectedVertices.toArray());
    this.emit("reshape-stop", t), this.callbacks.onReshapeStop?.(t);
  }
  _emitSelectEvent(e6) {
    const t = new N(e6);
    this.emit("select", t), this.callbacks.onVertexSelect?.(t);
  }
  _emitDeselectEvent(e6) {
    const t = new q(e6);
    this.emit("deselect", t), this.callbacks.onVertexDeselect?.(t);
  }
  _emitVertexAddEvent(e6, t, i5) {
    const s2 = new B(e6, this.graphic, t, i5);
    this.emit("vertex-add", s2), this.callbacks.onVertexAdd?.(s2);
  }
  _emitVertexRemoveEvent(e6, t, i5) {
    const s2 = new J(e6, this.graphic, t, i5);
    this.emit("vertex-remove", s2), this.callbacks.onVertexRemove?.(s2);
  }
  _logGeometryTypeError() {
    n.getLogger(this).error(new s("reshape:invalid-geometry", "Reshape operation not supported for the provided graphic. The geometry type is not supported."));
  }
};
function ee(e6) {
  const t = e3(e6.clone());
  if ("polygon" === e6.type) for (const i5 of t) {
    const e7 = i5[i5.length - 1];
    i5[0][0] === e7[0] && i5[0][1] === e7[1] && i5.length > 2 && i5.pop();
  }
  return t;
}
function te({
  attributes: e6
}) {
  return [e6?.pathIndex || 0, e6?.pointIndex || 0];
}
function ie(e6) {
  return e6 instanceof d3 ? [e6] : [...e6];
}
e2([y()], $.prototype, "_activeOperationInfo", void 0), e2([y()], $.prototype, "_coordinateHelper", null), e2([y()], $.prototype, "_editGeometryOperations", void 0), e2([y()], $.prototype, "tooltip", void 0), e2([y()], $.prototype, "tooltipInfos", void 0), e2([y()], $.prototype, "activeTooltipInfo", void 0), e2([y()], $.prototype, "_selectedVertex", null), e2([y()], $.prototype, "_tooltipsContext", null), e2([y()], $.prototype, "callbacks", void 0), e2([y()], $.prototype, "enableMidpoints", void 0), e2([y()], $.prototype, "enableMovement", void 0), e2([y()], $.prototype, "enableVertices", void 0), e2([y()], $.prototype, "graphic", void 0), e2([y({
  value: true
})], $.prototype, "highlightsEnabled", null), e2([y()], $.prototype, "layer", void 0), e2([y({
  readOnly: true
})], $.prototype, "midpointGraphics", void 0), e2([y()], $.prototype, "midpointSymbol", void 0), e2([y({
  readOnly: true
})], $.prototype, "selectedVertices", void 0), e2([y()], $.prototype, "snappingManager", void 0), e2([y({
  readOnly: true
})], $.prototype, "state", null), e2([y()], $.prototype, "symbols", void 0), e2([y({
  type: l2
})], $.prototype, "sketchOptions", void 0), e2([y({
  readOnly: true
})], $.prototype, "type", void 0), e2([y({
  readOnly: true
})], $.prototype, "vertexGraphics", void 0), e2([y()], $.prototype, "view", void 0), $ = e2([a("esri.views.draw.support.Reshape")], $);
var se = $;
export {
  se as default
};
//# sourceMappingURL=Reshape-6DEDGW3D.js.map
