import {
  i as i2,
  o as o2
} from "./chunk-HS4TEGJW.js";
import "./chunk-GHN4GWVN.js";
import {
  t
} from "./chunk-P3B4Y6UN.js";
import "./chunk-5QM72RFD.js";
import "./chunk-TJIA4U42.js";
import "./chunk-WQXGIEVZ.js";
import {
  f,
  y as y3
} from "./chunk-T3EGKTN6.js";
import "./chunk-ZFPMGEAK.js";
import "./chunk-4SCJM64G.js";
import "./chunk-DABQKFI5.js";
import "./chunk-67V5AGVJ.js";
import "./chunk-2ERGO64O.js";
import "./chunk-RP2GKJCD.js";
import "./chunk-QL5HR3YL.js";
import {
  a as a2
} from "./chunk-S5SROJXI.js";
import {
  J as J2
} from "./chunk-ZUHJZKEM.js";
import "./chunk-B4EEJXBQ.js";
import "./chunk-VS26W5Y5.js";
import {
  i,
  n,
  r
} from "./chunk-QFQHRGZH.js";
import {
  h as h2
} from "./chunk-PVO5NM6Q.js";
import {
  m
} from "./chunk-ROATEOHC.js";
import "./chunk-BIWDYV6F.js";
import {
  $
} from "./chunk-4MXR7W7N.js";
import "./chunk-6UYQMUGI.js";
import "./chunk-D3XZUGMN.js";
import {
  I
} from "./chunk-YFQ32AQX.js";
import "./chunk-L4AYSXFJ.js";
import "./chunk-POQ3T5EH.js";
import "./chunk-LPEFONL3.js";
import "./chunk-SSMSHZ2C.js";
import "./chunk-DM4WHMQY.js";
import "./chunk-DON3YPGT.js";
import {
  ot
} from "./chunk-C7NRYPDG.js";
import "./chunk-Z3GMSC63.js";
import "./chunk-F35MWZH7.js";
import "./chunk-ED7UGR2X.js";
import "./chunk-YA5CTHMT.js";
import "./chunk-4QBFFLOC.js";
import {
  e as e2
} from "./chunk-O437BSYE.js";
import "./chunk-YZNT6QWD.js";
import "./chunk-YVOGHYE3.js";
import "./chunk-IBOZJLSO.js";
import {
  y as y2
} from "./chunk-6MR4UDDL.js";
import "./chunk-O2DTA3XK.js";
import "./chunk-ZE47C44H.js";
import "./chunk-5GIS2C3K.js";
import "./chunk-XCOHDMBF.js";
import "./chunk-ZR5BOILP.js";
import "./chunk-HOH445RO.js";
import "./chunk-N4KQPPPI.js";
import "./chunk-4OGGMTIH.js";
import "./chunk-NQVBBKAN.js";
import "./chunk-DY7FJHTG.js";
import "./chunk-BQZBOYBD.js";
import "./chunk-TYQXPPSP.js";
import "./chunk-TRSGUVSM.js";
import "./chunk-U3MA63JX.js";
import "./chunk-WYKKCLBI.js";
import "./chunk-PFMGJTQM.js";
import {
  Z
} from "./chunk-Q7SRMLJZ.js";
import "./chunk-PQ4T66BG.js";
import "./chunk-SWPHGZYB.js";
import "./chunk-DWASPXVI.js";
import "./chunk-634JLXD4.js";
import "./chunk-Y3EDGYWG.js";
import "./chunk-UF6JOUSJ.js";
import "./chunk-T5JGQSO3.js";
import "./chunk-CIW3KHOW.js";
import "./chunk-J55F4AC2.js";
import "./chunk-IQLBZKUD.js";
import "./chunk-7MZZCQ64.js";
import "./chunk-LNRZHZOQ.js";
import "./chunk-DI6VABAK.js";
import "./chunk-5EBAJR7X.js";
import "./chunk-5JA2JHV3.js";
import "./chunk-FUKSTKFU.js";
import "./chunk-MIQZ6UDY.js";
import "./chunk-JOJZ6YC5.js";
import "./chunk-L4TOCXR5.js";
import "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import "./chunk-7WP676SE.js";
import "./chunk-SGSUM5YO.js";
import "./chunk-SG5TCCCK.js";
import "./chunk-6A7CWJED.js";
import {
  J,
  K,
  N
} from "./chunk-DUTZNK67.js";
import "./chunk-IN6BQCWS.js";
import "./chunk-JM7HAEY6.js";
import "./chunk-V5RMUGJJ.js";
import "./chunk-D2NB6D6N.js";
import "./chunk-3RRMLFFN.js";
import "./chunk-DR5TVNEL.js";
import "./chunk-K64AAM77.js";
import "./chunk-6EUVKE22.js";
import "./chunk-A3NNJ7XA.js";
import "./chunk-OKJHJ3CY.js";
import "./chunk-XTVPEVHA.js";
import "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import {
  o
} from "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import "./chunk-DZALMCYL.js";
import "./chunk-K226GFDN.js";
import "./chunk-4ZZRP4MA.js";
import "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-XWXBNAOW.js";
import "./chunk-GWC3DAGP.js";
import "./chunk-EODIWR2E.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-FYAEQPUY.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-7RMVJCDW.js";
import {
  j
} from "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import "./chunk-NYQ5CYNR.js";
import "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import "./chunk-AXVPJBVW.js";
import "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import {
  P,
  d as d2,
  v
} from "./chunk-6WHTZNUH.js";
import "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import {
  d
} from "./chunk-XNUH25NY.js";
import "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e
} from "./chunk-4Z5SGKRM.js";
import {
  S as S2
} from "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3 as a
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import {
  g,
  h,
  s
} from "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import "./chunk-WYIDUUN2.js";
import {
  S
} from "./chunk-DXLOWWK7.js";
import {
  __async
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/views/interactive/snapping/featureSources/GraphicsSnappingSource.js
var z = "graphics-collections";
var O = class extends S2 {
  get updating() {
    return this._updatingHandles.updating;
  }
  get _hasZ() {
    const e3 = this.view;
    return null != e3 && "3d" === e3.type && "map-notes" !== this.layerSource.layer.type;
  }
  get _snappingElevationAligner() {
    const {
      view: e3
    } = this, {
      layer: t2
    } = this.layerSource, o3 = null != e3 && "3d" === e3.type;
    if (!o3 || "map-notes" === t2.type) return i();
    const s2 = (o4, s3) => __async(this, null, function* () {
      return (yield h(e3.whenLayerView(t2), s3)).elevationAlignPointsInFeatures(o4, s3);
    });
    return i(o3, {
      elevationInfo: t2.elevationInfo,
      alignPointsInFeatures: s2
    });
  }
  get _snappingElevationFilter() {
    const {
      view: e3
    } = this, t2 = null != e3 && "3d" === e3.type && "map-notes" !== this.layerSource.layer.type;
    return r(t2);
  }
  get _symbologySnappingFetcher() {
    const {
      view: e3
    } = this, {
      layer: t2
    } = this.layerSource, o3 = null != e3 && "3d" === e3.type, s2 = this._extrudedPolygonSymbolsCount > 0;
    return o3 && "map-notes" !== t2.type && s2 ? n(s2, (o4, s3) => __async(this, null, function* () {
      const r2 = yield e3.whenLayerView(t2);
      return s(s3), r2.queryForSymbologySnapping({
        candidates: o4,
        spatialReference: e3.spatialReference
      }, s3);
    })) : n();
  }
  constructor(e3) {
    super(e3), this.availability = 1, this._sources = {
      multipoint: null,
      point: null,
      polygon: null,
      polyline: null
    }, this._loadedWkids = /* @__PURE__ */ new Set(), this._loadedWkts = /* @__PURE__ */ new Set(), this._pendingAdds = [], this._extrudedPolygonSymbolsCount = 0, this._updatingHandles = new h2(), this._memoizedMakeGetGroundElevation = t(i2);
  }
  destroy() {
    for (const e3 of this._pendingAdds) e3.task.abort();
    this._pendingAdds.length = 0, this._mapSources((e3) => this._destroySource(e3)), this._updatingHandles.destroy();
  }
  initialize() {
    this._updatingHandles.add(() => this.getGraphicsLayers(), (e4) => {
      this._updatingHandles.removeHandles(z);
      for (const t3 of e4) this._addMany(t3.graphics.toArray()), this.addHandles([t3.on("graphic-update", (e5) => this._onGraphicUpdate(e5)), this._updatingHandles.addOnCollectionChange(() => t3.graphics, (e5) => this._onGraphicsChanged(e5))], z);
    }, P);
    const {
      view: e3
    } = this, {
      layer: t2
    } = this.layerSource;
    null != e3 && "3d" === e3.type && "map-notes" !== t2.type && e3.elevationProvider && this.addHandles([e3.elevationProvider.on("elevation-change", ({
      context: e4
    }) => {
      y2(e4, t2.elevationInfo) && this._snappingElevationAligner.notifyElevationSourceChange();
    }), d2(() => t2.elevationInfo, () => this._snappingElevationAligner.notifyElevationSourceChange(), P), v(() => t2, ["edits", "apply-edits", "graphic-update"], () => this._symbologySnappingFetcher.notifySymbologyChange())]);
  }
  fetchCandidates(e3, t2) {
    return __async(this, null, function* () {
      const {
        point: o3,
        coordinateHelper: {
          spatialReference: s2
        }
      } = e3, r2 = yield g(this._mapSources((o4) => this._fetchCandidatesForSource(o4, e3, t2)));
      s(t2);
      const a3 = this._memoizedMakeGetGroundElevation(this.view, s2), p = r2.flat().map((e4) => o2(e4, a3));
      return f(o3, p), p;
    });
  }
  _fetchCandidatesForSource(e3, t2, o3) {
    return __async(this, null, function* () {
      const s2 = y3(t2, this.view?.type ?? "2d"), r2 = yield e3.queryEngine.executeQueryForSnapping(s2, o3);
      s(o3);
      const n2 = yield this._snappingElevationAligner.alignCandidates(r2.candidates, t2.coordinateHelper.spatialReference, o3);
      s(o3);
      const a3 = yield this._symbologySnappingFetcher.fetch(n2, o3);
      s(o3);
      const p = 0 === a3.length ? n2 : [...n2, ...a3];
      return this._snappingElevationFilter.filter(s2, p);
    });
  }
  refresh() {
  }
  _onGraphicUpdate(e3) {
    if (this.getGraphicsLayers().some((t2) => t2.graphics.includes(e3.graphic))) switch (e3.property) {
      case "geometry":
      case "visible":
        this._remove(e3.graphic), this._addMany([e3.graphic]);
    }
  }
  _onGraphicsChanged(e3) {
    for (const t2 of e3.removed) this._remove(t2);
    this._addMany(e3.added);
  }
  _addMany(e3) {
    const t2 = [], o3 = /* @__PURE__ */ new Map();
    for (const s2 of e3) null != s2.geometry && (this._needsInitializeProjection(s2.geometry.spatialReference) ? (t2.push(s2.geometry.spatialReference), o3.set(s2.uid, s2)) : this._add(s2));
    this._createPendingAdd(t2, o3);
  }
  _createPendingAdd(e3, t2) {
    if (!e3.length) return;
    const r2 = d((o3) => __async(this, null, function* () {
      yield N(e3.map((e4) => ({
        source: e4,
        dest: this.spatialReference
      })), {
        signal: o3
      }), this._markLoadedSpatialReferences(e3);
      for (const [, e4] of t2) this._add(e4);
    }));
    this._updatingHandles.addPromise(r2.promise);
    const i3 = {
      task: r2,
      graphics: t2
    }, n2 = () => S(this._pendingAdds, i3);
    r2.promise.then(n2, n2), this._pendingAdds.push(i3);
  }
  _markLoadedSpatialReferences(e3) {
    for (const t2 of e3) {
      null != t2.wkid && this._loadedWkids.add(t2.wkid);
      const e4 = t2.wkt2 || t2.wkt;
      e4 && this._loadedWkts.add(e4);
    }
  }
  _add(e3) {
    if (null == e3.geometry || !e3.visible) return;
    let t2 = e3.geometry;
    if ("mesh" === t2.type) return;
    "extent" === t2.type && (t2 = j.fromExtent(t2));
    const o3 = this._ensureSource(t2.type);
    if (null == o3) return;
    const s2 = this._createOptimizedFeature(e3.uid, t2);
    null != s2 && (o3.featureStore.add(s2), J2(e3.symbol) && this._extrudedPolygonSymbolsCount++);
  }
  _needsInitializeProjection(e3) {
    if (null != e3.wkid && this._loadedWkids.has(e3.wkid)) return false;
    const t2 = e3.wkt2 || e3.wkt;
    return (!t2 || !this._loadedWkts.has(t2)) && !J(e3, this.spatialReference);
  }
  _createOptimizedFeature(e3, t2) {
    const o3 = K(a2(t2), this.spatialReference);
    if (!o3) return null;
    const s2 = this._ensureGeometryHasZ(o3), r2 = ot(s2, this._hasZ, false);
    return new e2(r2, {
      [U]: e3
    }, null, e3);
  }
  _ensureGeometryHasZ(e3) {
    if (!this._hasZ) return e3;
    const t2 = (e4) => {
      for (; e4.length < 3; ) e4.push(0);
    }, o3 = e3.clone();
    switch (o3.hasZ = true, o3.type) {
      case "point":
        o3.z = o3.z ?? 0;
        break;
      case "multipoint":
        o3.points.forEach(t2);
        break;
      case "polyline":
        o3.paths.forEach((e4) => e4.forEach(t2));
        break;
      case "polygon":
        o3.rings.forEach((e4) => e4.forEach(t2));
    }
    return o3;
  }
  _ensureSource(e3) {
    const t2 = this._sources[e3];
    if (null != t2) return t2;
    const o3 = this._createSource(e3);
    return this._sources[e3] = o3, o3;
  }
  _createSource(e3) {
    const t2 = o.toJSON(e3), o3 = this._hasZ, s2 = new m({
      geometryType: t2,
      hasZ: o3,
      hasM: false
    });
    return {
      featureStore: s2,
      queryEngine: new $({
        featureStore: s2,
        fieldsIndex: Z.fromLayerJSON({
          fields: [{
            name: U,
            type: "esriFieldTypeOID",
            alias: U
          }]
        }),
        geometryType: t2,
        hasM: false,
        hasZ: o3,
        objectIdField: U,
        spatialReference: this.spatialReference,
        priority: I.SNAPPING,
        scheduler: null != this.view && "3d" === this.view.type ? this.view.resourceController.scheduler : null
      }),
      type: e3
    };
  }
  _remove(e3) {
    this._mapSources((t2) => this._removeFromSource(t2, e3));
    for (const t2 of this._pendingAdds) t2.graphics.delete(e3.uid), 0 === t2.graphics.size && t2.task.abort();
  }
  _removeFromSource(e3, t2) {
    const o3 = t2.uid;
    e3.featureStore.has(o3) && (e3.featureStore.removeById(t2.uid), J2(t2.symbol) && this._extrudedPolygonSymbolsCount--);
  }
  _destroySource(e3) {
    e3.queryEngine.destroy(), this._sources[e3.type] = null;
  }
  _mapSources(e3) {
    const {
      point: t2,
      polygon: o3,
      polyline: s2,
      multipoint: r2
    } = this._sources, i3 = [];
    return null != t2 && i3.push(e3(t2)), null != o3 && i3.push(e3(o3)), null != s2 && i3.push(e3(s2)), null != r2 && i3.push(e3(r2)), i3;
  }
};
e([y()], O.prototype, "getGraphicsLayers", void 0), e([y({
  constructOnly: true
})], O.prototype, "layerSource", void 0), e([y({
  constructOnly: true
})], O.prototype, "spatialReference", void 0), e([y({
  constructOnly: true
})], O.prototype, "view", void 0), e([y({
  readOnly: true
})], O.prototype, "updating", null), e([y({
  readOnly: true
})], O.prototype, "availability", void 0), e([y()], O.prototype, "_hasZ", null), e([y()], O.prototype, "_snappingElevationAligner", null), e([y()], O.prototype, "_snappingElevationFilter", null), e([y()], O.prototype, "_symbologySnappingFetcher", null), e([y()], O.prototype, "_extrudedPolygonSymbolsCount", void 0), O = e([a("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")], O);
var U = "OBJECTID";
export {
  O as GraphicsSnappingSource
};
//# sourceMappingURL=GraphicsSnappingSource-TD64DICF.js.map
