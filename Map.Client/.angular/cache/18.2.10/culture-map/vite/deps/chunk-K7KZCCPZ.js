import {
  i as i6,
  x as x2
} from "./chunk-5A6MLLPH.js";
import {
  m as m7,
  r as r8
} from "./chunk-IIXY5BBS.js";
import {
  e as e12,
  p as p3,
  s as s5,
  s2 as s6,
  u as u8,
  u2 as u9,
  ze
} from "./chunk-SB6NP2J2.js";
import {
  i as i5,
  l3 as l5,
  r2 as r7
} from "./chunk-PPMYY5TL.js";
import {
  G as G2,
  te
} from "./chunk-NEPAFG4J.js";
import {
  P as P2
} from "./chunk-4KGPH7OX.js";
import {
  c as c6
} from "./chunk-TLAW3ACJ.js";
import {
  a as a6
} from "./chunk-RDOYE3NP.js";
import {
  s as s7
} from "./chunk-DXJZ22ZH.js";
import {
  l as l4
} from "./chunk-LVYRNWV6.js";
import {
  E as E5,
  I as I4,
  m as m6
} from "./chunk-GW7WMRYJ.js";
import {
  e as e11
} from "./chunk-Z52R7W33.js";
import {
  C as C2
} from "./chunk-67LE7VNQ.js";
import {
  f as f2
} from "./chunk-NLEBYD5G.js";
import {
  t as t10
} from "./chunk-NSSWLGUQ.js";
import {
  i as i4
} from "./chunk-EOYCWFZW.js";
import {
  a as a5
} from "./chunk-IJVQCMOT.js";
import {
  n as n9
} from "./chunk-KM65NCZ2.js";
import {
  t as t9,
  u as u7
} from "./chunk-D3AKDIJC.js";
import {
  i as i2
} from "./chunk-WVEBK4ZV.js";
import {
  o as o7
} from "./chunk-5NCKEQLF.js";
import {
  o as o6
} from "./chunk-ATQ5GYTB.js";
import {
  J as J2
} from "./chunk-ZUHJZKEM.js";
import {
  I as I3
} from "./chunk-WG5JLPNN.js";
import {
  E as E4
} from "./chunk-RASN5P76.js";
import {
  b as b4,
  d as d8
} from "./chunk-5L3YXBNN.js";
import {
  A as A2
} from "./chunk-IFUKJDOU.js";
import {
  t as t8
} from "./chunk-J7KF6IEI.js";
import {
  r as r4,
  r2 as r5,
  t as t6
} from "./chunk-XGDLE7WK.js";
import {
  t as t5
} from "./chunk-GDEAPZ64.js";
import {
  r as r6
} from "./chunk-FHW2TG7X.js";
import {
  c2 as c5,
  u2 as u6
} from "./chunk-YAGNWBGU.js";
import {
  t as t7
} from "./chunk-DE6MQ5XE.js";
import {
  e as e10
} from "./chunk-LQTSBE7P.js";
import {
  O as O4
} from "./chunk-GCFUJXGH.js";
import {
  S as S2,
  _ as _3,
  s as s4
} from "./chunk-LKHUGH5W.js";
import {
  t as t4
} from "./chunk-ZVFENZUF.js";
import {
  M,
  N,
  Z as Z2,
  k
} from "./chunk-Z6Z2SY6R.js";
import {
  h as h4
} from "./chunk-YZBHNRVB.js";
import {
  E as E3
} from "./chunk-EXODD7PD.js";
import {
  c as c4,
  e2 as e9
} from "./chunk-P7OSFLIX.js";
import {
  i as i3
} from "./chunk-ZDC4PV4Y.js";
import {
  s as s3
} from "./chunk-O7ZVERIH.js";
import {
  H
} from "./chunk-NWICVENM.js";
import {
  l as l3
} from "./chunk-WU7FVYT7.js";
import {
  D,
  E as E2,
  G,
  R,
  T,
  U as U2,
  _ as _2
} from "./chunk-YLE5AYZV.js";
import {
  b as b3,
  o as o5
} from "./chunk-VS26W5Y5.js";
import {
  h as h3
} from "./chunk-PVO5NM6Q.js";
import {
  m as m5
} from "./chunk-ROATEOHC.js";
import {
  $
} from "./chunk-4MXR7W7N.js";
import {
  F as F2,
  I as I2,
  o as o4
} from "./chunk-YFQ32AQX.js";
import {
  r as r3
} from "./chunk-DM4WHMQY.js";
import {
  O as O2
} from "./chunk-C7NRYPDG.js";
import {
  e as e6
} from "./chunk-O437BSYE.js";
import {
  e as e5
} from "./chunk-YZNT6QWD.js";
import {
  d as d7
} from "./chunk-XQCKIDQO.js";
import {
  e as e7
} from "./chunk-AQJS6F3O.js";
import {
  d as d6
} from "./chunk-UFVMJL32.js";
import {
  o as o3
} from "./chunk-WJKYGQOY.js";
import {
  n as n8
} from "./chunk-SZWWBMQN.js";
import {
  d as d5
} from "./chunk-QCBC3RJX.js";
import {
  t as t3
} from "./chunk-RDQF44TE.js";
import {
  l as l2
} from "./chunk-KKD7A2GN.js";
import {
  e as e8
} from "./chunk-4MMTPKY4.js";
import {
  n as n7
} from "./chunk-DY7FJHTG.js";
import {
  c as c3
} from "./chunk-Q4KYZS3X.js";
import {
  a as a4,
  b as b2,
  m as m4
} from "./chunk-TRSGUVSM.js";
import {
  Z
} from "./chunk-Q7SRMLJZ.js";
import {
  d as d4
} from "./chunk-HD65DNIO.js";
import {
  n as n6
} from "./chunk-N6TJI25E.js";
import {
  d3,
  h,
  h3 as h2,
  m as m3,
  p2,
  w as w3,
  z
} from "./chunk-634JLXD4.js";
import {
  f
} from "./chunk-JOJZ6YC5.js";
import {
  g as g2
} from "./chunk-CRNUMTSV.js";
import {
  O as O3
} from "./chunk-JM7HAEY6.js";
import {
  pe
} from "./chunk-DTUSTSEJ.js";
import {
  o as o2
} from "./chunk-OEKKQXBD.js";
import {
  u as u5
} from "./chunk-K226GFDN.js";
import {
  u as u4
} from "./chunk-7ZJ6P7J7.js";
import {
  m,
  n as n4
} from "./chunk-EDSMXTFO.js";
import {
  j
} from "./chunk-T6GCUITX.js";
import {
  E,
  I,
  J,
  U,
  c as c2,
  e as e4,
  i,
  m as m2,
  o,
  u as u3
} from "./chunk-IHVSZYZS.js";
import {
  w as w2
} from "./chunk-NYQ5CYNR.js";
import {
  g,
  x
} from "./chunk-O7UDKFOW.js";
import {
  n as n5
} from "./chunk-OXEPWRM7.js";
import {
  A,
  C,
  P,
  d as d2,
  p,
  v as v2,
  w
} from "./chunk-6WHTZNUH.js";
import {
  V
} from "./chunk-EITGQLII.js";
import {
  _,
  d
} from "./chunk-XNUH25NY.js";
import {
  e as e3
} from "./chunk-4Z5SGKRM.js";
import {
  S,
  v
} from "./chunk-ANKOCGE2.js";
import {
  y as y2
} from "./chunk-7CJXZOFG.js";
import {
  a3,
  n as n3,
  r2
} from "./chunk-DDYVXG4F.js";
import {
  a as a2,
  b,
  s as s2,
  u as u2,
  y
} from "./chunk-HJY2YILU.js";
import {
  e as e2
} from "./chunk-7DA6A5LD.js";
import {
  e,
  l,
  r,
  t as t2,
  u
} from "./chunk-2MMLMOWS.js";
import {
  a,
  n2,
  s2 as s
} from "./chunk-WYIDUUN2.js";
import {
  F,
  O,
  c2 as c,
  has,
  n,
  t3 as t
} from "./chunk-DXLOWWK7.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/views/3d/layers/FeatureLikeLayerView3D.js
var u10 = (u11) => {
  let h7 = class extends u11 {
    constructor() {
      super(...arguments), this.updatePolicy = C2.SYNC, this.slicePlaneEnabled = false, this.fullExtentInLocalViewSpatialReference = null, this.supportsHeightUnitConversion = true;
    }
    initialize() {
      const e13 = this.layer;
      "isTable" in e13 && e13.isTable ? this.addResolvingPromise(Promise.reject(new s("featurelayerview:table-not-supported", "table feature layer can't be displayed", {
        layer: e13
      }))) : (this.addResolvingPromise(this._validateGeometryType()), this.addResolvingPromise((() => __async(this, null, function* () {
        const e14 = yield l4(this);
        this.fullExtentInLocalViewSpatialReference = e14;
        const t12 = this.createGraphicsPipeline();
        this.graphicsPipeline = t12, yield t12.when();
      }))()), this.notifyChange("updating"));
    }
    destroy() {
      this.graphicsPipeline = u(this.graphicsPipeline);
    }
    get dataUpdating() {
      return !!this.graphicsPipeline?.dataUpdating;
    }
    get legendEnabled() {
      return this.canResume() && this.graphicsPipeline?.legendEnabled;
    }
    get visibleAtCurrentScale() {
      return !this.graphicsPipeline?.scaleVisibilitySuspended;
    }
    get symbologySnappingSupported() {
      return this.graphicsPipeline.symbologySnappingSupported;
    }
    get hasAllFeatures() {
      return this.graphicsPipeline.hasAllFeatures;
    }
    get hasAllFeaturesInView() {
      return this.graphicsPipeline.hasAllFeaturesInView;
    }
    get hasFullGeometries() {
      return this.graphicsPipeline.hasFullGeometries;
    }
    get timeExtent() {
      return i4(this.layer, this.view?.timeExtent, this._get("timeExtent"));
    }
    get queryEngine() {
      return this.graphicsPipeline.queryEngine;
    }
    getHit(e13) {
      const t12 = this.graphicsPipeline.findGraphic((t13) => t13.uid === e13);
      if (null == t12) return null;
      const r10 = c6(t12, this.layer);
      return {
        type: "graphic",
        graphic: r10,
        layer: r10.layer
      };
    }
    whenGraphicBounds(e13, t12) {
      return this.graphicsPipeline?.whenGraphicBounds(e13, t12);
    }
    computeAttachmentOrigin(e13, t12) {
      return this.graphicsPipeline?.computeAttachmentOrigin(e13, t12);
    }
    elevationAlignPointsInFeatures(e13, t12) {
      return __async(this, null, function* () {
        return this.graphicsPipeline.elevationAlignPointsInFeatures(e13, t12);
      });
    }
    queryForSymbologySnapping(e13, t12) {
      return __async(this, null, function* () {
        return this.graphicsPipeline.queryForSymbologySnapping(e13, t12);
      });
    }
    queryFeatures(e13, t12) {
      return this.queryEngine.executeQuery(this._ensureQuery(e13), t12?.signal);
    }
    queryObjectIds(e13, t12) {
      return this.queryEngine.executeQueryForIds(this._ensureQuery(e13), t12?.signal);
    }
    queryFeatureCount(e13, t12) {
      return this.queryEngine.executeQueryForCount(this._ensureQuery(e13), t12?.signal);
    }
    queryExtent(e13, t12) {
      return this.queryEngine.executeQueryForExtent(this._ensureQuery(e13), t12?.signal);
    }
    _ensureQuery(e13) {
      return null == e13 ? this.createQuery() : b2.from(e13);
    }
    highlight(e13) {
      return this.graphicsPipeline.highlight(e13);
    }
    maskOccludee(e13) {
      return this.graphicsPipeline.maskOccludee(e13);
    }
    getSuspendInfo() {
      return __spreadValues(__spreadValues({}, super.getSuspendInfo()), this.graphicsPipeline.suspendInfo);
    }
    isUpdating() {
      return !(!this.graphicsPipeline || this.graphicsPipeline.destroyed) && !(!this.graphicsPipeline?.updating && this.view?.basemapTerrain?.ready);
    }
    _validateGeometryType() {
      return __async(this, null, function* () {
        switch (this.layer.geometryType) {
          case "multipatch":
          case "multipoint":
            throw new s("featurelayerview3d:unsupported-geometry-type", "Unsupported geometry type ${geometryType}", {
              geometryType: this.layer.geometryType
            });
        }
      });
    }
    get performanceInfo() {
      return this.graphicsPipeline.performanceInfo;
    }
  };
  return e3([y2()], h7.prototype, "graphicsPipeline", void 0), e3([y2({
    readOnly: true
  })], h7.prototype, "dataUpdating", null), e3([y2()], h7.prototype, "suspended", void 0), e3([y2({
    readOnly: true
  })], h7.prototype, "legendEnabled", null), e3([y2({
    readOnly: true
  })], h7.prototype, "visibleAtCurrentScale", null), e3([y2()], h7.prototype, "updating", void 0), e3([y2({
    readOnly: true
  })], h7.prototype, "updatePolicy", void 0), e3([y2({
    type: Boolean
  })], h7.prototype, "slicePlaneEnabled", void 0), e3([y2({
    readOnly: true
  })], h7.prototype, "suspendInfo", void 0), e3([y2()], h7.prototype, "symbologySnappingSupported", null), e3([y2({
    readOnly: true
  })], h7.prototype, "hasAllFeatures", null), e3([y2({
    readOnly: true
  })], h7.prototype, "hasAllFeaturesInView", null), e3([y2({
    readOnly: true
  })], h7.prototype, "hasFullGeometries", null), e3([y2({
    readOnly: true
  })], h7.prototype, "timeExtent", null), h7 = e3([a3("esri.views.3d.layers.FeatureLikeLayerView3D")], h7), h7;
};

// ../../../node_modules/@arcgis/core/views/3d/layers/graphics/QueryEngine.js
var c7 = $;
var l6 = class extends S {
  get layer() {
    return this.context.layer;
  }
  get spatialReference() {
    return this.context.spatialReference;
  }
  get _queryGeometryType() {
    switch (this.layer.geometryType) {
      case "multipoint":
      case "point":
      case "polygon":
      case "polyline":
        return this.layer.geometryType;
      case "mesh":
        return "polygon";
      default:
        return;
    }
  }
  get defaultQueryJSON() {
    return new b2({
      outSpatialReference: this.spatialReference
    }).toJSON();
  }
  get _dataQueryEngine() {
    return this._ensureDataQueryEngine();
  }
  constructor(e13) {
    super(e13), this._dataQueryEngineInstance = null;
  }
  destroy() {
    this.clear();
  }
  clear() {
    return !!this._dataQueryEngineInstance && (this._dataQueryEngineInstance.destroy(), this._dataQueryEngineInstance = null, true);
  }
  executeQueryForIdSet(e13, t12, r10) {
    return __async(this, null, function* () {
      return this._dataQueryEngine.executeQueryForIdSet(this._ensureQueryJSON(e13, t12), r10);
    });
  }
  executeQueryForCount(e13, t12) {
    return __async(this, null, function* () {
      return this._dataQueryEngine.executeQueryForCount(this._ensureQueryJSON(e13), t12);
    });
  }
  executeQueryForExtent(e13, t12) {
    return __async(this, null, function* () {
      const {
        count: r10,
        extent: s9
      } = yield this._dataQueryEngine.executeQueryForExtent(this._ensureQueryJSON(e13), t12);
      return {
        count: r10,
        extent: w2.fromJSON(s9)
      };
    });
  }
  executeQueryForIds(e13, t12) {
    return __async(this, null, function* () {
      return this._dataQueryEngine.executeQueryForIds(this._ensureQueryJSON(e13), t12);
    });
  }
  executeQueryForLatestObservations(e13, t12) {
    return __async(this, null, function* () {
      const r10 = yield this._dataQueryEngine.executeQueryForLatestObservations(this._ensureQueryJSON(e13), t12), s9 = d6.fromJSON(r10);
      return s9.features.forEach((e14) => {
        e14.layer = this.layer, e14.sourceLayer = this.layer;
      }), s9;
    });
  }
  executeQuery(e13, t12) {
    return __async(this, null, function* () {
      const r10 = yield this._dataQueryEngine.executeQuery(this._ensureQueryJSON(e13), t12), s9 = d6.fromJSON(r10);
      return s9.features.forEach((e14) => {
        e14.layer = this.layer, e14.sourceLayer = this.layer;
      }), s9;
    });
  }
  _ensureQueryJSON(e13, t12) {
    let r10 = this.defaultQueryJSON;
    if (null != e13 && ("outSpatialReference" in e13 && !e13.outSpatialReference && (e13.outSpatialReference = this.spatialReference), r10 = e13.toJSON()), null != t12) {
      const e14 = t12.geometries.map((e15) => e15.toJSON()).reduce((e15, t13) => (e15.rings = e15.rings.concat(t13.rings), e15));
      r10 = __spreadProps(__spreadValues({}, r10), {
        sceneFilter: __spreadProps(__spreadValues({}, t12), {
          geometry: e14
        })
      });
    }
    return r10;
  }
  _ensureDataQueryEngine() {
    if (this._dataQueryEngineInstance) return this._dataQueryEngineInstance;
    const e13 = "timeInfo" in this.layer && this.layer.timeInfo?.toJSON() || null, t12 = this.layer.objectIdField, r10 = o2.toJSON(this._queryGeometryType), s9 = this.layer.fieldsIndex?.toJSON() || new Z([]), n11 = this.priority, o9 = this.spatialReference.toJSON(), {
      hasZ: u11,
      hasM: i8,
      featureStore: l7,
      scheduler: p5
    } = this.context;
    return this._dataQueryEngineInstance = new c7({
      hasZ: u11,
      hasM: i8,
      geometryType: r10,
      fieldsIndex: s9,
      timeInfo: e13,
      spatialReference: o9,
      objectIdField: t12,
      featureStore: l7,
      scheduler: p5,
      priority: n11
    }), this._dataQueryEngineInstance;
  }
};
e3([y2({
  constructOnly: true
})], l6.prototype, "context", void 0), e3([y2({
  constructOnly: true
})], l6.prototype, "priority", void 0), e3([y2()], l6.prototype, "layer", null), e3([y2()], l6.prototype, "spatialReference", null), e3([y2()], l6.prototype, "_queryGeometryType", null), e3([y2()], l6.prototype, "defaultQueryJSON", null), l6 = e3([a3("esri.views.3d.layers.graphics.QueryEngine")], l6);

// ../../../node_modules/@arcgis/core/views/3d/layers/support/attributeUtils.js
function n10(n11, t12, e13) {
  if (!e13 || null == t12) return null;
  if (!n11) return r9(t12, e13);
  const o9 = n11.get(e13);
  return o9 ? t12[o9.name] : null;
}
function r9(n11, r10) {
  const t12 = r10.toLowerCase();
  for (const e13 in n11) if (e13.toLowerCase() === t12) return n11[e13];
  return null;
}

// ../../../node_modules/@arcgis/core/views/3d/layers/support/FeatureVisibilityFilter.js
var y3 = class extends S {
  constructor(t12) {
    super(t12), this._updateTask = null, this._frameTask = null, this._queryEngine = null, this._updateRequested = true, this._updatingHandles = new h3(), this._updateVisibility = (t13) => __async(this, null, function* () {
      if (null == this._compositedFeatureFilter && null == this._sceneFilter || 0 === this.context.getFeatureCount()) return yield this._frameTask.schedule(() => this.clear(), t13);
      try {
        const e13 = yield this._queryEngine.executeQueryForIdSet(this._compositedFeatureFilter, this._sceneFilter, t13);
        return s2(t13), yield this._frameTask.schedule(() => {
          this.context.updateFeatureVisibilities((t14) => e13.has(t14));
        }, t13);
      } catch (e13) {
        return a2(e13), n2.getLogger(this).warn(`FeatureFilter query failed: ${e13}`, {
          error: e13
        }), yield this._frameTask.schedule(() => {
          this.context.setAllFeaturesVisibility(true);
        }, t13);
      }
    });
  }
  initialize() {
    const t12 = I2.FILTER_VISIBILITY, {
      layer: e13,
      view: r10
    } = this._configuration, {
      featureStore: i8
    } = this.context, s9 = this._configuration.hasZ ?? false, o9 = this._configuration.hasM ?? false;
    this._queryEngine = new l6({
      context: {
        spatialReference: r10.spatialReference,
        layer: e13,
        scheduler: r10.resourceController.scheduler,
        featureStore: i8,
        hasM: o9,
        hasZ: s9
      },
      priority: t12
    }), this._frameTask = r10.resourceController.scheduler.registerTask(t12, this), this._updatingHandles.add(() => [this._compositedFeatureFilter, this._sceneFilter], () => this.reapply(), P);
  }
  destroy() {
    this._updateRequested = false, this._updatingHandles.destroy(), this.clear(), this._updateTask = e(this._updateTask), this._frameTask = l(this._frameTask), this._queryEngine = u(this._queryEngine), this._set("context", null);
  }
  get updating() {
    return this.running || this._updatingHandles.updating || null != this._updateTask && !this._updateTask.finished;
  }
  get running() {
    return this._updateRequested || this._frameTask.updating;
  }
  get defaultVisibility() {
    return null == this._compositedFeatureFilter && null == this._sceneFilter;
  }
  get _featureFilter() {
    return "filter" in this._configuration ? this._configuration.filter : null;
  }
  get _sceneFilter() {
    return "layerFilter" in this._configuration ? this._configuration.layerFilter : null;
  }
  get _floorFilter() {
    return o7(this._configuration);
  }
  get _timeExtent() {
    return "timeExtent" in this._configuration ? this._configuration.timeExtent : null;
  }
  get _compositedFeatureFilter() {
    const {
      _featureFilter: t12,
      _timeExtent: e13,
      _floorFilter: r10
    } = this;
    if (null == e13 && null == r10) return t12;
    const i8 = null != t12 ? t12.clone() : new d7();
    if (null != e13 && (i8.timeExtent = null != i8.timeExtent ? i8.timeExtent.intersection(e13) : e13), null != r10) {
      const t13 = null == i8.where || "" === i8.where;
      i8.where = t13 ? r10 : `(${i8.where}) AND (${r10})`;
    }
    return i8;
  }
  get _configuration() {
    return this.context.configuration;
  }
  reapply() {
    this._updateRequested = true;
  }
  clear() {
    this._queryEngine.clear(), this.context.clearFeaturesVisibility();
  }
  runTask(t12) {
    if (this._updateRequested && (this._updateTask = e(this._updateTask), this._updateTask = d(this._updateVisibility), this._updateRequested = false, t12.madeProgress()), this._frameTask.processQueue(t12), !t12.hasProgressed) return o4;
  }
};
e3([y2({
  constructOnly: true
})], y3.prototype, "context", void 0), e3([y2()], y3.prototype, "updating", null), e3([y2()], y3.prototype, "running", null), e3([y2()], y3.prototype, "defaultVisibility", null), e3([y2()], y3.prototype, "_featureFilter", null), e3([y2()], y3.prototype, "_sceneFilter", null), e3([y2()], y3.prototype, "_floorFilter", null), e3([y2()], y3.prototype, "_timeExtent", null), e3([y2()], y3.prototype, "_compositedFeatureFilter", null), e3([y2()], y3.prototype, "_configuration", null), e3([y2()], y3.prototype, "_updateTask", void 0), e3([y2()], y3.prototype, "_updateRequested", void 0), y3 = e3([a3("esri.views.3d.layers.support.FeatureVisibilityFilter")], y3);

// ../../../node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DFeatureProcessor.js
var P3 = class extends S {
  constructor(e13) {
    super(e13), this.type = "graphics-3d", this._randomRotationRenderers = null, this._updatingHandles = new h3(), this.elevationFeatureExpressionEnabled = false, this.scaleVisibilityEnabled = false, this.filterVisibilityEnabled = false, this.frustumVisibilityEnabled = false, this.elevationAlignmentEnabled = false, this.timeExtentEnabled = false, this.setUidToIdOnAdd = true, this.dataExtent = null, this.drapeSourceType = e11.Features, this.preferredUpdatePolicy = C2.ASYNC, this._suspendResumeExtent = null;
  }
  initialize() {
    const e13 = this.owner, t12 = (this.filterVisibilityEnabled || this.timeExtentEnabled) && "multipatch" !== e13.layer.geometryType, i8 = new ze({
      owner: this,
      layer: this.layer,
      preferredUpdatePolicy: this.preferredUpdatePolicy,
      elevationFeatureExpressionEnabled: this.elevationFeatureExpressionEnabled,
      graphicSymbolSupported: false,
      hasZ: e13.hasZ,
      hasM: e13.hasM,
      setUidToIdOnAdd: this.setUidToIdOnAdd,
      componentFactories: {
        deconflictor: (t13) => e13.view.deconflictor.addGraphicsOwner(t13),
        labeler: (t13, i9) => e13.view.labeler.addGraphicsOwner(t13, i9),
        elevationAlignment: this.elevationAlignmentEnabled ? (t13, i9) => new p3({
          graphicsCoreOwner: this,
          graphicsCore: t13,
          queryGraphicUIDsInExtent: i9,
          elevationProvider: e13.view.elevationProvider
        }) : null,
        scaleVisibility: this.scaleVisibilityEnabled ? (t13, i9) => new u8({
          graphicsCoreOwner: this,
          layer: this.layer,
          queryGraphicUIDsInExtent: i9,
          graphicsCore: t13,
          basemapTerrain: e13.view.basemapTerrain
        }) : null,
        filterVisibility: t12 ? (t13) => new y3({
          context: __spreadProps(__spreadValues({}, t13), {
            configuration: e13
          })
        }) : null,
        objectStates: (e14) => new s6(e14)
      }
    });
    this._set("graphicsCore", i8), this.frustumVisibilityEnabled && this._set("frustumVisibility", new u9({
      graphicsCoreOwner: this
    })), this.elevationAlignment && this._updatingHandles.add(() => this.layer.elevationInfo, (e14, t13) => {
      d5(e14, t13) && this._updatingHandles.addPromise(this.graphicsCore.elevationInfoChange());
    }), this._updatingHandles.add(() => this.layer.labelsVisible, () => this.graphicsCore.updateVisibilityInfo()), this._updatingHandles.add(() => this.layer.labelingInfo, (e14, t13) => {
      d5(e14, t13) && this.graphicsCore.updateLabelingInfo();
    }), this._updatingHandles.add(() => this.preferredUpdatePolicy, (e14) => this.graphicsCore.preferredUpdatePolicy = e14), this._set("initializePromise", this._initializeAsync()), this._updatingHandles.addPromise(this.initializePromise);
  }
  _initializeAsync() {
    return __async(this, null, function* () {
      yield y(this.graphicsCore.initializePromise);
      const e13 = this.owner;
      this._updatingHandles.add(() => this.renderer, (e14) => this._updatingHandles.addPromise(this.graphicsCore.rendererChange(e14))), this._updatingHandles.add(() => e13.fullOpacity, () => this.graphicsCore.opacityChange()), this._setupSuspendResumeExtent(), this.updateClippingExtent && (this._updatingHandles.add(() => e13.view.clippingArea, () => this._updateClippingExtent()), this._updateClippingExtent()), this.graphicsCore.startCreateGraphics(), this.graphicsCore.labelsEnabled && (yield y(this.graphicsCore.updateLabelingInfo()));
    });
  }
  destroy() {
    this._updatingHandles.destroy(), this._set("frustumVisibility", u(this.frustumVisibility)), this._set("graphicsCore", u(this.graphicsCore)), this._set("owner", null);
  }
  get layer() {
    return this.owner.layer;
  }
  get dataUpdating() {
    return this.graphicsCore?.dataUpdating ?? false;
  }
  get renderer() {
    const {
      renderer: e13,
      objectIdField: t12
    } = this.layer;
    if (!e13 || !t12 || "heatmap" === e13.type || !e13.visualVariables) return e13;
    const i8 = e13.visualVariables.findIndex((e14) => "rotation" === e14.type && null != e14.valueExpression && e7(e14.valueExpression) === t12 && (null == e14.axis || "heading" === e14.axis) && "geographic" === e14.rotationType);
    if (i8 < 0) return e13;
    const r10 = e13.clone();
    return r10.visualVariables.splice(i8, 1), this._randomRotationRenderers || (this._randomRotationRenderers = /* @__PURE__ */ new WeakMap()), this._randomRotationRenderers.set(r10, t12), r10;
  }
  get scaleVisibility() {
    return this.graphicsCore?.scaleVisibility;
  }
  get filterVisibility() {
    return this.graphicsCore?.filterVisibility;
  }
  get elevationAlignment() {
    return this.graphicsCore?.elevationAlignment;
  }
  get suspendResumeExtentMode() {
    return this.owner.suspendResumeExtentMode ?? "computed";
  }
  get scaleVisibilitySuspended() {
    return null != this.scaleVisibility && this.scaleVisibility.suspended;
  }
  get suspended() {
    return this.owner.suspended;
  }
  get legendEnabled() {
    return null == this.frustumVisibility || !this.frustumVisibility.suspended;
  }
  get suspendInfo() {
    const e13 = {};
    return this.scaleVisibilitySuspended && (e13.outsideScaleRange = true), null != this.frustumVisibility && this.frustumVisibility.suspended && (e13.outsideOfView = true), e13;
  }
  get updating() {
    return !!(this.graphicsCore?.updating || this.frustumVisibility?.updating || this._updatingHandles.updating);
  }
  get updatingRemaining() {
    return this.graphicsCore?.updatingRemaining ?? 0;
  }
  get featureStore() {
    return this.graphicsCore?.featureStore;
  }
  get view() {
    return this.owner.view;
  }
  get loadedGraphics() {
    return this.owner.loadedGraphics;
  }
  get fullOpacity() {
    return this.owner?.fullOpacity;
  }
  get filter() {
    return "filter" in this.owner ? this.owner.filter : null;
  }
  get slicePlaneEnabled() {
    return this.owner.slicePlaneEnabled;
  }
  get updatePolicy() {
    return this.owner.updatePolicy;
  }
  get featureSpatialReference() {
    return "featureSpatialReference" in this.owner ? this.owner.featureSpatialReference : this.owner.view.spatialReference;
  }
  get graphics3DGraphics() {
    return this.graphicsCore?.graphics3DGraphics;
  }
  get graphics3DGraphicsByObjectID() {
    return this.graphicsCore?.graphics3DGraphicsByObjectID;
  }
  get symbolUpdateType() {
    return this.graphicsCore?.symbolUpdateType;
  }
  get displayFeatureLimit() {
    const e13 = this.view.quality, t12 = this.graphicsCore?.displayFeatureLimit;
    if (1 === e13) return t12;
    const i8 = Math.ceil(t12.maximumNumberOfFeatures * e13);
    return new e12(t12.maximumTotalNumberOfVertices, i8, t12.averageSymbolComplexity);
  }
  get usedMemory() {
    return this.graphicsCore?.usedMemory ?? 0;
  }
  get loadedFeatures() {
    return this.graphicsCore?.numberOfGraphics ?? 0;
  }
  get usedMemoryPerFeature() {
    return this.graphicsCore?.usedMemoryPerGraphic ?? 0;
  }
  get unprocessedMemoryEstimate() {
    return this.graphicsCore?.unprocessedMemoryEstimate ?? 0;
  }
  get performanceInfo() {
    return this.graphicsCore.performanceInfo;
  }
  maskOccludee(e13) {
    const t12 = this.graphicsCore?.objectStates;
    if (!t12) return e2();
    const {
      set: i8,
      handle: r10
    } = t12.acquireSet(t4.MaskOccludee, null);
    return t12.setUid(i8, e13.uid), r10;
  }
  highlight(e13, i8) {
    const r10 = this.graphicsCore?.objectStates;
    if (!r10) return e2();
    if (e13 instanceof b2) {
      const {
        set: t12,
        handle: s9
      } = r10.acquireSet(t4.Highlight, i8);
      return this.owner.queryObjectIds(e13).then((e14) => r10.setObjectIds(t12, e14)), s9;
    }
    if ("number" == typeof e13 || "string" == typeof e13) return this.highlight([e13], i8);
    if (e13 instanceof d4) return this.highlight([e13], i8);
    if ("toArray" in e13 && (e13 = e13.toArray()), Array.isArray(e13) && e13.length > 0) {
      if (e13[0] instanceof d4) {
        const t12 = e13;
        if (null == n10(this.layer.fieldsIndex, t12[0].attributes, i8)) {
          const e14 = t12.map((e15) => e15.uid), {
            set: i9,
            handle: s9
          } = r10.acquireSet(t4.Highlight, null);
          return r10.setUids(i9, e14), s9;
        }
        e13 = t12.map((e14) => n10(this.layer.fieldsIndex, e14.attributes, i8));
      }
      if (Array.isArray(e13) && ("number" == typeof e13[0] || "string" == typeof e13[0])) {
        const t12 = e13, {
          set: s9,
          handle: n11
        } = r10.acquireSet(t4.Highlight, i8);
        return r10.setObjectIds(s9, t12), n11;
      }
    }
    return e2();
  }
  resetObjectStates() {
    this.graphicsCore?.objectStates?.reset();
  }
  whenGraphicBounds(e13, t12) {
    return this.graphicsCore?.whenGraphicBounds(e13, t12);
  }
  computeAttachmentOrigin(e13, t12) {
    return this.graphicsCore?.computeAttachmentOrigin(e13, t12);
  }
  notifyGraphicGeometryChanged(e13) {
    this.graphicsCore.notifyGraphicGeometryChanged(e13);
  }
  notifyGraphicVisibilityChanged(e13) {
    this.graphicsCore.notifyGraphicVisibilityChanged(e13);
  }
  getRenderingInfo(e13, t12, r10) {
    const s9 = i5(e13, {
      renderer: t12,
      arcade: r10
    });
    if (s9?.color) {
      const e14 = s9.color;
      e14[0] = e14[0] / 255, e14[1] = e14[1] / 255, e14[2] = e14[2] / 255;
    }
    if (null != s9 && null != t12 && this._randomRotationRenderers?.has(t12)) {
      const r11 = this._randomRotationRenderers.get(t12), n11 = e13.attributes[r11], a7 = new i2(0);
      a7.updateFloatArray([n11]), a7.updateUint8Array([173]), s9.heading = 8381e-11 * a7.digest();
    }
    return s9;
  }
  getRenderingInfoAsync(e13, t12, i8, r10) {
    return l5(e13, __spreadValues({
      renderer: t12,
      arcade: i8
    }, r10));
  }
  getSymbolLayerSize(e13, t12) {
    return this.graphicsCore?.getSymbolLayerSize(e13, t12);
  }
  setObjectIdVisibility(e13, t12) {
    this.graphicsCore?.setObjectIdVisibility(e13, t12);
  }
  refreshFilter() {
    null != this.filterVisibility && this.filterVisibility.reapply();
  }
  getGraphics3DGraphicByObjectId(e13) {
    return this.graphicsCore?.getGraphics3DGraphicByObjectId(e13);
  }
  _updateClippingExtent() {
    const e13 = this.owner.view.clippingArea;
    this.graphicsCore.setClippingExtent(e13, this.owner.view.spatialReference) && (this.updateClippingExtent(e13) || this.graphicsCore.recreateAllGraphics());
  }
  _setupSuspendResumeExtent() {
    (this.frustumVisibility || this.scaleVisibility) && this.addHandles(d2(() => this.suspendResumeExtentMode, () => {
      switch (this.removeHandles(H2), this.suspendResumeExtentMode) {
        case "computed":
          this.addHandles([d2(() => this.graphicsCore.computedExtent, (e13) => this._updateSuspendResumeExtent(e13), P), d2(() => this.graphicsCore.extentPadding, () => this._updateSuspendResumeExtent(this.graphicsCore.computedExtent))], H2);
          break;
        case "data":
          this.addHandles([p(() => this.dataExtent, (e13) => this._updateSuspendResumeExtent(e13), P), d2(() => this.graphicsCore.extentPadding, () => this._updateSuspendResumeExtent(this.dataExtent))], H2);
          break;
        default:
          n6(this.suspendResumeExtentMode);
      }
    }, P));
  }
  _updateSuspendResumeExtent(e13) {
    e13 ? this._suspendResumeExtentChanged(this._extentToSuspendResumeRect(e13, this._suspendResumeExtent)) : this._suspendResumeExtentChanged(null);
  }
  _extentToSuspendResumeRect(e13, t12) {
    const i8 = this.owner.view.spatialReference;
    if (!e13.spatialReference.equals(i8)) {
      if (!x(e13, i8)) return;
      e13 = g(e13, i8);
    }
    return P2(e13, t12, r7, this.graphicsCore.extentPadding);
  }
  _suspendResumeExtentChanged(e13) {
    null != this.frustumVisibility && this.frustumVisibility.setExtent(e13), null != this.scaleVisibility && this.scaleVisibility.setExtent(e13);
  }
};
e3([y2()], P3.prototype, "type", void 0), e3([y2({
  constructOnly: true
})], P3.prototype, "owner", void 0), e3([y2()], P3.prototype, "layer", null), e3([y2({
  readOnly: true
})], P3.prototype, "dataUpdating", null), e3([y2()], P3.prototype, "renderer", null), e3([y2({
  constructOnly: true
})], P3.prototype, "updateClippingExtent", void 0), e3([y2({
  constructOnly: true
})], P3.prototype, "elevationFeatureExpressionEnabled", void 0), e3([y2({
  constructOnly: true
})], P3.prototype, "graphicsCore", void 0), e3([y2({
  constructOnly: true
})], P3.prototype, "scaleVisibilityEnabled", void 0), e3([y2({
  constructOnly: true
})], P3.prototype, "filterVisibilityEnabled", void 0), e3([y2({
  constructOnly: true
})], P3.prototype, "frustumVisibilityEnabled", void 0), e3([y2({
  constructOnly: true
})], P3.prototype, "elevationAlignmentEnabled", void 0), e3([y2({
  constructOnly: true
})], P3.prototype, "timeExtentEnabled", void 0), e3([y2({
  constructOnly: true
})], P3.prototype, "setUidToIdOnAdd", void 0), e3([y2()], P3.prototype, "scaleVisibility", null), e3([y2()], P3.prototype, "filterVisibility", null), e3([y2()], P3.prototype, "elevationAlignment", null), e3([y2({
  constructOnly: true
})], P3.prototype, "frustumVisibility", void 0), e3([y2()], P3.prototype, "initializePromise", void 0), e3([y2()], P3.prototype, "suspendResumeExtentMode", null), e3([y2()], P3.prototype, "dataExtent", void 0), e3([y2()], P3.prototype, "scaleVisibilitySuspended", null), e3([y2()], P3.prototype, "suspended", null), e3([y2()], P3.prototype, "legendEnabled", null), e3([y2()], P3.prototype, "suspendInfo", null), e3([y2()], P3.prototype, "updating", null), e3([y2()], P3.prototype, "updatingRemaining", null), e3([y2()], P3.prototype, "featureStore", null), e3([y2()], P3.prototype, "view", null), e3([y2()], P3.prototype, "loadedGraphics", null), e3([y2()], P3.prototype, "fullOpacity", null), e3([y2()], P3.prototype, "filter", null), e3([y2()], P3.prototype, "slicePlaneEnabled", null), e3([y2()], P3.prototype, "drapeSourceType", void 0), e3([y2()], P3.prototype, "updatePolicy", null), e3([y2()], P3.prototype, "preferredUpdatePolicy", void 0), e3([y2({
  readOnly: true
})], P3.prototype, "displayFeatureLimit", null), P3 = e3([a3("esri.views.3d.layers.graphics.Graphics3DFeatureProcessor")], P3);
var H2 = "suspendResumeExtentMode";

// ../../../node_modules/@arcgis/core/views/3d/layers/support/featureReference.js
var t11 = class {
  get isReferenced() {
    return 0 !== this.versions.length;
  }
  get isSingle() {
    return 1 === this.versions.length && 1 === this.versions[0].refCount;
  }
  constructor(e13, t12) {
    this._highestResolutionVersion = null, this.versions = [], this.ref(e13, t12);
  }
  ref(t12, s9) {
    const r10 = this.feature;
    i7.oldVersion = r10, this.feature && Object.defineProperty(t12, "uid", {
      value: this.feature.uid,
      configurable: true
    });
    for (const n11 of this.versions) if (n11.resolution === s9) {
      n11.refCount++;
      const s10 = this._highestResolutionVersion === n11 && !h4(t12, n11.feature);
      return (s10 || this._highestResolutionVersion !== n11) && (n11.feature = t12), i7.newVersion = s10 ? t12 : r10, i7;
    }
    const o9 = {
      feature: t12,
      resolution: s9,
      refCount: 1
    };
    return this.versions.push(o9), !this._highestResolutionVersion || s9 < this._highestResolutionVersion.resolution ? (i7.newVersion = t12, this._highestResolutionVersion = o9) : i7.newVersion = r10, i7;
  }
  unref(e13) {
    for (let t12 = 0; t12 < this.versions.length; t12++) {
      const s9 = this.versions[t12];
      if (s9.resolution === e13) return s9.refCount--, i7.oldVersion = this.feature, 0 === s9.refCount && (this.versions[t12] = this.versions[this.versions.length - 1], this.versions.length--, this._highestResolutionVersion === s9 && (this._recalculateHighestResolutionVersion(), i7.oldVersion = s9.feature)), i7.newVersion = this.feature, i7;
    }
    return null;
  }
  get feature() {
    return this._highestResolutionVersion ? this._highestResolutionVersion.feature : null;
  }
  _recalculateHighestResolutionVersion() {
    if (0 === this.versions.length) return void (this._highestResolutionVersion = null);
    let e13 = this.versions[0];
    for (let t12 = 1; t12 < this.versions.length; t12++) {
      const s9 = this.versions[t12];
      s9.resolution < e13.resolution && (e13 = s9);
    }
    this._highestResolutionVersion = e13;
  }
};
var s8 = class {
  get isReferenced() {
    return 0 !== this._refCount;
  }
  get isSingle() {
    return 1 === this._refCount;
  }
  constructor(e13) {
    this._feature = e13, this._refCount = 1;
  }
  ref(t12) {
    return ++this._refCount, i7.oldVersion = this._feature, this.feature && Object.defineProperty(t12, "uid", {
      value: this.feature.uid,
      configurable: true
    }), h4(this._feature, t12) || (this._feature = t12), i7.newVersion = this._feature, i7;
  }
  unref() {
    return i7.oldVersion = this._feature, this._refCount > 0 && (this._refCount--, !this.isReferenced) ? (i7.newVersion = null, i7) : (i7.newVersion = this._feature, i7);
  }
  get feature() {
    return this._feature;
  }
};
var i7 = {
  oldVersion: null,
  newVersion: null
};

// ../../../node_modules/@arcgis/core/views/3d/layers/support/FeatureTile.js
var _4 = 16438;
var d9 = /* @__PURE__ */ new Set();
var m8 = class {
  get featuresMissing() {
    return this._featuresMissing.value;
  }
  set featuresMissing(t12) {
    this._featuresMissing.value = t12;
  }
  get missingAttributes() {
    return this._missingAttributes;
  }
  get fetchFailed() {
    return this._fetchFailed.value;
  }
  set fetchFailed(t12) {
    this._fetchFailed.value = t12;
  }
  get displayingFeatures() {
    return this._displayingFeatures;
  }
  set displayingFeatures(t12) {
    this._displayingFeatures = t12, this.extentIncludingBorrowedFeatures = null;
  }
  get perTileMaximumNumberOfFeaturesExceeded() {
    const t12 = (this.fetchStatus === c8.DONE || this.fetchStatus === c8.FULL) && this.featuresMissing;
    return !this.filtered && (t12 || this.hasFeatureLimit);
  }
  get features() {
    return this._features;
  }
  get featureLimit() {
    return this._featureLimit.value;
  }
  set featureLimit(t12) {
    this._featureLimit.value !== t12 && (this._featureLimit.value = t12, this._estimatedUnusedSizeDirty = true);
  }
  get hasFeatureLimit() {
    return this.featureLimit !== this._featuresLength.value;
  }
  get hasAllFeatures() {
    return !(this.featuresMissing || this.fetchFailed || this.hasFeatureLimit);
  }
  get availableFields() {
    return this._availableFields;
  }
  setFeatures(t12, e13, s9, i8) {
    this._availableFields = s9 ?? d9, this._features = t12, this._featuresLength.value = t12?.length ?? 0, this._shuffled = false, this._estimatedSize = -1, this._estimatedUnusedSizeDirty = true, this._missingAttributes = i8, t12 && t12.length > 0 ? (this._emptyFeatureRatio.value = e13 / (t12.length + e13), this._numVertices = t12.reduce((t13, e14) => t13 + k(e14.geometry), 0)) : (this._emptyFeatureRatio.value = 0, this._numVertices = 0);
  }
  get emptyFeatureRatio() {
    return this._emptyFeatureRatio.value;
  }
  get numFeatures() {
    return this.hasPreciseFeatureCount ? this._numFeatures : this._features ? this._features.length : 0;
  }
  set numFeatures(t12) {
    this._numFeatures = t12;
  }
  get hasPreciseFeatureCount() {
    return this._numFeatures > F3;
  }
  get needsFeatureCount() {
    return this._numFeatures === F3;
  }
  get numVertices() {
    return this._numVertices;
  }
  constructor(t12) {
    this.descriptor = t12, this.fetchStatus = c8.FETCH_NEEDED, this._features = null, this._featuresLength = r3(0), this._numVertices = 0, this._featureLimit = r3(0), this._featuresMissing = r3(true), this._fetchFailed = r3(false), this._shuffled = false, this._numFeatures = F3, this._emptyFeatureRatio = r3(0), this._estimatedSize = -1, this._estimatedUnusedSize = 0, this._estimatedUnusedSizeDirty = false, this._availableFields = d9, this._displayingFeatures = null, this.alive = true, this.filtered = false;
  }
  get id() {
    return this.descriptor.id;
  }
  get estimatedSize() {
    return this.updateMemoryEstimates(), this._estimatedSize;
  }
  get estimatedUnusedSize() {
    return this._estimatedUnusedSize;
  }
  updateMemoryEstimates() {
    if (this._estimatedSize < 0) {
      if (this._estimatedSize = 0, this._estimatedUnusedSize = 0, this._features) for (let t12 = 0; t12 < this._features.length; ++t12) {
        const e13 = Z2(this._features[t12]);
        this._estimatedSize += e13, t12 >= this.featureLimit && (this._estimatedUnusedSize += e13);
      }
      return true;
    }
    if (this._estimatedUnusedSizeDirty) {
      if (this._estimatedUnusedSize = 0, this._estimatedUnusedSizeDirty = false, this._features) for (let t12 = this.featureLimit; t12 < this._features.length; ++t12) this._estimatedUnusedSize += Z2(this._features[t12]);
      return true;
    }
    return false;
  }
  get isFetching() {
    return this.fetchStatus === c8.FETCHING || this.fetchStatus === c8.REFETCHING;
  }
  get isRefetching() {
    return this.fetchStatus === c8.REFETCHING;
  }
  get needsFetching() {
    return this.fetchStatus === c8.FETCH_NEEDED || this.fetchStatus === c8.REFETCH_NEEDED;
  }
  get needsRefetching() {
    return this.fetchStatus === c8.REFETCH_NEEDED;
  }
  get isFetched() {
    return this.fetchStatus === c8.DONE || this.fetchStatus === c8.FULL;
  }
  resetFetching() {
    this.fetchStatus = this.fetchStatus === c8.REFETCHING ? c8.REFETCH_NEEDED : c8.FETCH_NEEDED;
  }
  get needsDisplayUpdate() {
    return !!this._features && !E6(this._features, this.displayingFeatures, this.featureLimit);
  }
  intersects(t12) {
    return null == t12 || !this.descriptor.extent || (o(t12, o8), E(this.descriptor.extent, o8));
  }
  intersectionIncludingBorrowed(t12, e13) {
    const s9 = null != this.extentIncludingBorrowedFeatures ? this.extentIncludingBorrowedFeatures : this.descriptor.extent;
    return t12 || s9 ? (null != t12 ? (o(t12, e13), U(e13, s9, e13)) : e4(e13, s9), e13) : (e4(e13, J), e13);
  }
  _shuffle(e13) {
    this._features && (this._features.sort((t12, s9) => M(t12, e13) - M(s9, e13)), F(this._features, _4), this._shuffled = true, this._estimatedUnusedSizeDirty = true);
  }
  reduceFeatures(t12, e13, s9) {
    if (t12 <= 0) return false;
    if (!this._features) return this.featureLimit = 0, false;
    let i8 = false;
    this.featureLimit = Math.ceil(this.numFeatures * t12), this.featureLimit > this._features.length && (this.featureLimit = this._features.length, this.fetchStatus === c8.DONE && this._features.length > 0 && (this.fetchStatus = c8.REFETCH_NEEDED, i8 = true)), !this._shuffled && t12 < 1 && this._shuffle(s9);
    const r10 = Math.max(this.featureLimit, Math.ceil(e13 * this.numFeatures));
    return this._features.length > r10 && (this._features.length = r10, this._featuresLength.value = r10, this.featuresMissing = true, this.fetchStatus === c8.FULL && (this.fetchStatus = c8.DONE)), i8;
  }
  get cache() {
    return {
      availableFields: this._availableFields,
      features: this._features,
      numFeatures: this._numFeatures,
      emptyFeatureRatio: this._emptyFeatureRatio.value,
      fetchStatus: this.fetchStatus,
      featuresMissing: this.featuresMissing
    };
  }
  set cache(t12) {
    this.requestController = null, this._availableFields = t12.availableFields, this._features = t12.features, this._featuresLength.value = t12.features?.length ?? 0, this._numFeatures = t12.numFeatures, this._emptyFeatureRatio.value = t12.emptyFeatureRatio, this.fetchStatus = t12.fetchStatus, this.featuresMissing = t12.featuresMissing, this._estimatedSize = -1, this._estimatedUnusedSizeDirty = true;
  }
};
var F3 = -1;
var g3 = -2;
var c8;
function E6(t12, e13, s9) {
  if (null == e13 || null == t12 || s9 !== e13.length || s9 > t12.length) return false;
  for (let i8 = 0; i8 < s9; ++i8) if (t12[i8] !== e13[i8]) return false;
  return true;
}
!function(t12) {
  t12[t12.FETCH_NEEDED = 0] = "FETCH_NEEDED", t12[t12.REFETCH_NEEDED = 1] = "REFETCH_NEEDED", t12[t12.FETCHING = 2] = "FETCHING", t12[t12.REFETCHING = 3] = "REFETCHING", t12[t12.DONE = 4] = "DONE", t12[t12.FULL = 5] = "FULL";
}(c8 || (c8 = {}));
var o8 = u3();

// ../../../node_modules/@arcgis/core/views/3d/layers/support/FeatureTileFetcher3D.js
var U3 = class extends S {
  set maximumNumberOfFeatures(e13) {
    e13 = e13 || 1 / 0;
    const t12 = this._get("maximumNumberOfFeatures");
    e13 === t12 || e13 < 1 || (this._set("maximumNumberOfFeatures", e13), this._maximumFeaturesUpdated(t12, e13));
  }
  set memoryFactor(e13) {
    this.memoryFactor !== e13 && (this._set("memoryFactor", e13), this._setDirty());
  }
  set lodFactor(e13) {
    this.lodFactor !== e13 && (this._set("lodFactor", e13), this._supportsResolution && this.refetch());
  }
  get useTileCount() {
    return this._useTileCount && null != this.context.query.queryFeatureCount;
  }
  set useTileCount(e13) {
    this._useTileCount = e13, this.notifyChange("useTileCount");
  }
  get updating() {
    return this._dirty || !!this._pendingEdits || this._isFetching || (this.tileDescriptors?.updating ?? false);
  }
  get memoryForUnusedFeatures() {
    let e13 = 0;
    return this._featureTiles.forEach((t12) => e13 += t12.estimatedUnusedSize), e13;
  }
  get totalVertices() {
    let e13 = 0;
    return this._featureTiles.forEach((t12) => e13 += t12.numVertices), e13;
  }
  get totalFeatures() {
    let e13 = 0;
    return this._featureTiles.forEach((t12) => e13 += t12.numFeatures), e13;
  }
  get hasAllFeatures() {
    if (this._paused || this.dataUpdating) return false;
    for (const [, e13] of this._featureTiles) if (!this.hasFullGeometries && 0 !== e13.emptyFeatureRatio || !e13.hasAllFeatures) return false;
    return true;
  }
  get hasFullGeometries() {
    if (!this._supportsResolution) return true;
    return !this.tileDescriptors.find((e13) => null != e13.resolution) || !this.context.capabilities.supportsQuantization && "polyline" !== this.context.geometryType;
  }
  set filterExtent(e13) {
    if (null != e13 && this.context.tilingScheme && !e13.spatialReference.equals(this.context.tilingScheme.spatialReference)) return void n2.getLogger(this).error("#filterExtent=", "extent needs to be in the same spatial reference as the tiling scheme");
    const t12 = this._get("filterExtent");
    if (t12 === e13 || null != t12 && e13 && t12.equals(e13)) return;
    const i8 = null != e13 ? e13.clone() : null;
    this._set("filterExtent", i8), this._reclip(i8, t12);
  }
  constructor(e13) {
    super(e13), this._useTileCount = false, this.dataUpdating = false, this.running = false, this.updatingTotal = 0, this.updatingRemaining = 0, this.expectedFeatureDiff = 0, this.maximumNumberOfFeaturesExceeded = false, this._fullRatio = 1, this._farRatio = 1, this._changes = {
      updates: {
        adds: new Array(),
        removes: new Array()
      },
      adds: new Array(),
      removes: new Array()
    }, this._frameTask = F2, this._dirty = false, this._featureTiles = new s3(), this._displayingFeatureReferences = /* @__PURE__ */ new Map(), this._numDisplayingFeatureReferences = 0, this._suspended = true, this._pendingEdits = null, this._applyEditsTilesUpdated = false, this._isFetching = false;
  }
  initialize() {
    this.addHandles(v2(() => this.tileDescriptors, "change", () => this._setDirty(), {
      sync: true,
      onListenerAdd: () => this._setDirty()
    })), this._objectIdField = this.context.objectIdField, this.FeatureReferenceClass = this.context.capabilities.supportsMultipleResolutions ? t11 : s8;
    const e13 = this.context.scheduler;
    null != e13 && (this._frameTask = e13.registerTask(I2.FEATURE_TILE_FETCHER, this)), this._setDirty();
  }
  destroy() {
    this._frameTask.remove(), this._featureTiles.forEach((e13) => {
      this._cancelFetchTile(e13), this._removeTile(e13);
    }), this._featureTiles.clear(), this._displayingFeatureReferences.clear(), this._pendingEdits?.controller.abort(), this._pendingEdits = null;
  }
  get _paused() {
    return this._suspended || !!this._pendingEdits;
  }
  restart() {
    this._featureTiles.forEach((e13) => {
      this._cancelFetchTile(e13), this._clearTile(e13), this._resetFetchTile(e13);
    }), null != this.context.memoryCache && this.context.memoryCache.clear(), this._setDirty();
  }
  refetch() {
    this._featureTiles.forEach((e13) => {
      this._cancelFetchTile(e13), this._resetFetchTile(e13);
    }), null != this.context.memoryCache && this.context.memoryCache.clear(), this._setDirty();
  }
  suspend() {
    this._suspended || (this._suspended = true, this._pause(), this._setDirty());
  }
  resume() {
    this._suspended && (this._suspended = false, this._unpause());
  }
  getMissingAttributesForFeature(e13) {
    for (const [, t12] of this._featureTiles) {
      const s9 = t12.missingAttributes?.get(e13);
      if (null != s9) return s9;
    }
  }
  _pause() {
    this._paused && (this._featureTiles.forEach((e13) => this._cancelFetchTile(e13)), this._updated());
  }
  _unpause() {
    this._paused || this._setDirty();
  }
  get availableFields() {
    let e13 = null;
    return this._featureTiles.forEach((t12) => {
      null != t12.displayingFeatures && 0 !== t12.displayingFeatures.length && (null == e13 ? e13 = new Set(t12.availableFields) : e13.forEach((s9) => {
        t12.availableFields.has(s9) || e13.delete(s9);
      }));
    }), null != e13 ? e13 : /* @__PURE__ */ new Set();
  }
  applyEdits(e13) {
    this._pendingEdits || (this._pendingEdits = {
      edits: Promise.resolve(),
      count: 0,
      controller: new AbortController()
    }, this._pause());
    const t12 = this._pendingEdits;
    t12.count++;
    const s9 = t12.edits.then(() => e13.result.catch((e14) => {
      if (b(e14)) throw e14;
      return null;
    }).then((e14) => e14 ? (this._applyEditsDeleteFeatures(e14.deletedFeatures), this._applyEditsAddUpdateFeatures(e14.addedFeatures, e14.updatedFeatures, t12.controller.signal).then(() => e14)) : e14).then((e14) => (0 == --t12.count && (this._pendingEdits === t12 && (this._pendingEdits = null), null != this.context.memoryCache && this.context.memoryCache.clear(), this._applyEditsTilesUpdated = false, this._unpause()), e14)));
    return t12.edits = s9, this._updated(), s9;
  }
  _applyEditsDeleteFeatures(e13) {
    if (0 === e13.length) return;
    const t12 = this.context.globalIdField, i8 = t12 && this.availableFields.has(t12), r10 = /* @__PURE__ */ new Set(), a7 = this._objectIdField;
    e13.forEach(({
      objectId: e14,
      globalId: n11
    }) => {
      (!e14 || e14 < 0) && t12 && n11 && (i8 || n2.getLogger(this).errorOncePerTick(`Editing the specified service requires the layer's globalIdField, ${t12} to be included the layer's outFields for updates to be reflected in the view`), e14 = this._objectIdFromGlobalId(n11, a7, t12)), null != e14 && e14 >= 0 && r10.add(e14);
    }), this._featureTiles.forEach((e14) => {
      if (!e14.features) return;
      const t13 = e14.features.filter((e15) => !r10.has(M(e15, this._objectIdField)));
      t13.length !== e14.features.length && (this._applyEditsTileUpdated(), e14.setFeatures(t13, 0, e14.availableFields, e14.missingAttributes), this._invalidateCounts());
    });
  }
  _objectIdFromGlobalId(e13, t12, s9) {
    if (null == e13) return null;
    const i8 = this.features.find((t13) => t13.attributes?.[s9] === e13);
    return i8 ? M(i8, t12) : null;
  }
  _applyEditsAddUpdateFeatures(e13, t12, i8) {
    return __async(this, null, function* () {
      const {
        objectIdField: r10,
        globalIdField: a7
      } = this.context, n11 = a7 && this.availableFields.has(a7), o9 = /* @__PURE__ */ new Set(), u11 = /* @__PURE__ */ new Set();
      for (const s9 of e13) {
        const e14 = s9.objectId;
        null != e14 && o9.add(e14);
      }
      for (const {
        objectId: h7,
        globalId: d13
      } of t12) {
        let e14 = h7;
        (null == e14 || e14 < 0) && a7 && (n11 || n2.getLogger(this).errorOncePerTick(`Editing the specified service requires the layer's globalIdField, ${a7} to be included the layer's outFields for updates to be reflected in the view`), e14 = this._objectIdFromGlobalId(d13, r10, a7)), null != e14 && e14 >= 0 && (o9.add(e14), u11.add(e14));
      }
      if (0 === o9.size) return;
      const l7 = [];
      this._featureTiles.forEach((e14) => {
        const t13 = this._applyEditsAddUpdateTile(e14, o9, u11, i8);
        t13 && l7.push(t13);
      }), this._updated(), yield Promise.allSettled(l7);
    });
  }
  _applyEditsAddUpdateTile(e13, t12, s9, i8) {
    return __async(this, null, function* () {
      if (!e13.features) return;
      const r10 = this._createQuery(e13);
      r10.resultType = void 0, r10.cacheHint = false, r10.objectIds = Array.from(t12);
      const a7 = yield this._queryFeatures(r10, i8);
      let n11 = null;
      if (s9.size > 0) {
        const t13 = e13.features.filter((e14) => !s9.has(M(e14, this._objectIdField)));
        t13.length !== e13.features.length && (n11 = t13);
      }
      if (a7.features.length > 0) {
        n11 || (n11 = e13.features.slice());
        for (const e14 of a7.features) n11.push(e14);
      }
      n11 && (e13.hasPreciseFeatureCount && (e13.numFeatures = Math.max(e13.numFeatures, n11.length)), this._applyEditsTileUpdated(), e13.setFeatures(n11, 0, q(e13.availableFields, a7.fields), L(e13.missingAttributes, a7.missingAttributes)), this._invalidateCounts());
    });
  }
  _applyEditsTileUpdated() {
    this._applyEditsTilesUpdated || (this._applyEditsTilesUpdated = true, this._updated());
  }
  _queryFeatures(e13, t12) {
    return this.context.query.queryFeaturesDehydrated(e13, {
      signal: t12,
      timeout: V2
    });
  }
  _setDirty() {
    this._dirty = true, this._updated();
  }
  runTask(e13) {
    const t12 = this._frameTask.processQueue(e13);
    if (!this._dirty || !this.initialized) return t12;
    this._dirty = false;
    const s9 = this._getListOfTiles();
    if (this._markTilesNotAlive(s9), !e13.run(() => this._addTiles(s9, e13)) || !e13.run(() => this._filterExtentTiles(s9, e13)) || !e13.run(() => this._removeTiles(s9, e13)) || e13.done) return void this._setDirty();
    const i8 = this._sortTiles(s9);
    e13.run(() => this._showTiles(i8, e13)) && e13.run(() => this._fetchTiles(i8, e13)) && e13.run(() => this._updateMemoryEstimates(i8, e13)) || this._setDirty(), this._updated(), this.updating || this._updateMaximumNumberOfFeaturesExceeded();
  }
  _markTilesNotAlive(e13) {
    for (const t12 of e13) t12.alive = false;
  }
  _addTiles(e13, t12) {
    return !(this._suspended || !this.tileDescriptors) && (this.tileDescriptors.forEach((s9) => {
      const i8 = this._featureTiles.get(s9.id);
      i8 ? i8.alive = true : t12.done || (e13.push(this._addTile(s9)), t12.madeProgress());
    }), t12.hasProgressed);
  }
  _filterExtentTiles(e13, t12) {
    for (const s9 of e13) {
      if (t12.done) break;
      s9.alive && (s9.filtered = !s9.intersects(this.filterExtent), s9.filtered && (this._clearTile(s9), t12.madeProgress()));
    }
    return t12.hasProgressed;
  }
  _removeTiles(e13, t12) {
    for (let s9 = e13.length - 1; s9 >= 0 && !t12.done; s9--) {
      const i8 = e13[s9];
      i8.alive || (this._removeTile(i8), s9 !== e13.length - 1 && (e13[s9] = e13[e13.length - 1]), e13.pop(), t12.madeProgress());
    }
    return t12.hasProgressed;
  }
  _sortTiles(e13) {
    return e13.sort((e14, t12) => (e14.descriptor.loadPriority ?? 0) - (t12.descriptor.loadPriority ?? 0)), e13;
  }
  _showTiles(e13, t12) {
    const s9 = this._updateRatio(e13), i8 = (e14) => {
      const t13 = this._fullRatio < 1 ? s9(e14) * this._farRatio : 1;
      return e14.reduceFeatures(t13, this.memoryFactor, this._objectIdField) && this._setDirty(), this._showTile(e14);
    };
    for (const r10 of e13) if (!t12.run(() => i8(r10))) {
      this._setDirty();
      break;
    }
    return t12.hasProgressed;
  }
  _fetchTiles(e13, t12) {
    if (this._paused) return false;
    let i8 = false;
    for (const s9 of e13) {
      if (!s9.needsFetching) continue;
      const e14 = null != this.context.memoryCache ? this.context.memoryCache.pop(s9.id) : null;
      if (null == e14) {
        if (this._needsNumFeatures(s9)) {
          const e15 = new AbortController(), r10 = this._fetchTileCount(s9, e15.signal);
          this._handleRequest(s9, r10, e15, () => s9.numFeatures = g3), i8 = true, t12.madeProgress();
        }
        if (t12.done) return true;
      } else s9.cache = e14, s9.numFeatures && this._notifyDataUpdating(), this._setDirty(), this._scheduleUpdated(), t12.madeProgress();
    }
    if (i8) return t12.hasProgressed;
    for (const r10 of e13) if (r10.needsFetching) {
      const e14 = new AbortController(), i9 = this._fetchTile(r10, e14.signal);
      if (this._handleRequest(r10, i9, e14, (e15) => {
        r10.setFeatures([], 0, null, void 0), this._invalidateCounts(), r10.featuresMissing = false, r10.fetchFailed = true, this.context.logFetchError(n2.getLogger(this), e15);
      }), t12.madeProgress()) return true;
    }
    return t12.hasProgressed;
  }
  _updateMemoryEstimates(e13, t12) {
    return e13.some((e14) => !t12.run(() => e14.updateMemoryEstimates()) && (this._setDirty(), true)), t12.hasProgressed;
  }
  _reclip(e13, t12) {
    if (!this.initialized) return;
    const s9 = new Array();
    this._featureTiles.forEach((i8) => {
      null != i8.displayingFeatures && 0 !== i8.displayingFeatures.length && (i8.intersectionIncludingBorrowed(t12, Q), i8.intersectionIncludingBorrowed(e13, H3), I(Q, H3) || s9.push(i8));
    }), this._refreshDisplayingFeatures(s9), this._updated();
  }
  _refreshDisplayingFeatures(e13) {
    const t12 = /* @__PURE__ */ new Set(), s9 = this._changes.updates;
    for (const i8 of e13) if (null != i8.displayingFeatures) for (const e14 of i8.displayingFeatures) {
      const i9 = M(e14, this._objectIdField);
      if (t12.has(i9)) continue;
      t12.add(i9);
      const r10 = this._displayingFeatureReferences.get(i9).feature;
      s9.removes.push(r10), s9.adds.push(r10);
    }
    this._applyChanges();
  }
  _updated() {
    let e13 = 0;
    if (this._paused || this._featureTiles.forEach((t12) => t12.isFetching ? ++e13 : 0), this._isFetching = e13 > 0, this._set("running", this._dirty), e13 > 0 || this._applyEditsTilesUpdated ? this._notifyDataUpdating() : this._dirty || this._set("dataUpdating", false), this.updating) {
      let t12 = 0, s9 = 0, i8 = 0, r10 = 0, a7 = 0;
      const n11 = this._displayingFeatureReferences.size / this._numDisplayingFeatureReferences;
      this._featureTiles.forEach((e14) => {
        if (++s9, e14.isFetching && e14.hasPreciseFeatureCount) {
          const t13 = this._maximumFeaturesForTile(e14) * (1 - e14.emptyFeatureRatio), s10 = null != e14.displayingFeatures ? e14.displayingFeatures.length * n11 : 0;
          a7 += t13 - s10;
        }
        e14.needsFetching ? ++r10 : e14.numFeatures > 0 && (++i8, t12 += e14.numFeatures);
      }), r10 += e13;
      let o9 = 0, u11 = 0;
      t12 ? (u11 = t12, o9 = Math.min(r10 * t12 / i8, t12)) : (u11 = s9, o9 = r10), a7 = Math.min(this.maximumNumberOfFeatures - this.features.length, a7), this._set("updatingTotal", u11), this._set("updatingRemaining", o9), this._set("expectedFeatureDiff", a7);
    } else this._set("updatingTotal", 0), this._set("updatingRemaining", 0), this._set("expectedFeatureDiff", 0);
    this.debugger && this.debugger.update();
  }
  _updateMaximumNumberOfFeaturesExceeded() {
    const e13 = n3(this._featureTiles, (e14) => e14.perTileMaximumNumberOfFeaturesExceeded);
    this._set("maximumNumberOfFeaturesExceeded", e13);
  }
  _updateRatio(e13) {
    const t12 = O5(e13), s9 = (e14) => 1 / (1 << Math.max(0, t12 - e14.descriptor.lij[0]));
    let i8 = 0, r10 = 0;
    for (const a7 of e13) {
      const e14 = a7.numFeatures;
      i8 += e14, r10 += e14 * s9(a7);
    }
    return this._fullRatio = Math.min(1, this.maximumNumberOfFeatures / i8), this._farRatio = this.maximumNumberOfFeatures / r10, this._scheduleUpdated(), s9;
  }
  _maximumFeaturesUpdated(e13, t12) {
    e13 !== t12 && (t12 > e13 && this._featureTiles.forEach((e14) => {
      if (!e14.featuresMissing) return;
      const t13 = this._maximumFeaturesForTile(e14);
      e14.features && (e14.features.length >= t13 || e14.fetchStatus === c8.FULL) || (this._cancelFetchTile(e14), this._resetFetchTile(e14));
    }), this._setDirty());
  }
  _addTile(e13) {
    const t12 = new m8(e13);
    return this._featureTiles.set(t12.id, t12), this._resetFetchTile(t12), this._referenceDisplayingFeaturesFromRelatedTiles(t12), t12;
  }
  _referenceDisplayingFeaturesFromRelatedTiles(e13) {
    const t12 = e13.descriptor.resolution;
    this._featureTiles.forEach((s9) => {
      if (!(null == s9.displayingFeatures || e13 === s9 || e13.descriptor.lij && s9.descriptor.lij && !x2(e13.descriptor.lij, s9.descriptor.lij))) {
        null == e13.displayingFeatures && (e13.displayingFeatures = []), e13.descriptor.extent && s9.descriptor.extent && (null == e13.extentIncludingBorrowedFeatures && (e13.extentIncludingBorrowedFeatures = i(e13.descriptor.extent)), m2(e13.extentIncludingBorrowedFeatures, s9.descriptor.extent, e13.extentIncludingBorrowedFeatures));
        for (const i8 of s9.displayingFeatures) {
          e13.displayingFeatures.push(i8);
          const s10 = this._displayingFeatureReferences.get(M(i8, this._objectIdField));
          s10.ref(s10.feature, t12), this._numDisplayingFeatureReferences++;
        }
      }
    }), e13.featureLimit = null != e13.displayingFeatures ? e13.displayingFeatures.length : 0;
  }
  _removeTile(e13) {
    this._clearTile(e13), this._featureTiles.delete(e13.id);
  }
  _resetFetchTile(e13) {
    e13.filtered = !e13.intersects(this.filterExtent), e13.filtered ? e13.needsFetching && (e13.fetchStatus = c8.DONE) : e13.fetchStatus = c8.FETCH_NEEDED;
  }
  _cancelFetchTile(e13) {
    const t12 = e13.requestController;
    null != t12 && (e13.requestController = null, e13.resetFetching(), t12.abort());
  }
  _fetchTileCount(e13, t12) {
    return __async(this, null, function* () {
      return e13.numFeatures = yield this._fetchCount(e13, t12), this._updateRatio(this._getListOfTiles()), e13.fetchStatus === c8.REFETCHING ? c8.REFETCH_NEEDED : c8.FETCH_NEEDED;
    });
  }
  _fetchTile(e13, t12) {
    return __async(this, null, function* () {
      e13.fetchFailed = false;
      const s9 = this._maximumFeaturesForTile(e13);
      if (s9 <= 0) return e13.hasPreciseFeatureCount && 0 === e13.numFeatures || (e13.fetchFailed = true), I5(e13);
      const i8 = this._getMaxRecordCount(e13), r10 = Math.ceil(s9 / i8);
      if (j2(e13) || !this.context.capabilities.supportsMaxRecordCountFactor || e13.numFeatures <= s9 && r10 > b2.MAX_MAX_RECORD_COUNT_FACTOR) return this._fetchPagedTile(e13, t12);
      const a7 = this._createQuery(e13);
      if (a7.maxRecordCountFactor = Math.ceil(s9 / i8), e13.isRefetching && e13.features && e13.features.length > 0) {
        const t13 = Math.ceil(e13.features.length / (1 - e13.emptyFeatureRatio) / i8);
        a7.maxRecordCountFactor = Math.max(t13 + 1, a7.maxRecordCountFactor);
      }
      const {
        features: o9,
        exceededTransferLimit: u11,
        fields: l7,
        missingAttributes: h7
      } = yield this._queryFeatures(a7, t12), d13 = u11 ? a7.maxRecordCountFactor >= b2.MAX_MAX_RECORD_COUNT_FACTOR ? c8.FULL : c8.DONE : c8.FULL;
      return yield this._frameTask.schedule(() => {
        e13.featuresMissing = e13.hasPreciseFeatureCount && o9.length < e13.numFeatures || !!u11;
        const t13 = this._removeEmptyFeatures(o9);
        e13.setFeatures(o9, t13, N2(l7), L(void 0, h7));
      }, t12), s2(t12), this._invalidateCounts(), d13;
    });
  }
  _fetchCount(e13, t12) {
    return __async(this, null, function* () {
      return this.context.query.queryFeatureCount(this._createFeatureCountQuery(e13), {
        signal: t12
      });
    });
  }
  _fetchPagedTile(e13, t12) {
    return __async(this, null, function* () {
      let s9, i8 = 0, r10 = 0, a7 = 0, o9 = this._maximumFeaturesForTile(e13) - a7;
      const u11 = this._getMaxRecordCount(e13);
      let l7, h7 = null;
      for (; ; ) {
        const d13 = this._createQuery(e13), c9 = this._setPagingParameters(d13, i8, o9, u11), {
          features: p5,
          exceededTransferLimit: f5,
          fields: _5,
          missingAttributes: m9
        } = yield this._queryFeatures(d13, t12);
        if (yield this._frameTask.schedule(() => {
          c9 && (i8 += d13.num), a7 += p5.length, r10 += this._removeEmptyFeatures(p5), e13.featuresMissing = c9 && e13.hasPreciseFeatureCount && i8 < e13.numFeatures || !!f5, s9 = s9 ? s9.concat(p5) : p5, h7 = q(h7, _5), l7 = L(l7, m9), e13.setFeatures(s9, r10, h7, l7);
        }, t12), s2(t12), this._invalidateCounts(), this._setDirty(), o9 = this._maximumFeaturesForTile(e13) - a7, !c9 || !f5 || o9 <= 0) return f5 ? c8.DONE : c8.FULL;
      }
    });
  }
  _createFeatureCountQuery(e13) {
    const t12 = this._createQuery(e13);
    return this.context.capabilities.supportsCacheHint && (t12.resultType = void 0, t12.cacheHint = true), t12;
  }
  _createQuery(e13) {
    const t12 = this.context.createQuery(), s9 = e13.descriptor.extent;
    if (s9) {
      const e14 = this.context.tilingScheme.spatialReference;
      t12.geometry = c2(s9, e14);
    }
    return this._setResolutionParams(t12, e13), this._useTileQuery(e13) ? t12.resultType = "tile" : this.context.capabilities.supportsCacheHint && (t12.cacheHint = true), t12;
  }
  _setPagingParameters(e13, t12, s9, i8) {
    return !!this.context.capabilities.supportsPagination && (e13.start = t12, s9 > 0 && this.context.capabilities.supportsMaxRecordCountFactor ? (e13.maxRecordCountFactor = Math.ceil(s9 / i8), e13.num = Math.min(e13.maxRecordCountFactor * i8, s9)) : e13.num = Math.min(i8), true);
  }
  _getEffectiveTileResolution(e13) {
    if (null == e13.descriptor.resolution) return null;
    const t12 = this.context.viewingMode === l2.Global ? this.context.tilingScheme.resolutionAtLevel(3) : 1 / 0;
    return Math.min(e13.descriptor.resolution, t12) / this.lodFactor;
  }
  get _supportsResolution() {
    return this.context.capabilities.supportsMultipleResolutions && "point" !== this.context.geometryType;
  }
  _setResolutionParams(e13, t12) {
    if (!this._supportsResolution) return;
    const s9 = this._getEffectiveTileResolution(t12);
    null != s9 && (this.context.capabilities.supportsQuantization ? e13.quantizationParameters = new a4({
      mode: "view",
      originPosition: "upper-left",
      tolerance: s9,
      extent: this.context.fullExtent
    }) : "polyline" === this.context.geometryType && (e13.maxAllowableOffset = s9));
  }
  _removeEmptyFeatures(e13) {
    const t12 = e13.length;
    for (let s9 = 0; s9 < e13.length; ) {
      const t13 = e13[s9];
      N(t13.geometry) ? ++s9 : (e13[s9] = e13[e13.length - 1], --e13.length);
    }
    return t12 - e13.length;
  }
  _needsNumFeatures(e13) {
    return this.useTileCount && e13.needsFeatureCount && !j2(e13);
  }
  _getMaxRecordCount(e13) {
    const {
      tileMaxRecordCount: t12,
      maxRecordCount: s9
    } = this.context;
    return this._useTileQuery(e13) && null != t12 && t12 > 0 && this.context.capabilities.supportsResultType ? t12 : null != s9 && s9 > 0 ? s9 : S3;
  }
  _useTileQuery(e13) {
    return (!j2(e13) || !this.context.capabilities.supportsCacheHint) && this.context.capabilities.supportsResultType;
  }
  _handleRequest(e13, t12, s9, i8) {
    e13.fetchStatus = e13.needsRefetching ? c8.REFETCHING : c8.FETCHING, e13.requestController = s9;
    let r10 = false;
    t12.then((t13) => {
      e13.requestController = null, e13.fetchStatus = t13;
    }).catch((t13) => {
      e13.requestController === s9 && (e13.requestController = null, e13.fetchStatus = c8.DONE), b(t13) ? r10 = true : i8(t13);
    }).then(() => {
      r10 || this._setDirty(), this._scheduleUpdated();
    });
  }
  _scheduleUpdated() {
    this.hasHandles("scheduleUpdated") || this.addHandles(v(() => {
      this.removeHandles("scheduleUpdated"), this._updated();
    }), "scheduleUpdated");
  }
  _showTile(e13) {
    if (null != e13.displayingFeatures && !e13.needsDisplayUpdate) return false;
    const t12 = e13.features;
    if (0 === e13.featureLimit || !t12) {
      const t13 = null != e13.displayingFeatures && e13.displayingFeatures.length > 0;
      return this._hideTileFeatures(e13), e13.displayingFeatures = [], t13;
    }
    const s9 = e13.descriptor.resolution, i8 = this._changes.updates, r10 = this._changes.adds, a7 = Math.min(e13.featureLimit, t12.length);
    e13.featureLimit = a7;
    for (let n11 = 0; n11 < a7; ++n11) {
      const e14 = t12[n11], a8 = M(e14, this._objectIdField), o9 = this._displayingFeatureReferences.get(a8);
      if (o9) {
        const t13 = o9.ref(e14, s9);
        t13.oldVersion !== t13.newVersion && (t13.oldVersion && i8.removes.push(t13.oldVersion), t13.newVersion && i8.adds.push(t13.newVersion));
      } else this._displayingFeatureReferences.set(a8, new this.FeatureReferenceClass(e14, s9)), r10.push(e14);
      this._numDisplayingFeatureReferences++;
    }
    return this._hideTileFeatures(e13), this._applyChanges(), e13.displayingFeatures = t12.slice(0, a7), true;
  }
  _hideTile(e13) {
    this._cancelFetchTile(e13), this._hideTileFeatures(e13);
  }
  _hideTileFeatures(e13) {
    if (null == e13.displayingFeatures) return;
    const t12 = this._changes.updates, s9 = this._changes.removes;
    for (const i8 of e13.displayingFeatures) {
      const r10 = M(i8, this._objectIdField), a7 = this._displayingFeatureReferences.get(r10);
      if (!a7) continue;
      const n11 = a7.unref(e13.descriptor.resolution);
      this._numDisplayingFeatureReferences--, n11 ? n11.oldVersion !== n11.newVersion && (null == n11.newVersion ? (this._displayingFeatureReferences.delete(r10), n11.oldVersion && s9.push(n11.oldVersion)) : (t12.adds.push(n11.newVersion), n11.oldVersion && t12.removes.push(n11.oldVersion))) : console.error("Hiding unreferenced feature");
    }
    this._applyChanges(), e13.displayingFeatures = null;
  }
  _notifyDataUpdating() {
    this._get("dataUpdating") || this._set("dataUpdating", true);
  }
  _applyChanges() {
    const e13 = this._changes.updates;
    e13.removes.length > 0 && (this._notifyDataUpdating(), this.features.removeMany(e13.removes), e13.removes.length = 0), e13.adds.length > 0 && (this._notifyDataUpdating(), this.features.addMany(e13.adds), e13.adds.length = 0);
    const t12 = this._changes.adds, s9 = this._changes.removes, i8 = Math.min(t12.length, s9.length);
    let r10 = 0;
    for (; r10 < i8; ) {
      const e14 = Math.min(r10 + z2, i8);
      this._notifyDataUpdating(), this.features.addMany(t12.slice(r10, e14)), this.features.removeMany(s9.slice(r10, e14)), r10 = e14;
    }
    t12.length > i8 && (this._notifyDataUpdating(), this.features.addMany(0 === r10 ? t12 : t12.slice(r10))), s9.length > i8 && (this._notifyDataUpdating(), this.features.removeMany(0 === r10 ? s9 : s9.slice(r10))), t12.length = 0, s9.length = 0;
  }
  _clearTile(e13) {
    if (this._hideTile(e13), e13.features && null != this.context.memoryCache) {
      const t12 = 16 + e13.estimatedSize;
      this.context.memoryCache.put(e13.id, e13.cache, t12);
    }
    e13.setFeatures(null, 0, null, void 0), this._invalidateCounts();
  }
  _invalidateCounts() {
    this.notifyChange("totalVertices"), this.notifyChange("totalFeatures"), this.notifyChange("memoryForUnusedFeatures");
  }
  _getListOfTiles() {
    return Array.from(this._featureTiles.values());
  }
  get storedFeatures() {
    return this._getListOfTiles().reduce((e13, t12) => e13 + (t12.features ? t12.features.length : 0), 0);
  }
  get missingTiles() {
    return Array.from(this._featureTiles.values()).reduce((e13, t12) => e13 + (t12.needsFetching || t12.isFetching ? 1 : 0), 0);
  }
  _maximumFeaturesForTile(e13) {
    const t12 = e13.hasPreciseFeatureCount ? e13.numFeatures : 1 / 0, s9 = e13.hasPreciseFeatureCount ? t12 : this.maximumNumberOfFeatures, i8 = this._fullRatio < 1 ? this._farRatio : 1;
    return Math.min(Math.ceil(s9 * i8 / (1 - e13.emptyFeatureRatio)), t12);
  }
  get test() {
  }
};
function j2(e13) {
  return "dummy-tile-full-extent" === e13.id;
}
function O5(e13) {
  let t12 = 0;
  for (const s9 of e13) s9.features && s9.features.length > 0 && s9.alive && (t12 = Math.max(t12, s9.descriptor.lij[0]));
  return t12;
}
function P4(e13) {
  const t12 = e13.capabilities.query;
  return {
    supportsMultipleResolutions: A3(e13),
    supportsPagination: !(!t12 || !t12.supportsPagination),
    supportsResultType: !(!t12 || !t12.supportsResultType),
    supportsCacheHint: !(!t12 || !t12.supportsCacheHint),
    supportsQuantization: !(!t12 || !t12.supportsQuantization),
    supportsQuantizationEditMode: !(!t12 || !t12.supportsQuantizationEditMode),
    supportsMaxRecordCountFactor: !(!t12 || !t12.supportsMaxRecordCountFactor),
    supportsFormatPBF: !(!t12 || !t12.supportsFormatPBF)
  };
}
function A3(e13) {
  switch (e13.geometryType) {
    case "polyline":
      return true;
    case "polygon":
      return e13.capabilities && e13.capabilities.query && e13.capabilities.query.supportsQuantization;
    default:
      return false;
  }
}
function I5(e13) {
  return e13.setFeatures([], 0, null, void 0), e13.featuresMissing = false, c8.DONE;
}
function N2(e13) {
  return null == e13 ? /* @__PURE__ */ new Set() : new Set(e13.map((e14) => e14.name));
}
function q(e13, t12) {
  if (null == e13 || null == t12) return N2(t12);
  const s9 = /* @__PURE__ */ new Set();
  for (const {
    name: i8
  } of t12) e13.has(i8) && s9.add(i8);
  return s9;
}
function L(e13, t12) {
  if (!t12?.length) return e13;
  e13 ??= /* @__PURE__ */ new Map();
  const s9 = () => /* @__PURE__ */ new Set();
  for (const {
    objectId: i8,
    attribute: a7
  } of t12) r2(e13, i8, s9).add(a7);
  return e13;
}
e3([y2({
  constructOnly: true
})], U3.prototype, "features", void 0), e3([y2()], U3.prototype, "tileDescriptors", void 0), e3([y2({
  value: 1 / 0
})], U3.prototype, "maximumNumberOfFeatures", null), e3([y2({
  value: 1
})], U3.prototype, "memoryFactor", null), e3([y2({
  value: 1
})], U3.prototype, "lodFactor", null), e3([y2()], U3.prototype, "useTileCount", null), e3([y2({
  readOnly: true
})], U3.prototype, "updating", null), e3([y2({
  readOnly: true
})], U3.prototype, "dataUpdating", void 0), e3([y2({
  readOnly: true
})], U3.prototype, "running", void 0), e3([y2({
  readOnly: true
})], U3.prototype, "updatingTotal", void 0), e3([y2({
  readOnly: true
})], U3.prototype, "updatingRemaining", void 0), e3([y2({
  readOnly: true
})], U3.prototype, "expectedFeatureDiff", void 0), e3([y2({
  readOnly: true
})], U3.prototype, "memoryForUnusedFeatures", null), e3([y2({
  readOnly: true
})], U3.prototype, "maximumNumberOfFeaturesExceeded", void 0), e3([y2({
  readOnly: true
})], U3.prototype, "totalVertices", null), e3([y2({
  readOnly: true
})], U3.prototype, "totalFeatures", null), e3([y2({
  readOnly: true
})], U3.prototype, "hasAllFeatures", null), e3([y2({
  readOnly: true
})], U3.prototype, "hasFullGeometries", null), e3([y2()], U3.prototype, "filterExtent", null), e3([y2({
  constructOnly: true
})], U3.prototype, "context", void 0), e3([y2()], U3.prototype, "_dirty", void 0), e3([y2()], U3.prototype, "_suspended", void 0), e3([y2()], U3.prototype, "_pendingEdits", void 0), e3([y2()], U3.prototype, "_applyEditsTilesUpdated", void 0), e3([y2()], U3.prototype, "_paused", null), e3([y2()], U3.prototype, "_isFetching", void 0), U3 = e3([a3("esri.views.3d.layers.support.FeatureTileFetcher3D")], U3);
var S3 = 2e3;
var Q = u3();
var H3 = u3();
var V2 = 6e5;
var z2 = 200;

// ../../../node_modules/@arcgis/core/views/3d/layers/support/FeatureTileFetcher3DDebugger.js
var p4 = [[0, 179, 255], [117, 62, 128], [0, 104, 255], [215, 189, 166], [32, 0, 193], [98, 162, 206], [102, 112, 129], [52, 125, 0], [142, 118, 246], [138, 83, 0], [92, 122, 255], [122, 55, 83], [0, 142, 255], [81, 40, 179], [0, 200, 244], [13, 24, 127], [0, 170, 147], [19, 58, 241], [22, 44, 35]];
var y4 = class {
  constructor(e13, t12, s9) {
    this._loadingGraphics = /* @__PURE__ */ new Map(), this._loadedGraphics = /* @__PURE__ */ new Map(), this._pendingGraphics = /* @__PURE__ */ new Map(), this._dataExtentGraphic = null, this._enabled = true, this._tileFetcher = e13, this._view = s9, this._tilingScheme = new f2(t12), this._loadedSymbols = p4.map((e14) => new h2({
      symbolLayers: new V([new h({
        material: {
          color: [e14[0], e14[1], e14[2], 0.6]
        },
        outline: {
          color: "black",
          size: 1
        }
      })])
    })), this._loadingSymbols = [new h2({
      symbolLayers: new V([new h({
        material: {
          color: [200, 200, 200, 0.4]
        },
        outline: {
          color: [30, 30, 30],
          size: 1
        }
      })])
    })], this._pendingSymbols = [new h2({
      symbolLayers: new V([new h({
        material: {
          color: [100, 100, 100, 0.4]
        },
        outline: {
          color: [30, 30, 30],
          size: 1
        }
      })])
    })], this._dataExtentSymbol = new h2({
      symbolLayers: new V([new h({
        material: {
          color: [0, 0, 0, 0]
        },
        outline: {
          color: "green",
          size: 4
        }
      })])
    });
  }
  destroy() {
    this.enabled = false;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e13) {
    this._enabled = e13, this.update();
  }
  update() {
    this._enabled ? (this._synchronizeMaps(this._loadingGraphics, {
      filter: (e13) => e13.isFetching,
      symbols: this._loadingSymbols
    }), this._synchronizeMaps(this._loadedGraphics, {
      filter: (e13) => !e13.isFetching,
      symbols: this._loadedSymbols
    }), this._synchronizeMaps(this._pendingGraphics, {
      filter: (e13) => !e13.isFetching,
      symbols: this._pendingSymbols
    }), this.showDataExtent(this._tileFetcher.filterExtent)) : (this._loadingGraphics.forEach((e13) => {
      this._view.graphics.removeMany(e13);
    }), this._loadingGraphics.clear(), this._loadedGraphics.forEach((e13) => {
      this._view.graphics.removeMany(e13);
    }), this._loadedGraphics.clear(), this._pendingGraphics.forEach((e13) => {
      this._view.graphics.removeMany(e13);
    }), this._pendingGraphics.clear(), this._dataExtentGraphic && (this._view.graphics.remove(this._dataExtentGraphic), this._dataExtentGraphic = null));
  }
  showDataExtent(e13) {
    if (this._dataExtentGraphic && (this._view.graphics.remove(this._dataExtentGraphic), this._dataExtentGraphic = null), null == e13) return;
    const i8 = j.fromExtent(e13);
    this._dataExtentGraphic = new d4({
      geometry: i8,
      symbol: this._dataExtentSymbol
    }), this._view.graphics.add(this._dataExtentGraphic);
  }
  _synchronizeMaps(s9, o9) {
    const a7 = [];
    s9.forEach((e13, t12) => {
      const i8 = this._tileFetcher.test.getFeatureTileById(t12);
      i8 && o9.filter(i8) || (this._view.graphics.removeMany(e13), a7.push(t12));
    }), a7.forEach((e13) => s9.delete(e13)), this._tileFetcher.test.forEachFeatureTile((a8) => {
      if (o9.filter(a8) && !s9.has(a8.id)) {
        const [h7, p5, y5] = a8.descriptor.lij;
        this._tilingScheme.ensureMaxLod(h7);
        const d13 = this._tilingScheme.getExtentGeometry(h7, p5, y5), _5 = [new d4({
          geometry: d13,
          symbol: o9.symbols[h7 % o9.symbols.length]
        }), new d4({
          geometry: d13.center,
          symbol: new w3({
            verticalOffset: new p2({
              screenLength: 40 / 0.75
            }),
            callout: new d3({
              color: new u5("white"),
              border: new m3({
                color: new u5("black")
              })
            }),
            symbolLayers: new V([new z({
              text: `${h7}/${p5}/${y5}`,
              halo: {
                color: "white",
                size: 1 / 0.75
              },
              material: {
                color: "black"
              },
              size: 16
            })])
          })
        })];
        s9.set(a8.id, _5), this._view.graphics.addMany(_5);
      }
    });
  }
};

// ../../../node_modules/@arcgis/core/layers/graphics/controllers/FeatureTileController3D.js
var T2 = class extends n4(S) {
  get dataUpdating() {
    return this._tileFetcher?.dataUpdating ?? false;
  }
  set extent(e13) {
    if (null != e13 && !e13.spatialReference.equals(this.layerView.view.spatialReference)) return void n2.getLogger(this).error("#extent=", "extent needs to be in the same spatial reference as the view");
    const t12 = this._get("extent");
    if (t12 === e13) return;
    if (null != t12 && e13 && t12.equals(e13)) return;
    const i8 = null != e13 ? e13.clone() : null;
    this._set("extent", i8);
  }
  get updating() {
    return !!(null != this._tileFetcher && this._tileFetcher.updating || null != this._fetchDataInfoPromise || "tiles" === this.mode && this.layerView.view.featureTiles && this.layerView.view.featureTiles.updating || this._updatingHandles && this._updatingHandles.updating);
  }
  get updatingTotal() {
    return this.updating && null != this._tileFetcher ? this._tileFetcher.updatingTotal : 0;
  }
  get updatingRemaining() {
    return this.updating && null != this._tileFetcher ? this._tileFetcher.updatingRemaining : 0;
  }
  get expectedFeatureDiff() {
    return this.updating && null != this._tileFetcher ? this._tileFetcher.expectedFeatureDiff : 0;
  }
  get memoryForUnusedFeatures() {
    return null != this._tileFetcher ? this._tileFetcher.memoryForUnusedFeatures : 0;
  }
  get maximumNumberOfFeaturesExceeded() {
    return !(null == this._tileFetcher || !this._tileFetcher.maximumNumberOfFeaturesExceeded);
  }
  get maximumNumberOfFeatures() {
    return this.displayFeatureLimit?.maximumNumberOfFeatures ?? 0;
  }
  set maximumNumberOfFeatures(e13) {
    e13 !== this.maximumNumberOfFeatures && this._overrideIfSome("maximumNumberOfFeatures", e13);
  }
  get hasMaximumNumberOfFeaturesOverride() {
    return this._isOverridden("maximumNumberOfFeatures");
  }
  get hasAllFeatures() {
    return this.serviceDataCount === q2.noServiceDataCount && "snapshot" === this.mode && this.hasAllFeaturesInView || this.serviceDataCount === this.graphics.length;
  }
  get hasAllFeaturesInView() {
    return this._tileFetcher?.hasAllFeatures ?? false;
  }
  get hasFullGeometries() {
    return this._tileFetcher?.hasFullGeometries ?? false;
  }
  get mode() {
    const e13 = this.layerView.layer;
    if ("feature" === e13.type && null != e13.infoFor3D) return "snapshot";
    if ("catalog-footprint" === e13.type) return "tiles";
    if (this._forceTilesMode) return "tiles";
    const t12 = this.layerView.view;
    if (false === t12.qualitySettings?.graphics3D?.snapshotAvailable || this.serviceDataCount === q2.noServiceDataCount || this._snapshotLimitExceeded || this.maximumNumberOfFeaturesExceeded || t12.quality < 1) return "tiles";
    const i8 = t12 && t12.featureTiles, r10 = i8 && i8.tilingScheme;
    if (e13 && e13.minScale && this.serviceDataExtent && r10) {
      const t13 = this._approximateExtentSizeAtScale(e13.minScale, r10);
      if ((this.serviceDataExtent.width / t13 + this.serviceDataExtent.height / t13) / 2 > q2.maxSnapshotMinScaleFactor) return "tiles";
    }
    return !this.maximumNumberOfFeatures || this.serviceDataCount <= this.maximumNumberOfFeatures ? "snapshot" : "tiles";
  }
  get maxTotalSnapshotVertices() {
    const e13 = this._get("maxTotalSnapshotVertices") || 0, t12 = "snapshot" === this.mode && this._tileFetcher?.totalVertices || 0;
    return Math.max(e13, t12);
  }
  _approximateExtentSizeAtScale(e13, t12) {
    const i8 = this.layerView.view, r10 = Math.ceil((i8.width / t12.pixelSize + i8.height / t12.pixelSize) / 2), s9 = t12.levels[0];
    return r10 * ((s9.tileSize[0] / (s9.scale / e13) + s9.tileSize[1] / (s9.scale / e13)) / 2);
  }
  get tileDescriptors() {
    const e13 = this.layerView.view.featureTiles;
    return "snapshot" === this.mode ? new V([{
      id: "dummy-tile-full-extent",
      lij: [0, 0, 0]
    }]) : e13 ? e13.tiles : new V();
  }
  get test() {
  }
  constructor(e13) {
    super(e13), this.type = "feature-tile-3d", this._updatingHandles = new h3(), this.serviceDataExtent = null, this.serviceDataCount = q2.noServiceDataCount, this._snapshotLimitExceeded = false, this.displayFeatureLimit = null, this._forceTilesMode = false, this._suspended = false, this._tileFetcher = null, this._fetchDataInfoPromise = null, this._fetchDataInfoAbortController = null, this._lifeCycleAbortController = new AbortController();
  }
  initialize() {
    this._updatingHandles.add(() => this.displayFeatureLimit, (e13) => this._updatingHandles.addPromise(this._updateSnapshotLimit(e13, null, this._lifeCycleAbortController.signal))), this._updatingHandles.add(() => this.mode, () => this._modeChanged(), P), this._updatingHandles.add(() => this.mode, (e13, t12) => {
      "tiles" === e13 && "snapshot" === t12 && (this._forceTilesMode = true);
    }, P), this.addResolvingPromise(Promise.resolve().then(() => this._verifyCapabilities()).then(() => this._updatingHandles.addPromise(this._fetchServiceDataInfo())).then(() => this._initializeTileFetcher()));
  }
  _verifyCapabilities() {
    const e13 = this.layerView.layer;
    if ("ogc-feature" !== e13.type && !O3(e13)?.operations.supportsQuery) throw new s("graphicscontroller:query-capability-required", "Service requires query capabilities to be used as a feature layer", {
      layer: e13
    });
  }
  destroy() {
    this._cancelFetchServiceDataInfo(), this._tileFetcher = u(this._tileFetcher), this._tilesHandle = l(this._tilesHandle), this._lifeCycleAbortController = e(this._lifeCycleAbortController), this._updatingHandles.destroy(), this._set("_updatingHandles", null);
  }
  suspend() {
    this._suspended || (this._suspended = true, null != this._tileFetcher && this._tileFetcher.suspend());
  }
  resume() {
    this._suspended && (this._suspended = false, null != this._tileFetcher && this._tileFetcher.resume());
  }
  restart() {
    const e13 = () => {
      null != this._tileFetcher && this._tileFetcher.restart();
    };
    this._updatingHandles.addPromise(this._fetchServiceDataInfo().then(e13, e13));
  }
  refetch() {
    this._refetch({
      resetForceTilesMode: false
    });
  }
  getMissingAttributesForFeature(e13) {
    return this._tileFetcher?.getMissingAttributesForFeature(e13);
  }
  _refetch(e13) {
    const t12 = () => {
      null != this._tileFetcher && (e13.resetForceTilesMode && (this._forceTilesMode = false), this._tileFetcher.refetch());
    };
    this._updatingHandles.addPromise(this._fetchServiceDataInfo().then(t12, t12));
  }
  _initializeTileFetcher() {
    const e13 = this.layerView.view;
    if (!e13) return;
    const t12 = w(() => e13.featureTiles?.tilingScheme, this._lifeCycleAbortController.signal);
    this._updatingHandles.addPromise(t12), t12.then(() => {
      const {
        layerView: e14,
        tileDescriptors: t13
      } = this, i8 = e14.layer, r10 = new U3({
        context: this.context,
        filterExtent: this.extent,
        tileDescriptors: t13,
        features: this.graphics
      });
      this._tileFetcher = r10, this._suspended ? r10.suspend() : r10.resume();
      const s9 = this.layerView.view;
      s9 && this.addHandles(d2(() => s9.quality, (e15) => r10.memoryFactor = e15, A));
      const a7 = "polygon" === this.context.geometryType ? "polygonLodFactor" : "polyline" === this.context.geometryType ? "polylineLodFactor" : null;
      a7 && this.addHandles(d2(() => this.layerView.view?.qualitySettings?.graphics3D?.[a7], (e15) => r10.lodFactor = e15 || 1, P));
      const o9 = (e15) => {
        r10.maximumNumberOfFeatures = e15, r10.useTileCount = this.serviceDataCount > e15;
      }, l7 = (e15) => {
        r10.useTileCount = e15 > this.maximumNumberOfFeatures;
      };
      "ogc-feature" !== i8.type && this._updatingHandles.add(() => i8.createQueryVersion, () => this._dataFilterChanged()), this._updatingHandles.add(() => e14.availableFields, (e15, t14) => this._availableFieldsChanged(t14, e15)), this._updatingHandles.add(() => e14.requiredFields, (e15, t14) => this._requiredFieldsChanged(t14, e15)), "customParameters" in i8 && this._updatingHandles.add(() => i8.customParameters, () => this.restart()), this.addHandles([i8.on("apply-edits", (e15) => this._applyEdits(e15)), d2(() => this.extent, (e15) => r10.filterExtent = e15, C), d2(() => this.tileDescriptors, (e15) => r10.tileDescriptors = e15, C), d2(() => this.maximumNumberOfFeatures, o9, A), d2(() => this.serviceDataCount, l7, A), d2(() => t7.FEATURE_TILE_FETCH_SHOW_TILES, (e15) => {
        e15 && r10 && !r10.debugger ? (r10.debugger = new y4(r10, s9.featureTiles.tilingScheme.toTileInfo(), s9), r10.debugger.update()) : !e15 && this._tileFetcher && r10.debugger && (r10.debugger.destroy(), r10.debugger = null);
      }, A)]), this._supportsExceedsLimitQuery || this._updatingHandles.add(() => this.maxTotalSnapshotVertices, () => this._updatingHandles.addPromise(this._updateSnapshotLimit(this.displayFeatureLimit, null, this._lifeCycleAbortController.signal)));
    }).catch(() => {
    });
  }
  _modeChanged() {
    switch (this.mode) {
      case "tiles":
        this._tilesHandle || (this._tilesHandle = this.layerView.view.featureTiles.addClient());
        break;
      default:
        n2.getLogger(this).warn("Unhandled feature layer mode " + this.mode);
      case "snapshot":
        null != this._tilesHandle && (this._tilesHandle.remove(), this._tilesHandle = null);
    }
  }
  _dataFilterChanged() {
    this._set("maxTotalSnapshotVertices", 0), this.notifyChange("maxTotalSnapshotVertices"), this._refetch({
      resetForceTilesMode: true
    });
  }
  _applyEdits(e13) {
    const t12 = this.layerView.layer;
    null != this._tileFetcher && this._tileFetcher.applyEdits(e13).then((e14) => {
      if (e14) {
        if (!this._lifeCycleAbortController) throw u2();
        e14.exceededTransferLimit && "refresh" in t12 ? t12.refresh() : (e14.deletedFeatures.length || e14.updatedFeatures.length || e14.addedFeatures.length) && this._updatingHandles.addPromise(this._updateServiceDataExtent(this._lifeCycleAbortController.signal));
      }
    }).catch((e14) => {
      if (!b(e14)) throw e14;
    });
  }
  _availableFieldsChanged(e13, t12) {
    null != this._tileFetcher && A4(this._tileFetcher.availableFields, t12) && this._refetch({
      resetForceTilesMode: false
    });
  }
  _requiredFieldsChanged(e13, t12) {
    null != this._tileFetcher && A4(this._tileFetcher.availableFields, t12) && this.restart();
  }
  _createVertexLimitExceededQuery(e13) {
    const t12 = this.layerView.layer, i8 = t12.createQuery();
    return i8.returnGeometry = false, i8.outStatistics = [new m4({
      statisticType: "exceedslimit",
      maxVertexCount: e13,
      outStatisticFieldName: "exceedslimit",
      maxPointCount: 1e8,
      maxRecordCount: 1e8
    })], t12.capabilities?.query.supportsCacheHint && (i8.cacheHint = true), i8;
  }
  _createDataInfoQuery() {
    const e13 = this.layerView.layer, t12 = e13.createQuery();
    return t12.returnGeometry = false, t12.outSpatialReference = this.layerView.view.spatialReference, e13.capabilities?.query.supportsCacheHint && (t12.cacheHint = true), t12;
  }
  _fullExtentIsAccurate() {
    const e13 = this.layerView.layer;
    if ("definitionExpression" in e13 && e13.definitionExpression) return false;
    switch (e13.type) {
      case "feature":
      case "catalog-footprint":
      case "oriented-imagery":
        return g2(e13.url);
      case "csv":
      case "geojson":
      case "ogc-feature":
      case "wfs":
        return true;
      default:
        return;
    }
  }
  _updateServiceDataExtent(e13) {
    return __async(this, null, function* () {
      try {
        yield this._tryUpdateServiceDataExtent(e13);
      } catch (t12) {
        b(t12) || this._set("serviceDataExtent", a(this.layerView.fullExtentInLocalViewSpatialReference));
      }
    });
  }
  _tryUpdateServiceDataExtent(e13) {
    return __async(this, null, function* () {
      const t12 = this.layerView, i8 = t12.layer, r10 = i8.capabilities?.query.supportsExtent ?? false, s9 = a(t12.fullExtentInLocalViewSpatialReference), o9 = i8.fullExtent, l7 = this._fullExtentIsAccurate(), n11 = this.serviceDataCount;
      if (r10 && n11 <= q2.maxFeatureCountForExtent && (!s9 || !l7) && "queryExtent" in i8) {
        const t13 = this._createDataInfoQuery(), r11 = yield i8.queryExtent(t13, {
          timeout: q2.queryExtentTimeout,
          signal: e13
        });
        this._set("serviceDataExtent", r11.extent);
      } else if (s9) this._set("serviceDataExtent", s9);
      else if (null != o9) {
        const r11 = "portalItem" in i8 ? i8.portalItem : null, s10 = yield a5(o9, t12.view.spatialReference, r11, e13);
        this._set("serviceDataExtent", s10);
      } else this._set("serviceDataExtent", null);
    });
  }
  _updateServiceDataCount(e13) {
    return __async(this, null, function* () {
      const t12 = this.layerView.layer;
      if (!("queryFeatureCount" in t12) || !has("featurelayer-snapshot-enabled")) return void this._set("serviceDataCount", q2.noServiceDataCount);
      const r10 = yield _(t12.queryFeatureCount(this._createDataInfoQuery(), {
        timeout: q2.queryStatisticsTimeout,
        signal: e13
      }));
      if (true === r10.ok) this._set("serviceDataCount", r10.value);
      else {
        if (b(r10.error)) throw r10.error;
        this._set("serviceDataCount", q2.noServiceDataCount);
      }
    });
  }
  get _supportsExceedsLimitQuery() {
    const e13 = this.layerView.layer;
    return null != e13.capabilities && e13.capabilities.operations && e13.capabilities.operations.supportsExceedsLimitStatistics;
  }
  get _minimumNumberOfVerticesForGeometry() {
    switch (this.layerView.layer.geometryType) {
      case "point":
      case "multipoint":
        return 1;
      case "polygon":
        return 4;
      case "polyline":
        return 2;
      case "multipatch":
      case "mesh":
        return 3;
      default:
        return 0;
    }
  }
  _updateSnapshotLimit(e13, t12, r10) {
    return __async(this, null, function* () {
      if (null == e13?.averageSymbolComplexity) return void (this._snapshotLimitExceeded = false);
      const {
        maximumTotalNumberOfVertices: s9,
        averageSymbolComplexity: a7
      } = e13, {
        verticesPerFeature: o9,
        verticesPerCoordinate: l7
      } = a7, n11 = o9 <= 0, u11 = this._minimumNumberOfVerticesForGeometry > 1;
      if (!n11 && !u11) return void (this._snapshotLimitExceeded = false);
      0 !== o9 && null != t12 && (yield t12);
      const h7 = Math.min(s9, H4), c9 = this.serviceDataCount, p5 = c9 !== q2.noServiceDataCount;
      let m9 = p5 ? Math.ceil((h7 - c9 * o9) / (l7 || 1)) : Math.ceil(h7 / (l7 || 1));
      if (u11 && (m9 = Math.min(m9, L2)), p5 && this._minimumNumberOfVerticesForGeometry * c9 > m9) return void (this._snapshotLimitExceeded = true);
      if (!this._supportsExceedsLimitQuery || !has("featurelayer-snapshot-enabled")) return void (this._snapshotLimitExceeded = this.maxTotalSnapshotVertices > m9);
      const f5 = yield _(this.layerView.layer.queryFeatures(this._createVertexLimitExceededQuery(m9), {
        timeout: q2.queryStatisticsTimeout,
        signal: r10
      }));
      if (false === f5.ok) {
        if (b(f5.error)) throw f5.error;
        return void (this._snapshotLimitExceeded = false);
      }
      const y5 = f5.value.features[0];
      this._snapshotLimitExceeded = !!y5?.attributes && !!y5.attributes.exceedslimit;
    });
  }
  _fetchServiceDataInfo() {
    return __async(this, null, function* () {
      this._cancelFetchServiceDataInfo();
      let e13 = new AbortController();
      const t12 = e13.signal, i8 = this._updateServiceDataCount(t12), r10 = Promise.allSettled([i8, this._updateSnapshotLimit(this.displayFeatureLimit, i8, t12)]), s9 = r10.then(() => this._updateServiceDataExtent(t12)).catch((e14) => {
        b(e14) || n2.getLogger(this).error("#fetchServiceDataInfo()", e14);
      }).then(() => {
        s9 === this._fetchDataInfoPromise && (this._fetchDataInfoPromise = null, this._fetchDataInfoAbortController = null), e13 = null;
      });
      return e13 && (this._fetchDataInfoPromise = s9), this._fetchDataInfoAbortController = e13, r10.then(() => {
      }, () => {
      });
    });
  }
  _cancelFetchServiceDataInfo() {
    const e13 = this._fetchDataInfoAbortController;
    e13 && (this._fetchDataInfoAbortController = null, this._fetchDataInfoPromise = null, e13.abort());
  }
  get performanceInfo() {
    return {
      storedFeatures: this._tileFetcher?.storedFeatures ?? 0,
      totalFeatures: this._tileFetcher?.totalFeatures ?? 0,
      totalVertices: this._tileFetcher?.totalVertices ?? 0,
      missingTiles: this._tileFetcher?.missingTiles ?? 0
    };
  }
};
e3([y2({
  readOnly: true
})], T2.prototype, "type", void 0), e3([y2({
  constructOnly: true
})], T2.prototype, "graphics", void 0), e3([y2({
  constructOnly: true
})], T2.prototype, "layerView", void 0), e3([y2({
  constructOnly: true
})], T2.prototype, "context", void 0), e3([y2({
  readOnly: true
})], T2.prototype, "dataUpdating", null), e3([y2()], T2.prototype, "extent", null), e3([y2()], T2.prototype, "updating", null), e3([y2({
  readOnly: true
})], T2.prototype, "_updatingHandles", void 0), e3([y2()], T2.prototype, "updatingTotal", null), e3([y2()], T2.prototype, "updatingRemaining", null), e3([y2()], T2.prototype, "expectedFeatureDiff", null), e3([y2()], T2.prototype, "memoryForUnusedFeatures", null), e3([y2()], T2.prototype, "maximumNumberOfFeaturesExceeded", null), e3([y2({
  readOnly: true
})], T2.prototype, "serviceDataExtent", void 0), e3([y2({
  readOnly: true
})], T2.prototype, "serviceDataCount", void 0), e3([y2()], T2.prototype, "_snapshotLimitExceeded", void 0), e3([y2()], T2.prototype, "displayFeatureLimit", void 0), e3([y2({
  type: Number
})], T2.prototype, "maximumNumberOfFeatures", null), e3([y2({
  readOnly: true
})], T2.prototype, "hasAllFeatures", null), e3([y2({
  readOnly: true
})], T2.prototype, "hasAllFeaturesInView", null), e3([y2({
  readOnly: true
})], T2.prototype, "hasFullGeometries", null), e3([y2()], T2.prototype, "_forceTilesMode", void 0), e3([y2({
  readOnly: true
})], T2.prototype, "mode", null), e3([y2({
  readOnly: true
})], T2.prototype, "maxTotalSnapshotVertices", null), e3([y2({
  readOnly: true
})], T2.prototype, "tileDescriptors", null), e3([y2()], T2.prototype, "_tileFetcher", void 0), e3([y2()], T2.prototype, "_fetchDataInfoPromise", void 0), T2 = e3([a3("esri.layers.graphics.controllers.FeatureTileController3D")], T2);
var V3 = 1e4;
var H4 = 1e6;
var O6 = 12e3;
var I6 = 1e4;
var L2 = 5e6;
function A4(e13, t12) {
  if (!t12) return false;
  for (const i8 of t12) if (!e13.has(i8)) return true;
  return false;
}
var q2;
!function(e13) {
  function t12() {
    e13.maxFeatureCountForExtent = V3, e13.queryStatisticsTimeout = O6, e13.queryExtentTimeout = I6;
  }
  e13.noServiceDataCount = 1 / 0, e13.maxSnapshotMinScaleFactor = 5, e13.reset = t12;
}(q2 || (q2 = {})), q2.reset();

// ../../../node_modules/@arcgis/core/views/3d/webgl-engine/shaders/HeatmapTechnique.js
var h5 = class extends n8 {
  constructor() {
    super(...arguments), this.colorRamp = null, this.densityMap = null, this.searchRadius = 1, this.fieldTotal = 0, this.minDensity = 0, this.maxDensity = 100;
  }
};
var d10 = class _d extends r4 {
  constructor(e13, r10) {
    super(e13, r10, () => this.destroy());
  }
  initializeProgram(e13) {
    return new r5(e13.rctx, _d.shader.get().build(this.configuration), O4);
  }
  initializePipeline() {
    return S2({
      blending: A2,
      colorWrite: _3,
      depthTest: null,
      depthWrite: null
    });
  }
  get primitiveType() {
    return E2.TRIANGLE_STRIP;
  }
};
d10.shader = new t6(a6, () => import("./Heatmap.glsl-XGOJPPSG.js"));
var f3 = class extends t8 {
  constructor() {
    super(...arguments), this.usesHalfFloat = false;
  }
};
e3([r6()], f3.prototype, "usesHalfFloat", void 0);

// ../../../node_modules/@arcgis/core/views/3d/webgl-engine/lib/DrapedHeatmapRenderer.js
var x3 = class extends G2 {
  constructor(t12) {
    super(t12), this.pixelRatio = 1, this._colorRampData = new Uint8ClampedArray(4), this.type = "draped-heatmap", this._heatmapParameters = new h5();
    const e13 = new e9();
    e13.pixelFormat = t12.pixelFormat, e13.internalFormat = t12.internalFormat, e13.dataType = t12.dataType, e13.samplingMode = t12.samplingMode, e13.wrapMode = D.CLAMP_TO_EDGE;
    const r10 = t12.rendererContext.rctx;
    this._densityMap = new E3(r10, e13), this._quad = i6(r10);
    const a7 = new f3();
    a7.usesHalfFloat = t12.dataType !== U2.FLOAT, this._technique = new d10({
      rctx: r10,
      viewingMode: l2.Local
    }, a7);
  }
  initialize() {
    const t12 = this._colorRampData, e13 = new e9(t12.length / 4, 1);
    e13.wrapMode = D.CLAMP_TO_EDGE, this._colorRamp = new c4(this.rctx, e13, t12), this._heatmapParameters.densityMap = this._densityMap.colorTexture, this.addHandles(d2(() => [this.colorRampData, this.minDensity, this.maxDensity, this.fieldTotal, this.pixelRatio, this.searchRadius], () => this.rendererContext.notifyContentChanged()));
  }
  destroy() {
    this._technique = t2(this._technique), this._densityMap = r(this._densityMap), this._quad = r(this._quad), this._colorRamp = r(this._colorRamp);
  }
  get searchRadius() {
    return this._heatmapParameters.searchRadius;
  }
  set searchRadius(t12) {
    t12 !== this._heatmapParameters.searchRadius && (this._heatmapParameters.searchRadius = t12, this.notifyChange("searchRadius"));
  }
  get minDensity() {
    return this._heatmapParameters.minDensity;
  }
  set minDensity(t12) {
    t12 !== this._heatmapParameters.minDensity && (this._heatmapParameters.minDensity = t12, this.notifyChange("minDensity"));
  }
  get maxDensity() {
    return this._heatmapParameters.maxDensity;
  }
  set maxDensity(t12) {
    t12 !== this._heatmapParameters.maxDensity && (this._heatmapParameters.maxDensity = t12, this.notifyChange("maxDensity"));
  }
  get fieldTotal() {
    return this._heatmapParameters.fieldTotal;
  }
  set fieldTotal(t12) {
    this._heatmapParameters.fieldTotal = t12, this.notifyChange("fieldTotal");
  }
  get colorRampData() {
    return this._colorRampData;
  }
  set colorRampData(t12) {
    const {
      colorRamp: e13
    } = this._heatmapParameters;
    if (null != e13 && t12 !== this._colorRampData) {
      const r10 = e13.descriptor.width, a7 = t12.length / 4;
      a7 !== r10 && e13.resize(a7, 1), e13.setData(t12);
    }
    this._colorRampData = t12;
  }
  get _colorRamp() {
    return this._heatmapParameters.colorRamp;
  }
  set _colorRamp(t12) {
    this._heatmapParameters.colorRamp = t12;
  }
  get hasHighlights() {
    return false;
  }
  get hasWater() {
    return false;
  }
  get rendersOccludedDraped() {
    return false;
  }
  render(t12) {
    const e13 = this._sortedMaterialRenderers;
    if (0 === e13.length) return;
    const r10 = this.rctx.getBoundFramebufferObject(), a7 = this.rctx.getViewport(), {
      pixelRatio: i8
    } = this, s9 = Math.ceil(a7.width * i8), o9 = Math.ceil(a7.height * i8);
    this._densityMap.resize(s9, o9), this.rctx.bindFramebuffer(this._densityMap), this.rctx.setViewport(0, 0, s9, o9), this.rctx.clear(_2.COLOR_BUFFER_BIT);
    let n11 = false;
    e13.forAll((e14) => {
      const r11 = e14.prepareTechnique(t12);
      null != r11 && (e14.renderNode(t12, r11), n11 = true);
    }), this.rctx.bindFramebuffer(r10), this.rctx.setViewport(a7.x, a7.y, a7.width, a7.height), n11 && (this.rctx.bindVAO(this._quad), this.rctx.bindTechnique(this._technique, t12.bindParameters, this._heatmapParameters), this.rctx.drawArrays(this._technique.primitiveType, 0, i3(this._quad, "geometry")));
  }
};
e3([y2()], x3.prototype, "searchRadius", null), e3([y2()], x3.prototype, "minDensity", null), e3([y2()], x3.prototype, "maxDensity", null), e3([y2()], x3.prototype, "fieldTotal", null), e3([y2()], x3.prototype, "pixelRatio", void 0), e3([y2()], x3.prototype, "colorRampData", null), e3([y2({
  constructOnly: true
})], x3.prototype, "dataType", void 0), e3([y2({
  constructOnly: true
})], x3.prototype, "samplingMode", void 0), e3([y2({
  constructOnly: true
})], x3.prototype, "pixelFormat", void 0), e3([y2({
  constructOnly: true
})], x3.prototype, "internalFormat", void 0), e3([y2()], x3.prototype, "_colorRampData", void 0), x3 = e3([a3("esri.views.3d.webgl-engine.lib.DrapedHeatmapRenderer")], x3);

// ../../../node_modules/@arcgis/core/views/3d/webgl-engine/shaders/HeatmapDensityTechnique.js
var d11 = class extends u6 {
  constructor() {
    super(...arguments), this.searchRadius = 128, this.resolutionForScale = 0;
  }
};
var f4 = class _f extends r4 {
  initializeProgram(e13) {
    return new r5(e13.rctx, _f.shader.get().build(this.configuration), O4);
  }
  initializePipeline() {
    return S2({
      blending: s4(R.ONE, R.ONE, T.ADD),
      colorWrite: _3,
      depthTest: null,
      depthWrite: null
    });
  }
  destroy() {
    super.destroy();
  }
};
f4.shader = new t6(s7, () => import("./HeatmapDensity.glsl-ADZADTZQ.js"));
var b5 = class extends t8 {
  constructor() {
    super(...arguments), this.isAttributeDriven = false, this.usesHalfFloat = false;
  }
};
e3([r6()], b5.prototype, "isAttributeDriven", void 0), e3([r6()], b5.prototype, "usesHalfFloat", void 0);

// ../../../node_modules/@arcgis/core/views/3d/webgl-engine/materials/HeatmapDensityMaterial.js
var h6 = 2;
var b6 = class extends d11 {
  constructor() {
    super(...arguments), this.isAttributeDriven = false, this.usesHalfFloats = false;
  }
};
var T3 = class extends c5 {
  constructor(t12) {
    super(t12, new b6()), this.produces = /* @__PURE__ */ new Map([[E4.DRAPED_MATERIAL, (t13) => t13 === o3.Color]]), this._configuration = new b5();
  }
  getConfiguration() {
    return this._configuration.isAttributeDriven = this.parameters.isAttributeDriven, this._configuration.usesHalfFloat = this.parameters.usesHalfFloats, this._configuration;
  }
  createGLMaterial(t12) {
    return new d12(t12);
  }
  intersect() {
  }
  intersectDraped(r10, s9, i8, a7, o9, n11) {
    const l7 = r10.attributes.get(e8.POSITION), {
      parameters: c9
    } = this, {
      searchRadius: f5
    } = c9, {
      screenToWorldRatio: m9
    } = r10, p5 = f5 * m9 + h6 * m9, b7 = p5 * p5, T4 = l7.data.length / l7.size;
    for (let u11 = 0; u11 < T4; u11++) {
      const r11 = u11 * l7.size, s10 = o5(E7, l7.data[r11], l7.data[r11 + 1]);
      b3(s10, a7) < b7 && o9(n11.dist, n11.normal, -1, false);
    }
  }
  createBufferWriter() {
    return new g4(this.parameters.isAttributeDriven ? I7 : A5);
  }
};
var d12 = class extends t5 {
  beginSlot(t12) {
    return this.ensureTechnique(f4, t12);
  }
};
var g4 = class {
  constructor(t12) {
    this.vertexBufferLayout = t12;
  }
  elementCount(t12) {
    return t12.attributes.get(e8.POSITION).indices.length * v3;
  }
  write(t12, e13, r10, s9, i8) {
    b4(r10.attributes.get(e8.POSITION), t12, s9.position, i8, v3);
    const a7 = r10.attributes.get(e8.POSITION).indices.length, o9 = s9.uv0;
    let n11 = i8;
    for (let u11 = 0; u11 < a7; ++u11) o9.setValues(n11++, -1, -1), o9.setValues(n11++, 1, -1), o9.setValues(n11++, 1, 1), o9.setValues(n11++, 1, 1), o9.setValues(n11++, -1, 1), o9.setValues(n11++, -1, -1);
    const f5 = e8.FEATUREATTRIBUTE in s9 ? s9.featureAttribute : null;
    f5 && d8(r10.attributes.get(e8.FEATUREATTRIBUTE), f5, i8, v3);
  }
};
var A5 = H().vec3f(e8.POSITION).vec2f(e8.UV0);
var I7 = A5.clone().f32(e8.FEATUREATTRIBUTE);
var v3 = 6;
var E7 = n7();

// ../../../node_modules/@arcgis/core/views/3d/layers/support/HeatmapFeatureProcessor.js
var $2 = 112;
var q3 = class extends S {
  constructor(e13) {
    super(e13), this.type = "heatmap", this.preferredUpdatePolicy = C2.ASYNC, this.dataExtent = null, this.drapeSourceType = e11.Features, this._renderGeometries = /* @__PURE__ */ new Map(), this._fieldTotal = 0, this._drapeSourceRenderer = null, this._dataType = U2.HALF_FLOAT, this._pixelFormat = G.RGBA, this._updatingHandles = new h3(), this.initializePromise = Promise.resolve();
  }
  initialize() {
    this._featureStore = new m5({
      geometryType: "esriGeometryPoint",
      hasZ: this.hasZ,
      hasM: this.hasM
    });
    const {
      dataType: e13,
      samplingMode: t12,
      pixelFormat: r10,
      internalFormat: i8
    } = n9(this._renderView.renderingContext, n2.getLogger(this));
    this._dataType = e13, this._pixelFormat = r10;
    const a7 = e13 !== U2.FLOAT;
    this._drapeSourceRenderer = this.view.basemapTerrain.overlayManager.registerDrapeSource(this, x3, __spreadProps(__spreadValues({}, this._rendererParameters), {
      dataType: e13,
      samplingMode: t12,
      pixelFormat: r10,
      internalFormat: i8
    })), this._material = new T3({
      usesHalfFloats: a7
    }), this._materialWithField = new T3({
      usesHalfFloats: a7,
      isAttributeDriven: true
    }), this._filterVisibility = new y3({
      context: {
        configuration: this.owner,
        featureStore: this.featureStore,
        getFeatureCount: () => this._loadedPointGraphics.length,
        setAllFeaturesVisibility: (e14) => this._setAllFeaturesVisibility(e14),
        clearFeaturesVisibility: () => this._setAllFeaturesVisibility(true),
        updateFeatureVisibilities: (e14) => this._updateFeatureVisibilities(e14)
      }
    }), this._updatingHandles.addOnCollectionChange(() => this._loadedPointGraphics, (e14) => this._onLoadedFeaturesChange(e14), P), this._updatingHandles.addWhen(() => this._materialParameters, (e14) => this._forEachMaterial((t13) => t13.setParameters(e14)), P), this._updatingHandles.add(() => this._rendererParameters, (e14) => this._drapeSourceRenderer.set(e14)), this._updatingHandles.add(() => this._heatmapRendererField, () => {
      this._recreate();
    }, C), this._updatingHandles.add(() => ({
      fieldName: this._heatmapRendererFieldName,
      numeric: this._heatmapRendererFieldIsNumeric
    }), ({
      fieldName: e14,
      numeric: t13
    }) => {
      if (null != e14 && t13) {
        let t14 = 0;
        this._featureStore.forEach((r11) => t14 += r11.attributes[e14] ?? 0), this._fieldTotal = t14;
      } else this._fieldTotal = this._featureStore.numFeatures;
    }, P), this.addHandles([d2(() => ({
      fieldName: this._heatmapRendererFieldName,
      field: this._heatmapRendererField
    }), ({
      fieldName: e14,
      field: t13
    }) => {
      e14 && !t13 && n2.getLogger(this).warn(`Heatmap renderer field '${e14}' for layer '${this.layer.title ?? this.layer.id}' not found`);
    }), d2(() => ({
      field: this._heatmapRendererField,
      numeric: this._heatmapRendererFieldIsNumeric
    }), ({
      field: e14,
      numeric: t13
    }) => {
      null == e14 || t13 || n2.getLogger(this).warn(`Heatmap renderer field '${e14.name}' for layer '${this.layer.title ?? this.layer.id}' does not contain numeric values and cannot be used to drive the heatmap density`);
    }), e2(() => this.view.basemapTerrain.overlayManager.unregisterDrapeSource(this))]);
  }
  destroy() {
    this._renderGeometries.clear(), this._material = null, this._materialWithField = null, this._featureStore.clear(), this._featureStore = null, this._updatingHandles.destroy();
  }
  get layer() {
    return this.owner.layer;
  }
  get featureStore() {
    return this._featureStore;
  }
  get updating() {
    return this._updatingHandles.updating || this.filterVisibility.updating;
  }
  get updatingRemaining() {
    return 0;
  }
  get suspendInfo() {
    return {};
  }
  get legendEnabled() {
    return true;
  }
  get filterVisibility() {
    return this._filterVisibility;
  }
  get displayFeatureLimit() {
    const e13 = this.owner?.view?.quality ?? 1, t12 = this.owner?.view?.qualitySettings, r10 = t12 ? Math.ceil(t12.heatmap.maxTotalNumberOfFeatures * e13) : 0;
    return new e12(r10 * 6, r10);
  }
  get hasZ() {
    return "hasZ" in this.layer && this.layer.hasZ;
  }
  get hasM() {
    return "hasM" in this.layer && this.layer.hasM;
  }
  get view() {
    return this.owner.view;
  }
  get fullOpacity() {
    return this.owner.fullOpacity;
  }
  get updatePolicy() {
    return this.owner.updatePolicy;
  }
  get scaleVisibilitySuspended() {
    if (!this._isScaleRangeActive) return false;
    const {
      minScale: e13,
      maxScale: t12
    } = this.layer.effectiveScaleRange, {
      scale: r10
    } = this.view;
    return !t9(r10, e13 ?? 0, t12 ?? 0);
  }
  get usedMemory() {
    const e13 = this.usedMemoryPerFeature * this._featureStore.numFeatures, t12 = this._pixelFormat === G.RED ? 1 : 4, r10 = this._dataType === U2.FLOAT ? 4 : 2, i8 = Math.ceil((this._overlayRenderer?.overlays[0]?.resolution ?? 0) * this._densityMapPixelRatio) ?? 0;
    return i8 * i8 * t12 * r10 + e13;
  }
  get usedMemoryPerFeature() {
    const e13 = this._loadedPointGraphics.find(() => true);
    if (null == e13) return 0;
    const t12 = t(e13), r10 = n(), o9 = 6;
    return o9 * c([0, 0, 0], r10) + o9 * c([0, 0], r10) + (this._heatmapRendererFieldIsNumeric ? o9 * r10 : 0) + t12;
  }
  get loadedFeatures() {
    return this._featureStore.numFeatures;
  }
  get unprocessedMemoryEstimate() {
    return 0;
  }
  get performanceInfo() {
    return new s5(this._visibleFeatures, 0, 0);
  }
  get renderer() {
    return this._heatmapRenderer;
  }
  get _overlayRenderer() {
    return this.view.basemapTerrain.overlayManager.renderer;
  }
  get _overlaySpatialReference() {
    return this._overlayRenderer.spatialReference;
  }
  get _rendererParameters() {
    return __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, this._radiusParameter), this._densityParameters), this._colorRampParameter), this._pixelRatioParameter);
  }
  get _materialParameters() {
    return __spreadValues(__spreadValues({}, this._radiusParameter), this._resolutionForScaleParameter);
  }
  get _densityParameters() {
    const e13 = this._heatmapRenderer;
    if (null == e13) return null;
    const {
      minDensity: t12,
      maxDensity: r10
    } = e13;
    return {
      minDensity: t12,
      maxDensity: r10,
      fieldTotal: this._fieldTotal
    };
  }
  get _radiusParameter() {
    const e13 = this._heatmapRenderer;
    return e13 ? {
      searchRadius: u4(this._clampSearchRadius(e13.radius))
    } : null;
  }
  get _resolutionForScaleParameter() {
    const e13 = this._heatmapRenderer;
    if (!e13) return null;
    const {
      referenceScale: t12
    } = e13;
    return {
      resolutionForScale: 0 === t12 ? 0 : o6(t12, this.view.spatialReference)
    };
  }
  get _colorRampParameter() {
    const e13 = this._heatmapRenderer;
    return e13 ? {
      colorRampData: f(e13.colorStops)
    } : null;
  }
  get _pixelRatioParameter() {
    return {
      pixelRatio: this._densityMapPixelRatio
    };
  }
  get _densityMapPixelRatio() {
    return this.owner?.view?.qualitySettings.heatmap.pixelRatio ?? 1;
  }
  get _renderView() {
    return this.view._stage.renderView;
  }
  get _featuresArePoints() {
    return "point" === this.layer.geometryType;
  }
  get _loadedPointGraphics() {
    return this.owner.loadedGraphics;
  }
  get _heatmapRenderer() {
    const e13 = this.layer.renderer;
    return "heatmap" === e13?.type ? e13 : null;
  }
  get _heatmapRendererFieldName() {
    return this._heatmapRenderer?.field;
  }
  get _heatmapRendererField() {
    const e13 = this._heatmapRendererFieldName;
    return null != e13 ? this.layer.fieldsIndex.get(e13) : null;
  }
  get _heatmapRendererFieldIsNumeric() {
    const e13 = this._heatmapRendererField;
    return null != e13 && pe(e13);
  }
  get _isScaleRangeActive() {
    const {
      layer: e13
    } = this;
    if (!("effectiveScaleRange" in e13)) return false;
    const {
      minScale: t12,
      maxScale: r10
    } = e13.effectiveScaleRange;
    return u7(t12, r10);
  }
  get _visibleFeatures() {
    let e13 = 0;
    return this._renderGeometries.forEach((t12) => {
      t12.visible && ++e13;
    }), e13;
  }
  whenGraphicBounds() {
    return __async(this, null, function* () {
      return null;
    });
  }
  computeAttachmentOrigin() {
    return null;
  }
  highlight() {
    return e2();
  }
  maskOccludee() {
    return e2();
  }
  setObjectIdVisibility() {
  }
  refreshFilter() {
    this.filterVisibility.reapply();
  }
  _onLoadedFeaturesChange(e13) {
    if (!this._featuresArePoints) return;
    const {
      objectIdField: t12
    } = this.layer;
    this._featureStore.removeManyById(e13.removed.map((e14) => M(e14, t12))), this._featureStore.addMany(e13.added.map((e14) => {
      const {
        attributes: r10,
        centroid: i9,
        geometry: a8
      } = e14, s10 = new e6(O2(new e5(), a8), r10, i9 ? O2(new e5(), i9) : null, M(e14, t12));
      return s10.displayId = e14.uid, s10;
    }));
    const i8 = e13.added, a7 = e13.removed;
    this._fieldTotal += this._computeFieldTotalChange(i8, a7);
    const s9 = a7.map(({
      uid: e14
    }) => {
      const t13 = this._renderGeometries.get(e14);
      return this._renderGeometries.delete(e14), t13;
    }).filter(O), o9 = i8.map((e14) => {
      const t13 = this._pointGraphicToRenderGeometry(e14);
      return this._renderGeometries.set(e14.uid, t13), t13;
    });
    s9.length > 0 && this._drapeSourceRenderer.removeGeometries(s9, E5.REMOVE), o9.length > 0 && this._drapeSourceRenderer.addGeometries(o9, E5.ADD), (o9.length > 0 || s9.length > 0) && (this.filterVisibility.reapply(), this._renderView.requestRender());
  }
  _recreate() {
    if (!this._loadedPointGraphics) return;
    const e13 = this._loadedPointGraphics.toArray();
    this._onLoadedFeaturesChange({
      added: e13,
      removed: e13
    });
  }
  _pointGraphicToRenderGeometry(e13) {
    const t12 = this._heatmapRendererFieldName, r10 = null != t12 ? this._materialWithField : this._material, i8 = n5();
    c3(e13.geometry, i8, this._overlaySpatialReference), i8[2] = te;
    const a7 = l3(1), s9 = [[e8.POSITION, new t3(i8, a7, i8.length)]], o9 = this._heatmapRendererFieldIsNumeric;
    null != t12 && s9.push([e8.FEATUREATTRIBUTE, new t3([o9 ? e13.attributes[t12] ?? 0 : 0], a7, 1)]);
    const n11 = new m6(new I3(r10, s9, null, e10.Point), {
      layerUid: this.layer.uid,
      graphicUid: e13.uid
    });
    return n11.visible = this.filterVisibility.defaultVisibility, n11;
  }
  _forEachMaterial(e13) {
    e13(this._material), e13(this._materialWithField);
  }
  _computeFieldTotalChange(e13, t12) {
    if (null == this._heatmapRendererFieldName || !this._heatmapRendererFieldIsNumeric) return e13.length - t12.length;
    const r10 = this._heatmapRendererFieldName, i8 = (e14, t13) => e14 + (t13.attributes[r10] ?? 0);
    return e13.reduce(i8, 0) - t12.reduce(i8, 0);
  }
  _clampSearchRadius(e13) {
    return e13 > $2 && n2.getLogger(this).warnOnce(`SceneView supports a maximum radius of ${$2} pt for HeatmapRenderer.`), Math.min(e13, $2);
  }
  _updateFeatureVisibilities(e13) {
    const t12 = [];
    this._featureStore.forEach(({
      objectId: r10,
      displayId: i8
    }) => {
      const a7 = e13(r10), s9 = this._renderGeometries.get(i8);
      s9 && s9.visible !== a7 && (t12.push(s9), s9.visible = a7);
    }), this._drapeSourceRenderer.modifyGeometries(t12, I4.VISIBILITY);
  }
  _setAllFeaturesVisibility(e13) {
    const t12 = [];
    for (const r10 of this._renderGeometries.values()) r10.visible !== e13 && (t12.push(r10), r10.visible = e13);
    this._drapeSourceRenderer.modifyGeometries(t12, I4.VISIBILITY);
  }
  get test() {
  }
};
e3([y2()], q3.prototype, "type", void 0), e3([y2({
  constructOnly: true
})], q3.prototype, "owner", void 0), e3([y2()], q3.prototype, "layer", null), e3([y2()], q3.prototype, "featureStore", null), e3([y2()], q3.prototype, "updating", null), e3([y2()], q3.prototype, "updatingRemaining", null), e3([y2()], q3.prototype, "suspendInfo", null), e3([y2()], q3.prototype, "legendEnabled", null), e3([y2()], q3.prototype, "filterVisibility", null), e3([y2()], q3.prototype, "displayFeatureLimit", null), e3([y2()], q3.prototype, "preferredUpdatePolicy", void 0), e3([y2()], q3.prototype, "hasZ", null), e3([y2()], q3.prototype, "hasM", null), e3([y2()], q3.prototype, "dataExtent", void 0), e3([y2()], q3.prototype, "view", null), e3([y2()], q3.prototype, "fullOpacity", null), e3([y2()], q3.prototype, "updatePolicy", null), e3([y2()], q3.prototype, "drapeSourceType", void 0), e3([y2()], q3.prototype, "scaleVisibilitySuspended", null), e3([y2()], q3.prototype, "renderer", null), e3([y2()], q3.prototype, "_featureStore", void 0), e3([y2()], q3.prototype, "_filterVisibility", void 0), e3([y2()], q3.prototype, "_overlayRenderer", null), e3([y2()], q3.prototype, "_overlaySpatialReference", null), e3([y2()], q3.prototype, "_rendererParameters", null), e3([y2()], q3.prototype, "_materialParameters", null), e3([y2()], q3.prototype, "_densityParameters", null), e3([y2()], q3.prototype, "_radiusParameter", null), e3([y2()], q3.prototype, "_resolutionForScaleParameter", null), e3([y2()], q3.prototype, "_colorRampParameter", null), e3([y2()], q3.prototype, "_pixelRatioParameter", null), e3([y2()], q3.prototype, "_densityMapPixelRatio", null), e3([y2()], q3.prototype, "_renderGeometries", void 0), e3([y2()], q3.prototype, "_material", void 0), e3([y2()], q3.prototype, "_materialWithField", void 0), e3([y2()], q3.prototype, "_renderView", null), e3([y2()], q3.prototype, "_featuresArePoints", null), e3([y2()], q3.prototype, "_loadedPointGraphics", null), e3([y2()], q3.prototype, "_heatmapRenderer", null), e3([y2()], q3.prototype, "_heatmapRendererFieldName", null), e3([y2()], q3.prototype, "_heatmapRendererField", null), e3([y2()], q3.prototype, "_heatmapRendererFieldIsNumeric", null), e3([y2()], q3.prototype, "_fieldTotal", void 0), e3([y2()], q3.prototype, "_drapeSourceRenderer", void 0), e3([y2()], q3.prototype, "_isScaleRangeActive", null), q3 = e3([a3("esri.views.3d.layers.support.HeatmapFeatureProcessor")], q3);

// ../../../node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DGraphicsPipeline.js
var C3 = class extends m {
  constructor(e13) {
    super(e13), this._dataUpdatingState = S4.NONE, this.controller = null, this.updatingHandles = new h3(), this._controllerCreated = false, this._pendingController = null;
  }
  initialize() {
    this.addResolvingPromise(this._initializeController()), this.updatingHandles.add(() => this.layer.renderer, (e14) => this._recreateProcessor(e14), P), this.updatingHandles.add(() => this.updatePolicy, (e14) => this.processor.preferredUpdatePolicy = e14);
    const e13 = () => this.processor.featureStore;
    this.queryEngine = new l6({
      context: {
        spatialReference: this.view.spatialReference,
        layer: this.layer,
        scheduler: this.view.resourceController.scheduler,
        get featureStore() {
          return e13();
        },
        hasZ: this.hasZ,
        hasM: this.hasM
      },
      priority: I2.FEATURE_QUERY_ENGINE
    });
  }
  destroy() {
    this.removeAllHandles(), this.updatingHandles.destroy(), this._destroyPendingController(), this.controller = u(this.controller), this.processor = u(this.processor), this.queryEngine = u(this.queryEngine), this.loadedGraphics = null;
  }
  _destroyPendingController() {
    this._pendingController = u(this._pendingController);
  }
  get updating() {
    return this.updatingHandles.updating || !this._controllerCreated || this.controller?.updating || this.processor?.updating;
  }
  get legendEnabled() {
    return this.processor.legendEnabled;
  }
  get layer() {
    return this.layerView.layer;
  }
  get view() {
    return this.layerView.view;
  }
  get hasZ() {
    return this.layerView.hasZ;
  }
  get hasM() {
    return this.layerView.hasM;
  }
  get fullOpacity() {
    return this.layerView.fullOpacity;
  }
  get suspended() {
    return this.layerView.suspended;
  }
  get filter() {
    return "filter" in this.layerView ? this.layerView.filter : null;
  }
  get slicePlaneEnabled() {
    return this.layerView.slicePlaneEnabled;
  }
  get featureSpatialReference() {
    return "featureSpatialReference" in this.layerView ? this.layerView.featureSpatialReference : null;
  }
  get graphics3DProcessor() {
    return "graphics-3d" === this.processor?.type ? this.processor : null;
  }
  get heatmapProcessor() {
    return "heatmap" === this.processor?.type ? this.processor : null;
  }
  get hasAllFeatures() {
    return !(!this.controller || !("hasAllFeatures" in this.controller)) && this.controller.hasAllFeatures;
  }
  get hasAllFeaturesInView() {
    return !(!this.controller || !("hasAllFeaturesInView" in this.controller)) && this.controller.hasAllFeaturesInView;
  }
  get hasFullGeometries() {
    return !(!this.controller || !("hasFullGeometries" in this.controller)) && this.controller.hasFullGeometries;
  }
  get symbologySnappingSupported() {
    const e13 = this.layer?.renderer?.getSymbols();
    return e13?.some(J2) ?? false;
  }
  get updatePolicy() {
    return C2.SYNC;
  }
  get scaleVisibilitySuspended() {
    return this.processor?.scaleVisibilitySuspended;
  }
  get timeExtent() {
    return "timeExtent" in this.layerView ? this.layerView.timeExtent : null;
  }
  get dataUpdating() {
    return this._dataUpdatingState !== S4.NONE;
  }
  get suspendInfo() {
    return this.processor?.suspendInfo ?? {};
  }
  forEachGraphic(e13) {
    this.loadedGraphics.forEach(e13);
  }
  findGraphic(e13) {
    return this.loadedGraphics.find(e13);
  }
  queryObjectIds(e13, t12) {
    return this.layerView.queryObjectIds(e13, t12);
  }
  whenGraphicBounds(e13, t12) {
    return this.processor?.whenGraphicBounds(e13, t12);
  }
  computeAttachmentOrigin(e13, t12) {
    return this.processor?.computeAttachmentOrigin(e13, t12);
  }
  elevationAlignPointsInFeatures(e13, r10) {
    return __async(this, null, function* () {
      const i8 = this.graphics3DProcessor;
      if (null == i8) throw new s("featurelayerview3d:missing-processor", "A Graphics3D processor is needed to resolve graphics elevation.");
      return m7(this.view, this.layer, (e14) => i8.getGraphics3DGraphicByObjectId(e14), e13, r10);
    });
  }
  queryForSymbologySnapping(e13, t12) {
    return __async(this, null, function* () {
      return this.symbologySnappingSupported ? r8(this.graphics3DProcessor, e13, t12) : {
        candidates: [],
        sourceCandidateIndices: []
      };
    });
  }
  highlight(e13) {
    return this.processor.highlight(e13, this.layer.objectIdField);
  }
  maskOccludee(e13) {
    return this.processor.maskOccludee(e13);
  }
  _initializeController() {
    return __async(this, null, function* () {
      const e13 = this.createController();
      this._pendingController = e13, this._setupDataUpdating(e13), yield e13.when(), this._setControllerWhenInitialized(e13);
    });
  }
  _setupDataUpdating(e13) {
    "dataUpdating" in e13 && this.addHandles([d2(() => e13.dataUpdating, (e14) => {
      e14 && this._dataUpdatingState === S4.NONE ? this._dataUpdatingState = S4.CONTROLLER : e14 || this._dataUpdatingState !== S4.CONTROLLER || (this._dataUpdatingState = S4.NONE);
    }, C), d2(() => !!this.graphics3DProcessor?.dataUpdating, (t12) => {
      t12 && this._dataUpdatingState === S4.CONTROLLER ? this._dataUpdatingState = S4.CORE : t12 || this._dataUpdatingState !== S4.CORE || (this._dataUpdatingState = e13.dataUpdating ? S4.CONTROLLER : S4.NONE);
    }, C)]);
  }
  _setControllerWhenInitialized(e13) {
    return __async(this, null, function* () {
      try {
        yield this.when();
      } catch (t12) {
      }
      this._controllerCreated = true, this.isResolved() && !this.destroyed ? (yield w(() => this.view?.basemapTerrain?.ready), this.beforeSetController(e13), this._pendingController = null, this.controller = e13, this.loadedGraphics = e13.graphics) : this._destroyPendingController();
    });
  }
  _recreateProcessor(e13) {
    const t12 = "heatmap" === e13?.type, r10 = "heatmap" === this.processor?.type, i8 = this.processor;
    if (i8 && t12 === r10) return;
    const s9 = t12 ? new q3({
      owner: this
    }) : new P3({
      owner: this,
      frustumVisibilityEnabled: true,
      scaleVisibilityEnabled: true,
      filterVisibilityEnabled: true,
      timeExtentEnabled: true,
      elevationAlignmentEnabled: true,
      elevationFeatureExpressionEnabled: true,
      preferredUpdatePolicy: this.updatePolicy,
      updateClippingExtent: (e14) => this._updateClippingExtent(e14)
    });
    this.processor = s9, i8?.destroy(), this.queryEngine?.clear(), this.addResolvingPromise(s9.initializePromise);
  }
  _updateClippingExtent(e13) {
    if (this.clippingExtent = e13, !this.controller) return false;
    switch (this.controller.type) {
      case "stream":
        return false;
      case "feature-tile-3d":
        return this.controller.extent = e13, true;
    }
  }
  get performanceInfo() {
    const e13 = this.controller instanceof T2 ? this.controller : null;
    return new t10(this.processor.usedMemory, this.loadedGraphics?.length, e13?.serviceDataCount ?? -1, e13?.maximumNumberOfFeatures ?? -1, 0, this.processor.performanceInfo);
  }
};
var S4;
e3([y2()], C3.prototype, "updating", null), e3([y2()], C3.prototype, "legendEnabled", null), e3([y2()], C3.prototype, "layerView", void 0), e3([y2()], C3.prototype, "layer", null), e3([y2()], C3.prototype, "view", null), e3([y2()], C3.prototype, "hasZ", null), e3([y2()], C3.prototype, "hasM", null), e3([y2()], C3.prototype, "fullOpacity", null), e3([y2()], C3.prototype, "suspended", null), e3([y2()], C3.prototype, "filter", null), e3([y2()], C3.prototype, "slicePlaneEnabled", null), e3([y2()], C3.prototype, "featureSpatialReference", null), e3([y2()], C3.prototype, "loadedGraphics", void 0), e3([y2()], C3.prototype, "graphics3DProcessor", null), e3([y2()], C3.prototype, "heatmapProcessor", null), e3([y2()], C3.prototype, "hasAllFeatures", null), e3([y2()], C3.prototype, "hasAllFeaturesInView", null), e3([y2()], C3.prototype, "hasFullGeometries", null), e3([y2()], C3.prototype, "symbologySnappingSupported", null), e3([y2()], C3.prototype, "updatePolicy", null), e3([y2()], C3.prototype, "queryEngine", void 0), e3([y2()], C3.prototype, "scaleVisibilitySuspended", null), e3([y2()], C3.prototype, "timeExtent", null), e3([y2()], C3.prototype, "_dataUpdatingState", void 0), e3([y2({
  readOnly: true
})], C3.prototype, "dataUpdating", null), e3([y2()], C3.prototype, "controller", void 0), e3([y2()], C3.prototype, "processor", void 0), e3([y2()], C3.prototype, "updatingHandles", void 0), e3([y2()], C3.prototype, "_controllerCreated", void 0), C3 = e3([a3("esri.views.3d.layers.graphics.Graphics3DGraphicsPipeline")], C3), function(e13) {
  e13[e13.NONE = 0] = "NONE", e13[e13.CONTROLLER = 1] = "CONTROLLER", e13[e13.CORE = 2] = "CORE";
}(S4 || (S4 = {}));

export {
  u10 as u,
  P4 as P,
  T2 as T,
  n10 as n,
  l6 as l,
  P3 as P2,
  C3 as C
};
//# sourceMappingURL=chunk-K7KZCCPZ.js.map
