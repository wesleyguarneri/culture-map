{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/hud/HUDOcclusionPass.glsl.js", "../../../../../../node_modules/@arcgis/core/chunks/HUDMaterial.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { AlignPixel as e } from \"./AlignPixel.glsl.js\";\nimport { multipassTerrainTest as o } from \"../shading/MultipassTerrainTest.glsl.js\";\nimport { glsl as t } from \"../../shaderModules/interfaces.js\";\nfunction i(i, r) {\n  const {\n    vertex: s,\n    fragment: p\n  } = i;\n  s.include(e), r.multipassEnabled && i.varyings.add(\"depth\", \"float\"), s.code.add(t`\n  void main(void) {\n    vec4 posProjCenter;\n    if (dot(position, position) > 0.0) {\n      // Render single point to center of the pixel to avoid subpixel filtering to affect the marker color\n      ProjectHUDAux projectAux;\n      vec4 posProj = projectPositionHUD(projectAux);\n      posProjCenter = alignToPixelCenter(posProj, viewport.zw);\n\n      ${r.multipassEnabled ? \"depth = projectAux.posView.z;\" : \"\"}\n      vec3 vpos = projectAux.posModel;\n      if (rejectBySlice(vpos)) {\n        // Project out of clip space\n        posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n      }\n\n    } else {\n      // Project out of clip space\n      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n\n    gl_Position = posProjCenter;\n    gl_PointSize = 1.0;\n  }\n  `), i.include(o, r), p.code.add(t`\n  void main() {\n    fragColor = vec4(1);\n    ${r.multipassEnabled ? t`\n        if(terrainDepthTest(depth)) {\n          fragColor.g = 0.5;\n        }` : \"\"}\n  }\n  `);\n}\nexport { i as HUDOcclusionPass };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { set as e, copy as o } from \"../core/libs/gl-matrix-2/math/vec2.js\";\nimport { create as r } from \"../core/libs/gl-matrix-2/factories/vec2f64.js\";\nimport { ZEROS as i } from \"../core/libs/gl-matrix-2/factories/vec4f64.js\";\nimport { ShaderOutput as l } from \"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";\nimport { SliceDraw as t } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { ObjectAndLayerIdColor as a } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js\";\nimport { AlignPixel as s } from \"../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl.js\";\nimport { HUD as n } from \"../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js\";\nimport { HUDOcclusionPass as c } from \"../views/3d/webgl-engine/core/shaderLibrary/hud/HUDOcclusionPass.glsl.js\";\nimport { HUDVisibility as d } from \"../views/3d/webgl-engine/core/shaderLibrary/hud/HUDVisibility.glsl.js\";\nimport { occludedHighlightFlag as u, unoccludedHighlightFlag as p } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";\nimport { VisualVariables as g } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js\";\nimport { symbolAlphaCutoff as f, defaultMaskAlphaCutoff as v } from \"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";\nimport { ColorConversion as m } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { RgbaFloatEncoding as b } from \"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";\nimport { ScreenSizePerspective as h, addScreenSizePerspective as w, addScreenSizePerspectiveAlignment as x } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js\";\nimport { addPixelRatio as C } from \"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";\nimport { Float2PassUniform as P } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float4PassUniform as S } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as j } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as z } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as y } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as A } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nimport { TransparencyPassType as O } from \"../views/3d/webgl-engine/lib/TransparencyPassType.js\";\nimport { VertexAttribute as $ } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nfunction F(o) {\n  const r = new y(),\n    F = o.signedDistanceFieldEnabled;\n  if (r.include(n, o), r.include(t, o), o.occlusionPass) return r.include(c, o), r;\n  const {\n    vertex: B,\n    fragment: H\n  } = r;\n  r.include(h), H.include(b), H.include(m), r.include(g, o), r.include(a, o), r.include(d), r.varyings.add(\"vcolor\", \"vec4\"), r.varyings.add(\"vtc\", \"vec2\"), r.varyings.add(\"vsize\", \"vec2\"), r.varyings.add(\"voccluded\", \"float\"), B.uniforms.add(new S(\"viewport\", (e, o) => o.camera.fullViewport), new P(\"screenOffset\", (o, r) => e(T, 2 * o.screenOffset[0] * r.camera.pixelRatio, 2 * o.screenOffset[1] * r.camera.pixelRatio)), new P(\"anchorPosition\", e => D(e)), new S(\"materialColor\", e => e.color)), C(B), F && (B.uniforms.add(new S(\"outlineColor\", e => e.outlineColor)), H.uniforms.add(new S(\"outlineColor\", e => L(e) ? e.outlineColor : i), new j(\"outlineSize\", e => L(e) ? e.outlineSize : 0))), o.pixelSnappingEnabled && B.include(s), o.hasScreenSizePerspective && (w(B), x(B)), o.debugDrawLabelBorder && r.varyings.add(\"debugBorderCoords\", \"vec4\"), r.attributes.add($.UV0, \"vec2\"), r.attributes.add($.COLOR, \"vec4\"), r.attributes.add($.SIZE, \"vec2\"), r.attributes.add($.FEATUREATTRIBUTE, \"vec4\"), B.code.add(z`\n    void main(void) {\n      ProjectHUDAux projectAux;\n      vec4 posProj = projectPositionHUD(projectAux);\n      forwardObjectAndLayerIdColor();\n\n      if (rejectBySlice(projectAux.posModel)) {\n        // Project outside of clip plane\n        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n        return;\n      }\n      vec2 inputSize;\n      ${o.hasScreenSizePerspective ? z`\n            inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);\n            vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n         ` : z`\n            inputSize = size;\n            vec2 screenOffsetScaled = screenOffset;`}\n\n      ${o.vvSize ? \"inputSize *= vvScale(featureAttribute).xx;\" : \"\"}\n\n      vec2 combinedSize = inputSize * pixelRatio;\n      vec4 quadOffset = vec4(0.0);\n      bool visible = testHUDVisibility(posProj);\n      voccluded = visible ? 0.0 : 1.0;\n    `);\n  const U = z`vec2 uv01 = floor(uv0);\nvec2 uv = uv0 - uv01;\nquadOffset.xy = ((uv01 - anchorPosition) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;`,\n    V = o.pixelSnappingEnabled ? F ? z`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;` : z`posProj += quadOffset;\nif (inputSize.x == size.x) {\nposProj = alignToPixelOrigin(posProj, viewport.zw);\n}` : z`posProj += quadOffset;`;\n  B.code.add(z`\n    ${o.occlusionTestEnabled ? \"if (visible) {\" : \"\"}\n    ${U}\n    ${o.vvColor ? \"vcolor = interpolateVVColor(featureAttribute.y) * materialColor;\" : \"vcolor = color / 255.0 * materialColor;\"}\n\n    ${o.output === l.ObjectAndLayerIdColor ? z`vcolor.a = 1.0;` : \"\"}\n\n    bool alphaDiscard = vcolor.a < ${z.float(f)};\n    ${F ? `alphaDiscard = alphaDiscard && outlineColor.a < ${z.float(f)};` : \"\"}\n    if (alphaDiscard) {\n      // \"early discard\" if both symbol color (= fill) and outline color (if applicable) are transparent\n      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n      return;\n    } else {\n      ${V}\n      gl_Position = posProj;\n    }\n\n    vtc = uv;\n\n    ${o.debugDrawLabelBorder ? \"debugBorderCoords = vec4(uv01, 1.5 / combinedSize);\" : \"\"}\n    vsize = inputSize;\n    ${o.occlusionTestEnabled ? z`} else { vtc = vec2(0.0);\n      ${o.debugDrawLabelBorder ? \"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);}\" : \"}\"}` : \"\"}\n  }\n  `), H.uniforms.add(new A(\"tex\", e => e.texture));\n  const E = o.debugDrawLabelBorder ? z`(isBorder > 0.0 ? 0.0 : ${z.float(v)})` : z.float(v),\n    I = z`\n    ${o.debugDrawLabelBorder ? z`\n      float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));` : \"\"}\n\n    ${o.sampleSignedDistanceFieldTexelCenter ? z`\n      // Attempt to sample texel centers to avoid that thin cross outlines\n      // disappear with large symbol sizes.\n      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041\n      float txSize = float(textureSize(tex, 0).x);\n      float texelSize = 1.0 / txSize;\n\n      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel\n      vec2 scaleFactor = (vsize - txSize) * texelSize;\n      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;\n      ` : z`\n      vec2 samplePos = vtc;\n      `}\n\n    ${F ? z`\n      vec4 fillPixelColor = vcolor;\n\n      // Get distance and map it into [-0.5, 0.5]\n      float d = rgba2float(texture(tex, samplePos)) - 0.5;\n\n      // Distance in output units (i.e. pixels)\n      float dist = d * vsize.x;\n\n      // Create smooth transition from the icon into its outline\n      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);\n      fillPixelColor.a *= fillAlphaFactor;\n\n      if (outlineSize > 0.25) {\n        vec4 outlinePixelColor = outlineColor;\n        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);\n\n        // Create smooth transition around outline\n        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\n        outlinePixelColor.a *= outlineAlphaFactor;\n\n        if (\n          outlineAlphaFactor + fillAlphaFactor < ${E} ||\n          fillPixelColor.a + outlinePixelColor.a < ${z.float(f)}\n        ) {\n          discard;\n        }\n\n        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)\n        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\n        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +\n          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\n\n        fragColor = vec4(compositeColor, compositeAlpha);\n      } else {\n        if (fillAlphaFactor < ${E}) {\n          discard;\n        }\n\n        fragColor = premultiplyAlpha(fillPixelColor);\n      }\n\n      // visualize SDF:\n      // fragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);\n      ` : z`\n          vec4 texColor = texture(tex, vtc, -0.5);\n          if (texColor.a < ${E}) {\n            discard;\n          }\n          fragColor = texColor * premultiplyAlpha(vcolor);\n          `}\n\n    // Draw debug border with transparency, so that original texels along border are still partially visible\n    ${o.debugDrawLabelBorder ? z`fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);` : \"\"}\n  `;\n  switch (o.output) {\n    case l.Color:\n      o.transparencyPassType === O.ColorAlpha && (r.outputs.add(\"fragColor\", \"vec4\", 0), r.outputs.add(\"fragAlpha\", \"float\", 1)), H.code.add(z`\n        void main() {\n          ${I}\n          ${o.transparencyPassType === O.FrontFace ? \"fragColor.rgb /= fragColor.a;\" : \"\"}\n          ${o.transparencyPassType === O.ColorAlpha ? \"fragAlpha = fragColor.a;\" : \"\"}\n        }`);\n      break;\n    case l.ObjectAndLayerIdColor:\n      H.code.add(z`\n        void main() {\n          ${I}\n          outputObjectAndLayerIdColor();\n        }`);\n      break;\n    case l.Highlight:\n      H.constants.add(\"occludedHighlightFlag\", \"vec4\", u), H.constants.add(\"unoccludedHighlightFlag\", \"vec4\", p), H.code.add(z`\n        void main() {\n          ${I}\n          if (voccluded == 1.0) {\n            fragColor = occludedHighlightFlag;\n          } else {\n            fragColor = unoccludedHighlightFlag;\n          }\n        }`);\n  }\n  return r;\n}\nfunction L(e) {\n  return e.outlineColor[3] > 0 && e.outlineSize > 0;\n}\nfunction D(e, r = T) {\n  return e.textureIsSignedDistanceField ? B(e.anchorPosition, e.distanceFieldBoundingBox, r) : o(r, e.anchorPosition), r;\n}\nfunction B(o, r, i) {\n  null != r ? e(i, o[0] * (r[2] - r[0]) + r[0], o[1] * (r[3] - r[1]) + r[1]) : e(i, 0, 0);\n}\nconst T = r(),\n  H = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    build: F,\n    calculateAnchorPosForRendering: D\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { H, F as b, D as c };"],
  "mappings": "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",
  "names": ["i", "r", "s", "o", "a", "o", "r", "F", "d", "B", "H", "s", "e", "t", "i"]
}
