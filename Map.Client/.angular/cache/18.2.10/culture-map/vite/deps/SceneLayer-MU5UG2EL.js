import {
  j as j3
} from "./chunk-6PFH6TN3.js";
import "./chunk-Q7ENCKPJ.js";
import {
  i as i3,
  m as m2
} from "./chunk-B74LYY3G.js";
import {
  $ as $3
} from "./chunk-EUVN3KSV.js";
import "./chunk-WBOVDU4O.js";
import "./chunk-TQYVLRAH.js";
import "./chunk-6A3XUATG.js";
import "./chunk-WX42XBL6.js";
import {
  r as r2,
  t as t5
} from "./chunk-WBUJP5OW.js";
import "./chunk-TVV62TZG.js";
import "./chunk-ZNDAVKXT.js";
import "./chunk-C2NHN5LF.js";
import "./chunk-OHXCVJMH.js";
import "./chunk-L3F4XA4B.js";
import "./chunk-OUP4PSAG.js";
import "./chunk-WU7FVYT7.js";
import "./chunk-6V5NKLIC.js";
import "./chunk-CZQYBYHB.js";
import "./chunk-Q5ZRUB2Y.js";
import "./chunk-2XI572KI.js";
import "./chunk-R4P4UBKU.js";
import "./chunk-62WUYJJN.js";
import "./chunk-AWJPQWYU.js";
import "./chunk-JNWMZ6EJ.js";
import "./chunk-VS26W5Y5.js";
import {
  s as s5
} from "./chunk-6OHQEV7Z.js";
import {
  n as n3,
  p as p4
} from "./chunk-2N3BR7QT.js";
import {
  a as a4,
  m,
  p as p2,
  y as y3
} from "./chunk-6MR3LXEW.js";
import {
  C as C2,
  L
} from "./chunk-3RL4VAAQ.js";
import "./chunk-JPIYGHSR.js";
import {
  $ as $2,
  P,
  w as w2
} from "./chunk-6MR4UDDL.js";
import {
  p as p5
} from "./chunk-LZUPV7SL.js";
import {
  i as i2
} from "./chunk-YTFX4PFO.js";
import "./chunk-N3IR233K.js";
import {
  l as l2
} from "./chunk-DSMB46HB.js";
import {
  p as p6,
  t as t6
} from "./chunk-OTI4DGZ5.js";
import "./chunk-KQDYTHCF.js";
import {
  s as s6
} from "./chunk-BNK4CEA6.js";
import {
  C as C3,
  l as l3
} from "./chunk-6LDLRQX4.js";
import {
  f as f3
} from "./chunk-Z4YAQ5JI.js";
import {
  d as d3
} from "./chunk-K2XCQKCC.js";
import {
  l as l4
} from "./chunk-AJS4B62I.js";
import {
  p as p3
} from "./chunk-S5EXT7FA.js";
import {
  e as e3
} from "./chunk-73Y7XDLH.js";
import {
  u as u2
} from "./chunk-YFOAET4H.js";
import "./chunk-5U4TBXYS.js";
import "./chunk-6WG22V46.js";
import "./chunk-OOGIXDXG.js";
import {
  J as J2,
  v as v2
} from "./chunk-JFYQTYD3.js";
import "./chunk-KDJZAYOF.js";
import "./chunk-5453A3C5.js";
import "./chunk-HCFDI7IX.js";
import "./chunk-AQJS6F3O.js";
import "./chunk-WUB6LJVL.js";
import "./chunk-QXSES7JX.js";
import "./chunk-YPU2P4KO.js";
import {
  F
} from "./chunk-5GQ3OMCZ.js";
import "./chunk-2SMFPIRI.js";
import {
  $
} from "./chunk-VCFSVEDB.js";
import "./chunk-XCVOKQAA.js";
import "./chunk-3WQXHRJE.js";
import "./chunk-EBLQZUPS.js";
import "./chunk-URWREU3E.js";
import "./chunk-KE2YMCJC.js";
import "./chunk-L7ZKWTWL.js";
import "./chunk-O2DTA3XK.js";
import "./chunk-3UOXF3CT.js";
import "./chunk-WDDCGJTI.js";
import "./chunk-PA7WZX2U.js";
import "./chunk-GPUGMSHU.js";
import "./chunk-AIS5CSUZ.js";
import "./chunk-52UEU7LG.js";
import "./chunk-WJKYGQOY.js";
import "./chunk-GY52WOQZ.js";
import "./chunk-GAYJ4YPJ.js";
import "./chunk-PPMDUJ4E.js";
import "./chunk-ZTT6ENBS.js";
import "./chunk-MFZTGYUJ.js";
import "./chunk-R5ZE5A4K.js";
import "./chunk-24CN3HDP.js";
import "./chunk-SZWWBMQN.js";
import "./chunk-ZE47C44H.js";
import "./chunk-5GIS2C3K.js";
import "./chunk-XCOHDMBF.js";
import "./chunk-2GMKFOCL.js";
import "./chunk-ZR5BOILP.js";
import "./chunk-QCBC3RJX.js";
import "./chunk-R3F4JMNC.js";
import "./chunk-63QCTVYB.js";
import "./chunk-W5ERGD4Y.js";
import "./chunk-7B5YPLFX.js";
import "./chunk-RDQF44TE.js";
import "./chunk-KKD7A2GN.js";
import "./chunk-ZWCV4HKG.js";
import "./chunk-N4KQPPPI.js";
import "./chunk-4OGGMTIH.js";
import "./chunk-NQVBBKAN.js";
import "./chunk-U74WRHVJ.js";
import "./chunk-TCPN7AEH.js";
import "./chunk-4MMTPKY4.js";
import "./chunk-DY7FJHTG.js";
import "./chunk-Q4KYZS3X.js";
import "./chunk-KVKFHRJ3.js";
import "./chunk-VWML4J2J.js";
import "./chunk-JYODC3YQ.js";
import "./chunk-BQZBOYBD.js";
import "./chunk-TYQXPPSP.js";
import {
  b as b3
} from "./chunk-TRSGUVSM.js";
import "./chunk-U3MA63JX.js";
import "./chunk-WYKKCLBI.js";
import "./chunk-PFMGJTQM.js";
import {
  Z
} from "./chunk-Q7SRMLJZ.js";
import "./chunk-PQ4T66BG.js";
import "./chunk-SWPHGZYB.js";
import "./chunk-DWASPXVI.js";
import {
  n as n2
} from "./chunk-TNWXOQKO.js";
import "./chunk-MAO5BVLA.js";
import "./chunk-T2S5VXNP.js";
import "./chunk-4U5GUJRA.js";
import "./chunk-7KRERHHR.js";
import "./chunk-T4AP6CTC.js";
import {
  d as d2
} from "./chunk-HD65DNIO.js";
import {
  k
} from "./chunk-4KWLMXIA.js";
import "./chunk-BIUXKPKA.js";
import "./chunk-N6TJI25E.js";
import "./chunk-634JLXD4.js";
import "./chunk-Y3EDGYWG.js";
import "./chunk-UF6JOUSJ.js";
import "./chunk-T5JGQSO3.js";
import {
  i
} from "./chunk-CIW3KHOW.js";
import "./chunk-J55F4AC2.js";
import "./chunk-IQLBZKUD.js";
import "./chunk-7MZZCQ64.js";
import "./chunk-JOJZ6YC5.js";
import "./chunk-L4TOCXR5.js";
import "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import {
  t as t3
} from "./chunk-RTWBKPWJ.js";
import "./chunk-SNY4EEM3.js";
import "./chunk-2GDRAUF6.js";
import "./chunk-XLPKC3OB.js";
import "./chunk-HEWCRCJC.js";
import "./chunk-B5ZW6SJE.js";
import {
  j as j2
} from "./chunk-SJX5DIA7.js";
import "./chunk-6A7CWJED.js";
import "./chunk-APL7ANIA.js";
import "./chunk-LFKEQKEA.js";
import {
  J,
  on
} from "./chunk-DUTZNK67.js";
import "./chunk-IN6BQCWS.js";
import {
  s as s3
} from "./chunk-DCMO5DPK.js";
import {
  g
} from "./chunk-CRNUMTSV.js";
import {
  a as a5
} from "./chunk-7W742U7L.js";
import "./chunk-JM7HAEY6.js";
import {
  t as t4
} from "./chunk-UWJIHV6Q.js";
import {
  b as b2
} from "./chunk-ZUSCOMQM.js";
import {
  d,
  l,
  s as s4,
  t as t2,
  y as y2
} from "./chunk-DSEUCBVP.js";
import "./chunk-UPDWQH75.js";
import {
  S
} from "./chunk-RXWBJSJ5.js";
import {
  f as f2
} from "./chunk-M2NS3MSU.js";
import "./chunk-HMNBB7ED.js";
import "./chunk-3RRMLFFN.js";
import {
  c
} from "./chunk-DR5TVNEL.js";
import "./chunk-HT2T6PUB.js";
import "./chunk-K64AAM77.js";
import {
  r
} from "./chunk-6EUVKE22.js";
import "./chunk-OKJHJ3CY.js";
import "./chunk-XTVPEVHA.js";
import {
  g as g2,
  p as p7,
  x
} from "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import "./chunk-DZALMCYL.js";
import "./chunk-K226GFDN.js";
import "./chunk-4ZZRP4MA.js";
import "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-5I6J67HP.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-EODIWR2E.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-U2LCAVGY.js";
import "./chunk-FYAEQPUY.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import {
  p
} from "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-7RMVJCDW.js";
import {
  j
} from "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import "./chunk-NYQ5CYNR.js";
import {
  _
} from "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import {
  o
} from "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import "./chunk-AXVPJBVW.js";
import "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import {
  U,
  V as V2
} from "./chunk-SYATLP3H.js";
import {
  f,
  u2 as u
} from "./chunk-V6AMQYXE.js";
import {
  C,
  v,
  w
} from "./chunk-6WHTZNUH.js";
import {
  V
} from "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import "./chunk-XNUH25NY.js";
import "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e as e2
} from "./chunk-4Z5SGKRM.js";
import {
  e
} from "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3,
  s3 as s2,
  t
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import {
  a as a2,
  b
} from "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  a,
  n2 as n,
  s2 as s
} from "./chunk-WYIDUUN2.js";
import "./chunk-DXLOWWK7.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/layers/support/sceneLayerCacheUtils.js
function e4({
  associatedLayer: e6,
  serviceUpdateTimeStamp: t8
}) {
  const n4 = e6?.editingInfo?.lastEditDate, r3 = e6?.serverGens, a7 = null != n4, i5 = null != t8, s8 = a7 && i5 && t8.lastUpdate !== n4.getTime();
  return a7 && (s8 || !i5 && r3?.minServerGen !== r3?.serverGen);
}

// ../../../node_modules/@arcgis/core/layers/mixins/TemporalSceneLayer.js
var a6 = (i5) => {
  let a7 = class extends i5 {
    constructor() {
      super(...arguments), this.serviceTimeInfo = null;
    }
    get timeInfo() {
      const e6 = this.associatedLayer?.timeInfo;
      if (null == e6) return null;
      const t8 = e6.clone();
      return g2(t8, this.fieldsIndex), t8;
    }
    set timeInfo(e6) {
      g2(e6, this.fieldsIndex), this._override("timeInfo", e6);
    }
    get timeExtent() {
      return this.associatedLayer?.timeExtent;
    }
    set timeExtent(e6) {
      this._override("timeExtent", e6);
    }
    get timeOffset() {
      return this.associatedLayer?.timeOffset;
    }
    set timeOffset(e6) {
      this._override("timeOffset", e6);
    }
    get datesInUnknownTimezone() {
      return this.associatedLayer?.datesInUnknownTimezone ?? false;
    }
    set datesInUnknownTimezone(e6) {
      this._override("datesInUnknownTimezone", e6);
    }
    loadTimeInfoFromService(e6) {
      return __async(this, null, function* () {
        const {
          serviceTimeInfo: r3
        } = this;
        if (null == r3) return;
        const {
          startTimeField: i6,
          endTimeField: s8
        } = r3;
        if (null == i6 && null == s8) return;
        if (e4({
          associatedLayer: this.associatedLayer,
          serviceUpdateTimeStamp: this.serviceUpdateTimeStamp
        })) return;
        const n4 = (t8) => __async(this, null, function* () {
          let r4 = null;
          try {
            const i7 = yield this.fetchStatistics?.(t8, e6);
            r4 = i7?.stats;
          } catch {
          }
          if (null == r4) return null;
          const {
            minTimeStr: s9,
            min: n5,
            maxTimeStr: o3,
            max: l6
          } = r4, m3 = t8 === i6 ? s9 ?? n5 : o3 ?? l6;
          return null != m3 ? new Date(m3) : null;
        }), [o2, a8] = yield Promise.all([n4(i6), n4(s8)]);
        if (null != i6 && null == o2 || null != s8 && null == a8) return;
        const c4 = new c({
          start: o2,
          end: a8
        });
        this.setAtOrigin("timeInfo", new d3({
          endField: s8,
          startField: i6,
          fullTimeExtent: c4
        }), "service");
      });
    }
  };
  return e2([y({
    type: d3,
    json: {
      read: false,
      write: false
    }
  })], a7.prototype, "timeInfo", null), e2([y({
    type: c,
    json: {
      read: false,
      write: false
    }
  })], a7.prototype, "timeExtent", null), e2([y({
    type: l4,
    json: {
      read: false,
      write: false
    }
  })], a7.prototype, "timeOffset", null), e2([y({
    type: Boolean,
    nonNullable: true,
    json: {
      read: false,
      write: false
    }
  })], a7.prototype, "datesInUnknownTimezone", null), e2([y({
    type: c2,
    readOnly: true,
    json: {
      read: {
        source: "timeInfo"
      }
    }
  })], a7.prototype, "serviceTimeInfo", void 0), a7 = e2([a3("esri.layers.mixins.TemporalSceneLayer")], a7), a7;
};
var c2 = class extends f {
  constructor() {
    super(...arguments), this.endTimeField = null, this.startTimeField = null;
  }
};
e2([y({
  type: String
})], c2.prototype, "endTimeField", void 0), e2([y({
  type: String
})], c2.prototype, "startTimeField", void 0), c2 = e2([a3("esri.layers.mixins.TemporalSceneLayer.SceneServiceTimeInfo")], c2);

// ../../../node_modules/@arcgis/core/layers/support/RangeInfo.js
var s7 = class extends f {
  constructor() {
    super(...arguments), this.name = null, this.field = null, this.currentRangeExtent = null, this.fullRangeExtent = null, this.type = "rangeInfo";
  }
};
e2([y({
  type: String,
  json: {
    read: true,
    write: true
  }
})], s7.prototype, "name", void 0), e2([y({
  type: String,
  json: {
    read: true,
    write: true
  }
})], s7.prototype, "field", void 0), e2([y({
  type: [Number],
  json: {
    read: true,
    write: true
  }
})], s7.prototype, "currentRangeExtent", void 0), e2([y({
  type: [Number],
  json: {
    read: true,
    write: true
  }
})], s7.prototype, "fullRangeExtent", void 0), e2([y({
  type: ["rangeInfo"],
  readOnly: true,
  json: {
    read: false,
    write: true
  }
})], s7.prototype, "type", void 0), s7 = e2([a3("esri.layers.support.RangeInfo")], s7);

// ../../../node_modules/@arcgis/core/layers/support/PolygonCollection.js
var c3;
var p8 = c3 = class extends u(V.ofType(j)) {
  constructor(e6) {
    super(e6);
  }
  clone() {
    return new c3(this.items.map((e6) => e6.clone()));
  }
  write(e6, r3) {
    return this.toJSON(r3);
  }
  toJSON(e6) {
    const r3 = e6?.layer?.spatialReference;
    return r3 ? this.toArray().map((t8) => {
      if (!r3.equals(t8.spatialReference)) {
        if (!J(t8.spatialReference, r3)) return e6?.messages && e6.messages.push(new s2("scenefilter:unsupported", "Scene filters with incompatible spatial references are not supported", {
          modification: this,
          spatialReference: e6.layer.spatialReference,
          context: e6
        })), null;
        const s9 = new j();
        on(t8, s9, r3), t8 = s9;
      }
      const s8 = t8.toJSON(e6);
      return delete s8.spatialReference, s8;
    }).filter((e7) => null != e7) : (e6?.messages && e6.messages.push(new s2("scenefilter:unsupported", "Writing Scene filters without context layer is not supported", {
      modification: this,
      spatialReference: e6.layer.spatialReference,
      context: e6
    })), this.toArray().map((r4) => r4.toJSON(e6)));
  }
  static fromJSON(e6, r3) {
    const t8 = new c3();
    return e6.forEach((e7) => t8.add(j.fromJSON(e7, r3))), t8;
  }
};
p8 = c3 = e2([a3("esri.layers.support.PolygonCollection")], p8);
var l5 = p8;

// ../../../node_modules/@arcgis/core/layers/support/SceneFilter.js
var u3;
var g3 = u3 = class extends f {
  constructor(e6) {
    super(e6), this.spatialRelationship = "disjoint", this.geometries = new l5(), this._geometriesSource = null;
  }
  initialize() {
    this.addHandles(v(() => this.geometries, "after-changes", () => this.geometries = this.geometries, C));
  }
  readGeometries(e6, r3, o2) {
    Array.isArray(e6) ? this.geometries = l5.fromJSON(e6, o2) : this._geometriesSource = {
      url: p(e6, o2),
      context: o2
    };
  }
  loadGeometries(e6, o2) {
    return __async(this, null, function* () {
      if (null == this._geometriesSource) return;
      const {
        url: s8,
        context: t8
      } = this._geometriesSource, i5 = yield U(s8, {
        responseType: "json",
        signal: o2?.signal
      }), a7 = e6.toJSON(), p9 = i5.data.map((e7) => __spreadProps(__spreadValues({}, e7), {
        spatialReference: a7
      }));
      this.geometries = l5.fromJSON(p9, t8), this._geometriesSource = null;
    });
  }
  clone() {
    const e6 = new u3({
      geometries: a(this.geometries),
      spatialRelationship: this.spatialRelationship
    });
    return e6._geometriesSource = this._geometriesSource, e6;
  }
};
e2([y({
  type: ["disjoint", "contains"],
  nonNullable: true,
  json: {
    write: true
  }
})], g3.prototype, "spatialRelationship", void 0), e2([y({
  type: l5,
  nonNullable: true,
  json: {
    write: true
  }
}), j3({
  origins: ["web-scene", "portal-item"],
  type: "resource",
  prefix: "geometries",
  contentAddressed: true
})], g3.prototype, "geometries", void 0), e2([o(["web-scene", "portal-item"], "geometries")], g3.prototype, "readGeometries", null), g3 = u3 = e2([a3("esri.layers.support.SceneFilter")], g3);
var h = g3;

// ../../../node_modules/@arcgis/core/layers/support/sceneLayerStatistics.js
function i4(_0) {
  return __async(this, arguments, function* ({
    fieldName: i5,
    statisticsInfo: a7,
    errorContext: o2,
    fieldsIndex: r3,
    path: n4,
    customParameters: l6,
    apiKey: c4,
    signal: f4
  }) {
    if (null == a7) throw new s(`${o2}:no-cached-statistics`, "Cached statistics are not available for this layer");
    const d4 = r3.get(i5);
    if (null == d4) throw new s(`${o2}:field-unexisting`, `Field '${i5}' does not exist on the layer`);
    const h2 = a7.find((t8) => t8.name === d4.name);
    if (null == h2) throw new s(`${o2}:no-cached-statistics`, "Cached statistics for this attribute are not available");
    const m3 = V2(n4, h2.href), {
      data: u4
    } = yield U(m3, {
      query: __spreadProps(__spreadValues({
        f: "json"
      }, l6), {
        token: c4
      }),
      responseType: "json",
      signal: f4
    });
    return u4;
  });
}

// ../../../node_modules/@arcgis/core/support/zipUtils.js
function e5(e6) {
  return __async(this, null, function* () {
    const r3 = [];
    for (const n4 of e6) n4.name.toLowerCase().endsWith(".zip") ? r3.push(t7(n4)) : r3.push(Promise.resolve(n4));
    return (yield Promise.all(r3)).flat();
  });
}
function t7(e6) {
  return __async(this, null, function* () {
    const {
      BlobReader: t8,
      ZipReader: r3,
      BlobWriter: n4
    } = yield import("./zipjs-wrapper-QSLIQQA7.js"), a7 = [], i5 = new r3(new t8(e6));
    return (yield i5.getEntries()).forEach((e7) => {
      if (e7.directory || /^__MACOS/i.test(e7.filename)) return;
      const t9 = new n4(), r4 = e7.getData?.(t9).then((t10) => new File([t10], e7.filename));
      r4 && a7.push(r4);
    }), Promise.all(a7);
  });
}

// ../../../node_modules/@arcgis/core/layers/SceneLayer.js
var Ie = /* @__PURE__ */ new Set(["3DObject", "Point"]);
var Le = s6();
var je = class extends a6(F(L(l2(b2(j2(t4(S(e3(i2(i(f2))))))))))) {
  constructor(...e6) {
    super(...e6), this.featureReduction = null, this.rangeInfos = null, this.operationalLayerType = "ArcGISSceneServiceLayer", this.type = "scene", this.fields = null, this.floorInfo = null, this.outFields = null, this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.excludeObjectIds = new V(), this.definitionExpression = null, this.filter = null, this.path = null, this.labelsVisible = true, this.labelingInfo = null, this.legendEnabled = true, this.priority = null, this.semantic = null, this.cachedDrawingInfo = {
      color: false
    }, this.popupEnabled = true, this.popupTemplate = null, this.objectIdField = null, this.globalIdField = null, this._fieldUsageInfo = {}, this.screenSizePerspectiveEnabled = true, this.serviceItemId = void 0;
  }
  normalizeCtorArgs(e6, t8) {
    return "string" == typeof e6 ? __spreadValues({
      url: e6
    }, t8) : e6;
  }
  destroy() {
    this._set("renderer", null);
  }
  getField(e6) {
    return this.fieldsIndex.get(e6);
  }
  getFieldDomain(e6, t8) {
    const r3 = this.getFeatureType(t8?.feature)?.domains?.[e6];
    return r3 && "inherited" !== r3.type ? r3 : this.getField(e6)?.domain ?? null;
  }
  getFeatureType(e6) {
    return e6 && this.associatedLayer ? this.associatedLayer.getFeatureType(e6) : null;
  }
  get types() {
    return this.associatedLayer?.types ?? [];
  }
  get typeIdField() {
    return this.associatedLayer?.typeIdField ?? null;
  }
  get templates() {
    return this.associatedLayer?.templates ?? null;
  }
  get formTemplate() {
    return this.associatedLayer?.formTemplate ?? null;
  }
  get fieldsIndex() {
    return new Z(this.fields);
  }
  readNodePages(e6, t8, r3) {
    return "Point" === t8.layerType && (e6 = t8.pointNodePages), null == e6 || "object" != typeof e6 ? null : p2.fromJSON(e6, r3);
  }
  set elevationInfo(e6) {
    this._set("elevationInfo", e6), this.loaded && this._validateElevationInfo();
  }
  get effectiveCapabilities() {
    return this._capabilitiesFromAssociatedFeatureLayer(this.associatedLayer?.effectiveCapabilities);
  }
  get effectiveEditingEnabled() {
    return null != this.associatedLayer && v2(this.associatedLayer);
  }
  get geometryType() {
    return Se[this.profile] || "mesh";
  }
  set renderer(e6) {
    p7(e6, this.fieldsIndex), this._set("renderer", e6);
  }
  readCachedDrawingInfo(e6) {
    return null != e6 && "object" == typeof e6 || (e6 = {}), null == e6.color && (e6.color = false), e6;
  }
  get capabilities() {
    return this._capabilitiesFromAssociatedFeatureLayer(this.associatedLayer?.capabilities);
  }
  _capabilitiesFromAssociatedFeatureLayer(e6) {
    e6 = null != e6 ? e6 : s5;
    const {
      query: t8,
      queryRelated: r3,
      editing: {
        supportsGlobalId: i5,
        supportsRollbackOnFailure: s8,
        supportsUploadWithItemId: o2,
        supportsGeometryUpdate: a7,
        supportsReturnServiceEditsInSourceSpatialReference: n4
      },
      data: {
        supportsZ: l6,
        supportsM: p9,
        isVersioned: d4,
        supportsAttachment: u4
      },
      operations: {
        supportsEditing: y4,
        supportsAdd: c4,
        supportsUpdate: h2,
        supportsDelete: m3,
        supportsQuery: f4,
        supportsQueryAttachments: g4,
        supportsAsyncConvert3D: v3
      }
    } = e6, b4 = e6.operations.supportsChangeTracking, w3 = !!this.associatedLayer?.infoFor3D && n2();
    return {
      query: t8,
      queryRelated: r3,
      editing: {
        supportsGlobalId: i5,
        supportsReturnServiceEditsInSourceSpatialReference: n4,
        supportsRollbackOnFailure: s8,
        supportsGeometryUpdate: w3 && a7,
        supportsUploadWithItemId: o2
      },
      data: {
        supportsAttachment: u4,
        supportsZ: l6,
        supportsM: p9,
        isVersioned: d4
      },
      operations: {
        supportsQuery: f4,
        supportsQueryAttachments: g4,
        supportsEditing: y4 && b4,
        supportsAdd: w3 && c4 && b4,
        supportsDelete: w3 && m3 && b4,
        supportsUpdate: h2 && b4,
        supportsAsyncConvert3D: v3
      }
    };
  }
  get editingEnabled() {
    return this._isOverridden("editingEnabled") ? this._get("editingEnabled") : this.associatedLayer?.editingEnabled ?? false;
  }
  set editingEnabled(e6) {
    this._overrideIfSome("editingEnabled", e6);
  }
  get infoFor3D() {
    return this.associatedLayer?.infoFor3D ?? null;
  }
  get relationships() {
    return this.associatedLayer?.relationships;
  }
  get defaultPopupTemplate() {
    return this.associatedLayer || this.attributeStorageInfo ? this.createPopupTemplate() : null;
  }
  readObjectIdField(e6, t8) {
    return !e6 && t8.fields && t8.fields.some((t9) => ("esriFieldTypeOID" === t9.type && (e6 = t9.name), !!e6)), e6 || void 0;
  }
  readGlobalIdField(e6, t8) {
    return !e6 && t8.fields && t8.fields.some((t9) => ("esriFieldTypeGlobalID" === t9.type && (e6 = t9.name), !!e6)), e6 || void 0;
  }
  get displayField() {
    return this.associatedLayer?.displayField ?? null;
  }
  readProfile(e6, t8) {
    const r3 = t8.store.profile;
    return null != r3 && Fe[r3] ? Fe[r3] : (n.getLogger(this).error("Unknown or missing profile", {
      profile: r3,
      layer: this
    }), "mesh-pyramids");
  }
  get useViewTime() {
    return this.associatedLayer?.useViewTime ?? true;
  }
  set useViewTime(e6) {
    this._override("useViewTime", e6);
  }
  load(e6) {
    return this.addResolvingPromise(this._load(e6)), Promise.resolve(this);
  }
  _load(e6) {
    return __async(this, null, function* () {
      const t8 = null != e6 ? e6.signal : null;
      yield this.loadFromPortal({
        supportedTypes: ["Scene Service"]
      }, e6).catch(a2), yield this._fetchService(t8), yield Promise.all([this._fetchIndexAndUpdateExtent(this.nodePages, t8), this._setAssociatedFeatureLayer(t8), this._loadFilterGeometries()]), this._validateElevationInfo(), this._applyAssociatedLayerOverrides(), this._populateFieldUsageInfo(), yield this.loadTimeInfoFromService(e6), yield t3(this, {
        origin: "service"
      }, t8), p7(this.renderer, this.fieldsIndex), yield this.finishLoadEditablePortalLayer(e6);
    });
  }
  beforeSave() {
    return __async(this, null, function* () {
      null != this.filter && (this.filter = this.filter.clone(), yield this.load());
    });
  }
  _loadFilterGeometries() {
    return __async(this, null, function* () {
      if (this.filter) try {
        yield this.filter.loadGeometries(this.spatialReference);
      } catch (e6) {
        n.getLogger(this).error("#_loadFilterGeometries()", this, "Failed to load filter geometries. Geometry filter will not be applied for this layer.", {
          error: e6
        }), this.filter = null;
      }
    });
  }
  createQuery() {
    const e6 = new b3();
    return "mesh" === this.geometryType ? this.associatedLayer?.infoFor3D && (e6.returnGeometry = true) : (e6.returnGeometry = true, e6.returnZ = true), e6.where = this.definitionExpression || "1=1", e6.sqlFormat = "standard", e6.outFields = ["*"], e6;
  }
  queryExtent(e6, t8) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryExtent(e6 || this.createQuery(), t8));
  }
  queryFeatureCount(e6, t8) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryFeatureCount(e6 || this.createQuery(), t8));
  }
  queryFeatures(e6, t8) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryFeatures(e6 || this.createQuery(), t8)).then((e7) => {
      if (e7?.features) for (const t9 of e7.features) t9.layer = this, t9.sourceLayer = this;
      return e7;
    });
  }
  queryRelatedFeatures(e6, t8) {
    return __async(this, null, function* () {
      if (yield this.load(), !this.associatedLayer) throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", {
        layer: this
      });
      return this.associatedLayer.queryRelatedFeatures(e6, t8);
    });
  }
  queryRelatedFeaturesCount(e6, t8) {
    return __async(this, null, function* () {
      if (yield this.load(), !this.associatedLayer) throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", {
        layer: this
      });
      return this.associatedLayer.queryRelatedFeaturesCount(e6, t8);
    });
  }
  queryCachedAttributes(e6, t8) {
    return __async(this, null, function* () {
      const r3 = x(this.fieldsIndex, yield n3(this, p4(this)));
      return $(this.parsedUrl?.path ?? "", this.attributeStorageInfo ?? [], e6, t8, r3, this.apiKey, this.customParameters);
    });
  }
  queryCachedFeature(e6, r3) {
    return __async(this, null, function* () {
      const i5 = yield this.queryCachedAttributes(e6, [r3]);
      if (!i5 || 0 === i5.length) throw new s("scenelayer:feature-not-in-cached-data", "Feature not found in cached data");
      const s8 = new d2();
      return s8.attributes = i5[0], s8.layer = this, s8.sourceLayer = this, s8;
    });
  }
  queryObjectIds(e6, t8) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryObjectIds(e6 || this.createQuery(), t8));
  }
  queryAttachments(e6, t8) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryAttachments(e6, t8));
  }
  getFieldUsageInfo(e6) {
    const t8 = {
      supportsLabelingInfo: false,
      supportsRenderer: false,
      supportsPopupTemplate: false,
      supportsLayerQuery: false
    };
    return this.loaded ? this._fieldUsageInfo[e6] || t8 : (n.getLogger(this).error("#getFieldUsageInfo()", "Unavailable until layer is loaded"), t8);
  }
  createPopupTemplate(e6) {
    return p3(this, e6);
  }
  _getAssociatedLayerForQuery() {
    const e6 = this.associatedLayer;
    return e6?.loaded ? Promise.resolve(e6) : this._loadAssociatedLayerForQuery();
  }
  _loadAssociatedLayerForQuery() {
    return __async(this, null, function* () {
      if (yield this.load(), !this.associatedLayer) throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", {
        layer: this
      });
      try {
        yield this.associatedLayer.load();
      } catch (e6) {
        throw new s("scenelayer:query-not-available", "SceneLayer associated feature layer could not be loaded", {
          layer: this,
          error: e6
        });
      }
      return this.associatedLayer;
    });
  }
  hasCachedStatistics(e6) {
    return null != this.statisticsInfo && this.statisticsInfo.some((t8) => t8.name === e6);
  }
  queryCachedStatistics(e6, t8) {
    return __async(this, null, function* () {
      return yield this.load(t8), yield this.fetchStatistics(e6, t8);
    });
  }
  saveAs(e6, t8) {
    return __async(this, null, function* () {
      return this._debouncedSaveOperations(C2.SAVE_AS, __spreadProps(__spreadValues({}, t8), {
        getTypeKeywords: () => this._getTypeKeywords(),
        portalItemLayerType: "scene"
      }), e6);
    });
  }
  save() {
    return __async(this, null, function* () {
      const e6 = {
        getTypeKeywords: () => this._getTypeKeywords(),
        portalItemLayerType: "scene"
      };
      return this._debouncedSaveOperations(C2.SAVE, e6);
    });
  }
  applyEdits(e6, t8) {
    return __async(this, null, function* () {
      const {
        applyEdits: r3
      } = yield import("./editingSupport-PGDNTLCW.js");
      let i5 = t8;
      yield this.load();
      const s8 = this.associatedLayer;
      if (!s8) throw new s(`${this.type}-layer:not-editable`, "Service is not editable");
      yield s8.load();
      const {
        globalIdField: o2
      } = s8, n4 = !!s8.infoFor3D, l6 = i5?.globalIdUsed ?? true;
      if (n4 && null == o2) throw new s(`${this.type}-layer:not-editable`, "Valid globalIdField expected on editable SceneLayer");
      if (n4 && !l6) throw new s(`${this.type}-layer:globalid-required`, "globalIdUsed must not be false for SceneLayer editing as globalIds are required.");
      return g(s8.url) && n4 && null != e6.deleteFeatures && null != o2 && (i5 = __spreadProps(__spreadValues({}, i5), {
        globalIdToObjectId: yield J2(s8, e6.deleteFeatures, o2)
      })), r3(this, s8.source, e6, i5);
    });
  }
  uploadAssets(e6, t8) {
    return __async(this, null, function* () {
      if (yield this.load(), null == this.associatedLayer) throw new s(`${this.type}-layer:not-editable`, "Service is not editable");
      return yield this.associatedLayer.load(), this.associatedLayer.uploadAssets(e6, t8);
    });
  }
  on(e6, t8) {
    return super.on(e6, t8);
  }
  convertMesh(e6, t8) {
    return __async(this, null, function* () {
      const r3 = (e7) => {
        throw n.getLogger(this).error(".convertMesh()", e7.message), e7;
      };
      yield this.load(), this.infoFor3D || r3(new s("invalid:layer", "SceneLayer has no capability for mesh conversion"));
      const i5 = yield this.extractAndFilterFiles(e6), s8 = i5.reduce((e7, t9) => r2(this.infoFor3D, t9) ? e7 + 1 : e7, 0);
      0 === s8 && r3(new i3()), s8 > 1 && r3(new m2());
      const o2 = this.spatialReference, l6 = t8?.location ?? new _({
        x: 0,
        y: 0,
        z: 0,
        spatialReference: o2
      }), p9 = l6.spatialReference.isGeographic ? "local" : "georeferenced", d4 = $3.createWithExternalSource(l6, i5, {
        vertexSpace: p9
      }), [u4] = yield this.uploadAssets([d4], t8);
      return u4;
    });
  }
  extractAndFilterFiles(e6) {
    return __async(this, null, function* () {
      yield this.load();
      const t8 = this.infoFor3D;
      if (!t8) return e6;
      return (yield e5(e6)).filter((e7) => t5(t8, e7));
    });
  }
  validateLayer(e6) {
    if (e6.layerType && !Ie.has(e6.layerType)) throw new s("scenelayer:layer-type-not-supported", "SceneLayer does not support this layer type", {
      layerType: e6.layerType
    });
    if (isNaN(this.version.major) || isNaN(this.version.minor)) throw new s("layer:service-version-not-supported", "Service version is not supported.", {
      serviceVersion: this.version.versionString,
      supportedVersions: "1.x, 2.x"
    });
    if (this.version.major > 2) throw new s("layer:service-version-too-new", "Service version is too new.", {
      serviceVersion: this.version.versionString,
      supportedVersions: "1.x, 2.x"
    });
    function t8(e7, t9) {
      let r3 = false, i5 = false;
      if (null == e7) r3 = true, i5 = true;
      else {
        const s8 = t9 && t9.isGeographic;
        switch (e7) {
          case "east-north-up":
          case "earth-centered":
            r3 = true, i5 = s8;
            break;
          case "vertex-reference-frame":
            r3 = true, i5 = !s8;
            break;
          default:
            r3 = false;
        }
      }
      if (!r3) throw new s("scenelayer:unsupported-normal-reference-frame", "Normal reference frame is invalid.");
      if (!i5) throw new s("scenelayer:incompatible-normal-reference-frame", "Normal reference frame is incompatible with layer spatial reference.");
    }
    t8(this.normalReferenceFrame, this.spatialReference);
  }
  _getTypeKeywords() {
    const e6 = [];
    if ("points" === this.profile) e6.push("Point");
    else {
      if ("mesh-pyramids" !== this.profile) throw new s("scenelayer:unknown-profile", "SceneLayer:save() encountered an unknown SceneLayer profile: " + this.profile);
      e6.push("3DObject");
    }
    return e6;
  }
  _populateFieldUsageInfo() {
    if (this._fieldUsageInfo = {}, this.fields) for (const e6 of this.fields) {
      const t8 = !!this.attributeStorageInfo?.some((t9) => t9.name === e6.name), r3 = !!this.associatedLayer?.fields?.some((t9) => t9 && e6.name === t9.name), i5 = {
        supportsLabelingInfo: t8,
        supportsRenderer: t8,
        supportsPopupTemplate: t8 || r3,
        supportsLayerQuery: r3
      };
      this._fieldUsageInfo[e6.name] = i5;
    }
  }
  _applyAssociatedLayerOverrides() {
    this._applyAssociatedLayerFieldsOverrides(), this._applyAssociatedLayerPopupOverrides(), this._applyAssociatedLayerExtentOverride(), this._applyAssociatedLayerPrivileges();
  }
  _applyAssociatedLayerFieldsOverrides() {
    if (!this.associatedLayer?.fields) return;
    let e6 = null;
    for (const t8 of this.associatedLayer.fields) {
      const r3 = this.getField(t8.name);
      r3 ? (!r3.domain && t8.domain && (r3.domain = t8.domain.clone()), r3.editable = t8.editable, r3.nullable = t8.nullable, r3.length = t8.length) : (e6 || (e6 = this.fields ? this.fields.slice() : []), e6.push(t8.clone()));
    }
    e6 && this._set("fields", e6);
  }
  _applyAssociatedLayerPopupOverrides() {
    if (!this.associatedLayer) return;
    const e6 = ["popupTemplate", "popupEnabled"], t8 = t(this);
    for (let r3 = 0; r3 < e6.length; r3++) {
      const i5 = e6[r3], s8 = this.originIdOf(i5), o2 = this.associatedLayer.originIdOf(i5);
      s8 < o2 && (o2 === e.SERVICE || o2 === e.PORTAL_ITEM) && t8.setAtOrigin(i5, this.associatedLayer[i5], o2);
    }
  }
  _applyAssociatedLayerExtentOverride() {
    const e6 = this.associatedLayer?.getAtOrigin("fullExtent", "service");
    if (!(n2() && null != this.associatedLayer?.infoFor3D && e6 && g(this.associatedLayer?.url) && e4(this))) return;
    t(this).setAtOrigin("fullExtent", e6.clone(), e.SERVICE);
  }
  _applyAssociatedLayerPrivileges() {
    const e6 = this.associatedLayer;
    e6 && (this._set("userHasEditingPrivileges", e6.userHasEditingPrivileges), this._set("userHasFullEditingPrivileges", e6.userHasFullEditingPrivileges), this._set("userHasUpdateItemPrivileges", e6.userHasUpdateItemPrivileges));
  }
  _setAssociatedFeatureLayer(e6) {
    return __async(this, null, function* () {
      if (["mesh-pyramids", "points"].includes(this.profile)) try {
        const {
          serverUrl: t8,
          layerId: r3,
          portalItem: i5
        } = yield s3(`${this.url}/layers/${this.layerId}`, {
          sceneLayerItem: this.portalItem,
          customParameters: this.customParameters,
          apiKey: this.apiKey,
          signal: e6
        }), s8 = yield a5.FeatureLayer();
        this.associatedLayer = new s8({
          url: t8,
          customParameters: this.customParameters,
          layerId: r3,
          portalItem: i5
        }), yield this.associatedLayer.load();
      } catch (t8) {
        b(t8) || this._logWarningOnPopupEnabled();
      }
    });
  }
  _logWarningOnPopupEnabled() {
    return __async(this, null, function* () {
      yield w(() => this.popupEnabled && null != this.popupTemplate);
      const e6 = `this SceneLayer: ${this.title}`;
      null == this.attributeStorageInfo ? n.getLogger(this).warn(`Associated FeatureLayer could not be loaded and no binary attributes found. Popups will not work on ${e6}`) : n.getLogger(this).info(`Associated FeatureLayer could not be loaded. Falling back to binary attributes for Popups on ${e6}`);
    });
  }
  _validateElevationInfo() {
    const e6 = this.elevationInfo;
    "mesh-pyramids" === this.profile && $2(n.getLogger(this), P("Mesh scene layers", "relative-to-scene", e6)), $2(n.getLogger(this), w2("Scene layers", e6));
  }
  fetchStatistics(e6, t8) {
    return __async(this, null, function* () {
      return yield i4({
        fieldName: e6,
        statisticsInfo: this.statisticsInfo,
        errorContext: "scenelayer",
        fieldsIndex: this.fieldsIndex,
        path: this.parsedUrl?.path ?? "",
        customParameters: this.customParameters,
        apiKey: this.apiKey,
        signal: t8?.signal
      });
    });
  }
};
e2([y({
  types: {
    key: "type",
    base: t6,
    typeMap: {
      selection: p6
    }
  },
  json: {
    origins: {
      "web-scene": {
        name: "layerDefinition.featureReduction",
        write: true
      },
      "portal-item": {
        name: "layerDefinition.featureReduction",
        write: true
      }
    }
  }
})], je.prototype, "featureReduction", void 0), e2([y({
  type: [s7],
  json: {
    read: false,
    origins: {
      "web-scene": {
        name: "layerDefinition.rangeInfos",
        write: true
      },
      "portal-item": {
        name: "layerDefinition.rangeInfos",
        write: true
      }
    }
  }
})], je.prototype, "rangeInfos", void 0), e2([y({
  json: {
    read: false
  }
})], je.prototype, "associatedLayer", void 0), e2([y({
  type: ["show", "hide"]
})], je.prototype, "listMode", void 0), e2([y({
  type: ["ArcGISSceneServiceLayer"]
})], je.prototype, "operationalLayerType", void 0), e2([y({
  json: {
    read: false
  },
  readOnly: true
})], je.prototype, "type", void 0), e2([y(__spreadProps(__spreadValues({}, Le.fields), {
  readOnly: true,
  json: {
    read: false,
    origins: {
      service: {
        read: true
      }
    }
  }
}))], je.prototype, "fields", void 0), e2([y()], je.prototype, "types", null), e2([y()], je.prototype, "typeIdField", null), e2([y()], je.prototype, "templates", null), e2([y()], je.prototype, "formTemplate", null), e2([y({
  readOnly: true,
  clonable: false
})], je.prototype, "fieldsIndex", null), e2([y({
  type: p5,
  json: {
    read: {
      source: "layerDefinition.floorInfo"
    },
    write: {
      target: "layerDefinition.floorInfo"
    }
  }
})], je.prototype, "floorInfo", void 0), e2([y(Le.outFields)], je.prototype, "outFields", void 0), e2([y({
  type: p2,
  readOnly: true,
  json: {
    read: false
  }
})], je.prototype, "nodePages", void 0), e2([o("service", "nodePages", ["nodePages", "pointNodePages"])], je.prototype, "readNodePages", null), e2([y({
  type: [a4],
  readOnly: true
})], je.prototype, "materialDefinitions", void 0), e2([y({
  type: [y3],
  readOnly: true
})], je.prototype, "textureSetDefinitions", void 0), e2([y({
  type: [m],
  readOnly: true
})], je.prototype, "geometryDefinitions", void 0), e2([y({
  readOnly: true
})], je.prototype, "serviceUpdateTimeStamp", void 0), e2([y({
  readOnly: true
})], je.prototype, "attributeStorageInfo", void 0), e2([y({
  readOnly: true
})], je.prototype, "statisticsInfo", void 0), e2([y({
  type: V.ofType(Number),
  nonNullable: true,
  json: {
    origins: {
      service: {
        read: false,
        write: false
      }
    },
    name: "layerDefinition.excludeObjectIds",
    write: {
      enabled: true
    }
  }
})], je.prototype, "excludeObjectIds", void 0), e2([y({
  type: String,
  json: {
    origins: {
      service: {
        read: false,
        write: false
      }
    },
    name: "layerDefinition.definitionExpression",
    write: {
      enabled: true,
      allowNull: true
    }
  }
})], je.prototype, "definitionExpression", void 0), e2([y({
  type: h,
  json: {
    name: "layerDefinition.polygonFilter",
    write: {
      enabled: true,
      allowNull: true
    },
    origins: {
      service: {
        read: false,
        write: false
      }
    }
  }
})], je.prototype, "filter", void 0), e2([y({
  type: String,
  json: {
    origins: {
      "web-scene": {
        read: true,
        write: true
      }
    },
    read: false
  }
})], je.prototype, "path", void 0), e2([y(d)], je.prototype, "elevationInfo", null), e2([y({
  readOnly: true,
  json: {
    read: false
  }
})], je.prototype, "effectiveCapabilities", null), e2([y({
  readOnly: true
})], je.prototype, "effectiveEditingEnabled", null), e2([y({
  type: String
})], je.prototype, "geometryType", null), e2([y(l)], je.prototype, "labelsVisible", void 0), e2([y({
  type: [C3],
  json: {
    origins: {
      service: {
        name: "drawingInfo.labelingInfo",
        read: {
          reader: l3
        },
        write: false
      }
    },
    name: "layerDefinition.drawingInfo.labelingInfo",
    read: {
      reader: l3
    },
    write: true
  }
})], je.prototype, "labelingInfo", void 0), e2([y(y2)], je.prototype, "legendEnabled", void 0), e2([y({
  type: Number,
  json: {
    origins: {
      "web-document": {
        default: 1,
        write: {
          enabled: true,
          target: {
            opacity: {
              type: Number
            },
            "layerDefinition.drawingInfo.transparency": {
              type: Number
            }
          }
        },
        read: {
          source: ["opacity", "layerDefinition.drawingInfo.transparency"],
          reader(e6, t8) {
            if ("number" == typeof e6 && e6 >= 0 && e6 <= 1) return e6;
            const r3 = t8.layerDefinition?.drawingInfo?.transparency;
            return void 0 !== r3 ? r(r3) : void 0;
          }
        }
      },
      "portal-item": {
        write: true
      },
      service: {
        read: false
      }
    }
  }
})], je.prototype, "opacity", void 0), e2([y({
  type: ["Low", "High"],
  readOnly: true,
  json: {
    read: false,
    origins: {
      service: {
        read: true
      }
    }
  }
})], je.prototype, "priority", void 0), e2([y({
  type: ["Labels"],
  readOnly: true,
  json: {
    read: false,
    origins: {
      service: {
        read: true
      }
    }
  }
})], je.prototype, "semantic", void 0), e2([y({
  types: u2,
  json: {
    origins: {
      service: {
        read: {
          source: "drawingInfo.renderer"
        }
      }
    },
    name: "layerDefinition.drawingInfo.renderer",
    write: true
  },
  value: null
})], je.prototype, "renderer", null), e2([y({
  json: {
    read: false
  }
})], je.prototype, "cachedDrawingInfo", void 0), e2([o("service", "cachedDrawingInfo")], je.prototype, "readCachedDrawingInfo", null), e2([y({
  readOnly: true,
  json: {
    read: false
  }
})], je.prototype, "capabilities", null), e2([y({
  type: Boolean,
  json: {
    read: false
  }
})], je.prototype, "editingEnabled", null), e2([y({
  readOnly: true,
  json: {
    write: false,
    read: false
  }
})], je.prototype, "infoFor3D", null), e2([y({
  readOnly: true,
  json: {
    write: false,
    read: false
  }
})], je.prototype, "relationships", null), e2([y(s4)], je.prototype, "popupEnabled", void 0), e2([y({
  type: k,
  json: {
    name: "popupInfo",
    write: true
  }
})], je.prototype, "popupTemplate", void 0), e2([y({
  readOnly: true,
  json: {
    read: false
  }
})], je.prototype, "defaultPopupTemplate", null), e2([y({
  type: String,
  json: {
    read: false
  }
})], je.prototype, "objectIdField", void 0), e2([o("service", "objectIdField", ["objectIdField", "fields"])], je.prototype, "readObjectIdField", null), e2([y({
  type: String,
  json: {
    read: false
  }
})], je.prototype, "globalIdField", void 0), e2([o("service", "globalIdField", ["globalIdField", "fields"])], je.prototype, "readGlobalIdField", null), e2([y({
  readOnly: true,
  type: String,
  json: {
    read: false
  }
})], je.prototype, "displayField", null), e2([y({
  type: String,
  json: {
    read: false
  }
})], je.prototype, "profile", void 0), e2([o("service", "profile", ["store.profile"])], je.prototype, "readProfile", null), e2([y({
  readOnly: true,
  type: String,
  json: {
    origins: {
      service: {
        read: {
          source: "store.normalReferenceFrame"
        }
      }
    },
    read: false
  }
})], je.prototype, "normalReferenceFrame", void 0), e2([y(t2)], je.prototype, "screenSizePerspectiveEnabled", void 0), e2([y({
  json: {
    read: false,
    origins: {
      service: {
        read: true
      }
    }
  }
})], je.prototype, "serviceItemId", void 0), e2([y(f3)], je.prototype, "useViewTime", null), je = e2([a3("esri.layers.SceneLayer")], je);
var Fe = {
  "mesh-pyramids": "mesh-pyramids",
  meshpyramids: "mesh-pyramids",
  "features-meshes": "mesh-pyramids",
  points: "points",
  "features-points": "points",
  lines: "lines",
  "features-lines": "lines",
  polygons: "polygons",
  "features-polygons": "polygons"
};
var Se = {
  "mesh-pyramids": "mesh",
  points: "point"
};
var _e = je;
export {
  _e as default
};
//# sourceMappingURL=SceneLayer-MU5UG2EL.js.map
