{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/smartMapping/statistics/support/utils.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport \"../../../geometry.js\";\nimport e from \"../../../core/Error.js\";\nimport { pt2px as t } from \"../../../core/screenUtils.js\";\nimport { millisecondsPerTimeUnit as n } from \"../../../core/timeUtils.js\";\nimport r from \"../../../geometry/SpatialReference.js\";\nimport { quantizePoint as o } from \"../../../geometry/support/quantizationUtils.js\";\nimport { isWrappable as i, getInfo as s } from \"../../../geometry/support/spatialReferenceUtils.js\";\nimport { isTimeOnlyField as l, isNumericField as u, numericTypes as a } from \"../../../layers/support/fieldUtils.js\";\nimport { evaluateDensityKernel as f, createValueFunction as m } from \"../../../renderers/support/heatmapUtils.js\";\nimport { isAnyDateField as c } from \"../../support/utils.js\";\nimport { processNullValue as p, getNormalizedValue as d } from \"../../../statistics/utils.js\";\nimport { loadArcade as h } from \"../../../support/arcadeOnDemand.js\";\nimport y from \"../../../geometry/Point.js\";\nlet $ = null;\nconst g = /^(?<hh>([0-1][0-9])|([2][0-3])):(?<mm>[0-5][0-9])(:(?<ss>[0-5][0-9]))?([.](?<ms>\\d+))?$/;\nfunction I(e, t, n) {\n  return e.x < 0 ? e.x += t : e.x > n && (e.x -= t), e;\n}\nfunction j(e, t, n, r) {\n  const l = i(n) ? s(n) : null,\n    u = l ? Math.round((l.valid[1] - l.valid[0]) / t.scale[0]) : null;\n  return e.map(e => {\n    const n = new y(e.geometry);\n    return o(t, n, n), e.geometry = l ? I(n, u ?? 0, r[0]) : n, e;\n  });\n}\nfunction x(e, n = 18, r, o, i) {\n  const s = new Float64Array(o * i);\n  n = Math.round(t(n));\n  let l = Number.POSITIVE_INFINITY,\n    u = Number.NEGATIVE_INFINITY;\n  const a = m(r);\n  for (const {\n    geometry: t,\n    attributes: m\n  } of e) {\n    const {\n        x: e,\n        y: r\n      } = t,\n      c = Math.max(0, e - n),\n      p = Math.max(0, r - n),\n      d = Math.min(i, r + n),\n      h = Math.min(o, e + n),\n      y = +a(m);\n    for (let t = p; t < d; t++) for (let i = c; i < h; i++) {\n      const a = t * o + i,\n        m = f(i - e, t - r, n) * y,\n        c = s[a] += m;\n      l = Math.min(l, c), u = Math.max(u, c);\n    }\n  }\n  return {\n    min: l,\n    max: u\n  };\n}\nfunction w(e) {\n  const t = g.exec(e);\n  if (!t) return null;\n  const {\n    hh: r,\n    mm: o,\n    ss: i,\n    ms: s\n  } = t.groups;\n  return Number(r) * n.hours + Number(o) * n.minutes + Number(i) * n.seconds + Number(s || 0);\n}\nasync function b(e, t, n = !0) {\n  if (!t) return [];\n  const {\n      field: o,\n      field2: i,\n      field3: s,\n      fieldDelimiter: u,\n      fieldInfos: a,\n      timeZone: f\n    } = e,\n    m = o && a?.find(e => e.name.toLowerCase() === o.toLowerCase()),\n    y = !!m && l(m),\n    g = !!m && c(m),\n    I = e.valueExpression,\n    j = e.normalizationType,\n    x = e.normalizationField,\n    b = e.normalizationTotal,\n    F = [],\n    N = e.viewInfoParams;\n  let E = null,\n    v = null;\n  if (I) {\n    if (!$) {\n      const {\n        arcadeUtils: e\n      } = await h();\n      $ = e;\n    }\n    $.hasGeometryOperations(I) && (await $.enableGeometryOperations()), E = $.createFunction(I), v = N ? $.getViewInfo({\n      viewingMode: N.viewingMode,\n      scale: N.scale,\n      spatialReference: new r(N.spatialReference)\n    }) : null;\n  }\n  const U = e.fieldInfos,\n    M = !(t[0] && \"declaredClass\" in t[0] && \"esri.Graphic\" === t[0].declaredClass) && U ? {\n      fields: U\n    } : null;\n  return t.forEach(e => {\n    const t = e.attributes;\n    let r;\n    if (I) {\n      const t = M ? {\n          ...e,\n          layer: M\n        } : e,\n        n = $.createExecContext(t, v, f);\n      r = $.executeFunction(E, n);\n    } else t && (r = t[o], i ? (r = `${p(r)}${u}${p(t[i])}`, s && (r = `${r}${u}${p(t[s])}`)) : \"string\" == typeof r && n && (g ? r = r ? new Date(r).getTime() : null : y && (r = r ? w(r) : null)));\n    if (j && \"number\" == typeof r && isFinite(r)) {\n      const e = t && parseFloat(t[x]);\n      r = d(r, j, e, b);\n    }\n    F.push(r);\n  }), F;\n}\nfunction F(e) {\n  const t = e.field,\n    n = e.normalizationType,\n    r = e.normalizationField;\n  let o;\n  return \"field\" === n ? o = \"(NOT \" + r + \" = 0)\" : \"log\" !== n && \"natural-log\" !== n && \"square-root\" !== n || (o = `(${t} > 0)`), o;\n}\nfunction N(e, t, n) {\n  const r = null != t ? e + \" >= \" + t : \"\",\n    o = null != n ? e + \" <= \" + n : \"\";\n  let i = \"\";\n  return i = r && o ? U(r, o) : r || o, i ? \"(\" + i + \")\" : \"\";\n}\nfunction E(t, n, r, o) {\n  let i;\n  return n ? n.name !== t.objectIdField && o.includes(n.type) || (i = new e(r, \"'field' should be one of these types: \" + o.join(\",\"))) : i = new e(r, \"'field' is not defined in the layer schema\"), i;\n}\nfunction v(t, n, r) {\n  let o;\n  return n ? n.name !== t.objectIdField && u(n) || (o = new e(r, \"'field' should be one of these numeric types: \" + a.join(\",\"))) : o = new e(r, \"'field' is not defined in the layer schema\"), o;\n}\nfunction U(e, t) {\n  let n = null != e ? e : \"\";\n  return null != t && t && (n = n ? \"(\" + n + \") AND (\" + t + \")\" : t), n;\n}\nfunction M(t, n) {\n  if (t && \"intersects\" !== t.spatialRelationship) return new e(n, \"Only 'intersects' spatialRelationship is supported for featureFilter\");\n}\nfunction T(t, n, r) {\n  const o = z({\n    layer: t,\n    fields: n\n  });\n  if (o.length) return new e(r, \"Unknown fields: \" + o.join(\", \") + \". You can only use fields defined in the layer schema\");\n  const i = O({\n    layer: t,\n    fields: n\n  });\n  return i.length ? new e(r, \"Unsupported fields: \" + i.join(\", \") + \". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true\") : void 0;\n}\nfunction z(e) {\n  const t = e.layer;\n  return e.fields.filter(e => !t.getField(e));\n}\nfunction O(e) {\n  const t = e.layer;\n  return e.fields.filter(e => {\n    const n = t.getFieldUsageInfo(e);\n    return !n || !n.supportsStatistics;\n  });\n}\nfunction R(e, t, n) {\n  const r = [],\n    o = [],\n    i = [],\n    s = [],\n    l = [];\n  e.forEach((e, t) => {\n    const u = e.field ? \"field\" : \"expression\",\n      a = e.field || e.valueExpression;\n    e.field ? (l.push(a), o.push(`var ${u}${t} = Number($feature[\"${a}\"]);`)) : (r.push(`function getValueForExpr${t}() {\\n  ${a} \\n}`), o.push(`var ${u}${t} = Number(getValueForExpr${t}());`)), n || i.push(`${u}${t} = IIf(${u}${t} < 0, 0, ${u}${t});`), s.push(`${u}${t}`);\n  });\n  let u = \"return sum;\";\n  const a = r.length ? null : l.reduce((e, t) => `${e} + ${t}`);\n  let f = null;\n  t || n ? t ? n || (u = \"return IIf(sum >= 0, sum, null);\", a && (f = `(( ${a} ) >= 0)`)) : (u = \"return IIf(sum != 0, sum, null);\", a && (f = `(( ${a} ) <> 0)`)) : (u = \"return IIf(sum > 0, sum, null);\", a && (f = `(( ${a} ) > 0)`));\n  return {\n    valueExpression: [r.length ? r.join(\"\\n\") : \"\", o.join(\"\\n\"), i.join(\"\\n\"), `var sum = ${s.join(\" + \")};`, u].filter(Boolean).join(\"\\n\\n\"),\n    sqlExpression: a,\n    sqlWhere: f\n  };\n}\nexport { x as calculateHeatmapStats, b as getDataValues, N as getRangeExpr, F as getSQLFilterForNormalization, R as getSumOfAttributesExpr, U as mergeWhereClauses, j as quantizeFeatures, w as timeOnlyToMilliseconds, T as verifyBasicFieldValidity, E as verifyFieldType, M as verifyFilterValidty, v as verifyNumericField };"],
  "mappings": "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",
  "names": ["j", "r", "l", "u", "e", "n", "i", "s", "c", "t", "a", "m", "f", "g", "I", "x", "b"]
}
