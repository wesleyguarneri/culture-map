{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/LocalFromScreenSpace.glsl.js", "../../../../../../node_modules/@arcgis/core/chunks/Viewshed.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { translate as r, invertOrIdentity as e } from \"../../../../../../core/libs/gl-matrix-2/math/mat4.js\";\nimport { create as o } from \"../../../../../../core/libs/gl-matrix-2/factories/mat4f64.js\";\nimport { zeros as i } from \"../../../../../../core/libs/gl-matrix-2/factories/vec3f64.js\";\nimport { CameraSpace as t } from \"./CameraSpace.glsl.js\";\nimport { NoParameters as a, glsl as c } from \"../../shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as s } from \"../../shaderModules/Matrix4PassUniform.js\";\nclass m extends a {\n  constructor() {\n    super(...arguments), this.localOrigin = i();\n  }\n}\nfunction n(i) {\n  i.include(t), i.fragment.uniforms.add(new s(\"inverseViewMatrix\", (i, t) => {\n    const a = o();\n    return r(a, t.camera.viewMatrix, i.localOrigin), e(a, a);\n  })), i.fragment.code.add(c`vec4 reconstructLocalPosition(vec2 coord, float linearDepth) {\nvec4 cameraSpace = vec4(reconstructPosition(coord, linearDepth), 1.0);\nreturn inverseViewMatrix * cameraSpace;\n}`);\n}\nexport { n as LocalFromScreenSpace, m as LocalFromScreenSpacePassParameters };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { invertOrIdentity as e } from \"../core/libs/gl-matrix-2/math/mat4.js\";\nimport { IDENTITY as i, create as o } from \"../core/libs/gl-matrix-2/factories/mat4f64.js\";\nimport { NormalFromDepth as t } from \"../views/3d/webgl-engine/core/shaderLibrary/NormalFromDepth.glsl.js\";\nimport { ScreenSpacePass as r } from \"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js\";\nimport { ReadDepth as a } from \"../views/3d/webgl-engine/core/shaderLibrary/output/ReadDepth.glsl.js\";\nimport { LocalFromScreenSpacePassParameters as s, LocalFromScreenSpace as n } from \"../views/3d/webgl-engine/core/shaderLibrary/util/LocalFromScreenSpace.glsl.js\";\nimport { Rgba4FloatEncoding as d } from \"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloat16Encoding.glsl.js\";\nimport { TextureAtlasLookup as l } from \"../views/3d/webgl-engine/core/shaderLibrary/util/TextureAtlasLookup.glsl.js\";\nimport { Float2PassUniform as h } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float3PassUniform as c } from \"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";\nimport { FloatsPassUniform as v } from \"../views/3d/webgl-engine/core/shaderModules/FloatsPassUniform.js\";\nimport { IntegerPassUniform as w } from \"../views/3d/webgl-engine/core/shaderModules/IntegerPassUniform.js\";\nimport { glsl as m } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as p } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { Matrix4sPassUniform as u } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4sPassUniform.js\";\nimport { ShaderBuilder as f } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as g } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nclass x extends s {\n  constructor() {\n    super(...arguments), this.targetVector = [1, 0, 0], this.upVector = [0, 0, 1], this.fovs = [45, 45], this.headingAndTilt = [0, 0], this.shadowMap = {\n      depthTexture: null,\n      nearFar: [1, 100],\n      numActiveFaces: 1,\n      atlasRegions: [[0, 0, 1, 1]]\n    }, this.projectionMatrices = i.flat(), this.viewMatrices = i.flat();\n  }\n}\nfunction b(i) {\n  const o = new f(),\n    s = o.fragment;\n  o.include(r), o.include(n), o.include(l), s.include(a), s.include(d), s.uniforms.add(new g(\"depthTexture\", (e, i) => i.depth?.attachment)), s.uniforms.add(new p(\"inverseProjectionMatrix\", (e, i) => i.camera.inverseProjectionMatrix), new p(\"inverseViewNormalMatrix\", (i, o) => e(M, o.camera.viewInverseTransposeMatrix))), s.uniforms.add(new c(\"viewshedTargetVector\", (e, i) => e.targetVector), new c(\"viewshedUpVector\", (e, i) => e.upVector), new h(\"viewshedFOVs\", (e, i) => e.fovs), new h(\"viewshedHeadingAndTilt\", (e, i) => e.headingAndTilt), new h(\"viewshedNearFar\", (e, i) => e.shadowMap.nearFar ?? [1, 100])), s.uniforms.add(new g(\"viewshedShadowMap\", e => e.shadowMap.depthTexture), new u(\"viewshedProjectionMatrices\", (e, i) => e.projectionMatrices, 6), new u(\"viewshedViewMatrices\", (e, i) => e.viewMatrices, 6), new w(\"viewshedNumFaces\", (e, i) => e.shadowMap.numActiveFaces), new v(\"viewshedAtlasRegions\", (e, i) => e.shadowMap.atlasRegions.flat(), 24)), s.constants.add(\"visibleColor\", \"vec4\", [0, 1, 0, .5]), s.constants.add(\"occludedColor\", \"vec4\", [1, 0, 0, .5]);\n  const x = i.useNormalMap;\n  return x ? (s.uniforms.add(new g(\"normalMap\", (e, i) => e.normalTexture)), s.code.add(m`vec3 normalFromTexture() {\nvec4 norm4 = texture(normalMap, uv);\nvec3 nNormal = vec3(-1.0) + 2.0 * norm4.xyz;\nreturn normalize((inverseViewNormalMatrix * vec4(nNormal, 1.0)).xyz);\n}`)) : o.include(t), s.code.add(m`\n    // UV coordinates of point projected onto viewshed shadow map\n    vec2 getViewshedUv(vec4 worldPosition, int face) {\n      mat4 viewshedMatrix = viewshedProjectionMatrices[face];\n      vec4 viewshedUv4 = viewshedMatrix * worldPosition;\n      vec3 viewshedUv = viewshedUv4.xyz / viewshedUv4.w;\n      return viewshedUv.xy;\n    }\n\n    float viewshedDepthToFloat(float depth) {\n      return (depth - viewshedNearFar[0]) / (viewshedNearFar[1] - viewshedNearFar[0]);\n    }\n\n    // Orthographic depth to viewshed of given point and given cube map face in range [0, 1].\n    float getOrthographicDepthToViewshed(vec4 worldPosition, int face) {\n      mat4 viewshedViewMatrix = viewshedViewMatrices[face];\n      vec4 viewshedUv4 = viewshedViewMatrix * worldPosition;\n      vec3 viewshedUv = viewshedUv4.xyz / viewshedUv4.w;\n      float depth = -viewshedUv.z;\n      return viewshedDepthToFloat(depth);\n    }\n\n    // Read depth from shadow map given uv and cube map face\n    float getDepthFromShadowMap(vec2 uv, int face) {\n      int index = 4 * face;\n\n      float umin = viewshedAtlasRegions[index];\n      float umax = viewshedAtlasRegions[index + 1];\n      float vmin = viewshedAtlasRegions[index + 2];\n      float vmax = viewshedAtlasRegions[index + 3];\n\n      vec4 atlasRegion = vec4(umin, vmin, umax, vmax);\n      return rgba4ToFloat(textureAtlasLookup(viewshedShadowMap, uv, atlasRegion));\n    }\n\n    struct ViewshedPoint {\n      int face;\n      vec2 uv;\n      bool isWithin;\n      float orthographicDepth;\n    };\n\n    // Find cube map face the given position lies in and return relevant information about it\n    bool getViewshedPoint(vec4 worldPosition, out ViewshedPoint point) {\n      vec3 nUp = normalize(viewshedUpVector);\n\n      // Try with all active cube map faces\n      for(int i=0; i < viewshedNumFaces; i++) {\n\n        // Check if when projected, point lies within shadow map texture\n        vec2 viewshedUv = getViewshedUv(worldPosition, i);\n        if (viewshedUv.x > 0.0 && viewshedUv.x < 1.0 && viewshedUv.y > 0.0 && viewshedUv.y < 1.0) {\n          float orthoDepth = getOrthographicDepthToViewshed(worldPosition, i);\n          if (orthoDepth >= 0.0) { // found a cube map face\n\n            // Check whether point is really inside viewshed geometry, not just within the camera frustum\n\n            // outside farDistance\n            vec3 position = worldPosition.xyz;\n            bool isWithin = length(position) <= viewshedNearFar[1];\n\n            // horizontally outside fov\n            float t = dot(nUp, position);\n            bool isBottomHalf = t > 0.0;\n            vec3 nProjVector = normalize(position - t * nUp);\n            if (isWithin) {\n              float angle = acos(dot(normalize(viewshedTargetVector), nProjVector));\n              if (angle > viewshedFOVs[0] / 2.0) {\n                isWithin = false;\n              }\n            }\n\n            // vertically outside fov\n            if (isWithin) {\n              float angle = acos(dot(nProjVector, normalize(position)));\n              if (!isBottomHalf) {\n                angle = -angle;\n              }\n              float tilt = viewshedHeadingAndTilt[1];\n              float limit = viewshedFOVs[1] / 2.0;\n              if (angle > limit || angle < -limit) {\n                isWithin = false;\n              }\n            }\n\n            point = ViewshedPoint(i, viewshedUv, isWithin, orthoDepth);\n            return true;\n          }\n        }\n      }\n\n      // no cube face matches\n      return false;\n    }\n\n    float normalCosAngle(float linearDepth, vec3 localPosition) {\n      ${x ? m`vec3 normal = normalFromTexture();` : m`\n        vec3 cameraSpacePosition = reconstructPosition(gl_FragCoord.xy, linearDepth);\n        vec3 normal = normalFromDepth(depthTexture, cameraSpacePosition, gl_FragCoord.xy, uv);\n        normal = (inverseViewNormalMatrix * vec4(normal, 1.0)).xyz;\n        `};\n\n      vec3 viewingDir = normalize(localPosition);\n      return dot(normal, viewingDir);\n    }\n\n    void main() {\n      float depth = depthFromTexture(depthTexture, uv);\n\n      // Outside camera planes\n      if (depth >= 1.0 || depth <= 0.0) {\n        return;\n      }\n\n      float linearDepth = linearizeDepth(depth);\n\n      // Relative to viewshed position\n      vec4 localPosition = reconstructLocalPosition(gl_FragCoord.xy, linearDepth);\n\n      ViewshedPoint point;\n      bool foundFace = getViewshedPoint(localPosition, point);\n\n      // Outside every viewshed\n      if (!foundFace || !point.isWithin) {\n        return;\n      }\n\n      float viewshedDepth = getDepthFromShadowMap(point.uv, point.face);\n      float distance = point.orthographicDepth;\n\n      bool visible = distance < viewshedDepth;\n      fragColor = visible ? visibleColor : occludedColor;\n\n      float cosAngle = normalCosAngle(linearDepth, localPosition.xyz);\n\n      // Everything facing away, and close to parallel is considered occluded.\n      // Theshold corresponds to around 0.6 degrees, tuned empirically.\n      if (cosAngle > -0.01) {\n        fragColor = occludedColor;\n      }\n    }`), o;\n}\nconst M = o(),\n  P = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    ViewshedPassParameters: x,\n    build: b\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { x as V, P as a, b };"],
  "mappings": "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",
  "names": ["n", "i", "e", "a", "o", "o", "i", "s", "n", "e", "x"]
}
