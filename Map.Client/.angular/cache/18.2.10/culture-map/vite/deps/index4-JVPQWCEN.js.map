{
  "version": 3,
  "sources": ["../../../../../../node_modules/@esri/calcite-components/dist/components/index4.js"],
  "sourcesContent": ["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\n * v2.13.2\n */\nimport { timeZones } from './time-zones.js';\nimport { extractRegion, global } from './region.js';\nconst now = new Date();\nconst startDate = now.toISOString();\nconst daysInYear = 365;\nconst groupDateRange = daysInYear;\nconst defaultGroupingOptions = {\n  groupDateRange,\n  startDate\n};\nconst _getDates = (startDate, numberDays, dateEngine) => {\n  const dateArray = [];\n  let date = dateEngine.create(startDate);\n  for (let i = 0; i <= numberDays; i++) {\n    date = dateEngine.increase(date);\n    dateArray.push(dateEngine.formatToIsoDateString(date));\n  }\n  return dateArray;\n};\nconst generateTimeZoneMetadata = (timeZoneItems, startDate, numberDays, dateEngine) => {\n  const processedDates = new Map();\n  const theDates = _getDates(startDate, numberDays, dateEngine);\n  return timeZoneItems.map(tzItem => {\n    const {\n      label\n    } = tzItem;\n    const continent = extractRegion(label);\n    const dates = theDates.map(date => {\n      const key = `${date}-${label}`;\n      let utc = processedDates.get(key);\n      if (utc) {\n        return utc;\n      }\n      utc = dateEngine.isoToTimeZone(date, label);\n      processedDates.set(key, utc);\n      return utc;\n    });\n    return {\n      ...tzItem,\n      continent,\n      isRegularContinent: continent !== global,\n      dates\n    };\n  });\n};\nconst compareDateArrs = (array1, array2, dateEngine) => array1.length === array2.length && array1.every((value, index) => dateEngine.same(value, array2[index]));\nconst getGroupLabelTimeZoneIndices = (rawTZs, max = 5) => {\n  const shrinkedTzs = rawTZs.filter(({\n    label\n  }) => extractRegion(label) !== global);\n  if (shrinkedTzs.length === 0) {\n    return [0];\n  }\n  const validLabels = shrinkedTzs.map(tz => rawTZs.indexOf(tz));\n  return equallyDistributedSampling(validLabels, max);\n};\nfunction equallyDistributedSampling(items, maxItems = 5) {\n  const totalItems = items.length;\n  if (totalItems <= maxItems) {\n    return items;\n  }\n  const numberItemsToSelect = Math.min(totalItems - 2, maxItems - 2);\n  const stepSize = (totalItems - 1) / (numberItemsToSelect + 1);\n  return [items[0], ...Array.from({\n    length: numberItemsToSelect\n  }, (_, i) => items[Math.round((i + 1) * stepSize)]), items[totalItems - 1]];\n}\nasync function groupByOffset(options) {\n  const {\n    groupDateRange,\n    startDate,\n    dateEngine\n  } = {\n    ...defaultGroupingOptions,\n    ...options\n  };\n  const grouping = [];\n  if (!dateEngine) {\n    throw new Error('dateEngine is required');\n  }\n  const timeZoneItems = timeZones.map(tz => ({\n    label: tz\n  }));\n  const timeZoneMetadata = generateTimeZoneMetadata(timeZoneItems, startDate, groupDateRange, dateEngine);\n  // We traverse the mappedDB and see if we find matches by comparing each set\n  // of transformed date for that specific TZ.\n  for (const tzMetadatumI of timeZoneMetadata) {\n    const {\n      label,\n      continent,\n      dates\n    } = tzMetadatumI;\n    if (tzMetadatumI.visited) {\n      continue;\n    }\n    tzMetadatumI.visited = true;\n    const newGroup = {\n      labelIdx: [],\n      tzs: [{\n        label\n      }]\n    };\n    for (const tzMetadatumJ of timeZoneMetadata.filter(_ => !_.visited)) {\n      const {\n        label: labelJ,\n        continent: continentJ,\n        isRegularContinent: isRegularContinentJ,\n        dates: datesJ\n      } = tzMetadatumJ;\n      // We define a matching TZ by:\n      // 1) if both continents match (avoid grouping Antarctica with anything else)\n      // 2) if the transformed dates match in both TZs\n      if ((continent === continentJ || !isRegularContinentJ) && compareDateArrs(dates, datesJ, dateEngine)) {\n        const tzItem = {\n          label: labelJ\n        };\n        newGroup.tzs.push(tzItem);\n        tzMetadatumJ.visited = true;\n      }\n    }\n    grouping.push(newGroup);\n  }\n  // Now that we have a group, we want an easy way to find a fitting label for the group\n  // which is defined as the list of the most-common 7 cities, shown in alphabetical order\n  return grouping.map(group => {\n    group.tzs = group.tzs.sort((a, b) => a.label.localeCompare(b.label));\n    return {\n      labelTzIdx: getGroupLabelTimeZoneIndices(group.tzs, 7),\n      tzs: group.tzs.map(_ => _.label)\n    };\n  }).sort((a, b) => b.tzs.length - a.tzs.length);\n}\nexport { groupByOffset };\n\n"],
  "mappings": "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",
  "names": ["startDate", "groupDateRange"]
}
