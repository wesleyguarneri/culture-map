import {
  I as I3
} from "./chunk-WLZIKLQT.js";
import "./chunk-ISTWMT33.js";
import "./chunk-ZERTHD35.js";
import {
  f,
  i as i6,
  t as t6,
  x as x2
} from "./chunk-LC4TAVYF.js";
import {
  o as o2
} from "./chunk-6HNAQ6T3.js";
import {
  s as s4
} from "./chunk-KGPFLNKT.js";
import {
  a as a4
} from "./chunk-M66N34RL.js";
import {
  l as l4
} from "./chunk-UJF7LPVD.js";
import "./chunk-UAMCUBIO.js";
import "./chunk-DDIAZD6H.js";
import {
  G,
  e as e9,
  i as i5
} from "./chunk-ZIDRXKSJ.js";
import "./chunk-DBK2ELNZ.js";
import "./chunk-S2UCXOWF.js";
import "./chunk-VI6HLZLR.js";
import "./chunk-MYKOM3G6.js";
import "./chunk-6FZS4YUQ.js";
import "./chunk-JRZPZOI3.js";
import {
  t as t5
} from "./chunk-Z52R7W33.js";
import "./chunk-557LD7Q2.js";
import {
  a as a3,
  i as i4,
  l as l2
} from "./chunk-JXZY6SQ6.js";
import {
  t as t4
} from "./chunk-NSSWLGUQ.js";
import {
  l as l3
} from "./chunk-CITBGG5A.js";
import "./chunk-6HTAUV5K.js";
import {
  y as y2
} from "./chunk-5JJ6GBOU.js";
import {
  c as c3
} from "./chunk-D3AKDIJC.js";
import "./chunk-74INNEIP.js";
import "./chunk-7HBD4CJ3.js";
import {
  A,
  m as m2
} from "./chunk-5L3YXBNN.js";
import "./chunk-IFUKJDOU.js";
import "./chunk-LD5YIQXD.js";
import {
  N as N2
} from "./chunk-GOKBAMCG.js";
import "./chunk-E3P3LIVT.js";
import "./chunk-HUX6Y26H.js";
import "./chunk-JS5N3Y4L.js";
import "./chunk-PO7V7AQE.js";
import "./chunk-U4WO2GC4.js";
import "./chunk-JO76LYW5.js";
import "./chunk-A6XTYETO.js";
import "./chunk-EKCE56CG.js";
import "./chunk-4TJAOUC3.js";
import "./chunk-CILAEMQM.js";
import "./chunk-WRHEXEG3.js";
import "./chunk-3HAZL2RZ.js";
import "./chunk-XUAPJ5BK.js";
import "./chunk-TEOUFCJA.js";
import "./chunk-GTZOXRB5.js";
import "./chunk-3WPOFZBT.js";
import {
  d as d4
} from "./chunk-PPMHRAOP.js";
import "./chunk-75N5YDQB.js";
import "./chunk-3MNGTHM3.js";
import "./chunk-XGDLE7WK.js";
import "./chunk-QMUS26QM.js";
import "./chunk-GDEAPZ64.js";
import "./chunk-TCQSUQ7Y.js";
import "./chunk-GOOZVNO4.js";
import "./chunk-5RHKQDDL.js";
import "./chunk-FHW2TG7X.js";
import "./chunk-LQTSBE7P.js";
import "./chunk-GCFUJXGH.js";
import "./chunk-MBMY7SS6.js";
import "./chunk-ICUHXX2J.js";
import "./chunk-VIIVMRRO.js";
import "./chunk-ZKSEQXDM.js";
import "./chunk-675UQNXB.js";
import "./chunk-Z3FHX4FD.js";
import "./chunk-SUUOAZQT.js";
import "./chunk-TGHJVD7I.js";
import "./chunk-OZG2NNUW.js";
import "./chunk-LKHUGH5W.js";
import "./chunk-ODLAAWPY.js";
import "./chunk-VWVZLPC3.js";
import "./chunk-P2MXQ2EV.js";
import "./chunk-QZVEEM53.js";
import "./chunk-ACZYDHB3.js";
import "./chunk-JXVDTUGR.js";
import "./chunk-HAO4WCNW.js";
import "./chunk-X2OAE75B.js";
import "./chunk-UCPBGEQD.js";
import "./chunk-SIZK72CP.js";
import "./chunk-6A3XUATG.js";
import {
  e as e8,
  s as s3,
  u as u5
} from "./chunk-ZVFENZUF.js";
import "./chunk-MD2IQSSQ.js";
import {
  e as e6
} from "./chunk-VHERB2HE.js";
import {
  N,
  S as S2,
  a as a2,
  d as d3,
  e as e7,
  g as g2,
  i as i3,
  m,
  n as n5,
  r as r2,
  t as t3
} from "./chunk-5ATXT3S6.js";
import "./chunk-P7OSFLIX.js";
import "./chunk-ZDC4PV4Y.js";
import "./chunk-DLRYNII2.js";
import {
  c as c2
} from "./chunk-ENQEWBGS.js";
import "./chunk-WN3YAMRZ.js";
import "./chunk-NWICVENM.js";
import "./chunk-A4RKV2C7.js";
import "./chunk-SYYDVGKY.js";
import {
  D,
  E as E2
} from "./chunk-YLE5AYZV.js";
import {
  B,
  E,
  L,
  O,
  c,
  g,
  i as i2,
  k,
  u as u4,
  x
} from "./chunk-JNWMZ6EJ.js";
import "./chunk-VS26W5Y5.js";
import "./chunk-PVO5NM6Q.js";
import "./chunk-POQ3T5EH.js";
import {
  R
} from "./chunk-6MR4UDDL.js";
import "./chunk-N3IR233K.js";
import "./chunk-URWREU3E.js";
import "./chunk-KE2YMCJC.js";
import {
  n as n3
} from "./chunk-L7ZKWTWL.js";
import "./chunk-O2DTA3XK.js";
import "./chunk-3UOXF3CT.js";
import "./chunk-WDDCGJTI.js";
import "./chunk-PA7WZX2U.js";
import "./chunk-GPUGMSHU.js";
import "./chunk-AIS5CSUZ.js";
import "./chunk-52UEU7LG.js";
import "./chunk-WJKYGQOY.js";
import "./chunk-GY52WOQZ.js";
import "./chunk-GAYJ4YPJ.js";
import "./chunk-PPMDUJ4E.js";
import "./chunk-ZTT6ENBS.js";
import "./chunk-MFZTGYUJ.js";
import "./chunk-R5ZE5A4K.js";
import "./chunk-24CN3HDP.js";
import "./chunk-SZWWBMQN.js";
import "./chunk-ZE47C44H.js";
import "./chunk-5GIS2C3K.js";
import "./chunk-XCOHDMBF.js";
import "./chunk-R3F4JMNC.js";
import {
  I as I2,
  J
} from "./chunk-7B5YPLFX.js";
import {
  t as t2
} from "./chunk-RDQF44TE.js";
import {
  l
} from "./chunk-KKD7A2GN.js";
import "./chunk-ZWCV4HKG.js";
import "./chunk-N4KQPPPI.js";
import "./chunk-4OGGMTIH.js";
import {
  t
} from "./chunk-NQVBBKAN.js";
import {
  e as e5
} from "./chunk-4MMTPKY4.js";
import "./chunk-DY7FJHTG.js";
import "./chunk-Q4KYZS3X.js";
import {
  u as u3
} from "./chunk-KVKFHRJ3.js";
import "./chunk-VWML4J2J.js";
import {
  n as n4,
  s as s2
} from "./chunk-JYODC3YQ.js";
import {
  e as e3
} from "./chunk-BQZBOYBD.js";
import {
  e as e4,
  o
} from "./chunk-TYQXPPSP.js";
import {
  d as d2
} from "./chunk-HD65DNIO.js";
import "./chunk-4KWLMXIA.js";
import "./chunk-BIUXKPKA.js";
import "./chunk-N6TJI25E.js";
import "./chunk-634JLXD4.js";
import "./chunk-Y3EDGYWG.js";
import "./chunk-UF6JOUSJ.js";
import "./chunk-T5JGQSO3.js";
import "./chunk-CIW3KHOW.js";
import "./chunk-J55F4AC2.js";
import "./chunk-IQLBZKUD.js";
import "./chunk-7MZZCQ64.js";
import {
  r
} from "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import "./chunk-6A7CWJED.js";
import "./chunk-DUTZNK67.js";
import "./chunk-IN6BQCWS.js";
import "./chunk-CRNUMTSV.js";
import "./chunk-3RRMLFFN.js";
import "./chunk-HT2T6PUB.js";
import "./chunk-K64AAM77.js";
import "./chunk-6EUVKE22.js";
import {
  I,
  i
} from "./chunk-XTVPEVHA.js";
import "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import "./chunk-DZALMCYL.js";
import "./chunk-K226GFDN.js";
import "./chunk-4ZZRP4MA.js";
import "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import "./chunk-NYQ5CYNR.js";
import "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import {
  S,
  u as u2
} from "./chunk-AXVPJBVW.js";
import {
  e as e2,
  n as n2
} from "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import {
  T2 as T
} from "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import {
  P,
  d
} from "./chunk-6WHTZNUH.js";
import "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import "./chunk-XNUH25NY.js";
import "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e
} from "./chunk-4Z5SGKRM.js";
import {
  v
} from "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3 as a
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import {
  u
} from "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-WYIDUUN2.js";
import {
  has
} from "./chunk-DXLOWWK7.js";
import {
  __async
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/views/3d/layers/IntegratedMesh3DTilesViewPerformanceInfo.js
var t7 = class extends t4 {
  constructor(e10, t8, s5, r3, o3, h, c4) {
    super(e10, 0, 0, 0, t8), this.nodesCached = s5, this.vboMB = r3, this.textureMB = o3, this.vboMBCached = h, this.textureMBCached = c4;
  }
};

// ../../../node_modules/@arcgis/core/views/3d/layers/support/lyr3dTypeConversions.js
var l5 = {
  [r2.Points]: null,
  [r2.Lines]: null,
  [r2.LineStrip]: null,
  [r2.Triangles]: E2.TRIANGLES,
  [r2.TriangleStrip]: E2.TRIANGLE_STRIP,
  [r2.NotSet]: null
};
var T2 = {
  [a2.Opaque]: s3.Opaque,
  [a2.Mask]: s3.Mask,
  [a2.Blend]: s3.Blend
};
var P2 = {
  [S2.Back]: e8.Back,
  [S2.Front]: e8.Front,
  [S2.None]: e8.None,
  [S2.NotSet]: e8.Back
};
var _ = {
  [N.WrapYBit]: {
    s: D.CLAMP_TO_EDGE,
    t: D.REPEAT
  },
  [N.WrapXBit]: {
    s: D.REPEAT,
    t: D.CLAMP_TO_EDGE
  },
  [N.WrapXy]: {
    s: D.REPEAT,
    t: D.REPEAT
  },
  [N.None]: {
    s: D.CLAMP_TO_EDGE,
    t: D.CLAMP_TO_EDGE
  },
  [N.NotSet]: {
    s: D.CLAMP_TO_EDGE,
    t: D.CLAMP_TO_EDGE
  }
};
var A2 = {
  [e7.U8]: 1,
  [e7.I8]: 1,
  [e7.U16]: 2,
  [e7.I16]: 2,
  [e7.U32]: 4,
  [e7.I32]: 4,
  [e7.F32]: 4,
  [e7.F64]: 8,
  [e7.Utf8String]: 1,
  [e7.NotSet]: 1
};

// ../../../node_modules/@arcgis/core/views/3d/layers/support/Tiles3DIntersectionHandler.js
var l6 = class {
  constructor(e10) {
    this.layerUid = [], this.type = i5.TILES3D, this.slicePlaneEnabled = false, this.isGround = true, this.layerView = e10, this.layerUid.push(e10.layer.uid);
  }
  intersect(e10, r3, l7, o3, a5, c4) {
    const u6 = e10.results, d5 = e10.options.store === e9.ALL;
    if (e10.options.filteredLayerUids.includes(this.layerView.layer.uid)) return;
    const h = this.layerView.view._stage.renderView.componentObjectCollection, y3 = new m2(c4 ?? false, e10.options.normalRequired);
    this.layerView.objects.forEach((s5) => {
      s5.visible && s5.intersectionGeometry && h.intersect(s5, l7, o3, e10.tolerance, null, y3, (s6, n6, a6, c5) => {
        if (n6 >= 0) {
          if (null != r3 && !r3(l7, o3, n6)) return;
          const s7 = (e11) => {
            const t8 = new l4(this.layerView.layer.uid, () => this._createTiles3DGraphic(this.layerView.layer, {}));
            e11.set(this.type, t8, n6, a6);
          };
          if (this.isGround && (null == u6.ground.dist || n6 < u6.ground.dist) && s7(u6.ground), e10.options.isFiltered) return;
          if ((null == u6.min.dist || n6 < u6.min.dist) && s7(u6.min), (null == u6.max.dist || n6 > u6.max.dist) && s7(u6.max), d5) {
            const i7 = G(e10.ray);
            s7(i7), e10.results.all.push(i7);
          }
        }
      });
    });
  }
  _createTiles3DGraphic(i7, t8) {
    return new d2({
      layer: i7,
      sourceLayer: i7,
      attributes: t8
    });
  }
};

// ../../../node_modules/@arcgis/core/views/3d/layers/IntegratedMesh3DTilesLayerView3D.js
var Me;
!function(e10) {
  e10[e10.API = 1] = "API", e10[e10.VerboseAPI = 2] = "VerboseAPI", e10[e10.Error = 3] = "Error";
}(Me || (Me = {}));
var Pe = class {
  constructor() {
    this.handle = 0, this.isVisible = false, this.components = [], this.texMemoryUsage = 0, this.vboMemoryUsage = 0, this.cpuMemoryUsage = 0, this.textures = [];
  }
  totalMemory() {
    return this.texMemoryUsage + this.vboMemoryUsage + this.cpuMemoryUsage;
  }
};
function Oe(e10) {
  return Math.round(e10 / 1048.576) / 1e3;
}
var Ue = class extends l3(y2) {
  constructor() {
    super(...arguments), this.type = "integrated-mesh-3dtiles", this._visibleGeometryChangedSchedulerHandle = null, this._wasmLayerId = -1, this.ignoresMemoryFactor = false, this.drapeTargetType = t5.WithoutRasterImage, this._lyrHandleToObjects = /* @__PURE__ */ new Map(), this._initialCullFace = /* @__PURE__ */ new Map(), this._suspendedHandle = null, this._dbgFlags = /* @__PURE__ */ new Set();
  }
  initialize() {
    if (this._dbgFlags.add(Me.Error), this._dbg(Me.VerboseAPI, "Tiles3DLayerView3D initialize() called"), !this._canProjectWithoutEngine()) throw new s("layerview:spatial-reference-incompatible", "The spatial reference of this scene layer is incompatible with the spatial reference of the view", {});
    const e10 = i4(this).then((e11) => {
      this._intersectionHandler = new l6(this), this.view.sceneIntersectionHelper.addIntersectionHandler(this._intersectionHandler), this._updatingHandles.add(() => this.slicePlaneEnabled, (e12) => this._slicePlaneEnabledChange(e12)), this._elevationProvider = new x2({
        view: this.view,
        layerElevationSource: this,
        intersectionHandler: this._intersectionHandler
      }), this.view.elevationProvider.register("im", this._elevationProvider), this.view.basemapTerrain.overlayManager.registerDrapeTarget(this), this._wasmLayerId = e11;
      const t8 = this.view.resourceController.memoryController.newCache(`t3d-${this.uid}`, (e12) => this._onRemoveFromCache(e12));
      this._memCache = t8, this.addHandles([d(() => this.layer.elevationInfo, (e12) => this._elevationInfoChanged(e12))]), this._suspendedHandle = d(() => this.suspended, (e12) => {
        const t9 = l2(this.view);
        t9 && t9.setEnabled(this, !e12);
      }, P);
    }).catch((e11) => {
      if (a3(this), this._wasmLayerId = -1, e11 === m) throw new s("tiles3d:addLayer-failure", "The 3d tiles layer description was invalid.", {});
      if (e11 === d3) throw new s("tiles3d:addLayer-failure", "The 3d tiles layer web assembly module failed to download.", {});
    });
    this.addResolvingPromise(e10);
  }
  destroy() {
    this._dbg(Me.VerboseAPI, "Tiles3DLayerView3D destroy() called"), a3(this), this._suspendedHandle && (this._suspendedHandle.remove(), this._suspendedHandle = null), this._intersectionHandler && (this.view.sceneIntersectionHelper.removeIntersectionHandler(this._intersectionHandler), this._intersectionHandler = null), this._elevationProvider && (this._elevationProvider.objectsChanged(this._obbs), this.view.elevationProvider.unregister(this._elevationProvider), this._elevationProvider = null), this.view.basemapTerrain.overlayManager.unregisterDrapeTarget(this), this._lyrHandleToObjects.forEach((e10) => this.freeObject(e10)), this._lyrHandleToObjects.clear(), this._initialCullFace.clear(), this._memCache = u(this._memCache), this._updatingHandles = u(this._updatingHandles), this.emit("visible-geometry-changed"), this._visibleGeometryChangedSchedulerHandle && (this._visibleGeometryChangedSchedulerHandle.remove(), this._visibleGeometryChangedSchedulerHandle = null);
  }
  _visibleGeometryChanged() {
    null == this._visibleGeometryChangedSchedulerHandle && (this._visibleGeometryChangedSchedulerHandle = v(() => {
      this.emit("visible-geometry-changed"), this._visibleGeometryChangedSchedulerHandle = null;
    }));
  }
  _slicePlaneEnabledChange(e10) {
    this._intersectionHandler && (this._intersectionHandler.slicePlaneEnabled = e10), this.objects.forEach((t8) => {
      const r3 = this._collection.getMaterial(t8);
      r3.commonMaterialParameters.hasSlicePlane = e10, r3.commonMaterialParameters.cullFace = e10 ? e8.None : this._initialCullFace.get(t8);
    });
  }
  _elevationInfoChanged(e10) {
    const t8 = l2(this.view);
    t8 && t8.setLayerOffset(this, R(e10));
  }
  get _obbs() {
    return this.objects.map((e10) => this._collection.getComponentObb(e10));
  }
  get wasmLayerId() {
    return this._wasmLayerId;
  }
  get usedMemory() {
    let e10 = 0;
    return this._lyrHandleToObjects.forEach((t8) => {
      t8.isVisible && (e10 += t8.totalMemory());
    }), e10;
  }
  get unloadedMemory() {
    let e10 = 0;
    return this._lyrHandleToObjects.forEach((t8) => {
      t8.isVisible || (e10 += t8.totalMemory());
    }), e10;
  }
  get visibleAtCurrentScale() {
    return c3(this.layer.effectiveScaleRange, this.view.terrainScale);
  }
  get performanceInfo() {
    let e10 = 0, t8 = 0, r3 = 0, i7 = 0, s5 = 0, o3 = 0;
    return this._lyrHandleToObjects.forEach((n6) => {
      n6.isVisible ? (e10 += n6.texMemoryUsage, t8 += n6.vboMemoryUsage, s5++) : (r3 += n6.texMemoryUsage, i7 += n6.vboMemoryUsage, o3++);
    }), new t7(this.usedMemory, s5, o3, Oe(t8), Oe(e10), Oe(i7), Oe(r3));
  }
  _canProjectWithoutEngine() {
    if (this.view.state.viewingMode === l.Local) {
      const e10 = this.view.renderSpatialReference?.isWebMercator ? 3857 : this.view.renderSpatialReference?.wkid ?? -1;
      if (3857 !== e10 && 32662 !== e10) return false;
    }
    return true;
  }
  get _stage() {
    return this.view._stage;
  }
  get _collection() {
    return this._stage.renderView.componentObjectCollection;
  }
  get elevationOffset() {
    return R(this.layer.elevationInfo);
  }
  get elevationRange() {
    const e10 = this.fullExtent;
    return e10?.zmin && e10?.zmax ? new e6(e10.zmin, e10.zmax) : null;
  }
  getElevationRange(e10) {
    return null;
  }
  get fullExtent() {
    return this.layer.fullExtent;
  }
  get objects() {
    return Array.from(this._lyrHandleToObjects.values()).reduce((e10, t8) => e10.concat(t8.components), new Array());
  }
  isUpdating() {
    const e10 = l2(this.view);
    return !(this._wasmLayerId < 0 || null == e10) && e10.isUpdating(this._wasmLayerId);
  }
  updatingFlagChanged() {
    this.notifyChange("updating");
  }
  createRenderable(e10) {
    return __async(this, null, function* () {
      const t8 = e10.meshData;
      if (null == t8.data) throw new Error("meshData.data undefined");
      if (t8.desc = JSON.parse(t8.desc), null == t8.desc) throw new Error("meshData.desc undefined");
      const r3 = e2(t8.desc.origin), i7 = new Array(), s5 = /* @__PURE__ */ new Map(), o3 = new Pe();
      o3.handle = e10.handle, this._lyrHandleToObjects.set(e10.handle, o3);
      const n6 = this.view.basemapTerrain.spatialReference;
      let a5, l7;
      if ("global" === this.view.viewingMode) {
        const e11 = e3();
        u3(T, r3, e11, n6), a5 = n4(e4(), e11), l7 = s2(e4(), a5);
      } else a5 = o, l7 = o;
      const M = e3();
      i(M, M, r3);
      const P3 = I(n2(), M);
      let O2 = null;
      const U = n2();
      if (t8.desc.obb) {
        const e11 = t8.desc.obb.quaternion;
        O2 = new I2(t8.desc.obb.center, t8.desc.obb.halfSize, t(e11[0], e11[1], e11[2], e11[3]));
      }
      for (let c4 = 0; c4 < t8.desc.prims.length; c4++) {
        const e11 = t8.desc.prims[c4];
        if (this._dbg(Me.VerboseAPI, JSON.stringify(e11)), e11.ptype === r2.Lines) continue;
        if (null == l5[e11.ptype] || null == t8.data) {
          this._dbg(Me.VerboseAPI, "[Unsupported Feature] Unsupported primitive mode (" + e11.ptype + "). Skipping primitive.");
          continue;
        }
        const m3 = t8.desc?.materials && null != e11.materialId ? t8.desc.materials[e11.materialId] : null, h = null != m3 ? m3.lightingModel : g2.Unlit, u6 = !has("disable-feature:im-shading"), {
          positionView: p,
          positionAttr: f2,
          normalsView: g3,
          normalsAttr: w,
          colorAttr: x3,
          texCoord0Attr: j,
          indicesView: M2
        } = this.getBufferViews(e11, t8.data.buffer, a5, u6);
        if (null == f2 || null == p || null == M2) continue;
        const E3 = {
          colors: null != x3,
          textureCoordinates: null != j ? d4.Default : d4.None,
          hasNormals: null != g3,
          needsNormals: u6
        }, V = f2.data.length / f2.size, I4 = (e12, t9) => !e12 || e12.data.length / e12.size === V || (this._dbg(Me.Error, `${t9} !== numPos. Skipping primitive.`), false);
        if (!I4(j, "numTexcoord") || !I4(x3, "numColors") || !I4(w, "normals")) continue;
        const H = o2(E3);
        if (null != O2 ? O2 = O2.clone() : (O2 = J(f2), u2(U, O2.center, r3), O2.center = U), a5 !== o) for (let t9 = 0; t9 < p.count; t9++) p.getVec(t9, U), S(U, U, a5), p.setVec(t9, U);
        const R2 = H.createBuffer(f2.data.length), A3 = /* @__PURE__ */ new Map([[e5.POSITION, f2]]);
        null != j && A3.set(e5.UV0, j), null != x3 && A3.set(e5.COLOR, x3), null != w && A3.set(e5.NORMALCOMPRESSED, w), A3.forEach((e12, t9) => {
          null != e12 && A(t9, e12, null, null, R2, 0);
        });
        const F = new Uint32Array([0, M2.typedBuffer.length]), S3 = {
          vertices: {
            data: R2.buffer,
            count: R2.byteLength / H.stride,
            layoutParameters: E3
          },
          positionData: {
            positions: p.typedBuffer,
            indices: M2.typedBuffer
          },
          indices: M2.typedBuffer,
          componentOffsets: F
        };
        o3.cpuMemoryUsage += p.count, o3.cpuMemoryUsage += M2.count;
        const k2 = this.view.renderSpatialReference, B2 = n2(), G2 = [1, 1, 1];
        f(P3, k2, G2, n6) || this._dbg(Me.Error, "Unsupported coordinate system for IM overlay"), n3(P3, k2, B2, n6);
        const N3 = this._collection.createObject(new t6(r(B2[0], B2[1], G2[0], G2[1]), new i6(P3, l7), O2, S3));
        m3 && this._collection.updateMaterial(N3, (e12) => {
          e12.baseColor = m3.baseColorFactor, e12.usePBR = h === g2.Pbr, e12.hasParametersFromSource = false, e12.baseColorTexture = this._getTexture(m3.baseColorTex, t8, s5), e12.usePBR && (e12.mrrFactors = [m3.metallicFactor, m3.roughnessFactor, 0], e12.emissiveFactor = m3.emissiveFactor ?? [0, 0, 0], e12.metallicRoughnessTexture = this._getTexture(m3.metalTex, t8, s5), e12.emissionTexture = this._getTexture(m3.emissiveTex, t8, s5), e12.occlusionTexture = this._getTexture(m3.occlusionTex, t8, s5), e12.normalTexture = this._getTexture(m3.normalTex, t8, s5)), e12.objectOpacity = 0, e12.alphaDiscardMode = s3.Mask;
          const r4 = [];
          e12.baseColorTexture && r4.push(e12.baseColorTexture.loadPromise), e12.usePBR && e12.metallicRoughnessTexture && r4.push(e12.metallicRoughnessTexture.loadPromise), e12.usePBR && e12.emissionTexture && r4.push(e12.emissionTexture.loadPromise), e12.usePBR && e12.occlusionTexture && r4.push(e12.occlusionTexture.loadPromise), e12.usePBR && e12.normalTexture && r4.push(e12.normalTexture.loadPromise);
          const n7 = Promise.all(r4);
          i7.push(n7), n7.then(() => {
            e12.alphaDiscardMode = T2[m3.alphaMode], e12.objectOpacity = 1, o3.texMemoryUsage += e12.baseColorTexture?.glTexture?.usedMemory || 0, e12.usePBR && (o3.texMemoryUsage += e12.metallicRoughnessTexture?.glTexture?.usedMemory || 0, o3.texMemoryUsage += e12.emissionTexture?.glTexture?.usedMemory || 0, o3.texMemoryUsage += e12.occlusionTexture?.glTexture?.usedMemory || 0, o3.texMemoryUsage += e12.normalTexture?.glTexture?.usedMemory || 0);
          }), e12.commonMaterialParameters.doubleSided = m3.isDoubleSided, e12.commonMaterialParameters.cullFace = m3.faceCulling ? P2[m3.faceCulling] : e8.Back, this._initialCullFace.set(N3, e12.commonMaterialParameters.cullFace), e12.commonMaterialParameters.hasSlicePlane = this.slicePlaneEnabled, e12.componentParameters.castShadows = I3.All, e12.textureAlphaCutoff = m3.alphaCutoff ?? 0.1, e12.alphaDiscardMode = T2[m3.alphaMode], e12.isIntegratedMesh = true, e12.polygonOffsetEnabled = false, e12.hasOccludees = false, e12.ellipsoidMode = a4(this.view.spatialReference);
        }), o3.components.push(N3), o3.vboMemoryUsage += this._collection.getObjectGPUMemoryUsage(N3);
      }
      if (yield Promise.all(i7), s5.forEach((e11) => {
        o3.textures.push(e11);
      }), !this._memCache) throw new Error("no memCache");
      return this._memCache.put(`${o3.handle}`, o3, o3.totalMemory()), {
        memUsageBytes: o3.totalMemory()
      };
    });
  }
  freeRenderable(e10) {
    const t8 = this._lyrHandleToObjects.get(e10);
    t8 && (this.freeObject(t8), this._lyrHandleToObjects.delete(e10));
  }
  freeObject(e10) {
    this._memCache && this._memCache.pop(`${e10.handle}`), e10.components.forEach((t8) => {
      e10.textures.forEach((e11) => {
        this._stage.remove(e11);
      }), this._collection.destroyObject(t8), this._initialCullFace.delete(t8);
    });
  }
  setRenderableVisibility(e10, t8, r3) {
    if (this._memCache) {
      for (let i7 = 0; i7 < r3; ++i7) {
        const r4 = e10[i7], s5 = t8[i7];
        if (!s5) continue;
        const o3 = this._lyrHandleToObjects.get(r4);
        o3 && (this._visibleGeometryChanged(), o3.isVisible = s5, o3.components.forEach((e11) => {
          this._collection.setObjectVisibility(e11, s5), this._elevationProvider.objectChanged(this._collection.getComponentObb(e11));
        }), this._memCache.pop(`${r4}`));
      }
      for (let i7 = 0; i7 < r3; ++i7) {
        const r4 = e10[i7], s5 = t8[i7];
        if (s5) continue;
        const o3 = this._lyrHandleToObjects.get(r4);
        o3 && (this._visibleGeometryChanged(), o3.isVisible = s5, o3.components.forEach((e11) => {
          this._collection.setObjectVisibility(e11, s5), this._elevationProvider.objectChanged(this._collection.getComponentObb(e11));
        }), this._memCache.put(`${r4}`, o3, o3.totalMemory()));
      }
    }
  }
  _getTexture(e10, t8, r3) {
    let i7 = null;
    if (e10 && t8.desc?.images && t8.data?.buffer) {
      const s5 = t8.desc.images[e10?.imageId];
      if (i7 = r3.get(s5), !i7 && s5) {
        const o3 = this._stage.renderView.renderingContext.parameters.maxMaxAnisotropy, n6 = o3 > 1, a5 = _[e10.wrapMode ?? N.None];
        let l7 = s5.alpha ? 4 : 3;
        const c4 = new Uint8Array(t8.data.buffer, s5.data.byteOffset, s5.data.byteCount);
        let m3 = null, d5 = null, h = null;
        switch (s5.format) {
          case t3.Raw:
            s5.pixelFormat === n5.R8 ? (m3 = c4.buffer, l7 = 1, d5 = "") : s5.pixelFormat === n5.Rgb8 ? (m3 = c4.buffer, l7 = 3, d5 = "") : s5.pixelFormat === n5.Rgba8 && (m3 = c4.buffer, l7 = 4, d5 = "");
            break;
          case t3.Dxt1:
            m3 = c4.buffer, l7 = 3, d5 = u5.DDS_ENCODING;
            break;
          case t3.Dxt5:
            m3 = c4.buffer, l7 = 4, d5 = u5.DDS_ENCODING;
            break;
          case t3.Png:
            d5 = "image/png", h = document.createElement("img");
            break;
          case t3.Jpeg:
            d5 = "image/jpeg", h = document.createElement("img");
            break;
          case t3.Etc2:
            d5 = "image/ktx", h = document.createElement("img");
            break;
          case t3.Astc:
            this._dbg(Me.Error, "Astc texture not supported");
            break;
          case t3.Pvrtc:
            this._dbg(Me.Error, "Pvrtc texture not supported");
        }
        if (h && d5) {
          const e11 = new Blob([c4], {
            type: d5
          });
          h.src = URL.createObjectURL(e11), m3 = h;
        }
        m3 && null != d5 && (i7 = new N2(m3, {
          mipmap: n6,
          maxAnisotropy: o3,
          encoding: d5,
          wrap: a5,
          components: l7,
          noUnpackFlip: true,
          width: s5.mip0Width,
          height: s5.mip0Height
        }), this._stage.add(i7), r3.set(s5, i7));
      }
    }
    return i7 ? new s4(this.view._stage.renderView.textures, i7.id) : null;
  }
  getBufferViews(e10, t8, r3, i7) {
    let s5, o3, n6, a5, l7, c4, m3, d5 = null;
    for (let u6 = 0; u6 < e10.atrbs.length; u6++) {
      const m4 = e10.atrbs[u6], p = m4.view, f2 = void 0, g3 = p.byteOffset + p.byteCount, b = p.byteCount / A2[p.type], y3 = [...Array(b).keys()].map((e11) => e11);
      try {
        switch (m4.sem) {
          case i3.Position:
            3 !== p.ncomp || p.type !== e7.F32 ? this._dbg(Me.Error, "[Unsupported Feature] Unsupported view for Position (" + p + ")") : (s5 = new i2(t8, p.byteOffset, f2, g3), o3 = new t2(s5.typedBuffer, y3, 3));
            break;
          case i3.Normal:
            if (3 !== p.ncomp || p.type !== e7.F32) this._dbg(Me.Error, "[Unsupported Feature] Unsupported view for Normal (" + p + ")");
            else if (i7) {
              const e11 = new i2(t8, p.byteOffset, f2, g3), i8 = c2(e11.typedBuffer, r3);
              l7 = new k(i8), c4 = new t2(l7.typedBuffer, y3, 2);
            }
            break;
          case i3.TexCoord:
            2 !== p.ncomp || p.type !== e7.F32 ? this._dbg(Me.Error, "[Unsupported Feature] Unsupported view for Texcoord (" + p + ")") : void 0 === a5 && (a5 = new t2(new u4(t8, p.byteOffset, f2, g3).typedBuffer, y3, 2));
            break;
          case i3.Color:
            4 === p.ncomp ? (p.type === e7.F32 && (d5 = new c(t8, p.byteOffset, f2, g3)), p.type === e7.U8 && (d5 = new x(t8, p.byteOffset, f2, g3)), p.type === e7.U16 && (d5 = new L(t8, p.byteOffset, f2, g3))) : 3 === p.ncomp && (p.type === e7.F32 && (d5 = new i2(t8, p.byteOffset, f2, g3)), p.type === e7.U8 && (d5 = new O(t8, p.byteOffset, f2, g3)), p.type === e7.U16 && (d5 = new E(t8, p.byteOffset, f2, g3))), null == d5 ? this._dbg(Me.VerboseAPI, "[Unsupported Feature] Unsupported view for Color (" + p + ")") : n6 = new t2(d5.typedBuffer, y3, p.ncomp);
            break;
          case i3.FeatureIndex:
            break;
          default:
            this._dbg(Me.VerboseAPI, "[Unsupported Feature] Unsupported semantic (" + m4.sem + "). Skipping vertex attribute.");
        }
      } catch (h) {
        this._dbg(Me.VerboseAPI, "Error Creating buffer (" + h + "). Skipping vertex attribute.");
      }
    }
    if (e10.index) {
      const r4 = e10.index.view, i8 = void 0, s6 = r4.byteOffset + r4.byteCount;
      switch (e10.index.view.type) {
        case e7.U16:
          m3 = new g(t8, r4.byteOffset, i8, s6);
          break;
        case e7.U32:
          m3 = new B(t8, r4.byteOffset, i8, s6);
          break;
        case e7.U8:
        default:
          this._dbg(Me.Error, "[Unsupported Feature] index type not supported (" + r4.type + ").");
      }
    }
    if (null == m3 && null != s5) {
      const e11 = s5.count;
      if (e11 < 65535) {
        const t9 = new Uint16Array(e11);
        m3 = new g(t9);
      } else {
        const t9 = new Uint32Array(e11);
        m3 = new B(t9);
      }
      for (let t9 = 0; t9 < e11; t9++) m3.set(t9, t9);
    }
    return {
      positionView: s5,
      positionAttr: o3,
      colorAttr: n6,
      texCoord0Attr: a5,
      indicesView: m3,
      normalsView: l7,
      normalsAttr: c4
    };
  }
  _onRemoveFromCache(e10) {
    const t8 = l2(this.view);
    t8 && t8.onRenderableEvicted(this, e10.handle, e10.totalMemory()), this.freeRenderable(e10.handle);
  }
  _dbg(e10, t8) {
    this._dbgFlags.has(e10) && (e10 === Me.Error ? n.getLogger(this).error(t8) : n.getLogger(this).warn(t8));
  }
};
e([y()], Ue.prototype, "_visibleGeometryChangedSchedulerHandle", void 0), e([y()], Ue.prototype, "layer", void 0), e([y({
  readOnly: true
})], Ue.prototype, "visibleAtCurrentScale", null), e([y()], Ue.prototype, "elevationOffset", null), Ue = e([a("esri.views.3d.layers.IntegratedMesh3DTilesLayerView3D")], Ue);
var Ee = Ue;
export {
  Ee as default
};
//# sourceMappingURL=IntegratedMesh3DTilesLayerView3D-72AILDIJ.js.map
