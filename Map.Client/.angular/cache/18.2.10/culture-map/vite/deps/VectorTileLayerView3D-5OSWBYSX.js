import {
  p as p2
} from "./chunk-GP22YFQD.js";
import {
  D,
  G
} from "./chunk-XVR4FEAF.js";
import "./chunk-NLEBYD5G.js";
import "./chunk-MOCGEINB.js";
import "./chunk-NSSWLGUQ.js";
import {
  l as l2
} from "./chunk-CITBGG5A.js";
import "./chunk-6HTAUV5K.js";
import {
  h,
  t as t2
} from "./chunk-XBO6SJGQ.js";
import {
  d as d3
} from "./chunk-VDYOVDYI.js";
import {
  p
} from "./chunk-A4BKPCEQ.js";
import "./chunk-CDFFTJSF.js";
import "./chunk-OETW3NKJ.js";
import {
  y as y2
} from "./chunk-5JJ6GBOU.js";
import {
  d as d2,
  f,
  n,
  s as s3,
  u as u3
} from "./chunk-WSWHLWMU.js";
import "./chunk-R3AQ3TGL.js";
import "./chunk-B6VSQC7C.js";
import "./chunk-6QDMUFEM.js";
import {
  t
} from "./chunk-T3454WZK.js";
import "./chunk-HSB7FBE7.js";
import "./chunk-6YA72G7G.js";
import "./chunk-D3AKDIJC.js";
import "./chunk-3PCYF7PE.js";
import {
  l
} from "./chunk-53QPRVJS.js";
import "./chunk-TXQH7JZF.js";
import "./chunk-NJSYD5KZ.js";
import {
  a as a2,
  i
} from "./chunk-MPUFKSB2.js";
import "./chunk-FICJP6TJ.js";
import "./chunk-ON42KCSZ.js";
import "./chunk-HUHWKEOY.js";
import "./chunk-C7VF4AR2.js";
import {
  e as e4
} from "./chunk-3NGDRCQI.js";
import "./chunk-TVUZAYCE.js";
import "./chunk-JCWQ2LOQ.js";
import "./chunk-P7OSFLIX.js";
import "./chunk-ZDC4PV4Y.js";
import "./chunk-O7ZVERIH.js";
import "./chunk-YSIUOTSV.js";
import "./chunk-NQEXQAS7.js";
import "./chunk-R4DKV4UN.js";
import "./chunk-SNHPS7NU.js";
import "./chunk-6HBAAUBO.js";
import {
  O,
  R
} from "./chunk-YLE5AYZV.js";
import "./chunk-VS26W5Y5.js";
import "./chunk-PVO5NM6Q.js";
import "./chunk-E2WAKNLZ.js";
import "./chunk-DM4WHMQY.js";
import "./chunk-N3IR233K.js";
import "./chunk-5YIMTGEC.js";
import "./chunk-3UOXF3CT.js";
import "./chunk-6XGV55XZ.js";
import "./chunk-HOH445RO.js";
import "./chunk-KKD7A2GN.js";
import "./chunk-TCPN7AEH.js";
import "./chunk-JYODC3YQ.js";
import {
  e as e3
} from "./chunk-SWPHGZYB.js";
import "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import "./chunk-CRNUMTSV.js";
import "./chunk-JM7HAEY6.js";
import "./chunk-LJEOBI2I.js";
import "./chunk-2OMCGIU4.js";
import "./chunk-HT2T6PUB.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import "./chunk-K226GFDN.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import {
  u as u2
} from "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import "./chunk-NYQ5CYNR.js";
import "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import "./chunk-AXVPJBVW.js";
import "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import {
  A,
  d,
  w
} from "./chunk-6WHTZNUH.js";
import "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import "./chunk-XNUH25NY.js";
import "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e as e2
} from "./chunk-4Z5SGKRM.js";
import "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3 as a
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import {
  c2 as c,
  s as s2
} from "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import {
  e,
  r,
  u
} from "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  s2 as s
} from "./chunk-WYIDUUN2.js";
import {
  has
} from "./chunk-DXLOWWK7.js";
import {
  __async
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/views/2d/engine/vectorTiles/SchemaHelper.js
var t3 = class {
  constructor(t4, e5, s4) {
    this._scale = t4, this._shift = e5, this._levelShift = s4;
  }
  getLevelRowColumn(t4) {
    const e5 = this.getLevelShift(t4[0]), s4 = this._shift + e5;
    return s4 ? [t4[0] - e5, t4[1] >> s4, t4[2] >> s4] : t4;
  }
  getLevelShift(t4) {
    return Math.min(t4, this._levelShift);
  }
  getOffset(t4, e5) {
    let s4 = 0, i2 = 0;
    const h2 = this._shift + this.getLevelShift(t4[0]);
    if (h2) {
      const l4 = (1 << h2) - 1, f2 = e5 / (this._scale * (1 << h2 - 1));
      s4 = (t4[2] & l4) * f2, i2 = (t4[1] & l4) * f2;
    }
    return [s4, i2];
  }
  getScale(t4) {
    return this._scale * (1 << this._shift + this.getLevelShift(t4));
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler3D.js
var a3 = class extends h {
  constructor(e5, t4, o2, i2) {
    super(e5, t4, o2, e5.tileInfo.lods.length - 1), this._memCache = i2, this._ongoingTileRequests = /* @__PURE__ */ new Map(), this._ongoingRequestToController = /* @__PURE__ */ new Map(), this._tileInfoView = new t2(e5.tileInfo, e5.fullExtent);
  }
  destroy() {
    super.destroy(), this._ongoingRequestToController.forEach((e5) => e5.abort()), this._ongoingRequestToController.clear(), this._ongoingTileRequests.clear();
  }
  getVectorTile(s4, n2) {
    return __async(this, null, function* () {
      const a4 = new e4(s4[0], s4[1], s4[2], 0);
      let g = this._memCache.get(a4.id);
      if (null != g) return g.retain(), g;
      const h2 = yield this._getVectorTileData(a4);
      if (s2(n2), !this._layer) return null;
      if (g = this._memCache.get(a4.id), null != g) return g.retain(), g;
      const u4 = this._layer.tileInfo.getTileBounds(u2(), a4), m = this._tileInfoView.getTileResolution(s4[0]);
      return g = new d3(a4, m, u4[0], u4[3], 512, 512, this._styleRepository, this._memCache), g.setData(h2), h2 && (g.retain(), this._memCache.put(a4.id, g, g.usedMemory, e3)), g.neededForCoverage = true, g.transforms.tileUnitsToPixels = t(1 / 8, 0, 0, 0, 1 / 8, 0, 0, 0, 1), g;
    });
  }
  _getVectorTileData(e5) {
    const t4 = e5.id;
    if (this._ongoingTileRequests.has(t4)) return this._ongoingTileRequests.get(t4);
    const o2 = new AbortController(), i2 = {
      signal: o2.signal
    }, s4 = this._getParsedVectorTileData(e5, i2).then((e6) => (this._ongoingTileRequests.delete(t4), this._ongoingRequestToController.delete(t4), e6)).catch(() => (this._ongoingTileRequests.delete(t4), this._ongoingRequestToController.delete(t4), null));
    return this._ongoingTileRequests.set(t4, s4), this._ongoingRequestToController.set(t4, o2), s4;
  }
  _getParsedVectorTileData(e5, t4) {
    return this.fetchTileData(e5, t4).then((o2) => this.parseTileData({
      key: e5,
      data: o2
    }, t4));
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/vtlBrushes.js
var b = {
  vtlBackground: u3,
  vtlFill: f,
  vtlLine: s3,
  vtlCircle: n,
  vtlSymbol: d2
};

// ../../../node_modules/@arcgis/core/views/2d/engine/vectorTiles/VTLPainter3D.js
var o = 1e-6;
var l3 = class {
  constructor(e5, t4) {
    this.spriteMosaic = e5, this.glyphMosaic = t4, this._brushCache = /* @__PURE__ */ new Map(), this._vtlMaterialManager = new p();
  }
  dispose() {
    this._brushCache && (this._brushCache.forEach((e5) => e5.dispose()), this._brushCache = null), this._vtlMaterialManager = r(this._vtlMaterialManager), this.spriteMosaic.dispose(), this.glyphMosaic.dispose();
  }
  get vectorTilesMaterialManager() {
    return this._vtlMaterialManager;
  }
  drawSymbols(e5, t4, s4) {
    const n2 = s4.layers;
    e5.renderPass = "translucent";
    for (let i2 = 0; i2 < n2.length; i2++) {
      const s5 = n2[i2];
      if (s5.type !== a2.SYMBOL) continue;
      const l4 = s5.getLayoutProperty("visibility");
      if (l4 && l4.getValue() === i.NONE) continue;
      const c2 = e5.displayLevel;
      void 0 !== s5.minzoom && s5.minzoom > c2 + o || void 0 !== s5.maxzoom && s5.maxzoom <= c2 - o || (e5.styleLayerUID = s5.uid, e5.styleLayer = s5, this._drawWithBrush(e5, t4, "vtlSymbol"));
    }
  }
  drawBackground(e5, t4, s4) {
    if (0 === s4.backgroundBucketIds.length) return;
    const {
      context: n2,
      displayLevel: i2,
      requiredLevel: l4
    } = e5;
    t4.key.level = l4, n2.setBlendingEnabled(true), n2.setDepthTestEnabled(false), n2.setStencilTestEnabled(false), e5.renderPass = "background", s4.backgroundBucketIds.forEach((n3) => {
      const l5 = s4.getLayerById(n3);
      if (l5.type !== a2.BACKGROUND) return;
      const c2 = l5.getLayoutProperty("visibility");
      c2 && c2.getValue() === i.NONE || void 0 !== l5.minzoom && l5.minzoom > i2 + o || void 0 !== l5.maxzoom && l5.maxzoom <= i2 - o || (e5.styleLayerUID = l5.uid, e5.styleLayer = l5, this._drawWithBrush(e5, t4, "vtlBackground"));
    });
  }
  drawTile(e5, t4, s4, r2) {
    const {
      context: a4
    } = e5, o2 = s4.layers;
    a4.setBlendingEnabled(false), a4.setDepthTestEnabled(true), a4.setDepthWriteEnabled(true), a4.setDepthFunction(O.LEQUAL), e5.renderPass = "opaque";
    for (let n2 = o2.length - 1; n2 >= 0; n2--) {
      const s5 = o2[n2];
      null != r2 && r2 !== s5.type || this._renderStyleLayer(s5, e5, t4, false);
    }
    a4.setDepthWriteEnabled(false), a4.setBlendingEnabled(true), a4.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e5.renderPass = "translucent";
    for (let n2 = 0; n2 < o2.length; n2++) {
      const s5 = o2[n2];
      null != r2 && r2 !== s5.type || this._renderStyleLayer(s5, e5, t4, false);
    }
    a4.setDepthTestEnabled(false), a4.bindVAO();
  }
  _renderStyleLayer(e5, t4, s4, n2) {
    if (!(n2 || e5 && s4.layerData.has(e5.uid))) return;
    const i2 = e5.getLayoutProperty("visibility");
    if (i2 && i2.getValue() === i.NONE) return;
    const {
      renderPass: l4
    } = t4;
    let c2;
    switch (e5.type) {
      case a2.BACKGROUND:
        if ("background" !== l4) return;
        c2 = "vtlBackground";
        break;
      case a2.FILL:
        if ("opaque" !== l4 && "translucent" !== t4.renderPass) return;
        c2 = "vtlFill";
        break;
      case a2.LINE:
        if ("translucent" !== l4) return;
        c2 = "vtlLine";
        break;
      case a2.CIRCLE:
        if ("translucent" !== l4) return;
        c2 = "vtlCircle";
        break;
      case a2.SYMBOL:
        if ("translucent" !== l4) return;
        c2 = "vtlSymbol";
    }
    const d4 = t4.displayLevel;
    if (void 0 !== e5.minzoom && e5.minzoom > d4 + o || void 0 !== e5.maxzoom && e5.maxzoom <= d4 - o) return;
    const {
      context: h2
    } = t4;
    h2.setStencilTestEnabled(false), h2.setStencilWriteMask(0), t4.styleLayerUID = e5.uid, t4.styleLayer = e5, this._drawWithBrush(t4, s4, c2);
  }
  _drawWithBrush(e5, s4, r2) {
    if (!this._brushCache.has(r2)) {
      const e6 = b[r2];
      this._brushCache.set(r2, new e6());
    }
    this._brushCache.get(r2).drawMany(e5, [s4]);
  }
};

// ../../../node_modules/@arcgis/core/views/3d/layers/VectorTileLayerView3D.js
var _ = class extends p2(l2(y2)) {
  constructor() {
    super(...arguments), this._tileHandlerController = null, this.type = "vector-tile-3d", this.levelShift = has("disable-feature:vtl-level-shift") ? 0 : 1;
  }
  initialize() {
    if (null == this.layer.fullExtent) return void this.addResolvingPromise(Promise.reject(new s("vectortilelayerview:full-extent-undefined", "This layer view's layer does not define a fullExtent.")));
    const {
      basemapTerrain: e5,
      spatialReference: i2,
      state: l4,
      viewingMode: r2
    } = this.view, h2 = "local" === r2 && !D(i2) || G.force512VTL ? this.layer.tileInfo : this.layer.tileInfo.getCompatibleForVTL(256), c2 = this._getTileInfoSupportError(h2, this.layer.fullExtent);
    if (null != c2) return this.addResolvingPromise(Promise.reject(c2));
    const g = w(() => this.view?.basemapTerrain?.tilingSchemeLocked).then(() => {
      const t4 = e5.tilingScheme, i3 = t4.pixelSize, l5 = 256 === i3 ? 1 : 2, r3 = e5.spatialReference?.isGeographic && 256 === i3 ? 1 : 0, s4 = e5.spatialReference?.isGeographic || 256 !== i3 ? 0 : 1;
      let a4;
      this.schemaHelper = new t3(l5, r3, this.levelShift + s4), a4 = 256 === i3 || 512 === i3 ? this.layer.tileInfo.getCompatibleForVTL(i3) : this.layer.tileInfo;
      const o2 = this._getTileInfoCompatibilityError(a4, t4);
      if (o2) throw o2;
      this.tileInfo = a4;
    });
    this._tileHandlerController = new AbortController();
    const f2 = this.view.resourceController;
    this._memCache = f2.memoryController.newCache(`vtl-${this.layer.uid}`, (e6) => {
      e6.release();
    }), this.addHandles(d(() => this.view.qualitySettings.memoryLimit, (e6) => this._memCache.maxSize = Math.ceil(e6 / 10 * 1048576), A));
    const S = new l(this.layer.currentStyleInfo.style);
    this._tileHandler = new a3(this.layer, S, l4.contentPixelRatio, this._memCache);
    const _2 = this._tileHandlerController.signal, C2 = H(f2), w2 = this._tileHandler.start({
      signal: _2,
      schedule: C2
    }), R2 = this._tileHandler.spriteMosaic;
    R2.then((e6) => {
      !c(_2) && this._tileHandler && (this.painter = new l3(e6, this._tileHandler.glyphMosaic));
    }), w2.then(() => this._tileHandlerController = null);
    const L = () => {
      this._tileHandlerController && this._tileHandlerController.abort(), this._tileHandlerController = new AbortController(), this._memCache.clear();
      const e6 = this.layer.currentStyleInfo.style, t4 = this.view.state?.contentPixelRatio ?? 1, i3 = new l(e6), l5 = new a3(this.layer, i3, t4, this._memCache), r3 = l5.start({
        signal: this._tileHandlerController.signal,
        schedule: C2
      }), s4 = l5.spriteMosaic;
      r3.then(() => this._tileHandlerController = null), this._updatingHandles.addPromise(Promise.all([r3, s4]).then(([, e7]) => {
        const t5 = this._tileHandler, i4 = this.painter;
        this.painter = new l3(e7, l5.glyphMosaic), this._tileHandler = l5, this.emit("data-changed"), t5.destroy(), i4 && i4.dispose();
      }));
    };
    this._updatingHandles.add(() => ({
      style: this.layer.currentStyleInfo.style,
      pixelRatio: this.view.state?.contentPixelRatio
    }), L), this.addHandles([this.layer.on("paint-change", () => this.emit("data-changed")), this.layer.on("style-layer-change", L), this.layer.on("delete-style-layer", L), this.layer.on("spriteSource-change", () => this.emit("data-changed")), this.layer.on("layout-change", () => this.emit("data-changed")), this.layer.on("style-layer-visibility-change", () => this.emit("data-changed"))]);
    const j = Promise.all([g, w2, R2]);
    this.addResolvingPromise(j);
  }
  destroy() {
    this.painter = r(this.painter), this._tileHandlerController = e(this._tileHandlerController), this._tileHandler = u(this._tileHandler), this._memCache = u(this._memCache);
  }
  get contentZoom() {
    return has("disable-feature:vtl-level-shift") ? 1 : this.view.qualitySettings.tiledSurface.vtlContentZoom;
  }
  get displayLevelRange() {
    const e5 = this.tileInfo.lods, t4 = this.layer.minScale || e5[0].scale, i2 = this.layer.maxScale || e5[e5.length - 1].scale, l4 = this.levelRangeFromScaleRange(t4, i2);
    return this.layer.maxScale ? l4.maxLevel++ : l4.maxLevel += this.levelShift, l4;
  }
  get dataScaleRange() {
    const e5 = this.tileInfo.lods;
    return {
      minScale: e5[0].scale,
      maxScale: e5[e5.length - 1].scale
    };
  }
  get dataLevelRange() {
    const {
      minScale: e5,
      maxScale: t4
    } = this.dataScaleRange, i2 = this.levelRangeFromScaleRange(e5, t4);
    return 1 === i2.minLevel && 256 === this.tileInfo.size[0] && (i2.minLevel = 0), i2.maxLevel += this.levelShift, i2;
  }
  fetchTile(e5, t4) {
    return __async(this, null, function* () {
      const i2 = this.schemaHelper.getLevelRowColumn(e5);
      return this._tileHandler.getVectorTile(i2, t4);
    });
  }
};
e2([y()], _.prototype, "layer", void 0), e2([y()], _.prototype, "levelShift", void 0), e2([y()], _.prototype, "contentZoom", null), e2([y()], _.prototype, "displayLevelRange", null), e2([y()], _.prototype, "tileInfo", void 0), e2([y()], _.prototype, "dataScaleRange", null), e2([y()], _.prototype, "dataLevelRange", null), e2([y()], _.prototype, "updatingProgressValue", void 0), _ = e2([a("esri.views.3d.layers.VectorTileLayerView3D")], _);
var C = _;
function H(e5) {
  return (t4) => e5.immediate.schedule(t4);
}
export {
  C as default
};
//# sourceMappingURL=VectorTileLayerView3D-5OSWBYSX.js.map
