import {
  h as h4
} from "./chunk-4OY6E7VR.js";
import {
  U
} from "./chunk-YPWIGR43.js";
import {
  h as h3
} from "./chunk-3HMMJFFQ.js";
import {
  e as e3
} from "./chunk-WU45X43Z.js";
import {
  a as a3,
  i as i3,
  m as m3,
  s as s2
} from "./chunk-GSCGHCGH.js";
import {
  i as i2,
  o as o2,
  s
} from "./chunk-KKP76EHB.js";
import {
  i
} from "./chunk-XL7IZWA5.js";
import {
  h as h2
} from "./chunk-ZYQL5F6K.js";
import "./chunk-Q6IZWY56.js";
import {
  l
} from "./chunk-JBQJ3BUL.js";
import "./chunk-I5SWBGDW.js";
import "./chunk-YY43ZHCK.js";
import "./chunk-3FSYWRTQ.js";
import {
  m as m2
} from "./chunk-KYB3KTOZ.js";
import "./chunk-MNNI2X2N.js";
import "./chunk-2SHZAJ7S.js";
import "./chunk-SBMU7RBF.js";
import "./chunk-TMPIWG43.js";
import "./chunk-WE6VW4MG.js";
import "./chunk-P3B4Y6UN.js";
import "./chunk-4SCJM64G.js";
import "./chunk-DABQKFI5.js";
import "./chunk-FLWLBYXO.js";
import "./chunk-WTF7K3GK.js";
import "./chunk-2ERGO64O.js";
import "./chunk-RP2GKJCD.js";
import "./chunk-D3AKDIJC.js";
import "./chunk-3JEG7JG5.js";
import "./chunk-VTRNFNJR.js";
import "./chunk-W6GMJ4SS.js";
import {
  h
} from "./chunk-IIVUY2T7.js";
import "./chunk-GT3AQDRW.js";
import "./chunk-5APMY2AQ.js";
import "./chunk-GHUJU3NS.js";
import "./chunk-SLCHZ6DD.js";
import "./chunk-VS26W5Y5.js";
import "./chunk-LM2N2I5R.js";
import "./chunk-DM4WHMQY.js";
import "./chunk-6MR4UDDL.js";
import "./chunk-L7ZKWTWL.js";
import "./chunk-O2DTA3XK.js";
import "./chunk-HOH445RO.js";
import "./chunk-DY7FJHTG.js";
import "./chunk-Q4KYZS3X.js";
import "./chunk-VWML4J2J.js";
import "./chunk-T2S5VXNP.js";
import "./chunk-4U5GUJRA.js";
import {
  d as d3
} from "./chunk-HD65DNIO.js";
import "./chunk-4KWLMXIA.js";
import "./chunk-BIUXKPKA.js";
import "./chunk-634JLXD4.js";
import "./chunk-Y3EDGYWG.js";
import "./chunk-UF6JOUSJ.js";
import "./chunk-T5JGQSO3.js";
import "./chunk-CIW3KHOW.js";
import "./chunk-J55F4AC2.js";
import {
  S
} from "./chunk-IQLBZKUD.js";
import {
  y as y2
} from "./chunk-7MZZCQ64.js";
import "./chunk-DI6VABAK.js";
import "./chunk-5EBAJR7X.js";
import "./chunk-5JA2JHV3.js";
import "./chunk-SGSUM5YO.js";
import "./chunk-SG5TCCCK.js";
import "./chunk-6A7CWJED.js";
import "./chunk-DUTZNK67.js";
import "./chunk-IN6BQCWS.js";
import "./chunk-JM7HAEY6.js";
import "./chunk-OUKUASAF.js";
import "./chunk-V5RMUGJJ.js";
import "./chunk-D2NB6D6N.js";
import "./chunk-UWJIHV6Q.js";
import "./chunk-M2NS3MSU.js";
import "./chunk-HMNBB7ED.js";
import "./chunk-3RRMLFFN.js";
import "./chunk-DR5TVNEL.js";
import "./chunk-HT2T6PUB.js";
import "./chunk-K64AAM77.js";
import "./chunk-6EUVKE22.js";
import "./chunk-A3NNJ7XA.js";
import "./chunk-OKJHJ3CY.js";
import "./chunk-XTVPEVHA.js";
import "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import {
  d as d2
} from "./chunk-DZALMCYL.js";
import "./chunk-K226GFDN.js";
import "./chunk-4ZZRP4MA.js";
import "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-VDB6Y4TZ.js";
import "./chunk-WYMXVOAT.js";
import "./chunk-K7TO5IIO.js";
import "./chunk-A4VVDRCH.js";
import "./chunk-CQDYITZC.js";
import "./chunk-5I6J67HP.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-FYAEQPUY.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-ONPREQKF.js";
import "./chunk-7RMVJCDW.js";
import "./chunk-GTY5NXA4.js";
import {
  j,
  m2 as m,
  u as u2,
  x
} from "./chunk-T6GCUITX.js";
import {
  a as a2,
  e as e2
} from "./chunk-TUIGM7TV.js";
import {
  u as u3
} from "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import "./chunk-NYQ5CYNR.js";
import {
  _
} from "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import "./chunk-AXVPJBVW.js";
import "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import {
  A,
  P,
  d,
  p
} from "./chunk-6WHTZNUH.js";
import "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import "./chunk-XNUH25NY.js";
import {
  o
} from "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e
} from "./chunk-4Z5SGKRM.js";
import "./chunk-YPWMP2VK.js";
import "./chunk-23E6RT3O.js";
import "./chunk-RCBGISRX.js";
import "./chunk-2P72IR2Y.js";
import "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3 as a
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import {
  u
} from "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import "./chunk-WYIDUUN2.js";
import "./chunk-DXLOWWK7.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/geometry/support/rotate.js
function o3(n, e4, t, s3) {
  const i4 = [];
  for (const o4 of n) {
    const n2 = o4.slice(0);
    i4.push(n2);
    const r2 = e4 * (o4[0] - s3.x) - t * (o4[1] - s3.y) + s3.x, a4 = t * (o4[0] - s3.x) + e4 * (o4[1] - s3.y) + s3.y;
    n2[0] = r2, n2[1] = a4;
  }
  return i4;
}
function r(r2, a4, c) {
  const {
    hasM: m4,
    hasZ: x2,
    spatialReference: f
  } = r2, p2 = a4 * Math.PI / 180, l2 = Math.cos(p2), h5 = Math.sin(p2);
  if ("xmin" in r2 && (c = c ?? r2.center, r2 = new j({
    spatialReference: f,
    rings: [[[r2.xmin, r2.ymin], [r2.xmin, r2.ymax], [r2.xmax, r2.ymax], [r2.xmax, r2.ymin], [r2.xmin, r2.ymin]]]
  })), "paths" in r2) {
    c = c ?? r2.extent.center;
    const n = [];
    for (const e4 of r2.paths) n.push(o3(e4, l2, h5, c));
    return new m({
      hasM: m4,
      hasZ: x2,
      spatialReference: f,
      paths: n
    });
  }
  if ("rings" in r2) {
    c = c ?? r2.extent.center;
    const t = [];
    for (const e4 of r2.rings) {
      const s3 = a2(e4), i4 = o3(e4, l2, h5, c);
      a2(i4) !== s3 && i4.reverse(), t.push(i4);
    }
    return new j({
      hasM: m4,
      hasZ: x2,
      spatialReference: f,
      rings: t
    });
  }
  if ("x" in r2) {
    c = c ?? r2;
    const n = new _({
      x: l2 * (r2.x - c.x) - h5 * (r2.y - c.y) + c.x,
      y: h5 * (r2.x - c.x) + l2 * (r2.y - c.y) + c.y,
      spatialReference: f
    });
    return null != r2.z && (n.z = r2.z), null != r2.m && (n.m = r2.m), n;
  }
  return "points" in r2 ? (c = c ?? r2.extent.center, new u2({
    hasM: m4,
    hasZ: x2,
    points: o3(r2.points, l2, h5, c),
    spatialReference: f
  })) : null;
}

// ../../../node_modules/@arcgis/core/views/draw/support/Box.js
var z = class {
  constructor(t, e4, i4, s3) {
    this.graphics = t, this.mover = e4, this.dx = i4, this.dy = s3, this.type = "move-start";
  }
};
var B = class {
  constructor(t, e4, i4, s3) {
    this.graphics = t, this.mover = e4, this.dx = i4, this.dy = s3, this.type = "move";
  }
};
var Y = class {
  constructor(t, e4, i4, s3) {
    this.graphics = t, this.mover = e4, this.dx = i4, this.dy = s3, this.type = "move-stop";
  }
};
var N = class {
  constructor(t, e4, i4) {
    this.graphics = t, this.mover = e4, this.angle = i4, this.type = "rotate-start";
  }
};
var U2 = class {
  constructor(t, e4, i4) {
    this.graphics = t, this.mover = e4, this.angle = i4, this.type = "rotate";
  }
};
var A2 = class {
  constructor(t, e4, i4) {
    this.graphics = t, this.mover = e4, this.angle = i4, this.type = "rotate-stop";
  }
};
var P2 = class {
  constructor(t, e4, i4, s3) {
    this.graphics = t, this.mover = e4, this.xScale = i4, this.yScale = s3, this.type = "scale-start";
  }
};
var X = class {
  constructor(t, e4, i4, s3) {
    this.graphics = t, this.mover = e4, this.xScale = i4, this.yScale = s3, this.type = "scale";
  }
};
var F = class {
  constructor(t, e4, i4, s3) {
    this.graphics = t, this.mover = e4, this.xScale = i4, this.yScale = s3, this.type = "scale-stop";
  }
};
var D = h4.transformGraphics;
var V = {
  centerIndicator: new y2({
    style: "cross",
    size: D.center.size,
    color: D.center.color
  }),
  fill: {
    default: new S({
      color: D.fill.color,
      outline: {
        color: D.fill.outlineColor,
        join: "round",
        width: 1
      }
    }),
    active: new S({
      color: D.fill.stagedColor,
      outline: {
        color: D.fill.outlineColor,
        join: "round",
        style: "dash",
        width: 1
      }
    })
  },
  handles: {
    default: new y2({
      style: "square",
      size: D.vertex.size,
      color: D.vertex.color,
      outline: {
        color: D.vertex.outlineColor,
        width: 1
      }
    }),
    hover: new y2({
      style: "square",
      size: D.vertex.hoverSize,
      color: D.vertex.hoverColor,
      outline: {
        color: D.vertex.hoverOutlineColor,
        width: 1
      }
    })
  },
  rotator: {
    default: new y2({
      style: "circle",
      size: D.vertex.size,
      color: D.vertex.color,
      outline: {
        color: D.vertex.outlineColor,
        width: 1
      }
    }),
    hover: new y2({
      style: "circle",
      size: D.vertex.hoverSize,
      color: D.vertex.hoverColor,
      outline: {
        color: D.vertex.hoverOutlineColor,
        width: 1
      }
    })
  },
  rotatorLine: new d2({
    color: D.line.color,
    width: 1
  })
};
var q = class extends o.EventedAccessor {
  constructor(t) {
    super(t), this._activeHandleGraphic = null, this._graphicAttributes = {
      esriSketchTool: "box"
    }, this._mover = null, this._centerGraphic = null, this._backgroundGraphic = null, this._vertexGraphics = [], this._rotateHandleGraphic = null, this._rotateGraphicOffset = 20, this._angleOfRotation = 0, this._rotateLineGraphic = null, this._startInfo = null, this._totalDx = 0, this._totalDy = 0, this._xScale = 1, this._yScale = 1, this.tooltip = null, this.type = "box", this.callbacks = {
      onMoveStart() {
      },
      onMove() {
      },
      onMoveStop() {
      },
      onScaleStart() {
      },
      onScale() {
      },
      onScaleStop() {
      },
      onRotateStart() {
      },
      onRotate() {
      },
      onRotateStop() {
      },
      onGraphicClick() {
      }
    }, this.enableMovement = true, this.enableRotation = true, this.enableScaling = true, this.graphics = [], this.highlightsEnabled = true, this.layer = null, this.preserveAspectRatio = false, this.showCenterGraphic = true, this.symbols = V, this.sketchOptions = new l(), this.view = null, this._getBounds = (() => {
      const t2 = u3();
      return (e4, i4) => {
        e4[0] = Number.POSITIVE_INFINITY, e4[1] = Number.POSITIVE_INFINITY, e4[2] = Number.NEGATIVE_INFINITY, e4[3] = Number.NEGATIVE_INFINITY;
        for (const s3 of i4) {
          if (!s3) continue;
          let i5, o4, r2, a4;
          if ("point" === s3.type) i5 = r2 = s3.x, o4 = a4 = s3.y;
          else if ("multipoint" === s3.type) {
            const e5 = e2(s3);
            [i5, o4, r2, a4] = x(t2, [e5]);
          } else if ("extent" === s3.type) [i5, o4, r2, a4] = [s3.xmin, s3.ymin, s3.xmax, s3.ymax];
          else {
            const e5 = e2(s3);
            [i5, o4, r2, a4] = x(t2, e5);
          }
          e4[0] = Math.min(i5, e4[0]), e4[1] = Math.min(o4, e4[1]), e4[2] = Math.max(r2, e4[2]), e4[3] = Math.max(a4, e4[3]);
        }
        return e4;
      };
    })();
  }
  initialize() {
    const t = this.view;
    this._highlightHelper = new h3({
      view: t
    }), this._setup(), this.addHandles([p(() => t?.ready, () => {
      const {
        layer: t2,
        view: e4
      } = this;
      e3(e4, t2);
    }, {
      once: true,
      initial: true
    }), d(() => this.preserveAspectRatio, () => {
      this._activeHandleGraphic && (this._scaleGraphic(this._activeHandleGraphic), this._updateGraphics(), this._updateTooltip(this._activeHandleGraphic));
    }), d(() => t?.scale, () => {
      this._updateRotateGraphic(), this._updateRotateLineGraphic();
    }), d(() => this.graphics, () => this.refresh()), d(() => this.layer, (t2, e4) => {
      e4 && this._resetGraphics(e4), this.refresh();
    }), d(() => this.highlightsEnabled, () => {
      this._highlightHelper?.removeAll(), this._setUpHighlights();
    }), d(() => this.sketchOptions.tooltips.effectiveEnabled, (t2) => {
      this.tooltip = t2 ? new h2({
        view: this.view
      }) : u(this.tooltip);
    }, A), d(() => this.view.effectiveTheme.accentColor, () => this._updateSymbolsForTheme(), P), this.on("move-start", (t2) => this.callbacks?.onMoveStart?.(t2)), this.on("move", (t2) => this.callbacks?.onMove?.(t2)), this.on("move-stop", (t2) => this.callbacks?.onMoveStop?.(t2)), this.on("rotate-start", (t2) => this.callbacks?.onRotateStart?.(t2)), this.on("rotate", (t2) => this.callbacks?.onRotate?.(t2)), this.on("rotate-stop", (t2) => this.callbacks?.onRotateStop?.(t2)), this.on("scale-start", (t2) => this.callbacks?.onScaleStart?.(t2)), this.on("scale", (t2) => this.callbacks?.onScale?.(t2)), this.on("scale-stop", (t2) => this.callbacks?.onScaleStop?.(t2))]);
  }
  destroy() {
    this._reset(), this.tooltip = u(this.tooltip);
  }
  get state() {
    const t = this.view?.ready ?? false, e4 = this.graphics.length && this.layer;
    return t && e4 ? "active" : t ? "ready" : "disabled";
  }
  isUIGraphic(t) {
    return this._vertexGraphics.includes(t) || t === this._backgroundGraphic || t === this._centerGraphic || t === this._rotateHandleGraphic || t === this._rotateLineGraphic;
  }
  move(t, e4) {
    if (this._mover && this.graphics.length) {
      for (const i4 of this.graphics) {
        const s3 = i4.geometry, o4 = i3(s3, t, e4, this.view);
        i4.geometry = o4;
      }
      this.refresh(), this.emit("move-stop", new Y(this.graphics, null, t, e4));
    }
  }
  scale(t, e4) {
    if (this._mover && this.graphics.length) {
      for (const i4 of this.graphics) {
        const s3 = i4.geometry, o4 = s2(s3, t, e4);
        i4.geometry = o4;
      }
      this.refresh(), this.emit("scale-stop", new F(this.graphics, null, t, e4));
    }
  }
  rotate(t, e4) {
    if (this._mover && this.graphics.length) {
      if (!e4) {
        const t2 = this._vertexGraphics[1].geometry.x, i4 = this._vertexGraphics[3].geometry.y;
        e4 = new _(t2, i4, this.view.spatialReference);
      }
      for (const i4 of this.graphics) {
        const s3 = i4.geometry, o4 = r(s3, t, e4);
        i4.geometry = o4;
      }
      this.refresh(), this.emit("rotate-stop", new A2(this.graphics, null, t));
    }
  }
  refresh() {
    this._reset(), this._setup();
  }
  reset() {
    this.graphics = [];
  }
  _setup() {
    "active" === this.state && (this._setUpHighlights(), this._setupGraphics(), this._setupMover(), this._updateGraphics());
  }
  _reset() {
    this._highlightHelper?.removeAll(), this._resetGraphicStateVars(), this._resetGraphics(), this._updateTooltip(), this._mover && this._mover.destroy(), this._mover = null, this.view.cursor = "default";
  }
  _resetGraphicStateVars() {
    this._startInfo = null, this._activeHandleGraphic = null, this._totalDx = 0, this._totalDy = 0, this._xScale = 1, this._yScale = 1, this._angleOfRotation = 0;
  }
  _resetGraphics(t) {
    (t = t || this.layer) && (t.removeMany(this._vertexGraphics), t.remove(this._backgroundGraphic), t.remove(this._centerGraphic), t.remove(this._rotateHandleGraphic), t.remove(this._rotateLineGraphic)), this._vertexGraphics.forEach((t2) => !t2.destroyed && t2.destroy()), !this._backgroundGraphic.destroyed && this._backgroundGraphic.destroy(), !this._centerGraphic.destroyed && this._centerGraphic.destroy(), !this._rotateHandleGraphic.destroyed && this._rotateHandleGraphic.destroy(), !this._rotateLineGraphic.destroyed && this._rotateLineGraphic.destroy(), this._vertexGraphics = [], this._backgroundGraphic = null, this._centerGraphic = null, this._rotateHandleGraphic = null, this._rotateLineGraphic = null;
  }
  _setupMover() {
    let t = [];
    this.enableScaling && (t = t.concat(this._vertexGraphics)), this.enableMovement && (t = t.concat(this.graphics, this._backgroundGraphic)), this.enableRotation && t.push(this._rotateHandleGraphic), this.showCenterGraphic && t.push(this._centerGraphic), this._mover = new U({
      enableMoveAllGraphics: false,
      highlightsEnabled: false,
      indicatorsEnabled: false,
      view: this.view,
      graphics: t,
      callbacks: {
        onGraphicClick: (t2) => this._onGraphicClickCallback(t2),
        onGraphicMoveStart: (t2) => this._onGraphicMoveStartCallback(t2),
        onGraphicMove: (t2) => this._onGraphicMoveCallback(t2),
        onGraphicMoveStop: (t2) => this._onGraphicMoveStopCallback(t2),
        onGraphicPointerOver: (t2) => this._onGraphicPointerOverCallback(t2),
        onGraphicPointerOut: (t2) => this._onGraphicPointerOutCallback(t2)
      }
    });
  }
  _getStartInfo(t) {
    const [e4, i4, s3, o4] = this._getBoxBounds(u3()), r2 = Math.abs(s3 - e4), a4 = Math.abs(o4 - i4), h5 = (s3 + e4) / 2, c = (o4 + i4) / 2, {
      x: n,
      y: l2
    } = t.geometry;
    return {
      width: r2,
      height: a4,
      centerX: h5,
      centerY: c,
      startX: n,
      startY: l2,
      graphicInfos: this._getGraphicInfos(),
      box: this._backgroundGraphic.geometry,
      rotate: this._rotateHandleGraphic.geometry
    };
  }
  _getGraphicInfos() {
    return this.graphics.map((t) => this._getGraphicInfo(t));
  }
  _getGraphicInfo(t) {
    const e4 = t.geometry, [i4, s3, o4, r2] = this._getBounds(u3(), [e4]);
    return {
      width: Math.abs(o4 - i4),
      height: Math.abs(r2 - s3),
      centerX: (o4 + i4) / 2,
      centerY: (r2 + s3) / 2,
      geometry: e4
    };
  }
  _onGraphicClickCallback(t) {
    t.viewEvent.stopPropagation(), this.emit("graphic-click", t), this.callbacks.onGraphicClick && this.callbacks.onGraphicClick(t);
  }
  _onGraphicMoveStartCallback(t) {
    const {
      _angleOfRotation: e4,
      _xScale: i4,
      _yScale: s3,
      _backgroundGraphic: o4,
      _vertexGraphics: r2,
      _rotateHandleGraphic: a4,
      symbols: h5
    } = this, c = t.graphic;
    this._resetGraphicStateVars(), this._hideGraphicsBeforeUpdate(), o4.symbol = h5.fill.active, this._startInfo = this._getStartInfo(c), this._updateTooltip(c, t.viewEvent), c === a4 ? (this.view.cursor = "grabbing", this.emit("rotate-start", new N(this.graphics, c, e4))) : r2.includes(c) ? (this._activeHandleGraphic = c, this.emit("scale-start", new P2(this.graphics, c, i4, s3))) : this.emit("move-start", new z(this.graphics, c, t.dx, t.dy));
  }
  _onGraphicMoveCallback(t) {
    const e4 = t.graphic;
    if (this._startInfo) if (this._vertexGraphics.includes(e4)) this._scaleGraphic(e4), this._updateTooltip(e4, t.viewEvent), this.emit("scale", new X(this.graphics, e4, this._xScale, this._yScale));
    else if (e4 === this._rotateHandleGraphic) this._rotateGraphic(e4), this._updateTooltip(e4, t.viewEvent), this.emit("rotate", new U2(this.graphics, e4, this._angleOfRotation));
    else {
      const {
        dx: i4,
        dy: s3
      } = t;
      this._totalDx += i4, this._totalDy += s3, this._moveGraphic(e4, i4, s3), this._updateTooltip(e4, t.viewEvent), this.emit("move", new B(this.graphics, e4, i4, s3));
    }
  }
  _onGraphicMoveStopCallback(t) {
    const e4 = t.graphic;
    if (!this._startInfo) return void this.refresh();
    const {
      _angleOfRotation: i4,
      _totalDx: s3,
      _totalDy: o4,
      _xScale: r2,
      _yScale: a4,
      _vertexGraphics: h5,
      _rotateHandleGraphic: c
    } = this;
    this.refresh(), e4 === c ? (this.view.cursor = "pointer", this.emit("rotate-stop", new A2(this.graphics, e4, i4))) : h5.includes(e4) ? this.emit("scale-stop", new F(this.graphics, e4, r2, a4)) : this.emit("move-stop", new Y(this.graphics, e4, s3, o4));
  }
  _onGraphicPointerOverCallback(t) {
    const {
      _backgroundGraphic: e4,
      _vertexGraphics: i4,
      graphics: s3,
      _rotateHandleGraphic: o4,
      symbols: r2,
      view: a4
    } = this, h5 = t.graphic;
    if (this._hoveredGraphic = h5, h5 === o4) return o4.symbol = r2.rotator.hover, a4.cursor = "pointer", void this._updateTooltip(h5);
    if (s3.includes(h5) || h5 === e4) return void (a4.cursor = "move");
    if (!i4.includes(h5)) return void (a4.cursor = "pointer");
    this._updateTooltip(h5), t.graphic.symbol = r2.handles.hover;
    const c = a4.rotation;
    let n, l2 = t.index;
    switch (l2 < 8 && (c >= 0 && c < 45 ? l2 %= 8 : l2 = c >= 45 && c < 90 ? (l2 + 1) % 8 : c >= 90 && c < 135 ? (l2 + 2) % 8 : c >= 135 && c < 180 ? (l2 + 3) % 8 : c >= 180 && c < 225 ? (l2 + 4) % 8 : c >= 225 && c < 270 ? (l2 + 5) % 8 : c >= 270 && c < 315 ? (l2 + 6) % 8 : (l2 + 7) % 8), l2) {
      case 0:
      case 4:
        n = "nwse-resize";
        break;
      case 1:
      case 5:
        n = "ns-resize";
        break;
      case 2:
      case 6:
        n = "nesw-resize";
        break;
      case 3:
      case 7:
        n = "ew-resize";
        break;
      default:
        n = "pointer";
    }
    a4.cursor = n;
  }
  _onGraphicPointerOutCallback(t) {
    const {
      _vertexGraphics: e4,
      _rotateHandleGraphic: i4,
      symbols: s3,
      view: o4
    } = this;
    this._hoveredGraphic = null, t.graphic === i4 ? i4.symbol = s3.rotator.default : e4.includes(t.graphic) && (t.graphic.symbol = s3.handles.default), o4.cursor = "default", this._updateTooltip();
  }
  _scaleGraphic(t) {
    const {
      _startInfo: e4,
      _vertexGraphics: i4,
      preserveAspectRatio: s3,
      view: o4
    } = this, {
      centerX: r2,
      centerY: a4,
      graphicInfos: h5,
      height: c,
      startX: n,
      startY: l2,
      width: p2
    } = e4, {
      resolution: _2,
      transform: d4
    } = o4.state, m4 = i4.indexOf(t);
    1 !== m4 && 5 !== m4 || this._updateX(t, r2), 3 !== m4 && 7 !== m4 || this._updateY(t, a4);
    const {
      x: u4,
      y: g
    } = t.geometry, y3 = d4[0] * u4 + d4[2] * g + d4[4], G = d4[1] * u4 + d4[3] * g + d4[5], w = h5?.map((t2) => t2.geometry) ?? [], x2 = w.every((t2) => "point" === t2.type);
    if ((0 === p2 || 0 === c) && x2) {
      const t2 = J((u4 - n) / _2), i5 = J((l2 - g) / _2);
      for (let e5 = 0; e5 < w.length; e5++) this.graphics[e5].geometry = i3(w[e5], t2, i5, o4, true);
      return this._centerGraphic.geometry = new _(u4, g, o4.spatialReference), void (this._backgroundGraphic.geometry = i3(e4.box, t2, i5, o4, true));
    }
    if (s3) {
      const t2 = J(d4[0] * r2 + d4[2] * a4 + d4[4], 2), e5 = J(d4[1] * r2 + d4[3] * a4 + d4[5], 2), i5 = J(d4[0] * n + d4[2] * l2 + d4[4], 2), s4 = J(d4[1] * n + d4[3] * l2 + d4[5], 2);
      let o5 = a3(t2, e5, i5, s4, y3, G);
      0 !== o5 && Math.abs(o5) !== 1 / 0 || (o5 = 1), this._xScale = this._yScale = o5;
      for (const h6 of w) {
        const t3 = w.indexOf(h6);
        this.graphics[t3].geometry = s2(h6, this._xScale, this._yScale, [r2, a4]);
      }
      this._updateBackgroundGraphic();
    } else {
      let t2 = u4 - n, i5 = l2 - g;
      if (1 === m4 || 5 === m4 ? t2 = 0 : 3 !== m4 && 7 !== m4 || (i5 = 0), 0 === t2 && 0 === i5) return;
      const s4 = r2 + t2 / 2, h6 = a4 + i5 / 2;
      let d5 = (p2 + (n > r2 ? t2 : -1 * t2)) / p2, y4 = (c + (l2 < a4 ? i5 : -1 * i5)) / c;
      1 !== m4 && 5 !== m4 && 0 !== d5 && Math.abs(d5) !== 1 / 0 || (d5 = 1), 3 !== m4 && 7 !== m4 && 0 !== y4 && Math.abs(y4) !== 1 / 0 || (y4 = 1), this._xScale = d5, this._yScale = y4;
      const G2 = (s4 - r2) / _2, b = (h6 - a4) / _2, x3 = s2(e4.box, this._xScale, this._yScale);
      this._backgroundGraphic.geometry = i3(x3, G2, b, o4, true);
      const {
        centerX: S2,
        centerY: k
      } = this._getGraphicInfo(this._backgroundGraphic), R = (S2 - r2) / _2, M = -1 * (k - a4) / _2;
      for (const e5 of w) {
        const t3 = w.indexOf(e5), i6 = s2(e5, this._xScale, this._yScale, [r2, a4]);
        this.graphics[t3].geometry = i3(i6, R, M, o4, true);
      }
      this._centerGraphic.geometry = new _(S2, k, o4.spatialReference);
    }
  }
  _rotateGraphic(t) {
    const {
      centerX: e4,
      centerY: i4,
      startX: s3,
      startY: o4,
      box: r2,
      rotate: a4
    } = this._startInfo, h5 = this.view.spatialReference, c = new _(s3, o4, h5), n = new _(e4, i4, h5), l2 = t.geometry;
    this._angleOfRotation = m3(c, l2, n);
    const p2 = this._startInfo.graphicInfos?.map((t2) => t2.geometry) ?? [];
    for (const _2 of p2) {
      const t2 = p2.indexOf(_2), e5 = r(_2, this._angleOfRotation, n);
      this.graphics[t2].geometry = e5;
    }
    this._backgroundGraphic.geometry = r(r2, this._angleOfRotation, n), this._rotateHandleGraphic.geometry = r(a4, this._angleOfRotation, n);
  }
  _moveGraphic(t, e4, i4) {
    if (this.graphics.includes(t)) {
      const s3 = this._backgroundGraphic.geometry;
      this._backgroundGraphic.geometry = i3(s3, e4, i4, this.view);
      for (const o4 of this.graphics) o4 !== t && (o4.geometry = i3(o4.geometry, e4, i4, this.view));
    } else if (t === this._centerGraphic) {
      const t2 = this._backgroundGraphic.geometry;
      this._backgroundGraphic.geometry = i3(t2, e4, i4, this.view);
    }
    if (t === this._backgroundGraphic || t === this._centerGraphic) for (const s3 of this.graphics) s3.geometry = i3(s3.geometry, e4, i4, this.view);
  }
  _setUpHighlights() {
    this.highlightsEnabled && this.graphics.length && this._highlightHelper?.add(this.graphics);
  }
  _setupGraphics() {
    const {
      _graphicAttributes: t,
      symbols: i4
    } = this;
    this._centerGraphic = new d3({
      symbol: i4.centerIndicator,
      attributes: t
    }), this.showCenterGraphic && this.layer.add(this._centerGraphic), this._backgroundGraphic = new d3({
      symbol: i4.fill.default,
      attributes: t
    }), this.layer.add(this._backgroundGraphic), this._rotateLineGraphic = new d3({
      symbol: i4.rotatorLine,
      attributes: t
    }), this._rotateHandleGraphic = new d3({
      symbol: i4.rotator.default,
      attributes: t
    }), this.enableRotation && !this._hasExtentGraphic() && this.layer.addMany([this._rotateLineGraphic, this._rotateHandleGraphic]);
    for (let s3 = 0; s3 < 8; s3++) this._vertexGraphics.push(new d3({
      symbol: i4.handles.default,
      attributes: t
    }));
    this.enableScaling && this.layer.addMany(this._vertexGraphics);
  }
  _updateSymbolsForTheme() {
    const t = this.view.effectiveTheme.accentColor;
    this.symbols = __spreadProps(__spreadValues({}, this.symbols), {
      fill: {
        active: this.symbols.fill.active?.clone().set("outline.color", t),
        default: this.symbols.fill.default?.clone().set("outline.color", t)
      },
      handles: __spreadProps(__spreadValues({}, this.symbols.handles), {
        default: this.symbols.handles.default.clone().set("outline.color", t)
      }),
      rotator: __spreadProps(__spreadValues({}, this.symbols.rotator), {
        default: this.symbols.rotator.default.clone().set("outline.color", t)
      }),
      rotatorLine: this.symbols.rotatorLine.clone().set("color", t)
    });
    for (const e4 of this._vertexGraphics) e4.symbol = e4 === this._hoveredGraphic ? this.symbols.handles.hover : this.symbols.handles.default;
    this._backgroundGraphic.symbol = this.symbols.fill.default, this._rotateHandleGraphic.symbol = this._rotateHandleGraphic === this._hoveredGraphic ? this.symbols.rotator.hover : this.symbols.rotator.default, this._rotateLineGraphic.symbol = this.symbols.rotatorLine;
  }
  _updateGraphics() {
    this._updateBackgroundGraphic(), this._updateHandleGraphics(), this._updateCenterGraphic(), this._updateRotateGraphic(), this._updateRotateLineGraphic();
  }
  _hideGraphicsBeforeUpdate() {
    this._centerGraphic.visible = false, this._rotateHandleGraphic.visible = false, this._rotateLineGraphic.visible = false, this._vertexGraphics.forEach((t) => t.visible = false);
  }
  _updateHandleGraphics() {
    const t = this._getCoordinates(true);
    this._vertexGraphics.forEach((e4, i4) => {
      const [s3, o4] = t[i4];
      this._updateXY(e4, s3, o4);
    });
  }
  _updateBackgroundGraphic() {
    const t = this._getCoordinates();
    this._backgroundGraphic.geometry = new j({
      rings: t,
      spatialReference: this.view.spatialReference
    });
  }
  _updateCenterGraphic() {
    const [t, e4, i4, s3] = this._getBoxBounds(u3()), o4 = (i4 + t) / 2, r2 = (s3 + e4) / 2;
    this._centerGraphic.geometry = new _(o4, r2, this.view.spatialReference);
  }
  _updateRotateGraphic() {
    if (!this._vertexGraphics.length) return;
    const {
      x: t,
      y: e4
    } = this._vertexGraphics[1].geometry, i4 = e4 + this.view.state.resolution * this._rotateGraphicOffset;
    this._rotateHandleGraphic.geometry = new _(t, i4, this.view.spatialReference);
  }
  _updateRotateLineGraphic() {
    if (!this._vertexGraphics.length || !this._rotateHandleGraphic?.geometry) return;
    const t = this._vertexGraphics[1].geometry, e4 = this._rotateHandleGraphic.geometry;
    this._rotateLineGraphic.geometry = new m({
      paths: [[t.x, t.y], [e4.x, e4.y]],
      spatialReference: this.view.spatialReference
    });
  }
  _updateXY(t, e4, i4) {
    t.geometry = new _(e4, i4, this.view.spatialReference);
  }
  _updateX(t, e4) {
    const i4 = t.geometry.y;
    t.geometry = new _(e4, i4, this.view.spatialReference);
  }
  _updateY(t, e4) {
    const i4 = t.geometry.x;
    t.geometry = new _(i4, e4, this.view.spatialReference);
  }
  _hasExtentGraphic() {
    return this.graphics.some((t) => null != t?.geometry && "extent" === t.geometry.type);
  }
  _getBoxBounds(t) {
    const e4 = this.graphics.map((t2) => t2.geometry);
    return this._getBounds(t, e4);
  }
  _getCoordinates(t) {
    const [e4, i4, s3, o4] = this._getBoxBounds(u3());
    if (t) {
      const t2 = (e4 + s3) / 2, r2 = (o4 + i4) / 2;
      return [[e4, o4], [t2, o4], [s3, o4], [s3, r2], [s3, i4], [t2, i4], [e4, i4], [e4, r2]];
    }
    return [[e4, o4], [s3, o4], [s3, i4], [e4, i4]];
  }
  _updateTooltip(t, e4) {
    if (null == this.tooltip) return;
    if (!t) return void this.tooltip.clear();
    const {
      _backgroundGraphic: i4,
      graphics: s3,
      _vertexGraphics: o4,
      _rotateHandleGraphic: r2
    } = this;
    t === r2 ? this._updateRotateTooltip() : o4.includes(t) ? this._updateScaleTooltip() : (s3.includes(t) || t === i4) && this._updateMoveTooltip(e4);
  }
  _updateRotateTooltip() {
    null != this.tooltip && (this.tooltip.info = new s({
      sketchOptions: this.sketchOptions,
      angle: -this._angleOfRotation
    }));
  }
  _updateScaleTooltip() {
    const {
      tooltip: t,
      _xScale: e4,
      _yScale: i4,
      sketchOptions: s3,
      view: o4
    } = this;
    if (null == t) return;
    const r2 = this._getCoordinates(), a4 = o2({
      topLeft: r2[0],
      topRight: r2[1],
      bottomRight: r2[2],
      bottomLeft: r2[3],
      spatialReference: o4.spatialReference
    });
    if (null == a4) return;
    const {
      xSize: h5,
      ySize: c
    } = a4, n = Math.abs(e4), l2 = Math.abs(i4);
    t.info = new i2({
      sketchOptions: s3,
      xScale: n,
      yScale: l2,
      xSize: h5,
      ySize: c
    });
  }
  _updateMoveTooltip(t) {
    const {
      tooltip: e4,
      sketchOptions: i4,
      view: s3
    } = this;
    if (null == e4) return;
    const r2 = new i({
      sketchOptions: i4
    });
    if (t) {
      const {
        x: e5,
        y: i5
      } = t.origin, a4 = s3.toMap(t), h5 = s3.toMap({
        x: e5,
        y: i5
      }), c = m2(h5, a4);
      r2.distance = null != c ? c : h;
    }
    e4.info = r2;
  }
};
function J(t, e4 = 2) {
  return Number.parseFloat(t.toFixed(e4));
}
e([y()], q.prototype, "tooltip", void 0), e([y({
  readOnly: true
})], q.prototype, "type", void 0), e([y()], q.prototype, "callbacks", void 0), e([y()], q.prototype, "enableMovement", void 0), e([y()], q.prototype, "enableRotation", void 0), e([y()], q.prototype, "enableScaling", void 0), e([y()], q.prototype, "graphics", void 0), e([y()], q.prototype, "highlightsEnabled", void 0), e([y()], q.prototype, "layer", void 0), e([y()], q.prototype, "preserveAspectRatio", void 0), e([y()], q.prototype, "showCenterGraphic", void 0), e([y({
  readOnly: true
})], q.prototype, "state", null), e([y()], q.prototype, "symbols", void 0), e([y({
  type: l
})], q.prototype, "sketchOptions", void 0), e([y({
  constructOnly: true
})], q.prototype, "view", void 0), q = e([a("esri.views.draw.support.Box")], q);
var K = q;
export {
  K as default
};
//# sourceMappingURL=Box-ENEKINRZ.js.map
