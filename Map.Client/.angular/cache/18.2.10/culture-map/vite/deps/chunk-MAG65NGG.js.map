{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl.js", "../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js", "../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/hud/HUDVisibility.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { BooleanPassUniform as e } from \"../../shaderModules/BooleanPassUniform.js\";\nimport { glsl as i } from \"../../shaderModules/interfaces.js\";\nfunction o(o) {\n  o.uniforms.add(new e(\"alignPixelEnabled\", (e, i) => i.alignPixelEnabled)), o.code.add(i`vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {\nif (!alignPixelEnabled)\nreturn clipCoord;\nvec2 xy = vec2(0.500123) + 0.5 * clipCoord.xy / clipCoord.w;\nvec2 pixelSz = vec2(1.0) / widthHeight;\nvec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;\nvec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;\nreturn vec4(result, clipCoord.zw);\n}`), o.code.add(i`vec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {\nif (!alignPixelEnabled)\nreturn clipCoord;\nvec2 xy = vec2(0.5) + 0.5 * clipCoord.xy / clipCoord.w;\nvec2 pixelSz = vec2(1.0) / widthHeight;\nvec2 ij = floor((xy + 0.5 * pixelSz) * widthHeight) * pixelSz;\nvec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;\nreturn vec4(result, clipCoord.zw);\n}`);\n}\nexport { o as AlignPixel };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { addVerticalOffset as e } from \"../attributes/VerticalOffset.glsl.js\";\nimport { ScreenSizePerspective as t, addScreenSizePerspectiveAlignment as a } from \"../util/ScreenSizePerspective.glsl.js\";\nimport { addProjViewLocalOrigin as o, addCameraPosition as s, addViewNormal as i, addPixelRatio as n } from \"../util/View.glsl.js\";\nimport { Float4PassUniform as r } from \"../../shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as l } from \"../../shaderModules/FloatPassUniform.js\";\nimport { glsl as f } from \"../../shaderModules/interfaces.js\";\nimport { VertexAttribute as c } from \"../../../lib/VertexAttribute.js\";\nconst p = .5;\nfunction d(d, u) {\n  d.include(t), d.attributes.add(c.POSITION, \"vec3\"), d.attributes.add(c.NORMAL, \"vec3\"), d.attributes.add(c.CENTEROFFSETANDDISTANCE, \"vec4\");\n  const v = d.vertex;\n  o(v, u), s(v, u), v.uniforms.add(new r(\"viewport\", (e, t) => t.camera.fullViewport), new l(\"polygonOffset\", e => e.shaderPolygonOffset), new l(\"cameraGroundRelative\", (e, t) => t.camera.aboveGround ? 1 : -1)), u.hasVerticalOffset && e(v), v.constants.add(\"smallOffsetAngle\", \"float\", .984807753012208), v.code.add(f`struct ProjectHUDAux {\nvec3 posModel;\nvec3 posView;\nvec3 vnormal;\nfloat distanceToCamera;\nfloat absCosAngle;\n};`), v.code.add(f`\n    float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {\n      float pointGroundSign = ${u.multipassEnabled ? f.float(0) : f`sign(pointGroundDistance)`};\n      if (pointGroundSign == 0.0) {\n        pointGroundSign = cameraGroundRelative;\n      }\n\n      // cameraGroundRelative is -1 if camera is below ground, 1 if above ground\n      // groundRelative is 1 if both camera and symbol are on the same side of the ground, -1 otherwise\n      float groundRelative = cameraGroundRelative * pointGroundSign;\n\n      // view angle dependent part of polygon offset emulation: we take the absolute value because the sign that is\n      // dropped is instead introduced using the ground-relative position of the symbol and the camera\n      if (polygonOffset > .0) {\n        float cosAlpha = clamp(absCosAngle, 0.01, 1.0);\n        float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\n        float factor = (1.0 - tanAlpha / viewport[2]);\n\n        // same side of the terrain\n        if (groundRelative > 0.0) {\n          posView *= factor;\n        }\n        // opposite sides of the terrain\n        else {\n          posView /= factor;\n        }\n      }\n\n      return groundRelative;\n    }\n  `), u.draped && !u.hasVerticalOffset || i(v), u.draped || (v.uniforms.add(new l(\"perDistancePixelRatio\", (e, t) => Math.tan(t.camera.fovY / 2) / (t.camera.fullViewport[2] / 2))), v.code.add(f`\n    void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {\n      float distanceToCamera = length(posView);\n\n      // Compute offset in world units for a half pixel shift\n      float pixelOffset = distanceToCamera * perDistancePixelRatio * ${f.float(p)};\n\n      // Apply offset along normal in the direction away from the ground surface\n      vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;\n\n      // Apply the same offset also on the view space position\n      vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n\n      posModel += modelOffset;\n      posView += viewOffset;\n    }\n  `)), u.screenCenterOffsetUnitsEnabled && n(v), u.hasScreenSizePerspective && a(v), v.code.add(f`\n    vec4 projectPositionHUD(out ProjectHUDAux aux) {\n      vec3 centerOffset = centerOffsetAndDistance.xyz;\n      float pointGroundDistance = centerOffsetAndDistance.w;\n\n      aux.posModel = position;\n      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;\n      aux.vnormal = normal;\n      ${u.draped ? \"\" : \"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);\"}\n\n      // Screen sized offset in world space, used for example for line callouts\n      // Note: keep this implementation in sync with the CPU implementation, see\n      //   - MaterialUtil.verticalOffsetAtDistance\n      //   - HUDMaterial.applyVerticalOffsetTransformation\n\n      aux.distanceToCamera = length(aux.posView);\n\n      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);\n      float cosAngle = dot(aux.vnormal, viewDirObjSpace);\n\n      aux.absCosAngle = abs(cosAngle);\n\n      ${u.hasScreenSizePerspective && (u.hasVerticalOffset || u.screenCenterOffsetUnitsEnabled) ? \"vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);\" : \"\"}\n\n      ${u.hasVerticalOffset ? u.hasScreenSizePerspective ? \"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);\" : \"float verticalOffsetScreenHeight = verticalOffset.x;\" : \"\"}\n\n      ${u.hasVerticalOffset ? f`\n            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);\n            vec3 modelOffset = aux.vnormal * worldOffset;\n            aux.posModel += modelOffset;\n            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n            aux.posView += viewOffset;\n            // Since we elevate the object, we need to take that into account\n            // in the distance to ground\n            pointGroundDistance += worldOffset;` : \"\"}\n\n      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);\n\n      ${u.screenCenterOffsetUnitsEnabled ? \"\" : f`\n            // Apply x/y in view space, but z in screen space (i.e. along posView direction)\n            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);\n\n            // Same material all have same z != 0.0 condition so should not lead to\n            // branch fragmentation and will save a normalization if it's not needed\n            if (centerOffset.z != 0.0) {\n              aux.posView -= normalize(aux.posView) * centerOffset.z;\n            }\n          `}\n\n      vec4 posProj = proj * vec4(aux.posView, 1.0);\n\n      ${u.screenCenterOffsetUnitsEnabled ? u.hasScreenSizePerspective ? \"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);\" : \"float centerOffsetY = centerOffset.y;\" : \"\"}\n\n      ${u.screenCenterOffsetUnitsEnabled ? \"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;\" : \"\"}\n\n      // constant part of polygon offset emulation\n      posProj.z -= groundRelative * polygonOffset * posProj.w;\n      return posProj;\n    }\n  `);\n}\nexport { d as HUD, p as HUDVerticalPixelOffset };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { AlignPixel as e } from \"./AlignPixel.glsl.js\";\nimport { HUDRenderStyle as r } from \"./HUDRenderStyle.js\";\nimport { Float4PassUniform as o } from \"../../shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as i } from \"../../shaderModules/FloatPassUniform.js\";\nimport { glsl as l } from \"../../shaderModules/interfaces.js\";\nimport { Texture2DPassUniform as s } from \"../../shaderModules/Texture2DPassUniform.js\";\nfunction t(t) {\n  t.vertex.uniforms.add(new i(\"renderTransparentlyOccludedHUD\", (e, o) => o.hudRenderStyle === r.Occluded ? 1 : o.hudRenderStyle === r.NotOccluded ? 0 : .75), new o(\"viewport\", (e, r) => r.camera.fullViewport), new s(\"hudVisibilityTexture\", (e, r) => r.hudVisibility?.getTexture())), t.vertex.include(e), t.vertex.code.add(l`bool testHUDVisibility(vec4 posProj) {\nvec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);\nvec4 occlusionPixel = texture(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);\nif (renderTransparentlyOccludedHUD > 0.5) {\nreturn occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * renderTransparentlyOccludedHUD < 1.0;\n}\nreturn occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;\n}`);\n}\nexport { t as HUDVisibility };"],
  "mappings": "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",
  "names": ["o", "s", "e", "p", "d", "s", "e", "t", "o", "f", "t", "o", "e"]
}
