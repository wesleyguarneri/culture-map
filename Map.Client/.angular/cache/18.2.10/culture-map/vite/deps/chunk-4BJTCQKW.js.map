{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/views/3d/environment/atmosphereUtils.js", "../../../../../../node_modules/@arcgis/core/chunks/ChapmanAtmosphere.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { clamp as t } from \"../../../core/mathUtils.js\";\nfunction e(e) {\n  const o = 1e5;\n  return t((e - o) / (1e6 - o), 0, 1);\n}\nconst o = 1e4,\n  r = .085,\n  n = 1e5;\nexport { n as atmosphereHeight, e as computeInnerAltitudeFade, o as innerAtmosphereDepth, r as rayLeighScaleHeight };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { invertOrIdentity as e } from \"../core/libs/gl-matrix-2/math/mat4.js\";\nimport { create as t } from \"../core/libs/gl-matrix-2/factories/mat4f64.js\";\nimport { fromValues as a } from \"../core/libs/gl-matrix-2/factories/vec3f64.js\";\nimport { rayLeighScaleHeight as r, atmosphereHeight as i } from \"../views/3d/environment/atmosphereUtils.js\";\nimport { TextureCoordinateAttribute as o, TextureCoordinateAttributeType as s } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";\nimport { ReadDepth as n } from \"../views/3d/webgl-engine/core/shaderLibrary/output/ReadDepth.glsl.js\";\nimport { Gamma as l } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl.js\";\nimport { addMainLightDirection as c } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js\";\nimport { Float2PassUniform as h } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float3PassUniform as d } from \"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";\nimport { Float4PassUniform as p } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as m } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as u } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as g } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { ShaderBuilder as f } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as x } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nimport { VertexAttribute as v } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nconst y = a(parseFloat(Number(5802e-9).toFixed(6)), parseFloat(Number(13558e-9).toFixed(6)), parseFloat(Number(331e-7).toFixed(6))),\n  b = 3,\n  D = a(b * parseFloat(Number(65e-8).toFixed(6)), b * parseFloat(Number(1881e-9).toFixed(6)), b * parseFloat(Number(85e-9).toFixed(6))),\n  P = 3996e-9,\n  w = a(parseFloat(Number(y[0] + D[0]).toFixed(6)), parseFloat(Number(y[1] + D[1]).toFixed(6)), parseFloat(Number(y[2] + D[2]).toFixed(6)));\nfunction S(t) {\n  const a = new f();\n  a.attributes.add(v.POSITION, \"vec2\"), a.include(o, {\n    textureCoordinateType: s.Default\n  }), a.varyings.add(\"worldRay\", \"vec3\"), a.varyings.add(\"eyeDir\", \"vec3\");\n  const {\n    vertex: b,\n    fragment: D\n  } = a;\n  return b.uniforms.add(new g(\"inverseProjectionMatrix\", (e, t) => t.camera.inverseProjectionMatrix), new g(\"inverseViewMatrix\", (t, a) => e(z, a.camera.viewMatrix))), b.code.add(u`void main(void) {\nvec3 posViewNear = (inverseProjectionMatrix * vec4(position, -1, 1)).xyz;\neyeDir = posViewNear;\nworldRay = (inverseViewMatrix * vec4(posViewNear, 0)).xyz;\nforwardTextureCoordinates();\ngl_Position = vec4(position, 1, 1);\n}`), D.uniforms.add(new d(\"backgroundColor\", e => e.backgroundColor), new h(\"radii\", e => e.radii), new d(\"cameraPosition\", (e, t) => t.camera.eye), new p(\"heightParameters\", e => e.heightParameters), new m(\"innerFadeDistance\", e => e.innerFadeDistance), new m(\"altitudeFade\", e => e.altitudeFade), new x(\"depthTexture\", e => e.depthTexture), new m(\"hazeStrength\", e => e.hazeStrength)), D.constants.add(\"betaRayleigh\", \"vec3\", y), D.constants.add(\"betaCombined\", \"vec3\", w), D.constants.add(\"betaMie\", \"float\", P), D.constants.add(\"scaleHeight\", \"float\", r * i), c(D), a.include(l), t.haze && D.include(n), D.code.add(u`vec2 sphereIntersect(vec3 start, vec3 dir, float radius, bool planet) {\nfloat a = dot(dir, dir);\nfloat b = 2.0 * dot(dir, start);\nfloat c = planet ? heightParameters[1] - radius * radius : heightParameters[2];\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) {\nreturn vec2(1e5, -1e5);\n}\nreturn vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));\n}`), D.code.add(u`float chapmanApproximation(float X, float h, float cosZenith) {\nfloat c = sqrt(X + h);\nfloat cExpH = c * exp(-h);\nif (cosZenith >= 0.0) {\nreturn cExpH / (c * cosZenith + 1.0);\n} else {\nfloat x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);\nfloat c0 = sqrt(x0);\nreturn 2.0 * c0 * exp(X - x0) - cExpH / (1.0 - c * cosZenith);\n}\n}`), D.code.add(u`float getOpticalDepth(vec3 position, vec3 dir, float h) {\nreturn scaleHeight * chapmanApproximation(radii[0] / scaleHeight, h, dot(normalize(position), dir));\n}`), D.code.add(u`\n    const int STEPS = 6;\n\n    vec3 getAtmosphereColour(vec3 cameraPos, vec3 rayDir, vec3 lightDir, float terrainDepth) {\n      float reducedPlanetRadius = radii[0] - 20000.0;\n      vec2 rayPlanetIntersect = sphereIntersect(cameraPos, rayDir, reducedPlanetRadius, true);\n      vec2 rayAtmosphereIntersect = sphereIntersect(cameraPos, rayDir, radii[1], false);\n      bool hitsAtmosphere = (rayAtmosphereIntersect.x <= rayAtmosphereIntersect.y) && rayAtmosphereIntersect.x > 0.0;\n      bool insideAtmosphere = heightParameters[0] < radii[1];\n\n      if (!(hitsAtmosphere || insideAtmosphere)) {\n        return vec3(0);\n      }\n\n      bool hitsPlanet = (rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.x > 0.0;\n\n      float start = insideAtmosphere ? 0.0 : rayAtmosphereIntersect.x;\n\n      if (heightParameters[0] < reducedPlanetRadius) {\n        // Long light rays from the night side of the planet lead to numerical instability\n        // Do not render the atmosphere in such cases\n        if (dot(rayDir, normalize(cameraPos)) < -0.025) {\n          return vec3(0);\n        }\n        start = rayPlanetIntersect.y;\n      }\n\n      float end = hitsPlanet ? rayPlanetIntersect.x : rayAtmosphereIntersect.y;\n      float maxEnd = end;\n\n      ${t.haze ? u`if (terrainDepth != -1.0) { end = terrainDepth; }` : \"\"}\n\n      vec3 samplePoint = cameraPos + rayDir * end;\n      float multiplier = hitsPlanet ? -1.0 : 1.0;\n\n      vec3 scattering = vec3(0);\n      float scaleFract = (length(samplePoint) - radii[0]) / scaleHeight;\n      float lastOpticalDepth = getOpticalDepth(samplePoint, rayDir, scaleFract);\n      float stepSize = (end - start) / float(STEPS);\n      for (int i = 0; i < STEPS; i++) {\n        samplePoint -= stepSize * rayDir;\n        scaleFract = (length(samplePoint) - radii[0]) / scaleHeight;\n        float opticalDepth = multiplier * getOpticalDepth(samplePoint, rayDir * multiplier, scaleFract);\n\n        if (i > 0) {\n          scattering *= ${t.haze ? \"\" : u`mix(2.5, 1.0, clamp((length(cameraPos) - radii[0]) / 50e3, 0.0, 1.0)) * `} exp(-(mix(betaCombined, betaRayleigh, 0.5) + betaMie) * max(0.0, (opticalDepth - lastOpticalDepth)));\n        }\n\n        if (dot(normalize(samplePoint), lightDir) > -0.3) {\n\n          float scale = exp(-scaleFract);\n          float lightDepth = getOpticalDepth(samplePoint, lightDir, scaleFract);\n\n          scattering += scale * exp(-(betaCombined + betaMie) * lightDepth);\n          ${t.haze ? \"\" : u`scattering += scale * exp(-(0.25 * betaCombined ) * lightDepth);`}\n        }\n\n        lastOpticalDepth = opticalDepth;\n\n      }\n\n      float mu = dot(rayDir, lightDir);\n      float mumu = 1.0 + mu * mu;\n\n      float phaseRayleigh = 0.0596831 * mumu;\n\n      ${t.haze ? u`return 3.0 * scattering * stepSize * phaseRayleigh * betaRayleigh;` : u`\n            const float g = 0.8;\n            const float gg = g * g;\n            float phaseMie = end == maxEnd ? 0.1193662 * ((1.0 - gg) * mumu) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg)) : 0.0;\n            phaseMie = clamp(phaseMie, 0.0, 128.0);\n            return 3.0 * scattering * stepSize * (phaseRayleigh * betaRayleigh + 0.025 * phaseMie * betaMie);`}\n    }\n\n    ${t.haze ? \"\" : u`\n            vec4 applyUndergroundAtmosphere(vec3 rayDir, vec3 lightDirection, vec4 fragColor) {\n              vec2 rayPlanetIntersect = sphereIntersect(cameraPosition, rayDir, radii[0], true);\n              if (!((rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.y > 0.0)) {\n                return fragColor;\n              }\n\n              float lightAngle = dot(lightDirection, normalize(cameraPosition + rayDir * max(0.0, rayPlanetIntersect.x)));\n              vec4 surfaceColor = vec4(vec3(max(0.0, (smoothstep(-1.0, 0.8, 2.0 * lightAngle)))), 1.0 - altitudeFade);\n              float relDist = (rayPlanetIntersect.y - max(0.0, rayPlanetIntersect.x)) / innerFadeDistance;\n              if (relDist > 1.0) {\n                return surfaceColor;\n              }\n\n              return mix(fragColor, surfaceColor, smoothstep(0.0, 1.0, relDist * relDist));\n            }\n\n            float getGlow(float dist, float radius, float intensity) {\n              return pow(radius / max(dist, 1e-6), intensity);\n            }\n\n            vec3 getSun(vec3 cameraPos, vec3 rayDir, vec3 lightDir){\n\n              // Get the amount of atmosphere between camera and the Sun along the view ray\n              float scaleFract = (length(cameraPos) - radii[0]) / scaleHeight;\n              float sunOpticalDepth = getOpticalDepth(cameraPos, rayDir, max(scaleFract, 0.0));\n\n              // Find the amount of light that remains after travelling through the atmosphere from the Sun along the view ray\n              // This will make the colour of the Sun reddish on the horizon and white from space\n              vec3 sunTransmittance = exp(-(mix(betaCombined, betaRayleigh, 0.5)) * max(0.0, sunOpticalDepth));\n\n              // Alignment of light direction and view ray\n              float mu = clamp(dot(rayDir, lightDir), 0.0, 1.0);\n              // Draw the Sun as a bright disc\n              float sunDisc = 256.0 * smoothstep(0.0, 128.0, clamp(getGlow(1.0 - mu, 3e-5, 3.0), 0.0, 128.0));\n\n              return normalize(sunTransmittance) * sunDisc;\n            }`}\n\n    ${t.haze && t.reduced ? u`\n        float getDepth(vec2 uv){\n          return linearDepthFromTexture(depthTexture, uv);\n        }\n\n        float textureBilinear(vec2 uv) {\n          // Information about the high-resolution depth texture\n          vec2 depthTextureSize = vec2(textureSize(depthTexture, 0));\n          vec2 texelSize = 1.0 / depthTextureSize;\n\n          // The uv inside the upper right pixel - of the tile of 4 pixels -\n          // that the atmosphere uv maps to in the depth texture\n          vec2 depthUV = (uv * depthTextureSize) - vec2(0.5);\n\n          // Relative distance of the uv coordinates inside the depth texture pixel\n          vec2 f = fract(depthUV);\n\n          // Snap to the centre of the depth texture pixel\n          vec2 snapUV = (floor(depthUV) + vec2(0.5)) / depthTextureSize;\n\n          // Read the depth texture pixel and its three neighbours\n          float d0 = getDepth(snapUV);\n          float d1 = getDepth(snapUV + vec2(texelSize.x, 0.0));\n          float d2 = getDepth(snapUV + vec2(0.0, texelSize.y));\n          float d3 = getDepth(snapUV + texelSize);\n\n          // Return the bilinearly interpolated value of the neighbouring pixels based\n          // on the sample position in the depth texture pixel\n          return mix(mix(d0, d1, f.x), mix(d2, d3, f.x), f.y);\n        }\n        ` : \"\"}\n\n    vec3 tonemapACES(vec3 x) {\n      return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n    }\n\n    void main() {\n      vec3 rayDir = normalize(worldRay);\n      float terrainDepth = -1.0;\n      ${t.haze ? u`\n          float depthSample = texture(depthTexture, vuv0).r;\n          if (depthSample != 1.0) {\n            vec3 cameraSpaceRay = normalize(eyeDir);\n            cameraSpaceRay /= cameraSpaceRay.z;\n\n              ${t.reduced ? u`cameraSpaceRay *= -textureBilinear(vuv0);` : u`cameraSpaceRay *= -linearDepthFromTexture(depthTexture, vuv0);`}\n\n            terrainDepth = max(0.0, length(cameraSpaceRay));\n          }else{\n            discard;\n          }\n          ` : u`${t.reduced ? \"\" : u`\n                float depthSample = texture(depthTexture, vuv0).r;\n                if (depthSample != 1.0) {\n                  fragColor = vec4(0);\n                  return;\n                }`}`}\n\n      ${t.haze ? u`\n            vec3 col = vec3(0);\n            float fadeOut = smoothstep(-10000.0, -15000.0, heightParameters[0] - radii[0]);\n            if(depthSample != 1.0){\n              col = (1.0 - fadeOut) * hazeStrength * getAtmosphereColour(cameraPosition, rayDir, mainLightDirection, terrainDepth);\n            }\n            // Alpha is ignored for haze blending\n            float alpha = 1.0;\n            ` : u`\n            vec3 col = linearizeGamma(backgroundColor);\n            col += getAtmosphereColour(cameraPosition, rayDir, mainLightDirection, terrainDepth);\n            col += getSun(cameraPosition, rayDir, mainLightDirection);\n            float alpha = smoothstep(0.0, mix(0.15, 0.01, heightParameters[3]), length(col));`}\n\n      col = tonemapACES(col);\n      fragColor = delinearizeGamma(vec4(col, alpha));\n      ${t.haze ? \"\" : u`fragColor = applyUndergroundAtmosphere(rayDir, mainLightDirection, fragColor);`}\n    }\n  `), a;\n}\nconst z = t(),\n  F = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    betaRayleigh: y,\n    build: S\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { F as C, S as a, y as b };"],
  "mappings": "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",
  "names": ["e", "o", "r", "t", "o", "e", "b", "D", "a", "r"]
}
