{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/chunks/CloudsComposition.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { invertOrIdentity as e } from \"../core/libs/gl-matrix-2/math/mat4.js\";\nimport { create as r } from \"../core/libs/gl-matrix-2/factories/mat4f64.js\";\nimport { EvaluateAmbientLighting as i } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl.js\";\nimport { Gamma as o } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl.js\";\nimport { MainLighting as s } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js\";\nimport { PBRMode as a } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js\";\nimport { PiUtils as n } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl.js\";\nimport { CloudsParallaxShading as l } from \"../views/3d/webgl-engine/core/shaderLibrary/util/CloudsParallaxShading.glsl.js\";\nimport { ColorConversion as d } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { RgbaFloatEncoding as t } from \"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";\nimport { Float3PassUniform as g } from \"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";\nimport { glsl as m } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as c } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { ShaderBuilder as w } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { VertexAttribute as b } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nfunction v() {\n  const r = new w(),\n    {\n      attributes: v,\n      varyings: f,\n      vertex: h,\n      fragment: p\n    } = r;\n  return v.add(b.POSITION, \"vec2\"), f.add(\"worldRay\", \"vec3\"), h.uniforms.add(new c(\"inverseProjectionMatrix\", (e, r) => r.camera.inverseProjectionMatrix), new c(\"inverseViewMatrix\", (r, i) => e(u, i.camera.viewMatrix))), h.code.add(m`void main(void) {\nvec3 posViewNear = (inverseProjectionMatrix * vec4(position, -1.0, 1.0)).xyz;\nworldRay = (inverseViewMatrix * vec4(posViewNear, 0.0)).xyz;\ngl_Position = vec4(position, 1.0, 1.0);\n}`), p.include(d), p.include(t), r.include(i, {\n    pbrMode: a.Disabled,\n    lightingSphericalHarmonicsOrder: 2\n  }), r.include(n), r.include(o), r.include(s), r.include(l), p.uniforms.add(new g(\"cameraPosition\", (e, r) => r.camera.eye)), p.code.add(m`void main() {\nvec4 cloudsColor = renderClouds(normalize(worldRay), cameraPosition);\nfragColor = vec4((1.0 - totalFadeInOut) * cloudsColor.rgb, cloudsColor.a);\n}`), r;\n}\nconst u = r(),\n  f = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    build: v\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { f as C, v as b };"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmBA,SAASA,KAAI;AACX,QAAMC,KAAI,IAAIC,GAAE,GACd;AAAA,IACE,YAAYF;AAAA,IACZ,UAAUG;AAAA,IACV,QAAQ;AAAA,IACR,UAAU;AAAA,EACZ,IAAIF;AACN,SAAOD,GAAE,IAAII,GAAE,UAAU,MAAM,GAAGD,GAAE,IAAI,YAAY,MAAM,GAAG,EAAE,SAAS,IAAI,IAAIC,GAAE,2BAA2B,CAACA,IAAGH,OAAMA,GAAE,OAAO,uBAAuB,GAAG,IAAIG,GAAE,qBAAqB,CAACH,IAAG,MAAM,EAAE,GAAG,EAAE,OAAO,UAAU,CAAC,CAAC,GAAG,EAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA,EAIvO,GAAG,EAAE,QAAQG,EAAC,GAAG,EAAE,QAAQ,CAAC,GAAGH,GAAE,QAAQ,GAAG;AAAA,IAC1C,SAAS,EAAE;AAAA,IACX,iCAAiC;AAAA,EACnC,CAAC,GAAGA,GAAE,QAAQ,CAAC,GAAGA,GAAE,QAAQG,EAAC,GAAGH,GAAE,QAAQC,EAAC,GAAGD,GAAE,QAAQ,CAAC,GAAG,EAAE,SAAS,IAAI,IAAIG,GAAE,kBAAkB,CAACA,IAAGH,OAAMA,GAAE,OAAO,GAAG,CAAC,GAAG,EAAE,KAAK,IAAI;AAAA;AAAA;AAAA,EAGxI,GAAGA;AACL;AACA,IAAM,IAAIG,GAAE;AAAZ,IACE,IAAI,OAAO,OAAO,OAAO,eAAe;AAAA,EACtC,WAAW;AAAA,EACX,OAAOJ;AACT,GAAG,OAAO,aAAa;AAAA,EACrB,OAAO;AACT,CAAC,CAAC;",
  "names": ["v", "r", "o", "f", "e"]
}
