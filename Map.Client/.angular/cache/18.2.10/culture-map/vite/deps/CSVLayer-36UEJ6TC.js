import {
  l
} from "./chunk-7PCL3GUC.js";
import "./chunk-DON3YPGT.js";
import {
  Ze
} from "./chunk-B7GRWOZI.js";
import "./chunk-SAOPWBKU.js";
import "./chunk-Z2JVKOTW.js";
import "./chunk-YW5DYBTP.js";
import "./chunk-2C54H6O6.js";
import "./chunk-UHMXQYZT.js";
import "./chunk-LZUPV7SL.js";
import "./chunk-2GRLWAHK.js";
import "./chunk-C3UDKWXD.js";
import "./chunk-YTFX4PFO.js";
import "./chunk-VOROPCKI.js";
import "./chunk-N3IR233K.js";
import "./chunk-DSMB46HB.js";
import "./chunk-USSQX44O.js";
import "./chunk-OTI4DGZ5.js";
import "./chunk-KQDYTHCF.js";
import "./chunk-TR6FCWXY.js";
import "./chunk-TROPJVOL.js";
import "./chunk-JKHDI77M.js";
import "./chunk-3AY5EJVP.js";
import "./chunk-XQCKIDQO.js";
import "./chunk-BNK4CEA6.js";
import "./chunk-BPMRTFHU.js";
import "./chunk-6LDLRQX4.js";
import "./chunk-Z4YAQ5JI.js";
import "./chunk-K2XCQKCC.js";
import "./chunk-AJS4B62I.js";
import "./chunk-S5EXT7FA.js";
import "./chunk-73Y7XDLH.js";
import "./chunk-YFOAET4H.js";
import "./chunk-5U4TBXYS.js";
import "./chunk-6WG22V46.js";
import "./chunk-OOGIXDXG.js";
import "./chunk-JFYQTYD3.js";
import "./chunk-KDJZAYOF.js";
import "./chunk-5453A3C5.js";
import "./chunk-HCFDI7IX.js";
import "./chunk-AQJS6F3O.js";
import "./chunk-WUB6LJVL.js";
import "./chunk-QXSES7JX.js";
import {
  p
} from "./chunk-5YIMTGEC.js";
import "./chunk-YPU2P4KO.js";
import {
  d
} from "./chunk-UFVMJL32.js";
import "./chunk-B67FUUE5.js";
import "./chunk-5GQ3OMCZ.js";
import "./chunk-2SMFPIRI.js";
import "./chunk-2GMKFOCL.js";
import "./chunk-ZR5BOILP.js";
import "./chunk-QCBC3RJX.js";
import "./chunk-6XGV55XZ.js";
import "./chunk-HOH445RO.js";
import "./chunk-63QCTVYB.js";
import "./chunk-U74WRHVJ.js";
import "./chunk-TCPN7AEH.js";
import "./chunk-W2IRSMFY.js";
import {
  b
} from "./chunk-TRSGUVSM.js";
import "./chunk-U3MA63JX.js";
import "./chunk-WYKKCLBI.js";
import "./chunk-PFMGJTQM.js";
import "./chunk-Q7SRMLJZ.js";
import "./chunk-PQ4T66BG.js";
import "./chunk-SWPHGZYB.js";
import "./chunk-DWASPXVI.js";
import "./chunk-TNWXOQKO.js";
import "./chunk-MAO5BVLA.js";
import "./chunk-T2S5VXNP.js";
import "./chunk-4U5GUJRA.js";
import "./chunk-7KRERHHR.js";
import "./chunk-T4AP6CTC.js";
import "./chunk-HD65DNIO.js";
import "./chunk-4KWLMXIA.js";
import "./chunk-BIUXKPKA.js";
import "./chunk-N6TJI25E.js";
import "./chunk-634JLXD4.js";
import "./chunk-Y3EDGYWG.js";
import "./chunk-UF6JOUSJ.js";
import "./chunk-T5JGQSO3.js";
import "./chunk-CIW3KHOW.js";
import "./chunk-J55F4AC2.js";
import "./chunk-IQLBZKUD.js";
import "./chunk-7MZZCQ64.js";
import "./chunk-JOJZ6YC5.js";
import "./chunk-L4TOCXR5.js";
import "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import "./chunk-RTWBKPWJ.js";
import "./chunk-ZZEAVAVX.js";
import "./chunk-SJX5DIA7.js";
import "./chunk-6A7CWJED.js";
import "./chunk-LFKEQKEA.js";
import "./chunk-DUTZNK67.js";
import "./chunk-IN6BQCWS.js";
import "./chunk-CRNUMTSV.js";
import "./chunk-JM7HAEY6.js";
import "./chunk-DOK4SACJ.js";
import "./chunk-OUKUASAF.js";
import "./chunk-V5RMUGJJ.js";
import "./chunk-D2NB6D6N.js";
import "./chunk-UWJIHV6Q.js";
import "./chunk-ZUSCOMQM.js";
import "./chunk-DSEUCBVP.js";
import "./chunk-UPDWQH75.js";
import "./chunk-RXWBJSJ5.js";
import "./chunk-M2NS3MSU.js";
import "./chunk-HMNBB7ED.js";
import "./chunk-3RRMLFFN.js";
import "./chunk-DR5TVNEL.js";
import "./chunk-HT2T6PUB.js";
import "./chunk-K64AAM77.js";
import "./chunk-6EUVKE22.js";
import "./chunk-A3NNJ7XA.js";
import "./chunk-OKJHJ3CY.js";
import "./chunk-XTVPEVHA.js";
import "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import "./chunk-DZALMCYL.js";
import "./chunk-K226GFDN.js";
import "./chunk-4ZZRP4MA.js";
import "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-5I6J67HP.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-EODIWR2E.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-FYAEQPUY.js";
import "./chunk-7XMEZQ34.js";
import {
  m
} from "./chunk-BDM2D6IC.js";
import {
  f as f2,
  h
} from "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-7RMVJCDW.js";
import "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import {
  w
} from "./chunk-NYQ5CYNR.js";
import "./chunk-O7UDKFOW.js";
import {
  f
} from "./chunk-TKPMIAIW.js";
import {
  o
} from "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import "./chunk-AXVPJBVW.js";
import "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import {
  I
} from "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import "./chunk-6WHTZNUH.js";
import "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import "./chunk-XNUH25NY.js";
import "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e
} from "./chunk-4Z5SGKRM.js";
import "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3 as a2
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import {
  a,
  k
} from "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  s2 as s
} from "./chunk-WYIDUUN2.js";
import {
  has
} from "./chunk-DXLOWWK7.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/layers/graphics/sources/CSVSource.js
var c = class extends m {
  constructor(t) {
    super(t), this.type = "csv", this.refresh = k((t2) => __async(this, null, function* () {
      yield this.load();
      const {
        extent: e2,
        timeExtent: o2
      } = yield this._connection.invoke("refresh", t2);
      return e2 && (this.sourceJSON.extent = e2), o2 && (this.sourceJSON.timeInfo.timeExtent = [o2.start, o2.end]), {
        dataChanged: true,
        updates: {
          extent: this.sourceJSON.extent,
          timeInfo: this.sourceJSON.timeInfo
        }
      };
    }));
  }
  load(t) {
    const e2 = null != t ? t.signal : null;
    return this.addResolvingPromise(this._startWorker(e2)), Promise.resolve(this);
  }
  destroy() {
    this._connection?.close(), this._connection = null;
  }
  openPorts() {
    return __async(this, null, function* () {
      return yield this.load(), this._connection.openPorts();
    });
  }
  queryFeatures(_0) {
    return __async(this, arguments, function* (t, e2 = {}) {
      yield this.load(e2);
      const o2 = yield this._connection.invoke("queryFeatures", t ? t.toJSON() : null, e2);
      return d.fromJSON(o2);
    });
  }
  queryFeaturesJSON(_0) {
    return __async(this, arguments, function* (t, e2 = {}) {
      return yield this.load(e2), this._connection.invoke("queryFeatures", t ? t.toJSON() : null, e2);
    });
  }
  queryFeatureCount(_0) {
    return __async(this, arguments, function* (t, e2 = {}) {
      return yield this.load(e2), this._connection.invoke("queryFeatureCount", t ? t.toJSON() : null, e2);
    });
  }
  queryObjectIds(_0) {
    return __async(this, arguments, function* (t, e2 = {}) {
      return yield this.load(e2), this._connection.invoke("queryObjectIds", t ? t.toJSON() : null, e2);
    });
  }
  queryExtent(_0) {
    return __async(this, arguments, function* (t, e2 = {}) {
      yield this.load(e2);
      const o2 = yield this._connection.invoke("queryExtent", t ? t.toJSON() : null, e2);
      return {
        count: o2.count,
        extent: w.fromJSON(o2.extent)
      };
    });
  }
  querySnapping(_0) {
    return __async(this, arguments, function* (t, e2 = {}) {
      return yield this.load(e2), this._connection.invoke("querySnapping", t, e2);
    });
  }
  _startWorker(t) {
    return __async(this, null, function* () {
      this._connection = yield p("CSVSourceWorker", {
        strategy: has("feature-layers-workers") ? "dedicated" : "local",
        signal: t,
        registryTarget: this
      });
      const {
        url: e2,
        delimiter: o2,
        fields: i,
        latitudeField: s2,
        longitudeField: n,
        spatialReference: a3,
        timeInfo: c2
      } = this.loadOptions, l2 = yield this._connection.invoke("load", {
        url: e2,
        customParameters: this.customParameters,
        parsingOptions: {
          delimiter: o2,
          fields: i?.map((t2) => t2.toJSON()),
          latitudeField: s2,
          longitudeField: n,
          spatialReference: a3?.toJSON(),
          timeInfo: c2?.toJSON()
        }
      }, {
        signal: t
      });
      this.locationInfo = l2.locationInfo, this.sourceJSON = l2.layerDefinition, this.delimiter = l2.delimiter;
    });
  }
};
e([y()], c.prototype, "type", void 0), e([y()], c.prototype, "loadOptions", void 0), e([y()], c.prototype, "customParameters", void 0), e([y()], c.prototype, "locationInfo", void 0), e([y()], c.prototype, "sourceJSON", void 0), e([y()], c.prototype, "delimiter", void 0), c = e([a2("esri.layers.graphics.sources.CSVSource")], c);

// ../../../node_modules/@arcgis/core/layers/CSVLayer.js
function h2(e2, r) {
  throw new s(r, `CSVLayer (title: ${e2.title}, id: ${e2.id}) cannot be saved to a portal item`);
}
var m2 = class extends Ze {
  constructor(...e2) {
    super(...e2), this.geometryType = "point", this.capabilities = l(false, false), this.delimiter = null, this.editingEnabled = false, this.fields = null, this.latitudeField = null, this.locationType = "coordinates", this.longitudeField = null, this.operationalLayerType = "CSV", this.outFields = ["*"], this.path = null, this.spatialReference = f.WGS84, this.source = null, this.type = "csv";
  }
  normalizeCtorArgs(e2, t) {
    return "string" == typeof e2 ? __spreadValues({
      url: e2
    }, t) : e2;
  }
  load(e2) {
    const t = null != e2 ? e2.signal : null, i = this.loadFromPortal({
      supportedTypes: ["CSV"],
      supportsData: false
    }, e2).catch(a).then(() => __async(this, null, function* () {
      return this.initLayerProperties(yield this.createGraphicsSource(t));
    }));
    return this.addResolvingPromise(i), Promise.resolve(this);
  }
  get isTable() {
    return this.loaded && null == this.geometryType;
  }
  readWebMapLabelsVisible(e2, t) {
    return null != t.showLabels ? t.showLabels : !!t.layerDefinition?.drawingInfo?.labelingInfo;
  }
  set url(e2) {
    if (!e2) return void this._set("url", e2);
    const t = I(e2);
    this._set("url", t.path), t.query && (this.customParameters = __spreadValues(__spreadValues({}, this.customParameters), t.query));
  }
  createGraphicsSource(e2) {
    return __async(this, null, function* () {
      const t = new c({
        loadOptions: {
          delimiter: this.delimiter,
          fields: this.fields,
          latitudeField: this.latitudeField ?? void 0,
          longitudeField: this.longitudeField ?? void 0,
          spatialReference: this.spatialReference ?? void 0,
          timeInfo: this.timeInfo ?? void 0,
          url: this.url
        },
        customParameters: this.customParameters ?? void 0
      });
      return this._set("source", t), yield t.load({
        signal: e2
      }), this.read({
        locationInfo: t.locationInfo,
        columnDelimiter: t.delimiter
      }, {
        origin: "service",
        url: this.parsedUrl
      }), t;
    });
  }
  queryFeatures(e2, t) {
    return this.load().then(() => this.source.queryFeatures(b.from(e2) || this.createQuery())).then((e3) => {
      if (e3?.features) for (const t2 of e3.features) t2.layer = t2.sourceLayer = this;
      return e3;
    });
  }
  queryObjectIds(e2, t) {
    return this.load().then(() => this.source.queryObjectIds(b.from(e2) || this.createQuery()));
  }
  queryFeatureCount(e2, t) {
    return this.load().then(() => this.source.queryFeatureCount(b.from(e2) || this.createQuery()));
  }
  queryExtent(e2, t) {
    return this.load().then(() => this.source.queryExtent(b.from(e2) || this.createQuery()));
  }
  read(e2, t) {
    super.read(e2, t), t && "service" === t.origin && this.revert(["latitudeField", "longitudeField"], "service");
  }
  write(e2, t) {
    return super.write(e2, __spreadProps(__spreadValues({}, t), {
      writeLayerSchema: true
    }));
  }
  clone() {
    throw new s("csv-layer:clone", `CSVLayer (title: ${this.title}, id: ${this.id}) cannot be cloned`);
  }
  save(e2) {
    return __async(this, null, function* () {
      return h2(this, "csv-layer:save");
    });
  }
  saveAs(e2, t) {
    return __async(this, null, function* () {
      return h2(this, "csv-layer:save-as");
    });
  }
  hasDataChanged() {
    return __async(this, null, function* () {
      try {
        const {
          dataChanged: e2,
          updates: t
        } = yield this.source.refresh(this.customParameters);
        return null != t && this.read(t, {
          origin: "service",
          url: this.parsedUrl,
          ignoreDefaults: true
        }), e2;
      } catch {
      }
      return false;
    });
  }
  _verifyFields() {
  }
  _verifySource() {
  }
  _hasMemorySource() {
    return false;
  }
};
e([y({
  readOnly: true,
  json: {
    read: false,
    write: false
  }
})], m2.prototype, "capabilities", void 0), e([y({
  type: [",", " ", ";", "|", "	"],
  json: {
    read: {
      source: "columnDelimiter"
    },
    write: {
      target: "columnDelimiter",
      ignoreOrigin: true
    }
  }
})], m2.prototype, "delimiter", void 0), e([y({
  readOnly: true,
  type: Boolean,
  json: {
    origins: {
      "web-scene": {
        read: false,
        write: false
      }
    }
  }
})], m2.prototype, "editingEnabled", void 0), e([y({
  json: {
    read: {
      source: "layerDefinition.fields"
    },
    write: {
      target: "layerDefinition.fields"
    }
  }
})], m2.prototype, "fields", void 0), e([y({
  type: Boolean,
  readOnly: true
})], m2.prototype, "isTable", null), e([o("web-map", "labelsVisible", ["layerDefinition.drawingInfo.labelingInfo", "showLabels"])], m2.prototype, "readWebMapLabelsVisible", null), e([y({
  type: String,
  json: {
    read: {
      source: "locationInfo.latitudeFieldName"
    },
    write: {
      target: "locationInfo.latitudeFieldName",
      ignoreOrigin: true
    }
  }
})], m2.prototype, "latitudeField", void 0), e([y({
  type: ["show", "hide"]
})], m2.prototype, "listMode", void 0), e([y({
  type: ["coordinates"],
  json: {
    read: {
      source: "locationInfo.locationType"
    },
    write: {
      target: "locationInfo.locationType",
      ignoreOrigin: true,
      isRequired: true
    }
  }
})], m2.prototype, "locationType", void 0), e([y({
  type: String,
  json: {
    read: {
      source: "locationInfo.longitudeFieldName"
    },
    write: {
      target: "locationInfo.longitudeFieldName",
      ignoreOrigin: true
    }
  }
})], m2.prototype, "longitudeField", void 0), e([y({
  type: ["CSV"]
})], m2.prototype, "operationalLayerType", void 0), e([y()], m2.prototype, "outFields", void 0), e([y({
  type: String,
  json: {
    origins: {
      "web-scene": {
        read: false,
        write: false
      }
    },
    read: false,
    write: false
  }
})], m2.prototype, "path", void 0), e([y({
  json: {
    read: false
  },
  cast: null,
  type: c,
  readOnly: true
})], m2.prototype, "source", void 0), e([y({
  json: {
    read: false
  },
  value: "csv",
  readOnly: true
})], m2.prototype, "type", void 0), e([y({
  json: {
    read: f2,
    write: {
      isRequired: true,
      ignoreOrigin: true,
      writer: h
    }
  }
})], m2.prototype, "url", null), m2 = e([a2("esri.layers.CSVLayer")], m2);
var f3 = m2;
export {
  f3 as default
};
//# sourceMappingURL=CSVLayer-36UEJ6TC.js.map
