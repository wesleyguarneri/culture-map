import {
  B
} from "./chunk-WB2PLZ2R.js";
import {
  C as C3,
  D as D3,
  G as G2,
  K as K2,
  M,
  R,
  a as a3,
  b as b3,
  e as e13,
  s as s5
} from "./chunk-JCGHSOIP.js";
import {
  f as f2,
  i as i4,
  t as t9,
  x as x2
} from "./chunk-LC4TAVYF.js";
import {
  o as o5
} from "./chunk-6HNAQ6T3.js";
import {
  a as a2
} from "./chunk-KGPFLNKT.js";
import {
  o as o4
} from "./chunk-UJF7LPVD.js";
import {
  n as n9
} from "./chunk-K7KZCCPZ.js";
import {
  a as a4,
  u as u6,
  ze
} from "./chunk-SB6NP2J2.js";
import {
  u as u5
} from "./chunk-ONNA6736.js";
import {
  A as A5
} from "./chunk-4KGPH7OX.js";
import {
  G,
  e as e12,
  i as i3
} from "./chunk-ZIDRXKSJ.js";
import {
  C as C2
} from "./chunk-67LE7VNQ.js";
import {
  e as e11
} from "./chunk-I6P6ZEQ2.js";
import {
  t as t8
} from "./chunk-MOCGEINB.js";
import {
  t as t7
} from "./chunk-NSSWLGUQ.js";
import {
  o as o3
} from "./chunk-37FUJHR2.js";
import {
  f
} from "./chunk-HMUNABEN.js";
import {
  L as L3
} from "./chunk-7HBD4CJ3.js";
import {
  m as m3
} from "./chunk-5L3YXBNN.js";
import {
  g as g2
} from "./chunk-GOKBAMCG.js";
import {
  d as d4
} from "./chunk-PPMHRAOP.js";
import {
  t as t6
} from "./chunk-DE6MQ5XE.js";
import {
  h as h4
} from "./chunk-Y37SHKPH.js";
import {
  A as A4,
  E as E3,
  L as L2,
  _,
  e as e9
} from "./chunk-VERD3NGR.js";
import {
  c as c3,
  r as r3
} from "./chunk-H6HXZTAS.js";
import {
  e as e10
} from "./chunk-VHERB2HE.js";
import {
  t as t3
} from "./chunk-66QAJ2MI.js";
import {
  e as e8
} from "./chunk-WN3YAMRZ.js";
import {
  t as t4
} from "./chunk-WU7FVYT7.js";
import {
  t as t5
} from "./chunk-62WUYJJN.js";
import {
  E as E2
} from "./chunk-LM2N2I5R.js";
import {
  h as h3
} from "./chunk-PVO5NM6Q.js";
import {
  I as I4
} from "./chunk-YFQ32AQX.js";
import {
  h as h2
} from "./chunk-6MR4UDDL.js";
import {
  A as A3,
  D as D2,
  F,
  J as J2,
  O as O4,
  Q,
  de,
  fe,
  he,
  me,
  n as n6,
  ne,
  oe,
  q,
  ue,
  ye
} from "./chunk-VCFSVEDB.js";
import {
  A as A2
} from "./chunk-3WQXHRJE.js";
import {
  n as n5
} from "./chunk-L7ZKWTWL.js";
import {
  e as e6
} from "./chunk-O2DTA3XK.js";
import {
  n as n7
} from "./chunk-WDDCGJTI.js";
import {
  N,
  V as V2,
  Z
} from "./chunk-ZE47C44H.js";
import {
  d as d3
} from "./chunk-QCBC3RJX.js";
import {
  I as I3
} from "./chunk-7B5YPLFX.js";
import {
  l as l3
} from "./chunk-KKD7A2GN.js";
import {
  t as t2
} from "./chunk-NQVBBKAN.js";
import {
  n as n8,
  s as s4
} from "./chunk-JYODC3YQ.js";
import {
  e as e5,
  r as r2
} from "./chunk-BQZBOYBD.js";
import {
  e as e7
} from "./chunk-TYQXPPSP.js";
import {
  b as b2,
  m as m2
} from "./chunk-7KRERHHR.js";
import {
  d as d2
} from "./chunk-HD65DNIO.js";
import {
  k,
  w
} from "./chunk-634JLXD4.js";
import {
  C,
  D,
  O as O3,
  P as P2,
  S as S4,
  c,
  i
} from "./chunk-J55F4AC2.js";
import {
  S as S5
} from "./chunk-IQLBZKUD.js";
import {
  S as S6
} from "./chunk-5EBAJR7X.js";
import {
  r
} from "./chunk-IMVP5ADD.js";
import {
  s as s3
} from "./chunk-H7WPOTQH.js";
import {
  J
} from "./chunk-DUTZNK67.js";
import {
  I as I2,
  c as c2
} from "./chunk-XTVPEVHA.js";
import {
  I2 as I5
} from "./chunk-DTUSTSEJ.js";
import {
  i as i2
} from "./chunk-JILEJ6R2.js";
import {
  u as u4
} from "./chunk-K226GFDN.js";
import {
  W,
  n as n4
} from "./chunk-OGZAGPIO.js";
import {
  E,
  u as u3
} from "./chunk-IHVSZYZS.js";
import {
  x
} from "./chunk-3ZXOUEQG.js";
import {
  K,
  O as O2,
  S as S3,
  Y,
  e as e4,
  g,
  o as o2,
  u as u2
} from "./chunk-AXVPJBVW.js";
import {
  n as n3
} from "./chunk-OXEPWRM7.js";
import {
  P,
  d
} from "./chunk-6WHTZNUH.js";
import {
  V
} from "./chunk-EITGQLII.js";
import {
  o
} from "./chunk-WGAPNV7F.js";
import {
  e as e3
} from "./chunk-4Z5SGKRM.js";
import {
  A,
  S as S2,
  e3 as e2,
  v
} from "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import {
  a3 as a,
  n as n2
} from "./chunk-DDYVXG4F.js";
import {
  L,
  b,
  m,
  s as s2
} from "./chunk-HJY2YILU.js";
import {
  e
} from "./chunk-7DA6A5LD.js";
import {
  l,
  u
} from "./chunk-2MMLMOWS.js";
import {
  l as l2
} from "./chunk-4323ZVPF.js";
import {
  h,
  n2 as n,
  s2 as s
} from "./chunk-WYIDUUN2.js";
import {
  I,
  O,
  S,
  U,
  has,
  t4 as t
} from "./chunk-DXLOWWK7.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/I3SGeometryUtil.js
function u7(t12, e16, r5) {
  const n14 = t5(24);
  return (i8) => {
    let u9 = i8.meta.featureExtents;
    if (null == u9) {
      u9 = new Float64Array(6 * i8.meta.featureIds.length), i8.meta.featureExtents = u9;
      for (let t13 = 0; t13 < u9.length; t13 += 6) u9[t13] = Number.POSITIVE_INFINITY;
    }
    const l5 = new Float64Array(u9.buffer, 6 * i8.index * Float64Array.BYTES_PER_ELEMENT, 6);
    return l5[0] === Number.POSITIVE_INFINITY && (c4(i8.index, r5, i8.meta.objectHandle, n14, 0), n4(n14, e16, 0, n14, t12, 0, 8) ? (O3(l5, C), c(l5, n14, 0, 8)) : O3(l5, D)), l5;
  };
}
function c4(r5, o9, n14, a9, m4) {
  const s8 = o9.getComponentAabb(n14, r5, p), f3 = o9.getObjectTransform(n14);
  for (let i8 = 0; i8 < 8; ++i8) I6[0] = 1 & i8 ? s8[0] : s8[3], I6[1] = 2 & i8 ? s8[1] : s8[4], I6[2] = 4 & i8 ? s8[2] : s8[5], S3(I6, I6, f3.rotationScale), u2(I6, I6, f3.position), a9[m4++] = I6[0], a9[m4++] = I6[1], a9[m4++] = I6[2];
  return a9;
}
var l4 = 24;
var p = i();
var I6 = n3();

// ../../../node_modules/@arcgis/core/views/3d/layers/II3SMeshView3D.js
var n10;
var o6;
var E4;
!function(n14) {
  n14[n14.VISIBLE_ONLY = 0] = "VISIBLE_ONLY", n14[n14.ALL = 1] = "ALL", n14[n14.QUERYABLE = 2] = "QUERYABLE";
}(n10 || (n10 = {})), function(n14) {
  n14[n14.EXIT = 0] = "EXIT", n14[n14.CONTINUE = 1] = "CONTINUE", n14[n14.SKIP = 2] = "SKIP";
}(o6 || (o6 = {})), function(n14) {
  n14[n14.Absolute = 0] = "Absolute", n14[n14.RelativeToGround = 1] = "RelativeToGround", n14[n14.OnTheGround = 2] = "OnTheGround";
}(E4 || (E4 = {}));

// ../../../node_modules/@arcgis/core/geometry/support/UByteArray.js
function e14(e16, n14 = false) {
  return e16 <= U ? n14 ? new Array(e16).fill(0) : new Array(e16) : new Uint8Array(e16);
}

// ../../../node_modules/@arcgis/core/views/3d/support/GraphicsMap.js
var r4 = class extends o {
  constructor() {
    super(...arguments), this._map = /* @__PURE__ */ new Map();
  }
  clear() {
    if (this._map.size > 0) {
      const e16 = this.toArray();
      this._map.clear(), this.emit("change", {
        added: [],
        removed: e16
      });
    }
  }
  get length() {
    return this._map.size;
  }
  get(e16) {
    return this._map.get(e16);
  }
  addMany(e16) {
    if (0 === e16.length) return;
    const t12 = /* @__PURE__ */ new Set();
    for (let o9 = 0; o9 < e16.length; o9++) {
      const r6 = e16[o9], s8 = r6.objectId, n14 = this._map.get(s8);
      n14 ? (t12.add(s8), r6 !== n14 && (e16[o9] = n14), n14.refCount || (n14.refCount = 0), ++n14.refCount) : (r6.refCount = 1, this._map.set(s8, r6));
    }
    const r5 = t12.size > 0 ? e16.filter((e17) => !t12.has(e17.objectId)) : e16;
    r5.length > 0 && this.emit("change", {
      added: r5,
      removed: []
    });
  }
  removeMany(e16) {
    const t12 = [];
    for (const r5 of e16) {
      const e17 = r5.objectId, o9 = this._map.get(e17);
      null != o9 && (!o9.refCount || --o9.refCount <= 0) && (this._map.delete(e17), t12.push(r5));
    }
    t12.length > 0 && this.emit("change", {
      added: [],
      removed: t12
    });
  }
  removeManyByObjectId(e16) {
    const t12 = [];
    for (const r5 of e16) {
      const e17 = this._map.get(r5);
      null != e17 && (!e17.refCount || --e17.refCount <= 0) && (this._map.delete(r5), t12.push(e17));
    }
    t12.length > 0 && this.emit("change", {
      added: [],
      removed: t12
    });
  }
  toArray() {
    return [...this._map.values()];
  }
  find(e16) {
    let r5;
    return n2(this._map, (t12) => !!e16(t12) && (r5 = t12, true)), r5;
  }
  forEach(e16) {
    this._map.forEach((t12) => e16(t12));
  }
};

// ../../../node_modules/@arcgis/core/views/3d/support/LimitGraphicsMap.js
var i5 = class extends o {
  constructor(e16) {
    super(), this._limit = e16, this._all = new r4(), this._active = new a5(this), this._pending = /* @__PURE__ */ new Map(), this._handle = this._all.on("change", (e17) => this._handleChanges(e17));
  }
  destroy() {
    this._handle.remove();
  }
  get length() {
    return this._active.length;
  }
  toArray() {
    return this._active.toArray();
  }
  find(e16) {
    return this._active.find(e16);
  }
  forEach(e16) {
    this._active.forEach(e16);
  }
  addMany(e16) {
    this._all.addMany(e16);
  }
  removeManyByObjectId(e16) {
    this._all.removeManyByObjectId(e16);
  }
  _handleChanges(e16) {
    let t12 = e16.removed;
    if (this._pending.size > 0) {
      t12 = new Array();
      for (const s9 of e16.removed) this._pending.delete(s9.objectId) || t12.push(s9);
    }
    let s8 = this._limit - this._active.length + t12.length;
    s8 < e16.added.length && (this._active.removeMany(t12), t12 = [], h5.reset(1 - this._limit / (this._active.length + e16.added.length)), this._active.forEach((e17) => {
      h5.sample() && (t12.push(e17), this._pending.set(e17.objectId, e17));
    }), s8 = this._limit - this._active.length + t12.length);
    let i8 = e16.added;
    if (s8 < e16.added.length) {
      i8 = new Array(), h5.reset(s8 / e16.added.length);
      for (const t13 of e16.added) h5.sample() ? i8.push(t13) : this._pending.set(t13.objectId, t13);
    }
    const n14 = s8 - i8.length;
    n14 > 0 && this._pending.size > 0 && (h5.reset(n14 / this._pending.size), this._pending.forEach((e17) => {
      h5.sample() && (i8.push(e17), this._pending.delete(e17.objectId));
    })), this._active.addAndRemove(i8, t12);
  }
};
var n11 = class {
  constructor() {
    this._percentage = 1, this._last = -1, this._index = 0;
  }
  reset(e16) {
    this._percentage = e16, this._last = -1;
  }
  sample() {
    const e16 = Math.floor(this._index * this._percentage);
    return ++this._index, e16 !== this._last && (this._last = e16, true);
  }
};
var h5 = new n11();
var a5 = class {
  constructor(e16) {
    this._parent = e16, this._map = /* @__PURE__ */ new Map();
  }
  get length() {
    return this._map.size;
  }
  forEach(e16) {
    this._map.forEach((t12) => e16(t12));
  }
  find(e16) {
    let s8;
    return n2(this._map, (t12) => !!e16(t12) && (s8 = t12, true)), s8;
  }
  toArray() {
    return [...this._map.values()];
  }
  addAndRemove(e16, t12) {
    for (const s8 of e16) this._map.set(s8.objectId, s8);
    for (const s8 of t12) this._map.delete(s8.objectId);
    (e16.length > 0 || t12.length > 0) && this._parent.emit("change", {
      added: e16,
      removed: t12
    });
  }
  removeMany(e16) {
    for (const t12 of e16) this._map.delete(t12.objectId);
    e16.length > 0 && this._parent.emit("change", {
      added: [],
      removed: e16
    });
  }
};

// ../../../node_modules/@arcgis/core/views/3d/layers/I3SMeshViewLabeler.js
var G3 = class {
  constructor(e16, t12) {
    this.meta = e16, this.index = t12;
  }
};
var D4 = class {
  constructor(e16, t12) {
    this.graphic = e16, this.geometry = t12, this.components = [], this.overridesDirty = false;
  }
};
var w2 = class extends S2 {
  get updating() {
    return this._graphicsCore?.updating ?? false;
  }
  constructor(e16) {
    super(e16), this.loadedGraphics = new i5(5e4), this.slicePlaneEnabled = false, this._renderingInfo = {
      symbol: new w()
    }, this._featuresMap = /* @__PURE__ */ new Map();
  }
  initialize() {
    const e16 = this.view.basemapTerrain;
    this._graphicsCore = new ze({
      owner: this,
      layer: this.layer,
      preferredUpdatePolicy: C2.ASYNC,
      elevationFeatureExpressionEnabled: false,
      graphicSymbolSupported: false,
      getRenderingInfoWithoutRenderer: true,
      hasZ: true,
      hasM: false,
      componentFactories: {
        deconflictor: (e17) => this.view.deconflictor.addGraphicsOwner(e17),
        labeler: (e17, t12) => this.view.labeler.addGraphicsOwner(e17, t12, {
          emptySymbolLabelSupported: true,
          elevationInfoOverride: {
            mode: "absolute-height",
            offset: 0
          },
          disablePlacement: {
            logEntityDescription: "3D Object Scene Layer features"
          }
        }),
        scaleVisibility: (t12, r5) => new u6({
          graphicsCoreOwner: this,
          layer: this.layer,
          queryGraphicUIDsInExtent: r5,
          graphicsCore: t12,
          basemapTerrain: e16,
          layerScaleEnabled: false
        })
      }
    }), this._graphicsCore.initializePromise.then(() => this._graphicsCore.startCreateGraphics()).catch(() => {
    }), this.addHandles(d(() => this.layer.labelingInfo, (e17, t12) => {
      d3(e17, t12) && this._graphicsCore.updateLabelingInfo();
    }));
  }
  destroy() {
    this._graphicsCore = u(this._graphicsCore), this.loadedGraphics = u(this.loadedGraphics), this.view = null;
  }
  addNodeMeta(e16, t12) {
    let r5 = 0;
    const o9 = e16.filteredIds, s8 = this.view.spatialReference, i8 = [];
    for (let a9 = 0; a9 < e16.featureIds.length; a9++) {
      const p2 = e16.featureIds[a9];
      let c7 = null == o9;
      if (o9 && r5 < o9.length && p2 === o9[r5] && (c7 = true, r5++), !this._enabledForFeatureInNode(e16, a9)) continue;
      const h8 = this._featuresMap.get(p2);
      if (h8) {
        h8.components.push(new G3(e16, a9)), this._updateLabelPosition(p2);
        continue;
      }
      const l5 = t12(a9, e16), d5 = e6(0, 0, 0, s8), u9 = {
        objectId: p2,
        uid: e2(),
        attributes: l5,
        visible: c7,
        geometry: d5
      }, m4 = new D4(u9, d5);
      m4.components.push(new G3(e16, a9)), this._featuresMap.set(p2, m4), this._updateLabelGeometry(p2), i8.push(u9);
    }
    this.loadedGraphics.addMany(i8);
  }
  updateLabelPositions(e16) {
    const t12 = this.view.renderCoordsHelper;
    this._forEachGraphic(e16, (r5, o9, s8) => {
      const i8 = this._graphicsCore.getGraphics3DGraphicById(o9.uid);
      null != i8 && this._updateLabelGeometry(e16.featureIds[r5]) && i8.alignWithAbsoluteElevation(s8.z ?? 0, t12, false);
    });
  }
  setNodeMetaAttributes(e16, t12) {
    const r5 = new Array();
    this._forEachGraphic(e16, (s8, i8) => {
      const a9 = t12(s8, e16);
      h(i8.attributes, a9) || (i8.attributes = a9, r5.push(i8.uid));
    }), this._graphicsCore.updateLabelingInfo(r5);
  }
  applyFilterChange(e16) {
    this._forEachFeature(e16, (t12, r5, o9) => {
      if (!this._enabledForFeatureInNode(e16, t12)) {
        const o10 = e16.featureIds[t12];
        switch (this._removeFeature(r5, e16, t12)) {
          case F2.REMOVED:
            this.loadedGraphics.removeManyByObjectId([o10]);
            break;
          case F2.MODIFIED:
            this._updateLabelPosition(o10);
        }
        return;
      }
      const s8 = r5.graphic, i8 = s8.visible;
      i8 !== o9 && (s8.visible = o9, C4.graphic = s8, C4.property = "visible", C4.oldValue = i8, C4.newValue = o9, this._graphicsCore.graphicUpdateHandler(C4));
    });
  }
  removeNodeMeta(e16) {
    const t12 = [];
    this._forEachGraphic(e16, (r5) => {
      const o9 = e16.featureIds[r5], s8 = this._featuresMap.get(o9);
      if (!s8) return;
      switch (this._removeFeature(s8, e16, r5)) {
        case F2.MODIFIED:
          this._updateLabelPosition(o9);
          break;
        case F2.REMOVED:
          t12.push(o9);
      }
    }), this.loadedGraphics.removeManyByObjectId(t12);
  }
  _removeFeature(e16, t12, o9) {
    const s8 = e16.components.length;
    return I(e16.components, (e17) => !(e17.meta === t12 && e17.index === o9)), 0 === e16.components.length ? (this._featuresMap.delete(t12.featureIds[o9]), F2.REMOVED) : s8 !== e16.components.length ? F2.MODIFIED : F2.UNMODIFIED;
  }
  getRenderingInfo() {
    return this._renderingInfo;
  }
  notifyGraphicGeometryChanged() {
  }
  notifyGraphicVisibilityChanged() {
  }
  _updateLabelPosition(e16) {
    const t12 = this._featuresMap.get(e16);
    t12 && this._updateLabelGeometry(e16) && (this.loadedGraphics.removeManyByObjectId([e16]), this.loadedGraphics.addMany([t12.graphic]));
  }
  _updateLabelGeometry(e16) {
    const t12 = this._featuresMap.get(e16);
    if (!t12) return false;
    const r5 = t12.geometry, o9 = this.view.spatialReference, i8 = this.view.renderCoordsHelper, a9 = r5.x, n14 = r5.y, p2 = r5.z ?? 0, c7 = t12.components.length, h8 = t5(c7 * l4);
    let d5 = 0;
    for (const {
      meta: s8,
      index: l5
    } of t12.components) c4(l5, this.collection, s8.objectHandle, h8, d5), d5 += l4;
    return n4(h8, i8.spatialReference, 0, h8, o9, 0, h8.length / 3), O3(O5, C), c(O5, h8), r5.x = (O5[0] + O5[3]) / 2, r5.y = (O5[1] + O5[4]) / 2, r5.z = O5[5], !x(r5.x, a9) || !x(r5.y, n14) || !x(r5.z, p2);
  }
  _forEachGraphic(e16, t12) {
    this._forEachFeature(e16, (r5, {
      graphic: o9,
      geometry: s8
    }, i8) => {
      this._enabledForFeatureInNode(e16, r5) && t12(r5, o9, s8, i8);
    });
  }
  _forEachFeature(e16, t12) {
    let r5 = 0;
    for (let o9 = 0; o9 < e16.featureIds.length; o9++) {
      const s8 = this._featuresMap.get(e16.featureIds[o9]);
      let i8 = null == e16.filteredIds;
      e16.filteredIds && e16.filteredIds[r5] === e16.featureIds[o9] && (i8 = true, r5++), s8 && t12(o9, s8, i8);
    }
  }
  _enabledForFeatureInNode(e16, t12) {
    return e16.node.index < 0 || !this.overrides?.featureHasGeometryChanges(e16.featureIds[t12]);
  }
  get updatePolicy() {
    return this._graphicsCore.effectiveUpdatePolicy;
  }
  get usedMemory() {
    return this._graphicsCore.usedMemory;
  }
  get unloadedMemoryEstimate() {
    return this._graphicsCore.unprocessedMemoryEstimate;
  }
  get test() {
  }
};
e3([y()], w2.prototype, "view", void 0), e3([y()], w2.prototype, "layer", void 0), e3([y()], w2.prototype, "collection", void 0), e3([y()], w2.prototype, "loadedGraphics", void 0), e3([y()], w2.prototype, "overrides", void 0), e3([y()], w2.prototype, "updating", null), e3([y()], w2.prototype, "slicePlaneEnabled", void 0), e3([y()], w2.prototype, "_graphicsCore", void 0), w2 = e3([a("esri.views.3d.layers.I3SMeshViewLabeler")], w2);
var C4 = {
  graphic: null,
  property: null,
  oldValue: null,
  newValue: null
};
var F2;
!function(e16) {
  e16[e16.UNMODIFIED = 0] = "UNMODIFIED", e16[e16.MODIFIED = 1] = "MODIFIED", e16[e16.REMOVED = 2] = "REMOVED";
}(F2 || (F2 = {}));
var O5 = i();
var L4 = w2;

// ../../../node_modules/@arcgis/core/views/3d/layers/I3SMeshViewPerformanceInfo.js
var e15 = class extends t7 {
  constructor(t12, e16, r5, s8, o9, i8, p2) {
    super(t12, 0, 0, 0, e16), this.gpuMB = r5, this.geometryMB = s8, this.textureMB = o9, this.unloadedMB = i8, this.idbHitRate = p2;
  }
};

// ../../../node_modules/@arcgis/core/views/3d/layers/I3SMeshWorkerHandle.js
var h6 = class extends h4 {
  constructor(s8) {
    super("SceneLayerWorker", "process", {
      process: (s9) => [s9.geometryBuffer],
      project: (s9) => [s9.positions.buffer],
      transformNormals: (s9) => [s9.normals.buffer]
    }, s8, {
      hasInitialize: true
    });
  }
  setModifications(s8, e16, o9, t12) {
    const r5 = {
      context: s8,
      modifications: a6(e16, o9, t12),
      isGeodetic: t12.isGeographic
    };
    this.broadcast(r5, "setModifications");
  }
  setLegacySchema(s8, e16) {
    const o9 = JSON.stringify(e16);
    return this.broadcast({
      context: s8,
      jsonSchema: o9
    }, "setLegacySchema");
  }
  destroyContext(s8) {
    return this.broadcast(s8, "destroyContext");
  }
  project(s8, e16) {
    return this.invokeMethod("project", s8, e16);
  }
  transformNormals(s8, e16) {
    return this.invokeMethod("transformNormals", s8, e16);
  }
};
var n12 = new l2({
  deallocator: null
});
var u8 = n3();
function a6(e16, o9, t12) {
  n12.clear();
  let h8 = 1 / 0, a9 = 1 / 0, c7 = -1 / 0, f3 = -1 / 0, l5 = false;
  for (const d5 of o9) {
    const e17 = "clip" === d5.type ? e9.Inside : "mask" === d5.type ? e9.Outside : e9.Replace, o10 = d5.geometry;
    let m5 = (s8) => s8;
    if (o10.spatialReference) {
      if (!J(o10.spatialReference, t12)) {
        n.getLogger("esri.views.3d.layers.I3SMeshWorkerHandle").warn("Can't project modification polygon into layer spatial reference, ignoring modification");
        continue;
      }
      m5 = (s8) => (n5(s8, o10.spatialReference, u8, t12), u8);
    } else o10.hasZ || (u8[2] = 0, m5 = (s8) => (u8[0] = s8[0], u8[1] = s8[1], u8));
    l5 = l5 || e17 === e9.Outside, n12.push(e17), n12.push(o10.rings.length);
    for (const s8 of o10.rings) {
      n12.push(s8.length);
      for (const e18 of s8) {
        const s9 = m5(e18);
        n12.push(s9[0]), n12.push(s9[1]), n12.push(s9[2]), h8 = Math.min(h8, s9[0]), a9 = Math.min(a9, s9[1]), c7 = Math.max(c7, s9[0]), f3 = Math.max(f3, s9[1]);
      }
    }
  }
  if (null != e16) if (l5) {
    const s8 = 1e-4;
    n12.push(e9.Inside), n12.push(2), n12.push(4), n12.push(h8 - s8), n12.push(a9 - s8), n12.push(0), n12.push(c7 + s8), n12.push(a9 - s8), n12.push(0), n12.push(c7 + s8), n12.push(f3 + s8), n12.push(0), n12.push(h8 - s8), n12.push(f3 + s8), n12.push(0), n12.push(4), n12.push(e16[0]), n12.push(e16[1]), n12.push(0), n12.push(e16[2]), n12.push(e16[1]), n12.push(0), n12.push(e16[2]), n12.push(e16[3]), n12.push(0), n12.push(e16[0]), n12.push(e16[3]), n12.push(0);
  } else n12.push(e9.Outside), n12.push(1), n12.push(4), n12.push(e16[0]), n12.push(e16[1]), n12.push(0), n12.push(e16[2]), n12.push(e16[1]), n12.push(0), n12.push(e16[2]), n12.push(e16[3]), n12.push(0), n12.push(e16[0]), n12.push(e16[3]), n12.push(0);
  n12.push(e9.Finished);
  const m4 = new Float64Array(n12.length);
  for (let s8 = 0; s8 < n12.length; ++s8) m4[s8] = n12.at(s8);
  return m4;
}

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/Highlights.js
var s6 = class {
  constructor() {
    this.ids = /* @__PURE__ */ new Set();
  }
};
var h7 = class {
  constructor({
    collection: t12,
    forAllFeatures: e16,
    forAllFeaturesOfNode: i8
  }) {
    this._highlights = [], this._collection = t12, this._forAllFeatures = e16, this._forAllFeaturesOfNode = i8;
  }
  destroy() {
    this._highlights.forEach((t12) => this._releaseSet(t12)), this._highlights = null;
  }
  acquireSet() {
    const i8 = new s6();
    this._highlights.push(i8);
    const h8 = e(() => {
      this._highlights && (this._releaseSet(i8), S(this._highlights, i8));
    });
    return {
      set: i8,
      handle: h8
    };
  }
  setFeatureIds(t12, e16) {
    e16.forEach((e17) => t12.ids.add(e17)), this._initializeSet(t12);
  }
  _initializeSet(t12) {
    this._forAllFeatures((e16, s8, h8) => (t12.ids.has(e16) && this._collection.addComponentHighlight(h8.objectHandle, s8), o6.CONTINUE));
  }
  _releaseSet(t12) {
    this._forAllFeatures((e16, s8, h8) => (t12.ids.has(e16) && this._collection.removeComponentHighlight(h8.objectHandle, s8), o6.CONTINUE));
  }
  objectCreated(t12) {
    this._highlights.forEach((e16) => {
      this._forAllFeaturesOfNode(t12, (s8, h8) => (e16.ids.has(s8) && this._collection.addComponentHighlight(t12.objectHandle, h8), o6.CONTINUE));
    });
  }
  objectDeleted(t12) {
    this._collection.clearHighlights(t12.objectHandle);
  }
};

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/I3SAsyncElevationUpdater.js
var a7 = class extends S2 {
  constructor(t12, e16, s8, r5) {
    super({}), this._updateExtent = e16, this._updateNode = s8, this._getElevationMode = r5, this.running = false, this._extentSet = new a4(), this._nodeSet = /* @__PURE__ */ new Set();
    const i8 = this._taskPriority, n14 = t12.registerTask(this._taskPriority, this);
    this.addHandles(n14), this._task = n14, this._lastTaskPriority = i8;
  }
  get _taskPriority() {
    const t12 = this._getElevationMode();
    return t12 && t12 === E4.RelativeToGround ? I4.ELEVATION_ALIGNMENT_SCENE : I4.ELEVATION_ALIGNMENT;
  }
  _updateTaskPriority() {
    const t12 = this._taskPriority;
    t12 !== this._lastTaskPriority && (this._task.priority = t12, this._lastTaskPriority = t12);
  }
  normalizeCtorArgs() {
    return {};
  }
  addExtent(t12) {
    this._extentSet.add(t12), this._updateTaskPriority(), this.running = true;
  }
  schedule(t12) {
    this._nodeSet.add(t12), this._updateTaskPriority(), this.running = true;
  }
  remove(t12) {
    this._nodeSet.delete(t12), this._updateRunning();
  }
  runTask(t12) {
    const e16 = this._extentSet;
    for (t12.run(() => e16.merge(t12)); !e16.empty && !t12.done; ) {
      const s9 = this._updateExtent(e16.pop());
      null != s9 && s9.forAll((t13) => this.schedule(t13)), t12.madeProgress();
    }
    if (t12.done) return;
    const s8 = this._nodeSet;
    for (const r5 of s8) if (s8.delete(r5), this._updateNode(r5), t12.madeProgress(), t12.done) break;
    this._updateRunning();
  }
  _updateRunning() {
    this.running = this._nodeSet.size > 0 || this._extentSet.size > 0;
  }
};
e3([y()], a7.prototype, "running", void 0), a7 = e3([a("esri.views.3d.layers.i3s.I3SAsyncElevationUpdater")], a7);

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/I3SCrossfadeHelper.js
var o7 = class {
  constructor() {
    this.lodCrossfadeSignedDuration = 0;
  }
};
var i6 = class {
  constructor(e16) {
    this._view = e16, this._preRenderFrameTaskHandle = null, this._currentFrameStartTime = null, this._numFadingNodes = 0;
  }
  destroy() {
    this._preRenderFrameTaskHandle?.remove(), this._preRenderFrameTaskHandle = null, this._view = null;
  }
  get updating() {
    return this._numFadingNodes > 0;
  }
  stopNodeFading(s8) {
    null != s8.lodCrossfadeProgress && (this._numFadingNodes--, s8.lodCrossfadeProgress = null, 0 === this._numFadingNodes && (null != this._preRenderFrameTaskHandle && (this._preRenderFrameTaskHandle = l(this._preRenderFrameTaskHandle)), this._view.notifyLODUpdate(), this._view.notifyUpdate()));
  }
  _startNodeFading(e16, d5, o9) {
    0 === this._numFadingNodes && (this._preRenderFrameTaskHandle = A({
      preRender: (e17) => this._updateAllNodeFading(e17)
    }), this._view.notifyLODUpdate()), null == e16.lodCrossfadeProgress && (this._numFadingNodes++, this._view.notifyUpdate()), e16.lodCrossfadeSignedDuration = o9, e16.lodCrossfadeProgress = d5;
  }
  _updateAllNodeFading(e16) {
    const s8 = this._view.nodeCrossfadingEnabled;
    this._view.foreachCrossfadeNode((d5, o9) => {
      if (null != d5?.lodCrossfadeProgress) {
        const i8 = d5.lodCrossfadeSignedDuration, t12 = i8 > 0 ? this._view.fullOpacity : 0, r5 = e16.deltaTime / i8, a9 = d5.lodCrossfadeProgress + Math.abs(r5), n14 = !s8 || a9 >= 1 || 0 === i8, l5 = t12 - (n14 ? 0 : i8 > 0 ? 1 : -1) * (1 - a9);
        n14 ? (this.stopNodeFading(d5), i8 < 0 && this._view.markNodeToRemove(o9)) : d5.lodCrossfadeProgress = a9, this._view.setNodeOpacityByIndex(o9, l5);
      }
    }), this._view.removeMarkedNodes();
  }
  stopAllNodeFading() {
    this._view.foreachCrossfadeNode((e16, s8) => {
      if (null != e16?.lodCrossfadeProgress) {
        this.stopNodeFading(e16);
        const d5 = e16.lodCrossfadeSignedDuration;
        d5 < 0 && this._view.markNodeToRemove(s8);
        const o9 = d5 > 0 ? this._view.fullOpacity : 0;
        this._view.setNodeOpacityByIndex(s8, o9);
      }
    }), this._view.removeMarkedNodes();
  }
  fadeNode(e16, s8, o9, i8) {
    null == this._currentFrameStartTime && (this._currentFrameStartTime = Date.now());
    const r5 = this._view, a9 = r5.nodeCrossfadingEnabled, n14 = o9 === a3.FadeIn ? r5.fullOpacity : 0, l5 = a9 ? i8 ? o9 === a3.FadeIn ? r5.lodCrossfadeinDuration : r5.lodCrossfadeoutDuration : r5.lodCrossfadeUncoveredDuration : 0, h8 = this._view.getNodeOpacityByIndex(e16);
    if (a9 && h8 !== n14 && l5 > 0) {
      const e17 = 1 - Math.abs(n14 - h8);
      this._startNodeFading(s8, e17, t10(o9) * l5);
    } else this.stopNodeFading(s8), this._view.setNodeOpacityByIndex(e16, n14), o9 === a3.FadeOut && this._view.removeNode(e16);
  }
  isNodeFullyFadedIn(e16) {
    const s8 = this._view.getNodeCrossfadeMetaData(e16);
    return null == s8 || null == s8.lodCrossfadeProgress && this._view.getNodeOpacityByIndex(e16) === this._view.fullOpacity;
  }
};
function t10(e16) {
  return e16 === a3.FadeIn ? 1 : -1;
}

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/I3SIntersectionHandler.js
var c5 = class {
  constructor(e16) {
    this.type = i3.I3S, this._needVerticalOffset = false, this.layerUid = e16.layerUid, this.sublayerUid = e16.sublayerUid, this._collection = e16.collection, this._traverseNodeHierarchy = e16.traverseNodeHierarchy, this.slicePlaneEnabled = e16.slicePlaneEnabled, this.isGround = e16.isGround;
  }
  updateElevationAlignState(t12, i8) {
    this._needVerticalOffset = t12 && i8 === l3.Global;
  }
  intersect(e16, s8, c7, d5, u9, b4) {
    const f3 = b4 ?? false, m4 = e16.results, h8 = e16.options.store === e12.ALL, y2 = e16.ray.direction, p2 = e16.tolerance;
    let R2 = (e17) => e17, g3 = (e17) => e17;
    const I7 = L3(e16.verticalOffset ?? (this._needVerticalOffset ? 0 : null));
    null != e16.verticalOffset && null != I7 && (R2 = (e17) => I7.applyToMbs(e17), g3 = (e17) => I7.applyToObb(e17));
    const v2 = new m3(f3, e16.options.normalRequired), O6 = (n14, l5) => {
      if (0 === n14.childrenLoaded) return false;
      const o9 = n14.serviceObbInRenderSR?.isValid ? n14.serviceObbInRenderSR : null;
      return !(o9 && !g3(o9).intersectRay(c7, y2, p2)) && (!l5 || !o9 && ye(n14.serviceMbsInRenderSR) && !a8(R2(n14.serviceMbsInRenderSR), c7, y2, p2) || null != n14.geometryObbInRenderSR && !g3(n14.geometryObbInRenderSR).intersectRay(c7, y2, p2) || this._collection.intersect(l5, c7, d5, p2, I7, v2, (t12, l6, o10, a9) => {
        if (l6 < 0 || null != s8 && !s8(c7, d5, l6)) return;
        const u10 = (e17) => {
          const r5 = new o4(this.layerUid, this.sublayerUid, n14.index, t12, a9);
          e17.set(this.type, r5, l6, o10);
        };
        if (this.isGround && (null == m4.ground.dist || l6 < m4.ground.dist) && u10(m4.ground), !e16.options.isFiltered && ((null == m4.min.dist || l6 < m4.min.dist) && u10(m4.min), (null == m4.max.dist || l6 > m4.max.dist) && u10(m4.max), h8)) {
          const t13 = G(e16.ray);
          u10(t13), e16.results.all.push(t13);
        }
      }), true);
    };
    this._traverseNodeHierarchy(O6);
  }
};
function a8(e16, t12, i8, r5 = 0) {
  const s8 = e16[3] + r5, n14 = t12[0] - e16[0], l5 = t12[1] - e16[1], o9 = t12[2] - e16[2], c7 = i8[0], a9 = i8[1], d5 = i8[2], u9 = c7 * n14 + a9 * l5 + d5 * o9;
  return u9 * u9 - (c7 * c7 + a9 * a9 + d5 * d5) * (n14 * n14 + l5 * l5 + o9 * o9 - s8 * s8) >= 0;
}

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/IDBCache.js
var o8 = 14;
var i7 = class {
  constructor(t12, s8, r5 = o8) {
    this._version = r5, this._db = null, this._quotaReductionPromise = null, this._gcCounter = 0, this._hit = 0, this._miss = 0, this._destroyed = false, this.gcFrequency = 50, this.maxByteSize = E2.GIGABYTES, this.quotaReductionFactor = 0.2, this._dbName = t12, this._storeName = s8;
  }
  init() {
    return Promise.resolve().then(() => {
      const e16 = indexedDB.open(this._dbName, this._version);
      return e16.onupgradeneeded = (t12) => {
        const s8 = e16.result, r5 = e16.transaction, o9 = s8.objectStoreNames.contains(this._storeName) ? r5.objectStore(this._storeName) : s8.createObjectStore(this._storeName), i8 = s8.objectStoreNames.contains("last_access") ? r5.objectStore("last_access") : s8.createObjectStore("last_access");
        i8.indexNames.contains("date") || i8.createIndex("date", "date", {
          unique: false
        }), i8.indexNames.contains("byteSize") || i8.createIndex("byteSize", "byteSize", {
          unique: false
        }), t12.oldVersion < this._version && (o9.clear(), i8.clear());
      }, c6(e16);
    }).then((e16) => {
      this._destroyed ? e16.close() : this._db = e16;
    });
  }
  destroy() {
    this._db && (this._db.close(), this._db = null), this._destroyed = true;
  }
  get initialized() {
    return null != this._db;
  }
  getHitRate() {
    return this._hit / (this._hit + this._miss);
  }
  put(e16, s8) {
    if (null == this._db) return Promise.reject(new s("indexedb:not-initialized", "IndexedDB Cache is not initialized"));
    return (null != this._quotaReductionPromise ? this._quotaReductionPromise : Promise.resolve()).then(() => this._put(e16, s8)).catch((t12) => {
      if (t12 && "QuotaExceededError" === t12.name) return null == this._quotaReductionPromise && (this._quotaReductionPromise = this._getCacheSize().then((e17) => this._removeLeastRecentlyAccessed(s8.byteSize + Math.ceil(e17 * this.quotaReductionFactor))), this._quotaReductionPromise.then(() => this._quotaReductionPromise = null, () => this._quotaReductionPromise = null)), this._quotaReductionPromise.then(() => this._put(e16, s8));
      throw t12;
    }).then(() => {
      this._gcCounter--, this._gcCounter < 0 && null != this._db && (this._gcCounter = this.gcFrequency, this._getCacheSize().then((e17) => this._removeLeastRecentlyAccessed(e17 - this.maxByteSize)));
    });
  }
  get(e16, t12) {
    const o9 = this._db;
    if (null == o9) return Promise.resolve(void 0);
    let i8 = null;
    return Promise.resolve().then(() => {
      const r5 = o9.transaction(this._storeName, "readonly");
      i8 = m(t12, () => {
        r5.abort();
      });
      return c6(r5.objectStore(this._storeName).get(e16));
    }).then((t13) => {
      if (null == t13) ++this._miss;
      else if (this._db) {
        ++this._hit;
        this._db.transaction("last_access", "readwrite").objectStore("last_access").put({
          date: Date.now(),
          byteSize: t13.byteSize
        }, e16);
      }
      return null != i8 && i8.remove(), t13;
    }).catch(() => {
      ++this._miss, s2(t12), null != i8 && i8.remove();
    });
  }
  remove(e16) {
    const t12 = this._db;
    return null == t12 ? Promise.resolve() : Promise.resolve().then(() => __async(this, null, function* () {
      const s8 = t12.transaction([this._storeName, "last_access"], "readwrite"), r5 = s8.objectStore(this._storeName), o9 = s8.objectStore("last_access"), i8 = r5.delete(e16), a9 = o9.delete(e16);
      yield Promise.all([c6(i8), c6(a9), n13(s8)]);
    }));
  }
  _put(e16, t12) {
    const s8 = this._db;
    if (null == s8) return Promise.resolve();
    const r5 = s8.transaction([this._storeName, "last_access"], "readwrite"), o9 = r5.objectStore(this._storeName), i8 = r5.objectStore("last_access"), a9 = o9.put(t12, e16), l5 = i8.put({
      date: Date.now(),
      byteSize: t12.byteSize
    }, e16);
    return Promise.all([c6(a9), c6(l5), n13(r5)]);
  }
  _removeLeastRecentlyAccessed(e16) {
    if (e16 <= 0 || !this._db) return Promise.resolve();
    const t12 = this._db.transaction([this._storeName, "last_access"], "readwrite"), s8 = t12.objectStore(this._storeName), r5 = t12.objectStore("last_access");
    let o9 = 0;
    const i8 = r5.index("date").openCursor(null, "next");
    return i8.onsuccess = () => {
      const t13 = i8.result;
      null != t13 && (null != t13.value.byteSize && (o9 += t13.value.byteSize), s8.delete(t13.primaryKey), r5.delete(t13.primaryKey), o9 < e16 && t13.continue());
    }, n13(t12);
  }
  _getCacheSize() {
    const e16 = this._db;
    if (null == e16) return Promise.resolve(0);
    const t12 = e16.transaction("last_access"), s8 = t12.objectStore("last_access");
    let r5 = 0;
    const o9 = s8.index("byteSize").openKeyCursor();
    return o9.onsuccess = () => {
      const e17 = o9.result;
      if (!e17) return;
      const t13 = e17.key;
      null != t13 && (r5 += t13), e17.continue();
    }, n13(t12).then(() => r5);
  }
};
function n13(e16) {
  return new Promise((t12, s8) => {
    e16.oncomplete = () => t12(), e16.onerror = () => s8(e16.error), e16.onabort = () => s8(e16.error);
  });
}
function c6(e16) {
  return new Promise((t12, s8) => {
    "done" === e16.readyState ? null != e16.error ? s8(e16.error) : t12(e16.result) : (e16.onsuccess = () => t12(e16.result), e16.onerror = () => s8(e16.error));
  });
}

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/IDBMockCache.js
var t11 = /* @__PURE__ */ new WeakMap();
var s7 = class {
  constructor(s8, e16) {
    switch (this._miss = 0, this._hit = 0, this.initialized = true, e16) {
      case "layer":
        this._data = /* @__PURE__ */ new Map();
        break;
      case "view": {
        const e17 = t11.get(s8);
        if (e17) {
          this._data = e17;
          break;
        }
        const i8 = /* @__PURE__ */ new Map();
        this._data = i8, t11.set(s8, i8);
      }
    }
  }
  init() {
    return Promise.resolve();
  }
  get(t12, s8) {
    return __async(this, null, function* () {
      if (this._data.has(t12)) return this._hit++, this._data.get(t12) ?? void 0;
      this._miss++;
    });
  }
  destroy() {
  }
  put(t12, s8) {
    return this._data.set(t12, s8), Promise.resolve();
  }
  remove(t12) {
    return this._data.delete(t12), Promise.resolve();
  }
  getHitRate() {
    return this._hit / (this._hit + this._miss);
  }
};

// ../../../node_modules/@arcgis/core/views/3d/layers/I3SMeshView3D.js
var xt = "esri.views.3d.layers.I3SMeshView3D";
var Et = () => n.getLogger(xt);
var Ot = [1, 1, 1, 1];
var jt = class extends o7 {
  constructor(e16, t12, i8, s8, r5, o9, n14, a9, l5) {
    super(), this.node = e16, this.featureIds = t12, this.objectHandle = i8, this.cachedRendererVersion = s8, this.attributeInfo = r5, this.material = o9, this.textures = n14, this.anchorIds = a9, this.anchors = l5, this.cachedElevationAnchors = null, this.cachedEdgeMaterials = new Array(), this.edgeMemoryUsage = 0;
  }
};
var wt;
!function(e16) {
  e16[e16.CastShadows = 4] = "CastShadows", e16[e16.Pickable = 5] = "Pickable";
}(wt || (wt = {}));
var Rt = 24;
var St = 100 * E2.MEGABYTES;
var At = (t12) => {
  let o9 = class extends t12 {
    constructor() {
      super(...arguments), this._needsNormals = true, this._updatingHandles = new h3(), this._nodeId2Meta = /* @__PURE__ */ new Map(), this._nodeId2MetaReloading = /* @__PURE__ */ new Map(), this._i3sWasmLoaded = false, this._snappingSourcesTrackers = [], this._hasLoadedPBRTextures = false, this._asyncModuleLoading = 0, this._addTasks = /* @__PURE__ */ new Map(), this._currentRenderer = null, this._rendererVersion = 0, this._colorVariable = null, this._opacityVariable = null, this._rendererFields = null, this._symbologyFields = null, this._symbologyOverride = null, this._symbologyOverrideFields = null, this._symbolInfos = /* @__PURE__ */ new Map(), this._visibleGeometryChangedSchedulerHandle = null, this._hasComponentData = false, this._hasVertexColors = false, this._nodeColorOverride = null, this.updating = true, this.holeFilling = "auto", this._hasColors = false, this._hasTextures = false, this._hasData = false, this.slicePlaneEnabled = false, this._modifications = new Array(), this.ignoresMemoryFactor = false, this._layerUrl = "", this._cacheKeySuffix = null, this._planetRadiusInGlobalMode = 0, this._elevationTask = null, this._filters = [], this._arcade = null, this._tmpAttributeOnlyGraphic = new d2(), this._crossfadeHelper = new i6(this);
    }
    get lodCrossfadeoutDuration() {
      return 0;
    }
    get lodCrossfadeinDuration() {
      return 0;
    }
    get lodCrossfadeUncoveredDuration() {
      return 0;
    }
    get layerUid() {
      return this.i3slayer && this.i3slayer.uid;
    }
    get sublayerUid() {
      return null;
    }
    get layerId() {
      return this.i3slayer && this.i3slayer.id;
    }
    get sublayerId() {
      return null;
    }
    get contentVisible() {
      return !this.suspended && this._controller?.rootNodeVisible;
    }
    get legendEnabled() {
      return this.contentVisible && true === this.i3slayer?.legendEnabled;
    }
    get updatingProgressValue() {
      return this._controller?.updatingProgress ?? 0;
    }
    get hasTexturesOrVertexColors() {
      return this._hasData ? this._hasTextures || this._hasColors ? "yes" : "probably-not" : "unknown";
    }
    get rendererTextureUsage() {
      return ue(this._currentRenderer) ? this._usePBR || this._hasLoadedPBRTextures ? s5.AllTexturesPBR : s5.AllTextures : this._usePBR || this._hasLoadedPBRTextures ? s5.GeometryTexturesPBR : s5.GeometryTextures;
    }
    get elevationOffset() {
      const e16 = null != this.i3slayer ? this.i3slayer.elevationInfo : null;
      return null != e16 && "absolute-height" === e16.mode ? h2(e16, this.i3slayer.spatialReference) : 0;
    }
    get elevationInfo() {
      const e16 = null != this.i3slayer ? this.i3slayer.elevationInfo : null;
      if (null == e16) return new $t(E4.Absolute, 0);
      const t13 = h2(e16, this.i3slayer.spatialReference);
      switch (e16.mode) {
        case "absolute-height":
          return new $t(E4.Absolute, t13);
        case "relative-to-ground":
          return new $t(E4.RelativeToGround, t13);
        case "on-the-ground":
          return new $t(E4.OnTheGround, 0);
        default:
          return new $t(E4.Absolute, 0);
      }
    }
    get supportedTextureEncodings() {
      return R(this.view._stage.renderView.capabilities);
    }
    get uncompressedTextureDownsamplingEnabled() {
      const e16 = this.view?.qualitySettings.sceneService.uncompressedTextureDownsamplingEnabled, t13 = !(this.supportedTextureEncodings & e13.DDS_S3TC);
      return e16 && t13;
    }
    get clientGeometry() {
      return this.i3sOverrides.geometryOverrides;
    }
    get elevationRange() {
      const e16 = this._nodeId2Meta, t13 = new e10();
      for (const i8 of e16.values()) {
        if (null == i8) continue;
        const {
          node: {
            serviceMbsInIndexSR: e17
          }
        } = i8, [s8, r5, o10, n14] = e17;
        t13.expandElevationRangeValues(o10 - n14, o10 + n14);
      }
      return t13.elevationRangeValid ? t13 : null;
    }
    get fullExtent() {
      return this.i3slayer.fullExtent;
    }
    initialize() {
      const e16 = has("enable-feature:idb-mock-cache");
      this._idbCache = e16 ? new s7(this.view, e16) : new i7("esri-scenelayer-cache", "geometries"), this._preLoadBasis(), this.addResolvingPromise(this.i3slayer.indexInfo);
      const t13 = this.view.resourceController, i8 = t13.memoryController;
      this.i3sOverrides = new G2({
        view: this.view,
        layer: this.i3slayer,
        memoryController: i8
      }), this._worker = new h6(e11(t13)), this.addResolvingPromise(this._worker.promise);
      const s8 = this.i3slayer.store;
      this._worker.setLegacySchema(this.uid, s8.defaultGeometrySchema), oe(this.i3slayer), ne(this.i3slayer, this.view), this._layerUrl = this.i3slayer.parsedUrl.path, this._controller = new K2({
        layerView: this,
        worker: this._worker
      }), this._gpuMemoryEstimate = 0, this._texMemoryEstimate = 0, this._geoMemoryEstimate = 0, this._stage = this.view._stage, this._collection = this._stage.renderView.componentObjectCollection, this.resetHighlights();
      const r5 = s8.defaultGeometrySchema;
      if (this._isIntegratedMesh || !r5) this._hasComponentData = false;
      else {
        const e17 = r5.featureAttributes;
        this._hasComponentData = !!(e17 && e17.faceRange && e17.id);
      }
      this._hasVertexColors = null != (r5?.vertexAttributes.color ?? null) && !this.i3slayer.cachedDrawingInfo?.color;
      const o10 = this.view.resourceController.memoryController.newCache(`sl-${this.uid}`, (e17) => this._deleteComponentObject(e17));
      this._memCache = o10;
      const n14 = this._controller, a9 = this._nodeId2Meta, l5 = this._nodeId2MetaReloading, d5 = (e17) => {
        const t14 = n14.index;
        if (!t14) return;
        const i9 = t14.rootNode;
        if (!i9) return;
        const s9 = (t15) => {
          const i10 = t15.index, s10 = a9.get(i10) || l5.get(i10);
          return e17(t15, s10?.objectHandle ?? null);
        };
        t14.traverse(i9, s9);
      };
      this._intersectionHandler = new c5({
        layerUid: this.layerUid,
        sublayerUid: this.sublayerUid,
        collection: this._collection,
        slicePlaneEnabled: this.slicePlaneEnabled,
        isGround: this._isIntegratedMesh,
        traverseNodeHierarchy: d5
      }), this._updatingHandles.add(() => this.layerUid, (e17) => this._intersectionHandler.layerUid = e17), this._updatingHandles.add(() => this.sublayerUid, (e17) => this._intersectionHandler.sublayerUid = e17), this._elevationProvider = new x2({
        view: this.view,
        layerElevationSource: this,
        intersectionHandler: this._intersectionHandler
      }), this._hasLoadedPBRTextures = this._usePBR, this._updatingHandles.add(() => this.view.clippingArea, () => this._clippingAreaChanged(), P), this._updatingHandles.add(() => this.fullOpacity, (e17) => this._opacityChange(e17)), this._updatingHandles.add(() => this.slicePlaneEnabled, (e17) => this._slicePlaneEnabledChange(e17)), this._updatingHandles.add(() => this.elevationOffset, (e17, t14) => {
        this._reloadAll(t14), this._controller.invalidateVisibilityObbs();
      }), this._updatingHandles.add(() => this.elevationInfo, (e17, t14) => this._elevationInfoChanged(e17, t14), P), this._updatingHandles.add(() => !this.suspended && this.elevationInfo.mode !== E4.Absolute, (e17, t14) => {
        e17 ? this.addHandles(this.view.basemapTerrain.on("elevation-change", ({
          extent: e18
        }) => this._ensureElevationTask().addExtent(e18)), Yt) : t14 && this.removeHandles(Yt);
      }, P), this._updatingHandles.add(() => this._usePBR, (e17) => this._updatePBR(e17));
      const c7 = () => {
        this._reloadAll(), this.clearMemCache();
      };
      this._updatingHandles.add(() => this.rendererTextureUsage, c7), this._updatingHandles.add(() => this.uncompressedTextureDownsamplingEnabled, c7), this._updatingHandles.add(() => this.contentVisible, (e17) => this._contentVisibleChanged(e17), P), this._updatingHandles.add(() => this.i3slayer.labelsVisible, () => this._labelingChanged(), P), this._updatingHandles.add(() => this.i3slayer.labelingInfo, () => this._labelingChanged(), P), this._updatingHandles.add(() => this._modifications, () => this._modificationsChanged(), P), this.addHandles([d(() => t6.I3S_TREE_SHOW_TILES, (e17) => {
        if (e17 && !this._treeDebugger) {
          const e18 = this._controller.crsIndex;
          import("./I3STreeDebugger-7RP7JCSS.js").then(({
            I3STreeDebugger: t14
          }) => {
            !this._treeDebugger && t6.I3S_TREE_SHOW_TILES && (this._treeDebugger = new t14({
              lv: this,
              view: this.view,
              nodeSR: e18
            }));
          });
        } else e17 || t6.I3S_TREE_SHOW_TILES || (this._treeDebugger = u(this._treeDebugger));
      }, P), d(() => t6.I3S_SHOW_MODIFICATIONS, () => this._showModifications(), P)]), this._cacheKeySuffix = J2(this.i3slayer.spatialReference, this.view.renderSpatialReference), this._idbCache.init().catch((e17) => Et().warn(`Failed to initialize IndexedDB cache: ${e17}`));
      const {
        view: u9
      } = this, {
        viewingMode: _2,
        renderCoordsHelper: g3
      } = u9;
      this._planetRadiusInGlobalMode = "local" === _2 ? 0 : g3.referenceEllipsoid.radius;
    }
    destroy() {
      this._clearAddTasks(), this._elevationTask = u(this._elevationTask), this.i3sOverrides = u(this.i3sOverrides), this._elevationProvider && (this._elevationProvider.objectsChanged(this.getVisibleObbs()), this.view.elevationProvider.unregister(this._elevationProvider), this._elevationProvider = null), this._intersectionHandler && (this._stage.view.sceneIntersectionHelper.removeIntersectionHandler(this._intersectionHandler), this._intersectionHandler = null);
      const e16 = this._worker;
      e16 && (e16.destroyContext(this.uid).then(() => e16.destroy()), this._worker = null), this._removeAllNodeDataFromStage(), this._memCache = u(this._memCache), this._collection = null, this._stage = null, this._edgeView = null, this._labeler = u(this._labeler), this._treeDebugger = u(this._treeDebugger), this._controller = u(this._controller), this._highlights.destroy(), this._nodeId2Meta.clear(), this._nodeId2MetaReloading.clear(), this._crossfadeHelper = u(this._crossfadeHelper), this.emit("visible-geometry-changed"), this._visibleGeometryChangedSchedulerHandle && (this._visibleGeometryChangedSchedulerHandle.remove(), this._visibleGeometryChangedSchedulerHandle = null), this._updatingHandles = u(this._updatingHandles);
    }
    _memEstimateTextureAdded(e16) {
      const t13 = e16.memoryEstimate;
      return this._gpuMemoryEstimate += t13, this._texMemoryEstimate += t13, t13;
    }
    _memEstimateTextureRemoved(e16) {
      if (null != e16) {
        const t13 = e16.memoryEstimate;
        this._gpuMemoryEstimate -= t13, this._texMemoryEstimate -= t13;
      }
    }
    _memEstimateGeometryAdded(e16) {
      const t13 = this._collection.getObjectGPUMemoryUsage(e16);
      return this._gpuMemoryEstimate += t13, this._geoMemoryEstimate += t13, t13;
    }
    _memEstimateGeometryRemoved(e16) {
      const t13 = this._collection.getObjectGPUMemoryUsage(e16);
      this._gpuMemoryEstimate -= t13, this._geoMemoryEstimate -= t13;
    }
    isNodeLoaded(e16) {
      return this._nodeId2Meta.has(e16);
    }
    isNodeReloading(e16) {
      return this._nodeId2MetaReloading.has(e16);
    }
    get usedMemory() {
      let e16 = null != this._labeler ? this._labeler.usedMemory : 0;
      return this._nodeId2Meta.forEach((t13) => e16 += null != t13 ? t13.node.memory : 0), this._nodeId2MetaReloading.forEach((t13) => e16 += null != t13 ? t13.node.memory : 0), e16;
    }
    get unloadedMemory() {
      return (null != this._controller ? this._controller.unloadedMemoryEstimate : 0) + (null != this._labeler ? this._labeler.unloadedMemoryEstimate : 0);
    }
    _labelingChanged() {
      if (!(B(this.i3slayer) && this._supportsLabeling)) return void (null != this._labeler && (this._labeler.destroy(), this._labeler = null));
      if (null != this._labeler) return;
      const e16 = new L4({
        view: this.view,
        layer: this.i3slayer,
        collection: this._collection,
        overrides: this.i3sOverrides
      });
      this._nodeId2Meta.forEach((t13) => null != t13 && this._addMetaToLabeler(e16, t13)), this._labeler = e16;
    }
    _loadAsyncModule(e16) {
      return ++this._asyncModuleLoading, e16.then((e17) => (--this._asyncModuleLoading, e17), (e17) => {
        throw --this._asyncModuleLoading, e17;
      });
    }
    _modificationsChanged() {
      if (!this._i3sWasmLoaded && this.hasModifications) return this._i3sWasmLoaded = _().then(() => {
        this._i3sWasmLoaded = true, this._modificationsChanged(), this.notifyUpdate();
      }), void this.notifyUpdate();
      if (true !== this._i3sWasmLoaded) return;
      const e16 = this.uid, t13 = this.i3slayer.spatialReference;
      this._worker.setModifications(e16, this._layerClippingArea, this._modifications, t13);
      const i8 = a6(this._layerClippingArea, this._modifications, t13);
      E3({
        context: e16,
        modifications: i8,
        isGeodetic: t13.isGeographic
      }), this._controller.modificationsChanged();
      const s8 = this.hasModifications ? new l2() : null;
      this._nodeId2Meta.forEach((e17, t14) => {
        null == e17 ? (this._nodeId2Meta.delete(t14), this._controller.updateLoadStatus(t14, false)) : e17.node.hasModifications ? (this._nodeId2Meta.delete(t14), this._nodeId2MetaReloading.set(t14, e17)) : null != s8 && s8.push(e17.node);
      }), this.notifyChange("elevationRange"), null != s8 && this._nodeId2MetaReloading.forEach((e17) => s8.push(e17.node)), null != s8 && s8.length > 0 && (this.updateNodeModificationStatus(s8), s8.forAll((e17) => {
        if (e17.imModificationImpact !== r3.Culled) {
          const t14 = this._nodeId2Meta.get(e17.index);
          this._controller.invalidateGeometryVisibility(e17.index), null != t14 ? (this._nodeId2Meta.delete(e17.index), this._nodeId2MetaReloading.set(e17.index, t14), this.notifyChange("elevationRange")) : this._nodeId2Meta.has(e17.index) && (this._nodeId2Meta.delete(e17.index), this._controller.updateLoadStatus(e17.index, false));
        }
      })), this.clearMemCache(), this._controller.restartNodeLoading(), this._showModifications();
    }
    _showModifications() {
      if (null != this._modificationGraphics && (this.view.graphics.removeMany(this._modificationGraphics), this._modificationGraphics = null), !t6.I3S_SHOW_MODIFICATIONS || 0 === this._modifications.length) return;
      const e16 = {
        clip: [227, 227, 79, 0.8],
        mask: [227, 139, 79, 0.8],
        replace: [139, 227, 79, 0.8]
      }, t13 = {
        outline: {
          color: [255, 255, 255],
          width: 1
        }
      };
      this._modificationGraphics = new Array();
      for (const s8 of this._modifications) {
        const r5 = s8.geometry;
        r5.spatialReference = this.i3slayer.spatialReference;
        const o10 = new S5(__spreadProps(__spreadValues({}, t13), {
          color: e16[s8.type]
        }));
        this._modificationGraphics.push(new d2({
          geometry: r5,
          symbol: o10
        }));
      }
      this.view.graphics.addMany(this._modificationGraphics);
    }
    _addMetaToLabeler(e16, t13) {
      e16.addNodeMeta(t13, (e17, t14) => this._createAttributes(e17, t14));
    }
    _contentVisibleChanged(e16) {
      e16 ? (this.view.elevationProvider.register(this._elevationContext, this._elevationProvider), this._stage.view.sceneIntersectionHelper.addIntersectionHandler(this._intersectionHandler)) : (this._removeAllNodeDataFromStage(), this.view.elevationProvider && this.view.elevationProvider.unregister(this._elevationProvider), this._stage.view.sceneIntersectionHelper.removeIntersectionHandler(this._intersectionHandler));
    }
    getLoadedAttributes(e16) {
      const t13 = this._nodeId2Meta.get(e16);
      if (null != t13?.attributeInfo) return t13.attributeInfo.loadedAttributes;
    }
    getAttributeData(e16) {
      const t13 = this._nodeId2Meta.get(e16);
      if (null != t13?.attributeInfo) return t13.attributeInfo.attributeData;
    }
    setAttributeData(e16, t13) {
      const i8 = this._nodeId2Meta.get(e16);
      null != i8?.attributeInfo && (i8.attributeInfo.attributeData = t13, this._attributeValuesChanged(i8));
    }
    updateAttributes(e16, t13, i8) {
      return __async(this, null, function* () {
        const s8 = this._nodeId2Meta.get(e16);
        null != s8 && (yield this.i3sOverrides.applyAttributeOverrides(s8.featureIds, t13, i8, this._controller.requiredAttributes), s8.attributeInfo = t13, this._controller.reschedule(() => this._attributeValuesChanged(s8), i8).catch((e17) => {
          b(e17) || Et().warn("Error while updating attribute values. Layer might not display correctly.", e17);
        }));
      });
    }
    _attributeValuesChanged(e16) {
      e16.cachedRendererVersion = this._getInvalidRendererVersion(), e16.filteredIds = null, null != this._labeler && this._labeler.setNodeMetaAttributes(e16, (e17, t13) => this._createAttributes(e17, t13)), this._updateEngineObject(e16);
    }
    clearMemCache() {
      null != this._memCache && this._memCache.clear();
    }
    getVisibleNodes() {
      const e16 = new Array();
      return this._nodeId2Meta.forEach((t13) => null != t13 && e16.push(t13.node)), e16;
    }
    getVisibleObbs() {
      const e16 = new Array();
      return this._nodeId2Meta.forEach((t13) => {
        if (null != t13) {
          const i8 = this.getNodeComponentObb(t13.node);
          null != i8 && e16.push(i8);
        }
      }), e16;
    }
    getNodeComponentObb(e16) {
      const t13 = this._nodeId2Meta.get(e16.index) ?? this._nodeId2MetaReloading.get(e16.index);
      return null != t13 ? this._collection.getComponentObb(t13.objectHandle) : null;
    }
    getLoadedNodeIndices(e16) {
      this._nodeId2Meta.forEach((t13, i8) => e16.push(i8)), this._nodeId2MetaReloading.forEach((t13, i8) => e16.push(i8));
    }
    _preLoadBasis() {
      !has("disable-feature:i3s-basis") && this.supportedTextureEncodings & e13.Basis && this.i3slayer.textureSetDefinitions?.some((e16) => e16.formats.some((e17) => "basis" === e17.format || "ktx2" === e17.format)) && g2();
    }
    _getVertexBufferLayout(e16, t13) {
      const i8 = {
        hasTexture: Lt(e16.params.material),
        hasNormals: t13.normal,
        hasRegions: t13.uvRegion
      };
      return t3(o5(this._getGeometryParameters(i8)));
    }
    _getObjectIdField() {
      return this.i3slayer.objectIdField || o3;
    }
    _getGlobalIdField() {
      return this.i3slayer.associatedLayer?.globalIdField;
    }
    _findGraphicNodeAndIndex(e16) {
      const t13 = n9(this.i3slayer.fieldsIndex, e16.attributes, this._getObjectIdField());
      let i8 = null;
      return n2(this._nodeId2Meta, (e17) => {
        if (null == e17) return false;
        const s8 = e17.featureIds.indexOf(t13);
        return -1 !== s8 && (i8 = {
          node: e17.node,
          index: s8
        }, true);
      }), i8;
    }
    _getGraphicIndices(e16, t13) {
      const i8 = this._nodeId2Meta.get(e16.index);
      if (null == i8) return [];
      const s8 = [], r5 = this._getObjectIdField(), o10 = this.i3slayer.fieldsIndex;
      for (const n14 of t13) {
        const e17 = n9(o10, n14.attributes, r5), t14 = i8.featureIds.indexOf(e17);
        -1 !== t14 && s8.push(t14);
      }
      return s8;
    }
    whenGraphicBounds(e16) {
      const t13 = this._findGraphicNodeAndIndex(e16);
      if (!t13) return Promise.reject();
      const i8 = this._getAABB(t13.node.index, t13.index);
      return null == i8 ? Promise.reject() : Promise.resolve({
        boundingBox: i8,
        screenSpaceObjects: []
      });
    }
    getAABBFromIntersectorTarget(e16) {
      return null == e16.nodeIndex || null == e16.componentIndex ? null : this._getAABB(e16.nodeIndex, e16.componentIndex);
    }
    _getAABB(e16, t13) {
      const i8 = this._nodeId2Meta.get(e16);
      if (null == i8?.featureIds || t13 >= i8.featureIds.length) return null;
      const s8 = i8.objectHandle, r5 = c4(t13, this._collection, s8, t5(24), 0), o10 = this.view.renderSpatialReference, n14 = this.view.spatialReference;
      if (!n4(r5, o10, 0, r5, n14, 0, 8)) return null;
      const a9 = P2();
      return c(a9, r5, 0, 8), a9;
    }
    whenGraphicAttributes(e16, t13) {
      return A3(this.i3slayer, e16, this._getObjectIdField(), t13, () => [...this._nodeId2Meta.values()].filter(O));
    }
    getGraphicFromIntersectorTarget(e16) {
      if (null == e16.nodeIndex || null == e16.componentIndex) return null;
      const t13 = this._nodeId2Meta.get(e16.nodeIndex);
      return null == t13?.featureIds || e16.componentIndex >= t13.featureIds.length ? null : this._createGraphic(e16.componentIndex, t13);
    }
    _getCacheKey(e16) {
      return `${this._layerUrl}/v${Rt}/${e16}${this._cacheKeySuffix}`;
    }
    _getMemCacheKey(e16, t13 = this.elevationOffset) {
      return e16 + "#" + t13;
    }
    get _idbCacheEnabled() {
      return !this._controller.disableIDBCache && !this.hasModifications && 0 === this.elevationOffset && null != this._cacheKeySuffix;
    }
    loadCachedGPUData(e16) {
      return null != this._memCache ? this._memCache.pop(this._getMemCacheKey(e16)) : null;
    }
    deleteCachedGPUData(e16) {
      null != e16 && this._deleteComponentObject(e16);
    }
    _cacheGPUData(e16, t13 = this.elevationOffset) {
      if (null == this._memCache) return void this._deleteComponentObject(e16);
      const i8 = this._controller.indexDepth - e16.node.level;
      this._memCache.put(this._getMemCacheKey(e16.node.index, t13), e16, e16.node.memory, i8);
    }
    loadMissingTextures(e16, t13, i8, s8) {
      const r5 = e16?.filter((e17, i9) => {
        if (!(e17.usage & this.rendererTextureUsage)) return false;
        if (null == t13) return true;
        const s9 = D3(e17.encodings, this.supportedTextureEncodings), r6 = t13[i9];
        return !!(null == r6?.data || s9 && r6.encoding !== s9.encoding);
      }) ?? [];
      return 0 === r5.length ? Promise.resolve(false) : i8(r5, s8).then((i9) => {
        let s9 = 0;
        for (let r6 = 0; r6 < e16.length; r6++) s9 < i9.length && i9[s9].id === e16[r6].id && (t13[r6] = i9[s9], s9++);
        return true;
      });
    }
    loadCachedNodeData(e16, t13, i8) {
      return this._idbCacheEnabled ? this._idbCache.get(this._getCacheKey(e16.id), t13).then((s8) => null == s8 ? null : s8.nodeVersion !== e16.version ? (this._idbCache.remove(this._getCacheKey(e16.id)), null) : (this.elevationInfo.mode === E4.Absolute && (e16.geometryObbInRenderSR = I3.fromData(s8.geometryObbData)), this.loadMissingTextures(s8.requiredTextures, s8.textureData, i8, t13).then((i9) => (i9 && this._idbCache.initialized && null != s8.textureData && (s8.byteSize = qt(s8.transformedGeometry, s8.textureData), s8.textureData.every(Bt) && Wt(e16, s8) && this._idbCache.put(this._getCacheKey(e16.id), s8).catch((t14) => Et().warn(`Failed to update node with textures in IndexedDB cache: ${e16.id}: ${t14}`))), s2(t13), s8)))) : Promise.resolve(null);
    }
    addNode(e16, t13, i8) {
      return kt(t13) ? null == t13.geometryBuffer ? (this._addNodeMeta(e16.index, null), Promise.resolve()) : this._addData(e16, t13.attributeDataInfo, () => this._transformNode(e16, t13, i8).then((s8) => this._safeReschedule(() => {
        if (null == s8) return e16.hasModifications = false, this._addCachedNodeData(e16, null, i8);
        e16.hasModifications = s8.transformedGeometry.hasModifications;
        const {
          obb: r5,
          componentOffsets: o10,
          featureIds: n14,
          anchorIds: a9,
          anchors: l5,
          transformedGeometry: d5,
          globalTrafo: h8
        } = s8, c7 = o2(Qt, r5.center.x, r5.center.y, r5.center.z);
        O2(c7, c7, h8);
        const u9 = new I3(c7, [r5.extents.x, r5.extents.y, r5.extents.z], t2(r5.orientation.x, r5.orientation.y, r5.orientation.z, r5.orientation.w));
        this.elevationInfo.mode === E4.Absolute && (e16.geometryObbInRenderSR = u9), t13.geometryData.componentOffsets = o10, n14 && (t13.geometryData.featureIds = Array.from(n14)), t13.geometryData.anchorIds = a9, t13.geometryData.anchors = l5;
        const _2 = {
          nodeVersion: e16.version,
          geometryData: t13.geometryData,
          requiredTextures: t13.requiredTextures,
          textureData: t13.textureData,
          transformedGeometry: d5,
          globalTrafo: h8,
          geometryObbData: u9.data,
          byteSize: qt(d5, t13.textureData)
        };
        if (this._idbCacheEnabled && this._idbCache.initialized && Wt(e16, _2)) {
          const t14 = null != _2.textureData ? _2.textureData.map((e17) => Bt(e17) ? e17 : null) : null;
          this._idbCache.put(this._getCacheKey(e16.id), __spreadProps(__spreadValues({}, _2), {
            textureData: t14
          })).catch((t15) => Et().warn(`Failed to store node in IndexedDB cache: ${e16.id}: ${t15}`));
        }
        return this._addCachedNodeData(e16, _2, i8);
      }, i8))) : Promise.reject();
    }
    getElevationRange(e16) {
      const t13 = new e10(), i8 = this._controller, {
        index: s8
      } = i8;
      if (!s8) return t13;
      const {
        rootNode: r5
      } = s8;
      if (!r5) return t13;
      const o10 = this._nodeId2Meta, n14 = e16[3], a9 = i8.viewportQueries, l5 = this._planetRadiusInGlobalMode, {
        view: d5
      } = this, {
        renderCoordsHelper: h8
      } = d5, c7 = h8.referenceEllipsoid.radius, u9 = this._collection, _2 = (i9) => {
        const {
          childrenLoaded: s9
        } = i9;
        if (0 === s9) return false;
        const r6 = a9.getAndUpdateVisibilityObbInRenderSR(i9);
        let d6 = null, _3 = -1;
        if (r6) {
          if (_3 = r6.radius, !r6.intersectSphereWithMBS(e16, _3)) return false;
        } else d6 = a9.getServiceMbsInRenderSR(i9), d6 && (_3 = d6[3]);
        if (_3 >= 0 && n14 >= 1 * _3) return null != r6 ? ei(t13, r6, l5) : null != d6 && d6[3] >= 0 && ti(t13, d6, l5), false;
        const g3 = Zt;
        if (g3.elevationRangeMin = 1 / 0, g3.elevationRangeMax = -1 / 0, (null != r6 || null != d6) && (null != r6 ? ei(g3, r6, l5) : null != d6 && ti(g3, d6, l5), g3.elevationRangeMin >= t13.elevationRangeMin && g3.elevationRangeMax <= t13.elevationRangeMax)) return false;
        const m4 = o10.get(i9.index);
        if (m4) {
          const {
            geometryObbInRenderSR: s10
          } = i9;
          if (!s10 || s10.intersectSphereWithMBS(e16)) {
            if (s10) {
              if (n14 > 0 * s10.radius) return ei(t13, s10, l5), false;
            }
            const {
              objectHandle: e17
            } = m4, i10 = u9.getObjectTransform(e17), r7 = h8.getAltitude(i10.position);
            u9.expandRangeWithComponentObjectElevationRange(e17, r7, c7, t13);
          }
        }
        return s9 - (m4 ? 1 : 0) > 0;
      };
      return s8.traverse(r5, _2), t13;
    }
    computeVisibilityObb(e16) {
      return he(e16, this.view.renderSpatialReference, this._controller.crsIndex, this.i3slayer.spatialReference, this.elevationOffset, this._modifications, this.view.renderCoordsHelper.sphericalPCPF);
    }
    _transformNode(e16, t13, i8) {
      const s8 = t13.geometryData.geometries ?? [], r5 = new Array(s8.length);
      for (let p2 = 0; p2 < s8.length; ++p2) r5[p2] = this._getVertexBufferLayout(s8[p2], t13.geometryDescriptor);
      const o10 = this.i3slayer.normalReferenceFrame, n14 = t13.normalReferenceFrame ?? o10 ?? "none", a9 = e16.serviceMbsInIndexSR, l5 = this.elevationOffset, d5 = this._controller.crsIndex, h8 = this._controller.crsVertex, c7 = this.view.renderSpatialReference, u9 = n6(a9, l5, n14, d5, c7), _2 = W(d5, h8), g3 = W(h8, c7);
      if (null == _2 || null == g3) return Promise.resolve(null);
      const m4 = {
        context: this.uid,
        geometryBuffer: t13.geometryBuffer,
        geometryData: t13.geometryData,
        geometryDescriptor: t13.geometryDescriptor,
        layouts: r5,
        globalTrafo: u9,
        mbs: a9,
        obbData: e16.serviceObbInIndexSR?.data,
        elevationOffset: l5,
        needNormals: this._needsNormals && this._controller.isMeshPyramid,
        normalReferenceFrame: n14,
        indexToVertexProjector: _2,
        vertexToRenderProjector: g3
      };
      return this._worker.invoke(m4, i8);
    }
    get _supportsNodeCrossFading() {
      return !this.view?._stage?.renderer.shadowsEnabled;
    }
    get nodeCrossfadingEnabled() {
      return this._supportsNodeCrossFading && (this.lodCrossfadeinDuration > 0 || this.lodCrossfadeoutDuration > 0 || this.lodCrossfadeUncoveredDuration > 0);
    }
    get nodeFadeoutEnabled() {
      return this._supportsNodeCrossFading && this.lodCrossfadeoutDuration > 0;
    }
    _setNewNodeOpacity(e16) {
      const t13 = this.nodeCrossfadingEnabled ? 0 : this.fullOpacity;
      this._setNodeOpacity(e16, t13);
    }
    addCachedGPUData(e16, t13, i8) {
      if (this.elevationInfo.mode === E4.Absolute && (e16.geometryObbInRenderSR = this._collection.getComponentObb(t13.objectHandle).clone()), !this._controller.isGeometryVisible(e16)) return void this._cacheGPUData(t13);
      null != this._labeler && this._addMetaToLabeler(this._labeler, t13);
      const s8 = e16.index;
      this._addNodeMeta(s8, t13), this.updateNodeState(s8, i8), this._collection.setObjectVisibility(t13.objectHandle, true), this._updateMaterial(t13), this._setNewNodeOpacity(t13), this.elevationInfo.mode !== E4.Absolute && this._ensureElevationTask().schedule(s8), this._updateEngineObject(t13), this._highlights.objectCreated(t13), null != this._treeDebugger && this._treeDebugger.update();
    }
    addCachedNodeData(e16, t13, i8, s8) {
      return this._addData(e16, i8, () => this._addCachedNodeData(e16, t13, s8));
    }
    deleteCachedNodeData(e16) {
      return __async(this, null, function* () {
        if (this._idbCacheEnabled) return this._idbCache.remove(this._getCacheKey(e16));
      });
    }
    _addCachedNodeData(e16, t13, i8) {
      return __async(this, null, function* () {
        if (!this.contentVisible || !this._controller.isGeometryVisible(e16)) return void this._removeNodeStageData(e16.index, this.elevationOffset, this._nodeId2MetaReloading);
        if (null == t13) return void this._addNodeMeta(e16.index, null);
        const s8 = this._addTasks.get(e16.index), {
          geometryData: r5,
          transformedGeometry: o10,
          globalTrafo: n14
        } = t13;
        yield this.i3sOverrides.applyAttributeOverrides(r5.featureIds, s8.attributeInfo, i8, this._controller.requiredAttributes);
        const a9 = null != t13.textureData ? t13.textureData.filter((e17) => null != e17 && !!(e17.usage & this.rendererTextureUsage)) : [];
        !has("disable-feature:i3s-basis") && a9.some((e17) => null != e17 && (e17.encoding === e13.Basis || e17.encoding === e13.KTX2)) && (yield g2()), e16.memory = 0;
        const {
          componentOffsets: l5,
          geometries: d5,
          featureIds: h8,
          anchorIds: c7,
          anchors: u9
        } = r5, _2 = this._collection, g3 = d5[0], {
          layout: m4,
          indices: p2,
          interleavedVertexData: f3,
          positionData: b4,
          hasColors: y2
        } = o10, {
          material: v2,
          geometryParameters: w3
        } = this._materialParameters(g3, m4), R2 = l5 || new Uint32Array([0, p2 ? p2.length : f3.byteLength / m4[0].stride]), S7 = {
          vertices: {
            data: f3,
            count: f3.byteLength / m4[0].stride,
            layoutParameters: w3
          },
          positionData: {
            positions: e8(b4.data),
            indices: t4(b4.indices)
          },
          indices: p2,
          componentOffsets: R2
        }, T = g3.transformation ? r2(g3.transformation) : e5();
        c2(T, n14, T);
        const N2 = I2(n3(), T), V3 = n8(e7(), T), F3 = this.view.renderSpatialReference, H = this.view.basemapTerrain.spatialReference, G4 = I3.fromData(t13.geometryObbData).center, k2 = [1, 1, 1];
        f2(G4, F3, k2, H) || Et().errorOnce("Unsupported coordinate system for IM overlay");
        const B2 = n3();
        n5(G4, F3, B2, H);
        const q2 = e7();
        s4(q2, V3);
        const z = n3();
        S3(z, K(z, G4, N2), q2);
        const K3 = B2[0] - z[0] * k2[0], $ = B2[1] - z[1] * k2[1], Q2 = _2.createObject(new t9(r(K3, $, k2[0], k2[1]), new i4(N2, V3), I3.fromData(t13.geometryObbData), S7)), X = w3.textureCoordinates === d4.Atlas, {
          textures: Y2,
          texturePromise: J3
        } = this._initMaterialAndTextures(Q2, v2, a9, X);
        e16.memory += this._memEstimateGeometryAdded(Q2), e16.memory += Y2.reduce((e17, t14) => e17 + (null != t14 ? this._memEstimateTextureAdded(t14) : 0), 0);
        const te = !!v2.hasParametersFromSource, ie = "blend" !== v2.alphaMode && v2.metallicRoughness.baseColorFactor[3] >= 1, se = new jt(e16, h8, Q2, this._getInvalidRendererVersion(), s8.attributeInfo, {
          hasParametersFromSource: te,
          isOpaque: ie
        }, Y2, c7, u9);
        s8.meta = se, !this._hasTextures && t13.requiredTextures?.some(({
          usage: e17
        }) => !!(e17 & s5.ColorTextures)) && (this._hasTextures = true), this._hasData = true, this._hasColors = this._hasColors || y2, this._hasTextures = this._hasTextures || !!e16.resources.texture, this.notifyChange("hasTexturesOrVertexColors");
        const re = this.slicePlaneEnabled;
        return Promise.all([this._addOrUpdateEdgeRendering(se), J3]).then(([t14, s9]) => (this._addTasks.has(e16.index) && t14?.updateObjectVisibility(se.objectHandle, false).catch((e17) => Dt(e17, this.i3slayer.title)), this._safeReschedule(() => {
          const i9 = this._addTasks.get(e16.index);
          if (!i9) return;
          if (this._addNodeMeta(e16.index, se), i9.meta = null, !this.contentVisible) return void this._removeNodeStageData(e16.index, this.elevationOffset);
          _2.setObjectVisibility(Q2, true), t14?.updateObjectVisibility(se.objectHandle, true).catch((e17) => Dt(e17, this.i3slayer.title)), se.attributeInfo = i9.attributeInfo;
          const s10 = se.cachedRendererVersion !== this._rendererVersion, r6 = re !== this.slicePlaneEnabled;
          this._updateElevationOffsets(se);
          const o11 = se.elevationOffsets;
          this._updateComponentData(se);
          const n15 = this._applyFiltersToNode(se);
          (s10 || null != t14 && (r6 || n15 || o11)) && this._addOrUpdateEdgeRendering(se), null != this._labeler && this._addMetaToLabeler(this._labeler, se), this._visibleGeometryChanged(se, Tt.ADD), this._highlights.objectCreated(se), this._updateMaterial(se), this._setNewNodeOpacity(se), null != this._treeDebugger && this._treeDebugger.update();
        }, i8))).catch((e17) => {
          throw null != s8.meta && (this._cacheGPUData(s8.meta), s8.meta = null), e17;
        });
      });
    }
    _addNodeMeta(e16, t13) {
      if (this._removeNodeStageData(e16, this.elevationOffset, this._nodeId2MetaReloading), this._nodeId2Meta.has(e16)) {
        Et().error("Removing duplicated node");
        const t14 = this._nodeId2Meta.get(e16);
        null != t14 && this._deleteComponentObject(t14);
      } else this._controller.updateLoadStatus(e16, true);
      null != t13 && (t13.lodCrossfadeProgress = null, this.nodeCrossfadingEnabled && Kt(t13.cachedEdgeMaterials, 0)), this._nodeId2Meta.set(e16, t13), this.notifyChange("elevationRange");
    }
    _updateElevationOffsets(e16) {
      const t13 = this.view.renderSpatialReference, i8 = this._controller.crsIndex, s8 = this.elevationInfo, r5 = this.view.basemapTerrain, o10 = r5.spatialReference, n14 = s8.mode;
      if (null == t13 || null == o10 || n14 === E4.Absolute) return void (e16.elevationOffsets = null);
      const a9 = this._collection.getObjectTransform(e16.objectHandle);
      e16.elevationOffsets = e16.elevationOffsets ?? [];
      const l5 = Qt, d5 = Xt, h8 = n14 === E4.OnTheGround, c7 = this.view.renderCoordsHelper, u9 = e16.featureIds.length, _2 = (() => {
        if (e16.cachedElevationAnchors) return e16.cachedElevationAnchors;
        const s9 = t5(3 * u9);
        e16.cachedElevationAnchors = s9;
        for (let r6 = 0; r6 < u9; r6++) {
          const n15 = 3 * r6, h9 = e16.anchorIds?.indexOf(r6) ?? -1;
          e16.anchors && h9 >= 0 ? (o2(l5, e16.anchors[3 * h9], e16.anchors[3 * h9 + 1], e16.anchors[3 * h9 + 2]), u2(l5, l5, V2(e16.node.serviceMbsInIndexSR)), n5(l5, i8, l5, o10), s9[n15] = l5[0], s9[n15 + 1] = l5[1], s9[n15 + 2] = c7.getAltitude(l5)) : (this._collection.getComponentAabb(e16.objectHandle, r6, d5, true), o2(l5, (d5[0] + d5[3]) / 2, (d5[1] + d5[4]) / 2, d5[2]), S3(l5, l5, a9.rotationScale), u2(l5, l5, a9.position), s9[n15 + 2] = c7.getAltitude(l5), n5(l5, t13, l5, o10), s9[n15] = l5[0], s9[n15 + 1] = l5[1]);
        }
        return s9;
      })(), g3 = s8.offset, m4 = e16.elevationOffsets, p2 = (e17, t14) => {
        const i9 = h8 ? _2[3 * e17 + 2] : 0;
        m4[e17] = g3 + (null != t14 ? t14 - i9 : 0);
      };
      r5.getElevations(_2, u9, p2);
    }
    _ensureElevationTask() {
      return null != this._elevationTask || (this._elevationTask = new a7(this.view.resourceController.scheduler, (e16) => {
        const t13 = this._controller.updateElevationChanged(e16, this.view.basemapTerrain.spatialReference);
        return null != t13 ? t13.filterInPlace((e17) => null != this._nodeId2Meta.get(e17)) : null;
      }, (e16) => {
        const t13 = this._nodeId2Meta.get(e16);
        this._nodeElevationAlignmentChanged(t13);
      }, () => this.elevationInfo?.mode)), this._elevationTask;
    }
    _elevationInfoChanged(e16, t13) {
      const i8 = e16.mode !== E4.Absolute, s8 = !!t13 && t13 !== e16 && t13.mode !== E4.Absolute;
      this._intersectionHandler.updateElevationAlignState(i8, this.view.state.viewingMode), i8 && !s8 && this._controller.removeAllGeometryObbs(), this._nodeId2Meta.forEach((e17) => this._nodeElevationAlignmentChanged(e17));
    }
    _nodeElevationAlignmentChanged(e16) {
      null != e16 && (this._updateElevationOffsets(e16), this._updateComponentData(e16), this._updateEdgeRendering(e16), null != this._labeler && this._labeler.updateLabelPositions(e16), this._updateSnappingSources(e16, Tt.UPDATE));
    }
    _safeReschedule(e16, t13) {
      return s2(t13), this._controller.reschedule(e16, t13);
    }
    _materialParameters(e16, t13) {
      const i8 = null != e16.params.material ? e16.params.material : b3(), s8 = t13.some((e17) => "uvRegion" === e17.name), r5 = t13.some((e17) => "normalCompressed" === e17.name), o10 = Lt(i8);
      return {
        geometryParameters: this._getGeometryParameters({
          hasTexture: o10,
          hasNormals: r5,
          hasRegions: s8
        }),
        material: i8
      };
    }
    _initMaterialAndTextures(e16, t13, i8, s8) {
      const r5 = this._stage.renderView, o10 = i8.map((e17) => C3(e17, t13, s8, r5));
      this._stage.addMany(o10);
      let n14 = null;
      return this._collection.updateMaterial(e16, (e17) => {
        n14 = M(e17, t13, o10, i8, this.view._stage.renderView.textures, {
          rendererTextureUsage: this.rendererTextureUsage,
          usePBR: this._usePBR,
          isIntegratedMesh: this._isIntegratedMesh,
          slicePlaneEnabled: this.slicePlaneEnabled,
          viewSpatialReference: this.view.spatialReference
        }), this._updateMaterialOverlay(e17);
      }), {
        textures: o10,
        texturePromise: n14
      };
    }
    _getGeometryParameters(e16) {
      return {
        textureCoordinates: e16.hasTexture ? e16.hasRegions ? d4.Atlas : d4.Default : d4.None,
        colors: this._hasVertexColors,
        hasNormals: e16.hasNormals && this._needsNormals,
        needsNormals: this._needsNormals
      };
    }
    _addData(e16, t13, i8) {
      let s8 = this._addTasks.get(e16.index);
      return s8 ? s8.attributeInfo = t13 : (s8 = __spreadProps(__spreadValues({}, L()), {
        attributeInfo: t13,
        meta: null
      }), this._addTasks.set(e16.index, s8), i8().then(s8.resolve, s8.reject).then(() => this._addTasks.delete(e16.index)).catch((t14) => {
        throw this._addTasks.delete(e16.index), t14;
      })), s8.promise;
    }
    _clearAddTasks() {
      this._addTasks.forEach((e16) => {
        null != e16.meta && (this._cacheGPUData(e16.meta), e16.meta = null);
      }), this._addTasks.clear();
    }
    _clippingAreaChanged() {
      const e16 = this.view.renderSpatialReference, t13 = this.i3slayer.spatialReference, i8 = u3();
      this._renderClippingArea = u5(this.view.clippingArea, i8, e16) ? i8 : null;
      const s8 = u3();
      this._layerClippingArea = u5(this.view.clippingArea, s8, t13) ? s8 : null, this._filterChange(), this._controller && this._controller.updateClippingArea(this.view.clippingArea), this._isIntegratedMesh && this._modificationsChanged();
    }
    get hasGeometryFilter() {
      return false;
    }
    _geometryFilterChange() {
      const e16 = this.hasGeometryFilter;
      this._controller.geometryFilterChanged(e16), this._applyFilters(e16);
    }
    _filterChange() {
      this._applyFilters(this.hasGeometryFilter);
    }
    _applyFilters(e16) {
      this._filters = this.getFilters(), e16 ? this._controller && this._controller.requestUpdate() : this._nodeId2Meta.forEach((e17) => {
        null != e17 && this._applyFiltersToNode(e17) && (this._addOrUpdateEdgeRendering(e17), this._visibleGeometryChanged(e17, Tt.UPDATE));
      });
    }
    getFilters() {
      const e16 = [], t13 = this._renderClippingArea;
      return null != t13 && e16.push((e17, i8) => this._boundingRectFilter(e17, i8, t13)), e16;
    }
    addSqlFilter(e16, t13, i8) {
      if (null != t13) {
        const s8 = t13.fieldNames;
        e16.push((e17, r5) => this._sqlFilter(e17, r5, t13, s8, i8));
      }
    }
    _sqlFilter(e16, t13, i8, s8, r5) {
      const o10 = {}, n14 = this._createLayerGraphic(o10), a9 = this.i3slayer.objectIdField, l5 = t13.featureIds, d5 = t13.attributeInfo?.attributeData;
      s8.every((e17) => e17 === a9 || null != d5?.[e17]) && D2(e16, l5, (e17) => {
        o10[a9] = l5[e17];
        for (const i9 of s8) i9 !== a9 && (o10[i9] = d5 ? Q(d5[i9], e17) : null);
        try {
          return i8.testFeature(n14);
        } catch (t14) {
          return r5(t14), false;
        }
      });
    }
    _boundingRectNodeTest(e16, t13) {
      return a2(e16.node.serviceMbsInIndexSR, this._controller.crsIndex, Gt, this.view.renderSpatialReference), O4(t13, Gt);
    }
    _boundingRectFeatureTest(e16, t13, i8) {
      return this._collection.getComponentAabb(e16.objectHandle, t13, Nt), S4(Nt, Vt), E(i8, Vt);
    }
    _boundingRectFilter(e16, t13, i8) {
      const s8 = this._collection, r5 = this._boundingRectNodeTest(t13, i8);
      if (r5 === F.INSIDE) return;
      if (r5 === F.OUTSIDE) return void (e16.length = 0);
      const o10 = s8.getComponentCount(t13.objectHandle);
      if (o10.invisible + o10.visible !== t13.featureIds.length) return;
      const n14 = this._transformClippingArea(Ft, i8, t13.objectHandle);
      D2(e16, t13.featureIds, (e17) => this._boundingRectFeatureTest(t13, e17, n14));
    }
    _transformClippingArea(e16, t13, i8) {
      const s8 = this._collection.getObjectTransform(i8), r5 = s8.position, o10 = s8.rotationScale;
      return e16[0] = (t13[0] - r5[0]) / o10[0], e16[1] = (t13[1] - r5[1]) / o10[4], e16[2] = (t13[2] - r5[0]) / o10[0], e16[3] = (t13[3] - r5[1]) / o10[4], e16;
    }
    _addOrUpdateEdgeRendering(e16, t13 = true) {
      return __async(this, null, function* () {
        const i8 = e16.objectHandle, {
          hasEdges: s8,
          perFeatureEdgeMaterials: r5
        } = this._getFilteredEdgeMaterials(e16), o10 = {
          hasSlicePlane: this.slicePlaneEnabled
        };
        s8 && !this._edgeView && (this._edgeView = yield this._stage.renderer.loadEdgeView());
        const n14 = this._edgeView;
        if (!n14) return null;
        const a9 = n14.hasObject(i8);
        if (s8) {
          if (a9) {
            if (this.nodeCrossfadingEnabled) {
              Kt(r5, this.getNodeOpacity(e16));
            }
            return n14.updateAllComponentMaterials(i8, r5, o10, t13).catch((e17) => Dt(e17, this.i3slayer.title)), n14.updateObjectVisibility(i8, true).catch((e17) => Dt(e17, this.i3slayer.title)), n14.updateAllVerticalOffsets(i8, e16.elevationOffsets).catch((e17) => Dt(e17, this.i3slayer.title)), n14;
          }
          const s9 = yield this._collection.addEdges(i8, n14, r5, o10, e16.elevationOffsets);
          return e16.edgeMemoryUsage = s9, e16.node.memory += s9, n14;
        }
        return a9 && (e16.node.memory -= e16.edgeMemoryUsage, e16.edgeMemoryUsage = 0, n14.removeObject(i8)), null;
      });
    }
    _applyFiltersToNode(e16) {
      return !!this._applyFiltersToNodeComponents(e16) && (null != this._labeler && this._labeler.applyFilterChange(e16), true);
    }
    _applyFiltersToNodeComponents(e16) {
      const t13 = this._collection, i8 = t13.getComponentCount(e16.objectHandle), s8 = null != e16.filteredIds, r5 = 0 === i8.invisible;
      if (t13.setAllComponentVisibilities(e16.objectHandle, "all"), 0 === this._filters.length) return e16.filteredIds = null, !r5;
      if (this._updateCachedFilteredIds(e16), s8 && e16.filteredIds === e16.featureIds) return !r5;
      const o10 = this._computeFilteredComponentIndices(e16);
      return t13.setAllComponentVisibilities(e16.objectHandle, o10), true;
    }
    _updateCachedFilteredIds(e16) {
      null != e16.filteredIds && e16.appliedFilters === this._filters || (e16.filteredIds = this._computeFilteredIds(e16), e16.appliedFilters = this._filters);
    }
    _computeFilteredIds(e16) {
      const t13 = e16.featureIds.slice();
      for (const i8 of this._filters) if (i8(t13, e16), 0 === t13.length) break;
      return t13.length === e16.featureIds.length ? e16.featureIds : t13;
    }
    _computeFilteredComponentIndices(e16) {
      const t13 = new Array(), i8 = e16.filteredIds;
      return null != i8 && e16.featureIds.forEach((e17, s8) => {
        i8[t13.length] === e17 && t13.push(s8);
      }), t13;
    }
    _removeAllNodeDataFromStage(e16 = this.elevationOffset) {
      this._nodeId2Meta.forEach((t13, i8) => this._removeNodeStageData(i8, e16)), this._nodeId2MetaReloading.forEach((t13, i8) => this._removeNodeStageData(i8, e16, this._nodeId2MetaReloading)), this._elevationTask = u(this._elevationTask);
    }
    removeNode(e16) {
      const t13 = this.elevationOffset;
      this._removeNodeStageData(e16, t13), this._removeNodeStageData(e16, t13, this._nodeId2MetaReloading), null != this._elevationTask && this._elevationTask.remove(e16);
    }
    _removeNodeStageData(e16, t13, i8 = this._nodeId2Meta) {
      i8.has(e16) && this._controller.updateLoadStatus(e16, false);
      const s8 = i8.get(e16);
      null != s8 ? (this._collection.setObjectVisibility(s8.objectHandle, false), null != this._edgeView && this._edgeView.hasObject(s8.objectHandle) && this._edgeView.updateObjectVisibility(s8.objectHandle, false).catch((e17) => Dt(e17, this.i3slayer.title)), this._visibleGeometryChanged(s8, Tt.REMOVE), null != this._labeler && this._labeler.removeNodeMeta(s8), i8.delete(e16), this._highlights.objectDeleted(s8), i8 === this._nodeId2Meta ? (this._cacheGPUData(s8, t13), this.nodeCrossfadingEnabled && this._crossfadeHelper.stopNodeFading(s8)) : this._deleteComponentObject(s8), null != this._treeDebugger && this._treeDebugger.update()) : i8.delete(e16);
    }
    _deleteComponentObject(e16) {
      if (null != this._edgeView && this._edgeView.removeObject(e16.objectHandle), this._memEstimateGeometryRemoved(e16.objectHandle), this._collection.destroyObject(e16.objectHandle), e16.textures) for (const t13 of e16.textures) this._memEstimateTextureRemoved(t13), this._stage.remove(t13);
    }
    updateNodeState(e16, t13) {
      const i8 = this._nodeId2Meta.get(e16);
      null != i8 && this._collection.updateMaterial(i8.objectHandle, (e17) => e17.polygonOffsetEnabled = t13 === c3.Hole);
    }
    updateNodeIndex(e16, t13) {
      if (this._nodeId2Meta.has(e16)) {
        const i9 = this._nodeId2Meta.get(e16);
        this._nodeId2Meta.delete(e16), this._nodeId2Meta.set(t13, i9), this.notifyChange("elevationRange");
      }
      const i8 = this._nodeId2MetaReloading.get(e16);
      i8 && (this._nodeId2MetaReloading.delete(e16), this._nodeId2MetaReloading.set(t13, i8));
    }
    _invalidateAllSymbols() {
      this._rendererVersion = de(this._rendererVersion, 1), this._controller && this._controller.requestUpdate();
    }
    _getInvalidRendererVersion() {
      return de(this._rendererVersion, -1);
    }
    _rendererChange(e16) {
      return __async(this, null, function* () {
        if (this._currentRenderer = e16, this.notifyChange("rendererTextureUsage"), this._rendererVersion = de(this._rendererVersion, 1), this._rendererFields = null, this._colorVariable = null, this._opacityVariable = null, this._invalidateAllSymbols(), e16 && (this._rendererFields = yield e16.getRequiredFields(this.i3slayer.fieldsIndex)), this._updateSymbologyFields(), !this._arcade && e16 && "arcadeRequired" in e16 && e16.arcadeRequired && (this._arcade = yield i2()), e16 && "visualVariables" in e16 && e16.visualVariables) for (const t13 of e16.visualVariables) "color" === t13.type ? this._colorVariable = t13 : "opacity" === t13.type ? this._opacityVariable = t13 : Et().warn(`Unsupported visual variable type for 3D Object Scene Services: ${t13.type}`);
        if (e16) for (const t13 of e16.getSymbols()) "mesh-3d" !== t13.type && Et().error(`Symbols of type '${t13.type}' are not supported for 3D Object Scene Services.`);
        this._controller && this._controller.requestUpdate();
      });
    }
    _getCachedEdgeMaterials(e16) {
      return this._hasComponentData && e16.cachedRendererVersion !== this._rendererVersion && this._updateCachedRendererData(e16), e16.cachedEdgeMaterials;
    }
    _getComponentParameters(e16) {
      this._hasComponentData && e16.cachedRendererVersion !== this._rendererVersion && this._updateCachedRendererData(e16);
      const t13 = e16.cachedSymbology;
      return (i8, s8) => {
        const r5 = 5 * i8;
        if (s3(s8.externalColor, t13[r5] / 255, t13[r5 + 1] / 255, t13[r5 + 2] / 255, t13[r5 + 3] / 255), null != this._stage.renderView.objectAndLayerIdRenderHelper) {
          const t14 = e16.featureIds[i8], r6 = S6(this.view.map, this.layerUid);
          this._stage.renderView.objectAndLayerIdRenderHelper.setUidToObjectAndLayerId(t14, t14, this.layerId, this.layerUid + "_" + this.sublayerId, this.layerPopupEnabledAndHasTemplate && !r6, e16.node.resources.attributes, i8, this.sublayerId), s8.objectAndLayerIdColor = this._stage.renderView.getObjectAndLayerIdColor({
            graphicUid: t14,
            layerUid: this.layerUid + "_" + this.sublayerId
          });
        }
        s8.externalColorMixMode = t13[r5 + 4] & (1 << wt.CastShadows) - 1, s8.castShadows = !!(t13[r5 + 4] & 1 << wt.CastShadows), s8.pickable = !!(t13[r5 + 4] & 1 << wt.Pickable), s8.elevationOffset = e16.elevationOffsets?.[i8] ?? 0;
      };
    }
    _getSymbolInfo(e16, t13) {
      const i8 = e16?.getSymbol(t13, {
        arcade: this._arcade
      });
      if (!(i8 instanceof k)) return null;
      const s8 = i8.id;
      if (this._symbolInfos.has(s8)) return this._symbolInfos.get(s8);
      const r5 = me(i8);
      return this._symbolInfos.set(s8, r5), r5;
    }
    _setSymbologyOverride(e16, t13) {
      this._symbologyOverride !== e16 && (this._symbologyOverride = e16, this._symbologyOverrideFields = t13, this._invalidateAllSymbols(), this._updateSymbologyFields());
    }
    _updateSymbologyFields() {
      this._symbologyFields = null != this._symbologyOverrideFields && this._symbologyOverrideFields.length > 0 ? null != this._rendererFields && this._rendererFields.length > 0 ? I5(this.i3slayer.fieldsIndex, [...this._rendererFields, ...this._symbologyOverrideFields]) : this._symbologyOverrideFields : this._rendererFields;
    }
    _updateCachedRendererData(e16) {
      if (e16.cachedRendererVersion = this._rendererVersion, !this._hasComponentData) return;
      const t13 = this._tmpAttributeOnlyGraphic, i8 = {};
      t13.attributes = i8;
      const s8 = this._currentRenderer, r5 = e16.attributeInfo?.attributeData, o10 = null != e16.featureIds ? this.i3slayer.objectIdField : null, n14 = null != r5 && null != this._symbologyFields && this._symbologyFields.length > 0;
      let a9 = null, l5 = null;
      if (n14 && null != this._symbologyFields) {
        a9 = [], l5 = [];
        for (const e17 of this._symbologyFields) {
          const t14 = r5[e17];
          t14 && (a9.push(e17), l5.push(t14));
        }
      }
      e16.cachedSymbology || (e16.cachedSymbology = e14(5 * e16.featureIds.length));
      const d5 = {
        color: Ht,
        castShadows: true,
        pickable: true,
        colorMixMode: n7.Multiply,
        edgeMaterial: null
      }, h8 = this.fullOpacity, c7 = this.nodeCrossfadingEnabled ? this.getNodeOpacity(e16) : h8;
      let u9 = null, _2 = A2.OPAQUE, g3 = fe, m4 = 0;
      for (let p2 = 0; p2 < e16.featureIds.length; p2++) {
        if (null != o10 && (i8[o10] = e16.featureIds[p2]), n14 && a9) for (let e17 = 0; e17 < a9.length; e17++) i8[a9[e17]] = Q(l5[e17], p2);
        const r6 = s8 ? this._getSymbolInfo(s8, t13) : null;
        let h9 = null, f3 = null;
        if (s8 && "visualVariables" in s8) {
          if (this._colorVariable) {
            const e17 = m2(this._colorVariable, t13, {
              color: Ut,
              arcade: this._arcade
            });
            e17 && (h9 = Ht, h9[0] = e17.r / 255, h9[1] = e17.g / 255, h9[2] = e17.b / 255, this._opacityVariable || null === e17.a || (f3 = e17.a));
          }
          this._opacityVariable && (f3 = b2(this._opacityVariable, t13, {
            arcade: this._arcade
          }));
        }
        if (r6?.material) {
          const e17 = r6.material;
          h9 = null == h9 || null == f3 ? A5(h9, f3, e17.color, e17.alpha, Ot, Ht) : A5(h9, f3, null, null, Ot, Ht);
        }
        if (null == h9 && (h9 = Ht, h9[0] = 1, h9[1] = 1, h9[2] = 1, h9[3] = 1), d5.pickable = true, d5.castShadows = !r6 || r6.castShadows, d5.colorMixMode = r6?.material ? r6.material.colorMixMode : n7.Multiply, d5.edgeMaterial = r6 ? r6.edgeMaterial : null, null != this._symbologyOverride && (d5.color = h9, this._symbologyOverride(t13, d5), h9 = d5.color), null != this._nodeColorOverride && (this._nodeColorOverride(e16.node, h9), d5.colorMixMode = n7.Replace), null != d5.edgeMaterial) {
          const t14 = h9[3] <= 0 ? A2.INVISIBLE : h9[3] >= 1 && (e16.material.isOpaque || d5.colorMixMode === n7.Replace) ? A2.OPAQUE : A2.TRANSPARENT;
          d5.edgeMaterial === u9 && t14 === _2 || (g3 = __spreadProps(__spreadValues({}, d5.edgeMaterial), {
            opacity: c7,
            objectTransparency: t14
          }), u9 = d5.edgeMaterial, _2 = t14), e16.cachedEdgeMaterials[p2] = g3;
        } else e16.cachedEdgeMaterials[p2] = fe;
        e16.cachedSymbology[m4++] = Math.round(255 * h9[0]), e16.cachedSymbology[m4++] = Math.round(255 * h9[1]), e16.cachedSymbology[m4++] = Math.round(255 * h9[2]), e16.cachedSymbology[m4++] = Math.round(255 * h9[3]), e16.cachedSymbology[m4++] = d5.colorMixMode | +d5.castShadows << wt.CastShadows | +d5.pickable << wt.Pickable;
      }
    }
    _getFilteredEdgeMaterials(e16) {
      const t13 = this._getCachedEdgeMaterials(e16);
      this.nodeCrossfadingEnabled || Kt(t13, this.fullOpacity);
      const i8 = e16.filteredIds;
      if (null == i8) {
        return {
          hasEdges: t13.some((e17) => e17 !== fe),
          perFeatureEdgeMaterials: t13
        };
      }
      let s8 = 0, r5 = false;
      const o10 = t13.map((t14, o11) => e16.featureIds[o11] !== i8[s8] ? fe : (r5 = r5 || t14 !== fe, s8++, t14));
      return {
        hasEdges: r5,
        perFeatureEdgeMaterials: o10
      };
    }
    _updateComponentData(e16) {
      if (!this._hasComponentData) return;
      const t13 = e16.objectHandle, i8 = this._getComponentParameters(e16);
      this._collection.setComponentData(t13, i8), this._stage.renderView.requestRender();
    }
    _reloadAll(e16 = this.elevationOffset) {
      this._removeAllNodeDataFromStage(e16), null != this._controller && this._controller.restartNodeLoading();
    }
    _opacityChange(e16) {
      this.nodeCrossfadingEnabled && this._crossfadeHelper.stopAllNodeFading(), this._nodeId2Meta.forEach((t13) => {
        null != t13 && (this._collection.updateMaterial(t13.objectHandle, (t14) => t14.objectOpacity = e16), Kt(t13.cachedEdgeMaterials, e16), this._updateEdgeRendering(t13));
      });
    }
    _updateMaterial(e16) {
      this._collection.updateMaterial(e16.objectHandle, (e17) => {
        e17.commonMaterialParameters.hasSlicePlane = this.slicePlaneEnabled, e17.usePBR = this._usePBR, this._updateMaterialOverlay(e17);
      });
    }
    _updateMaterialOverlay(e16) {
    }
    _updateEngineObject(e16) {
      this._updateComponentData(e16), this._applyFiltersToNode(e16), this._addOrUpdateEdgeRendering(e16), this._visibleGeometryChanged(e16, Tt.UPDATE);
    }
    _slicePlaneEnabledChange(e16) {
      this._intersectionHandler && (this._intersectionHandler.slicePlaneEnabled = e16), null != this._labeler && (this._labeler.slicePlaneEnabled = e16), this._nodeId2Meta.forEach((t13) => {
        null != t13 && (this._collection.updateMaterial(t13.objectHandle, (t14) => t14.commonMaterialParameters.hasSlicePlane = e16), this._updateEdgeRendering(t13, false));
      });
    }
    _updatePBR(e16) {
      this._nodeId2Meta.forEach((t13) => {
        null != t13 && this._collection.updateMaterial(t13.objectHandle, (t14) => t14.usePBR = e16);
      }), this._hasLoadedPBRTextures = true;
    }
    get _usePBR() {
      return this._needsNormals && this.view.qualitySettings.physicallyBasedRenderingEnabled;
    }
    _updateEdgeRendering(e16, t13 = true) {
      null != this._edgeView && this._edgeView.hasObject(e16.objectHandle) && this._addOrUpdateEdgeRendering(e16, t13);
    }
    _forAllNodes(e16) {
      this._nodeId2Meta.forEach(e16);
    }
    _ignoreClientNodeOverriddenFeatures(e16) {
      return this.i3sOverrides.hasGeometryChanges ? (t13, i8, s8) => s8.node.index >= 0 && this.i3sOverrides.featureHasGeometryChanges(t13) ? o6.CONTINUE : e16(t13, i8, s8) : e16;
    }
    _forAllFeatures(e16, t13, i8) {
      n2(this._nodeId2Meta, (s8) => {
        if (null == s8) return false;
        if (null != t13) {
          switch (t13(s8)) {
            case o6.EXIT:
              return true;
            case o6.SKIP:
              return false;
          }
        }
        let r5 = o6.CONTINUE;
        switch (i8) {
          case n10.ALL:
            r5 = this._forAllFeaturesOfNode(s8, e16);
            break;
          case n10.VISIBLE_ONLY:
            r5 = this._forAllVisibleFeaturesOfNode(s8, e16);
            break;
          case n10.QUERYABLE:
            r5 = this._forAllQueryableFeaturesOfNode(s8, e16);
        }
        return r5 === o6.EXIT;
      });
    }
    _forAllFeaturesOfNode(e16, t13) {
      let i8 = o6.CONTINUE;
      const s8 = e16.featureIds;
      for (let r5 = 0; r5 < s8.length; r5++) if (i8 = t13(s8[r5], r5, e16), i8 === o6.EXIT) return i8;
      return i8;
    }
    _forAllVisibleFeaturesOfNode(e16, t13) {
      let i8 = o6.CONTINUE;
      const s8 = e16.featureIds;
      return this._collection.forEachVisibleComponent(e16.objectHandle, (r5) => (i8 = t13(s8[r5], r5, e16), i8 === o6.CONTINUE)), i8;
    }
    _forAllQueryableFeaturesOfNode(e16, t13) {
      const i8 = this._ignoreClientNodeOverriddenFeatures(t13);
      if (null == this._renderClippingArea) return this._forAllFeaturesOfNode(e16, i8);
      const s8 = this._boundingRectNodeTest(e16, this._renderClippingArea);
      if (s8 === F.OUTSIDE) return o6.CONTINUE;
      if (s8 === F.INSIDE) return this._forAllFeaturesOfNode(e16, i8);
      const r5 = o6.CONTINUE, o10 = e16.featureIds, n14 = e16.objectHandle, a9 = q(this._renderClippingArea, this._collection.getObjectTransform(n14));
      for (let l5 = 0; l5 < o10.length; l5++) {
        if (!this._boundingRectFeatureTest(e16, l5, a9)) continue;
        const t14 = i8(o10[l5], l5, e16);
        if (t14 === o6.EXIT) return t14;
      }
      return r5;
    }
    _createAttributes(e16, t13) {
      const i8 = {};
      null != t13.featureIds && (i8[this._getObjectIdField()] = t13.featureIds[e16]);
      const s8 = t13.attributeInfo?.attributeData;
      if (null != s8) for (const r5 of Object.keys(s8)) i8[r5] = Q(s8[r5], e16);
      return i8;
    }
    _createGraphic(e16, t13) {
      return this._createLayerGraphic(this._createAttributes(e16, t13));
    }
    highlight(e16) {
      if ("number" == typeof e16 || e16 instanceof d2 ? e16 = [e16] : e16 instanceof V && (e16 = e16.toArray()), Array.isArray(e16) && e16.length > 0) {
        if (e16[0] instanceof d2) {
          const t13 = e16, i8 = this.i3slayer.fieldsIndex, s8 = this._getObjectIdField(), r5 = t13.map((e17) => n9(i8, e17.attributes, s8)), {
            set: o10,
            handle: n14
          } = this._highlights.acquireSet();
          return this._highlights.setFeatureIds(o10, r5), n14;
        }
        if ("number" == typeof e16[0]) {
          const t13 = e16, {
            set: i8,
            handle: s8
          } = this._highlights.acquireSet();
          return this._highlights.setFeatureIds(i8, t13), s8;
        }
      }
      return e();
    }
    resetHighlights() {
      u(this._highlights), this._highlights = new h7({
        collection: this._collection,
        forAllFeatures: (e16) => this._forAllFeatures(e16, null, n10.ALL),
        forAllFeaturesOfNode: (e16, t13) => this._forAllFeaturesOfNode(e16, t13)
      });
    }
    _visibleGeometryChanged(e16, t13) {
      if (!this._elevationProvider) return;
      const i8 = this.getNodeComponentObb(e16.node);
      i8 && this._elevationProvider.objectChanged(i8), null == this._visibleGeometryChangedSchedulerHandle && (this._visibleGeometryChangedSchedulerHandle = v(() => {
        this.emit("visible-geometry-changed"), this._visibleGeometryChangedSchedulerHandle = null;
      })), this._updateSnappingSources(e16, t13);
    }
    get performanceInfo() {
      return new e15(this.usedMemory, this._nodeId2Meta.size, Math.round(this._gpuMemoryEstimate / 1048576), Math.round(this._geoMemoryEstimate / 1048576), Math.round(this._texMemoryEstimate / 1048576), Math.round(this.unloadedMemory / 1048576), this._idbCacheEnabled ? Math.round(100 * this._idbCache.getHitRate()) : 0);
    }
    get test() {
    }
    getNodeOpacityByIndex(e16) {
      const t13 = this._nodeId2Meta.get(e16);
      return this.getNodeOpacity(t13);
    }
    getNodeOpacity(e16) {
      return null != e16 ? this._collection.getMaterial(e16.objectHandle).objectOpacity : 0;
    }
    isNodeFullyFadedIn(e16) {
      return this._crossfadeHelper.isNodeFullyFadedIn(e16);
    }
    getNodeCrossfadeMetaData(e16) {
      return this._nodeId2Meta.get(e16);
    }
    markNodeToRemove(e16) {
      this._controller && this._controller.markNodeToRemove(e16);
    }
    removeMarkedNodes() {
      this._controller && this._controller.removeMarkedNodes();
    }
    foreachCrossfadeNode(e16) {
      this._nodeId2Meta.forEach(e16);
    }
    fadeNode(e16, t13, i8) {
      if (!this.nodeCrossfadingEnabled) return;
      const s8 = this._nodeId2Meta.get(e16);
      null != s8 && this._crossfadeHelper.fadeNode(e16, s8, t13, i8);
    }
    setNodeOpacityByIndex(e16, t13) {
      const i8 = this._nodeId2Meta.get(e16);
      null != i8 && this._setNodeOpacity(i8, t13);
    }
    _setNodeOpacity(e16, t13) {
      this._collection.updateMaterial(e16.objectHandle, (e17) => e17.objectOpacity = t13), this._setNodeEdgeOpacity(e16, t13);
    }
    _setNodeEdgeOpacity(e16, t13) {
      if (null == this._edgeView || !e16.cachedEdgeMaterials) return;
      Kt(e16.cachedEdgeMaterials, t13);
      const i8 = e16.objectHandle;
      this._edgeView.hasObject(i8) && this._edgeView.updateAllComponentOpacities(i8, t13).catch((e17) => Dt(e17, this.i3slayer.title));
    }
    get hasModifications() {
      return this._isIntegratedMesh && null != this._layerClippingArea || this._modifications && this._modifications.length > 0;
    }
    updateNodeModificationStatus(e16) {
      const t13 = e16.length;
      if (!this.hasModifications || t13 <= 0 || true !== this._i3sWasmLoaded) return;
      const i8 = this.uid, s8 = zt(e16);
      if (s8) {
        const t14 = {
          context: i8,
          buffer: s8.buffer
        };
        L2(t14);
        const r5 = new Float64Array(s8.buffer);
        e16.forAll((e17, t15) => {
          const i9 = r5[t15], s9 = A4(i9);
          e17.imModificationImpact = s9, s9 !== r3.Unmodified && this._controller.invalidateGeometryVisibility(e17.index);
        });
      }
    }
    notifyUpdate() {
      this.notifyChange("updating");
    }
    notifyLODUpdate() {
      this._controller.notifyLODUpdate();
    }
    isUpdating() {
      return !(!this._controller || !this._controller.updating) || !!this._visibleGeometryChangedSchedulerHandle || null != this._labeler && this._labeler.updating || this._crossfadeHelper?.updating || this._i3sWasmLoaded instanceof Promise || this._asyncModuleLoading > 0 || null != this._elevationTask && this._elevationTask.running;
    }
    trackSnappingSources(e16) {
      const t13 = {
        events: e16,
        fetchEdgeLocations: (e17, t14, i8) => __async(this, null, function* () {
          const s8 = this._nodeId2Meta.get(e17);
          if (null == s8) throw new Error("invalid-node");
          const {
            origin: r5,
            buffer: o10
          } = yield this._collection.extractEdgeInformation(s8.objectHandle, t14, i8);
          return this._snappingLocationsApplyElevation(s8, o10, r5), {
            type: "components",
            objectIds: s8.featureIds,
            locations: o10,
            origin: r5
          };
        }),
        remove: () => S(this._snappingSourcesTrackers, t13)
      };
      return this._snappingSourcesTrackers.push(t13), this._nodeId2Meta.forEach((t14, i8) => {
        if (null == t14) return;
        const s8 = this._controller.getRenderMbs(t14.node);
        s8 && e16.add(i8, s8);
      }), t13;
    }
    _snappingLocationsApplyElevation(e16, t13, i8) {
      if (!e16.elevationOffsets || this.elevationInfo.mode === E4.Absolute) return;
      const s8 = t13.position0, r5 = t13.position1, o10 = t13.componentIndex, n14 = n3(), a9 = n3(), l5 = (e17, t14) => {
        u2(e17, e17, i8), this.view.renderCoordsHelper.worldUpAtPosition(e17, a9), u2(e17, e17, g(a9, a9, t14)), e4(e17, e17, i8);
      };
      for (let d5 = 0; d5 < s8.count; d5++) {
        const t14 = e16.elevationOffsets[o10.get(d5)];
        s8.getVec(d5, n14), l5(n14, t14), s8.setVec(d5, n14), r5.getVec(d5, n14), l5(n14, t14), r5.setVec(d5, n14);
      }
    }
    _updateSnappingSources(e16, t13) {
      const {
        index: i8
      } = e16.node, s8 = this._controller.getRenderMbs(e16.node);
      if (null != s8) for (const r5 of this._snappingSourcesTrackers) t13 !== Tt.REMOVE && t13 !== Tt.UPDATE || r5.events.remove(i8), t13 !== Tt.ADD && t13 !== Tt.UPDATE || r5.events.add(i8, s8);
    }
  };
  return e3([y()], o9.prototype, "_hasLoadedPBRTextures", void 0), e3([y()], o9.prototype, "_asyncModuleLoading", void 0), e3([y()], o9.prototype, "_visibleGeometryChangedSchedulerHandle", void 0), e3([y()], o9.prototype, "view", void 0), e3([y()], o9.prototype, "i3slayer", void 0), e3([y()], o9.prototype, "_controller", void 0), e3([y()], o9.prototype, "_labeler", void 0), e3([y()], o9.prototype, "updating", void 0), e3([y()], o9.prototype, "suspended", void 0), e3([y()], o9.prototype, "contentVisible", null), e3([y({
    readOnly: true
  })], o9.prototype, "legendEnabled", null), e3([y()], o9.prototype, "holeFilling", void 0), e3([y(t8)], o9.prototype, "updatingProgress", void 0), e3([y()], o9.prototype, "updatingProgressValue", null), e3([y()], o9.prototype, "hasTexturesOrVertexColors", null), e3([y()], o9.prototype, "rendererTextureUsage", null), e3([y()], o9.prototype, "elevationOffset", null), e3([y()], o9.prototype, "elevationInfo", null), e3([y({
    type: Boolean
  })], o9.prototype, "slicePlaneEnabled", void 0), e3([y()], o9.prototype, "supportedTextureEncodings", null), e3([y()], o9.prototype, "uncompressedTextureDownsamplingEnabled", null), e3([y({
    type: [f]
  })], o9.prototype, "_modifications", void 0), e3([y({
    readOnly: true
  })], o9.prototype, "clientGeometry", null), e3([y()], o9.prototype, "elevationRange", null), e3([y()], o9.prototype, "fullExtent", null), e3([y()], o9.prototype, "_elevationTask", void 0), e3([y({
    readOnly: true
  })], o9.prototype, "_usePBR", null), o9 = e3([a(xt)], o9), o9;
};
function Dt(e16, t12) {
  b(e16) || Et().warn("Error while processing edges. Edges on this layer might not display correctly", t12, e16);
}
var Tt;
!function(e16) {
  e16[e16.ADD = 0] = "ADD", e16[e16.REMOVE = 1] = "REMOVE", e16[e16.UPDATE = 2] = "UPDATE";
}(Tt || (Tt = {}));
var Nt = i();
var Vt = u3();
var Ft = u3();
var Pt = new I3();
var Ht = [0, 0, 0, 0];
var Ut = new u4([0, 0, 0, 0]);
var Gt = Z(0, 0, 0, 0);
function Lt(e16) {
  if (null == e16) return false;
  const t12 = e16.metallicRoughness;
  return t12 && t12.baseColorTextureId >= 0 || t12 && t12.metallicRoughnessTextureId >= 0 || e16.normalTextureId >= 0 || e16.emissiveTextureId >= 0 || e16.occlusionTextureId >= 0;
}
function kt(e16) {
  return "geometryData" in e16;
}
function Bt(e16) {
  return null != e16 && t(e16.data);
}
function qt(e16, t12) {
  let i8 = 1024 + e16.interleavedVertexData.byteLength + (e16.indices ? e16.indices.byteLength : 0) + e16.positionData.data.byteLength + e16.positionData.indices.byteLength;
  if (null != t12) for (const s8 of t12) null != s8 && t(s8.data) && (i8 += s8.data.byteLength);
  return i8;
}
function Wt(e16, t12) {
  return t12.byteSize > St ? (Et().warn(`Node is too big to store in IndexedDB cache: ${e16.id} (${t12.byteSize} bytes)`), false) : t12.byteSize > 0;
}
function zt(e16) {
  if (0 === e16.length) return;
  const t12 = 10 * e16.length, i8 = new Float64Array(t12);
  let s8 = 0;
  return e16.forAll((e17) => {
    let t13 = e17.serviceObbInIndexSR;
    null == t13 && (t13 = Pt, t13.center = V2(e17.serviceMbsInIndexSR), t13.halfSize = [e17.serviceMbsInIndexSR[3], e17.serviceMbsInIndexSR[3], e17.serviceMbsInIndexSR[3]]);
    const r5 = t13.data;
    i8[s8++] = r5[0], i8[s8++] = r5[1], i8[s8++] = r5[2], i8[s8++] = r5[3], i8[s8++] = r5[4], i8[s8++] = r5[5], i8[s8++] = r5[6], i8[s8++] = r5[7], i8[s8++] = r5[8], i8[s8++] = r5[9];
  }), i8;
}
function Kt(e16, t12) {
  e16.forEach((e17) => e17.opacity = t12);
}
var $t = class {
  constructor(e16, t12) {
    this.mode = e16, this.offset = t12;
  }
};
var Qt = n3();
var Xt = i();
var Yt = "elevation-change";
var Jt = [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]];
var Zt = new e10();
function ei(e16, t12, i8) {
  let s8 = e16.elevationRangeMin, r5 = e16.elevationRangeMax;
  const o9 = i8;
  if (o9 > 0) {
    t12.getCorners(Jt);
    for (const e17 of Jt) {
      const t13 = Y(e17) - o9;
      s8 = Math.min(s8, t13), r5 = Math.max(r5, t13);
    }
  } else {
    t12.getCorners(Jt);
    for (const e17 of Jt) {
      const t13 = e17[2];
      s8 = Math.min(s8, t13), r5 = Math.max(r5, t13);
    }
  }
  e16.expandElevationRangeValues(s8, r5);
}
function ti(e16, t12, i8) {
  const s8 = V2(t12), r5 = i8 > 0 ? Y(s8) - i8 : s8[2], o9 = N(t12);
  e16.expandElevationRangeValues(r5 - o9, r5 + o9);
}

export {
  u7 as u,
  n10 as n,
  o6 as o,
  At
};
//# sourceMappingURL=chunk-33OC6OD3.js.map
