{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/views/2d/engine/imagery/enums.js", "../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/raster/Colormap.glsl.js", "../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/raster/Projection.glsl.js", "../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/raster/Common.glsl.js", "../../../../../../node_modules/@arcgis/core/chunks/RasterColorizer.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nvar t, e;\n!function (t) {\n  t[t.Stretch = 0] = \"Stretch\", t[t.Lut = 1] = \"Lut\", t[t.Hillshade = 2] = \"Hillshade\", t[t.COUNT = 3] = \"COUNT\";\n}(t || (t = {})), function (t) {\n  t[t.Noop = 0] = \"Noop\", t[t.PerBand = 1] = \"PerBand\", t[t.COUNT = 2] = \"COUNT\";\n}(e || (e = {}));\nexport { e as RasterColorizerStretchType, t as RasterColorizerType };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { FloatPassUniform as o } from \"../../shaderModules/FloatPassUniform.js\";\nimport { glsl as e } from \"../../shaderModules/interfaces.js\";\nimport { Texture2DPassUniform as r } from \"../../shaderModules/Texture2DPassUniform.js\";\nfunction l(l) {\n  l.fragment.uniforms.add(new r(\"u_colormap\", o => o.u_colormap), new o(\"u_colormapOffset\", o => o.colormap.u_colormapOffset), new o(\"u_colormapMaxIndex\", o => o.colormap.u_colormapMaxIndex), new o(\"u_opacity\", o => o.common.u_opacity)), l.fragment.code.add(e`vec4 colormap(vec4 currentPixel, bool isFloat) {\nfloat colorIndex = isFloat ? currentPixel.r - u_colormapOffset : currentPixel.r * 255.0 - u_colormapOffset;\nvec4 result;\nif (currentPixel.a == 0.0 || colorIndex > u_colormapMaxIndex) {\nresult = vec4(0.0, 0.0, 0.0, 0.0);\n} else {\nvec2 texelCoordinates = vec2((colorIndex + 0.5), 0.5);\nresult = texelFetch(u_colormap, ivec2(texelCoordinates), 0);\n}\nreturn result;\n}`);\n}\nexport { l as Colormap };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { Float2PassUniform as o } from \"../../shaderModules/Float2PassUniform.js\";\nimport { glsl as r } from \"../../shaderModules/interfaces.js\";\nimport { Texture2DPassUniform as e } from \"../../shaderModules/Texture2DPassUniform.js\";\nfunction t(t) {\n  t.fragment.uniforms.add(new e(\"u_transformGrid\", o => o.u_transformGrid), new o(\"u_transformSpacing\", o => o.common.u_transformSpacing), new o(\"u_targetImageSize\", o => o.common.u_targetImageSize)), t.fragment.code.add(r`vec2 projectPixelLocation(vec2 coords) {\nvec2 index_image = floor(coords * u_targetImageSize);\nvec2 oneTransformPixel = vec2(4.0, 1.0);\nvec2 index_transform = floor(index_image / u_transformSpacing) * oneTransformPixel;\nvec2 pos = fract((index_image + 0.5) / u_transformSpacing);\nvec2 transform_location = index_transform + 0.5;\nvec2 srcLocation;\nif (pos.s <= pos.t) {\nvec3 ll_abc = texelFetch(u_transformGrid, ivec2(transform_location), 0).rgb;\nvec3 ll_def = texelFetch(u_transformGrid, ivec2(transform_location.s + 1.0, transform_location.t), 0).rgb;\nsrcLocation.s = dot(ll_abc, vec3(pos, 1.0));\nsrcLocation.t = dot(ll_def, vec3(pos, 1.0));\n} else {\nvec3 ur_abc = texelFetch(u_transformGrid, ivec2(transform_location.s + 2.0, transform_location.t), 0).rgb;\nvec3 ur_def = texelFetch(u_transformGrid, ivec2(transform_location.s + 3.0, transform_location.t), 0).rgb;\nsrcLocation.s = dot(ur_abc, vec3(pos, 1.0));\nsrcLocation.t = dot(ur_def, vec3(pos, 1.0));\n}\nreturn srcLocation;\n}`);\n}\nexport { t as Projection };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { Projection as o } from \"./Projection.glsl.js\";\nimport { TileCompositePassParameters as e } from \"../terrain/TileComposite.glsl.js\";\nimport { BooleanPassUniform as r } from \"../../shaderModules/BooleanPassUniform.js\";\nimport { Float2PassUniform as c } from \"../../shaderModules/Float2PassUniform.js\";\nimport { glsl as t } from \"../../shaderModules/interfaces.js\";\nimport { Texture2DPassUniform as a } from \"../../shaderModules/Texture2DPassUniform.js\";\nclass l extends e {\n  constructor(o, e, r) {\n    super(), this.common = o, this.u_image = e, this.u_transformGrid = r;\n  }\n}\nfunction i(e, l) {\n  e.include(o), e.fragment.uniforms.add(new a(\"u_image\", o => o.u_image), new r(\"u_flipY\", o => o.common.u_flipY), new r(\"u_applyTransform\", o => o.common.u_applyTransform));\n  const {\n    requireBilinearWithNN: i\n  } = l;\n  i && e.fragment.uniforms.add(new c(\"u_srcImageSize\", o => o.common.u_srcImageSize)), e.fragment.code.add(t`vec2 getPixelLocation(vec2 coords) {\nvec2 targetLocation = u_flipY ? vec2(coords.s, 1.0 - coords.t) : coords;\nif (!u_applyTransform) {\nreturn targetLocation;\n}\nreturn projectPixelLocation(targetLocation);\n}\nbool isOutside(vec2 coords){\nif (coords.t>1.00001 ||coords.t<-0.00001 || coords.s>1.00001 ||coords.s<-0.00001) {\nreturn true;\n} else {\nreturn false;\n}\n}`), i ? e.fragment.code.add(t`vec4 sampleBilinear(sampler2D sampler, vec2 coords, vec2 texSize) {\nvec2 texelStart = floor(coords * texSize);\nvec2 coord0 = texelStart / texSize;\nvec2 coord1 = (texelStart +  vec2(1.0, 0.0)) / texSize;\nvec2 coord2 = (texelStart +  vec2(0.0, 1.0)) / texSize;\nvec2 coord3 = (texelStart +  vec2(1.0, 1.0)) / texSize;\nvec4 color0 = texture(sampler, coord0);\nvec4 color1 = texture(sampler, coord1);\nvec4 color2 = texture(sampler, coord2);\nvec4 color3 = texture(sampler, coord3);\nvec2 blend = fract(coords * texSize);\nvec4 color01 = mix(color0, color1, blend.x);\nvec4 color23 = mix(color2, color3, blend.x);\nvec4 color = mix(color01, color23, blend.y);\nfloat alpha = floor(color0.a * color1.a * color2.a * color3.a + 0.5);\ncolor = color * alpha + (1.0 - alpha) * texture(sampler, coords);\nreturn color;\n}\nvec4 getPixel(vec2 pixelLocation) {\nreturn sampleBilinear(u_image, pixelLocation, u_srcImageSize);\n}`) : e.fragment.code.add(t`vec4 getPixel(vec2 pixelLocation) {\nreturn texture(u_image, pixelLocation);\n}`);\n}\nexport { i as Common, l as CommonPassParameters };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { ZEROS as e } from \"../core/libs/gl-matrix-2/factories/vec3f64.js\";\nimport { RasterColorizerType as a, RasterColorizerStretchType as o } from \"../views/2d/engine/imagery/enums.js\";\nimport { Colormap as l } from \"../views/3d/webgl-engine/core/shaderLibrary/raster/Colormap.glsl.js\";\nimport { CommonPassParameters as r, Common as i } from \"../views/3d/webgl-engine/core/shaderLibrary/raster/Common.glsl.js\";\nimport { TileBackground as t } from \"../views/3d/webgl-engine/core/shaderLibrary/terrain/TileBackground.glsl.js\";\nimport { TileComposite as u } from \"../views/3d/webgl-engine/core/shaderLibrary/terrain/TileComposite.glsl.js\";\nimport { ColorConversion as n } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { BooleanPassUniform as s } from \"../views/3d/webgl-engine/core/shaderModules/BooleanPassUniform.js\";\nimport { Float2PassUniform as c } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { FloatPassUniform as m } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { FloatsPassUniform as f } from \"../views/3d/webgl-engine/core/shaderModules/FloatsPassUniform.js\";\nimport { IntegerPassUniform as d } from \"../views/3d/webgl-engine/core/shaderModules/IntegerPassUniform.js\";\nimport { glsl as g } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as p } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as x } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nclass v extends r {\n  constructor(a, o, l, r, i, t) {\n    super(a, r, i), this.colormap = o, this.symbolizer = l, this.u_colormap = t, this.backgroundColor = e, this.fboTexture = null, this.baseOpacity = 1;\n  }\n}\nclass _ extends v {}\nclass y extends v {}\nfunction h(e) {\n  const o = new p();\n  return o.include(u), o.include(i, e), o.include(l, e), o.include(t, e), o.fragment.code.add(g`vec4 applyBackgroundBlend(vec4 layerColor) {\nreturn blendLayers(vuv, layerColor, u_opacity);\n}`), e.colorizerType === a.Stretch ? C(o, e) : e.colorizerType === a.Lut ? b(o) : e.colorizerType === a.Hillshade && w(o, e), o;\n}\nfunction b(e) {\n  e.fragment.code.add(g`void main() {\nvec2 pixelLocation = getPixelLocation(uv);\nif (isOutside(pixelLocation)) {\nfragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\nreturn;\n}\nvec4 currentPixel = getPixel(pixelLocation);\nfragColor = applyBackgroundBlend(colormap(currentPixel, true));\n}`);\n}\nfunction C(e, a) {\n  e.fragment.uniforms.add(new d(\"u_bandCount\", e => e.symbolizer.u_bandCount), new f(\"u_minCutOff\", e => e.symbolizer.u_minCutOff, 3), new f(\"u_maxCutOff\", e => e.symbolizer.u_maxCutOff, 3), new f(\"u_factor\", e => e.symbolizer.u_factor, 3), new m(\"u_minOutput\", e => e.symbolizer.u_minOutput), new m(\"u_maxOutput\", e => e.symbolizer.u_maxOutput), new s(\"u_useGamma\", e => e.symbolizer.u_useGamma), new f(\"u_gamma\", e => e.symbolizer.u_gamma, 3), new f(\"u_gammaCorrection\", e => e.symbolizer.u_gammaCorrection, 3), new m(\"u_opacity\", e => e.common.u_opacity)), e.fragment.code.add(g`float stretchOneValue(float val, float minCutOff, float maxCutOff, float minOutput, float maxOutput, float factor, bool useGamma, float gamma, float gammaCorrection) {\nif (val >= maxCutOff) {\nreturn maxOutput;\n} else if (val <= minCutOff) {\nreturn minOutput;\n}\nfloat stretchedVal;\nif (useGamma) {\nfloat tempf = 1.0;\nfloat outRange = maxOutput - minOutput;\nfloat relativeVal = (val - minCutOff) / (maxCutOff - minCutOff);\nif (gamma > 1.0) {\ntempf -= pow(1.0 / outRange, relativeVal * gammaCorrection);\n}\nstretchedVal = (tempf * outRange * pow(relativeVal, 1.0 / gamma) + minOutput) / 255.0;\n} else {\nstretchedVal = minOutput + (val - minCutOff) * factor;\n}\nreturn stretchedVal;\n}`);\n  const l = a.applyColormap ? g`fragColor = applyBackgroundBlend(colormap(vec4(grayVal, grayVal, grayVal, currentPixel.a), !u_useGamma));` : g`fragColor = applyBackgroundBlend(vec4(grayVal, grayVal, grayVal, currentPixel.a));`;\n  e.fragment.code.add(g`\n      void main() {\n        vec2 pixelLocation = getPixelLocation(uv);\n        if (isOutside(pixelLocation)) {\n          fragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n          return;\n        }\n\n        vec4 currentPixel = getPixel(pixelLocation);\n        ${a.stretchType === o.Noop ? g`\n        fragColor = applyBackgroundBlend(currentPixel);` : g`\n        if (currentPixel.a == 0.0) {\n          fragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n          return;\n        }\n        if (u_bandCount == 1) {\n          float grayVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          ${l}\n        } else {\n          float redVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\n          float greenVal = stretchOneValue(currentPixel.g, u_minCutOff[1], u_maxCutOff[1], u_minOutput, u_maxOutput, u_factor[1], u_useGamma, u_gamma[1], u_gammaCorrection[1]);\n          float blueVal = stretchOneValue(currentPixel.b, u_minCutOff[2], u_maxCutOff[2], u_minOutput, u_maxOutput, u_factor[2], u_useGamma, u_gamma[2], u_gammaCorrection[2]);\n          fragColor = applyBackgroundBlend(vec4(redVal, greenVal, blueVal, currentPixel.a));\n        }`}\n      }`);\n}\nfunction w(e, a) {\n  const o = e.fragment;\n  o.uniforms.add(new x(\"u_image\", e => e.u_image), new d(\"u_hillshadeType\", e => e.symbolizer.u_hillshadeType), new f(\"u_sinZcosAs\", e => e.symbolizer.u_sinZcosAs, 6), new f(\"u_sinZsinAs\", e => e.symbolizer.u_sinZsinAs, 6), new f(\"u_cosZs\", e => e.symbolizer.u_cosZs, 6), new f(\"u_weights\", e => e.symbolizer.u_weights, 6), new c(\"u_factor\", e => e.symbolizer.u_factor), new m(\"u_minValue\", e => e.symbolizer.u_minValue), new m(\"u_maxValue\", e => e.symbolizer.u_maxValue), new c(\"u_srcImageSize\", e => e.common.u_srcImageSize)), o.include(n), o.code.add(g`vec4 overlay(float val, float minValue, float maxValue, float hillshade, float alpha) {\nval = clamp((val - minValue) / (maxValue - minValue), 0.0, 1.0);\nvec4 color = colormap(vec4(val, val, val, 1.0), false);\nvec3 hsv = rgb2hsv(color.rgb);\nhsv.z = hillshade;\nreturn vec4(hsv2rgb(hsv), 1.0) * alpha * color.a;\n}`), o.code.add(g`float getNeighborHoodAlpha(float a, float b, float c, float d, float e, float f, float g, float h, float i){\nif (a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0 || a == 0.0 || a == 0.0 || a==0.0) {\nreturn 0.0;\n}  else {\nreturn e;\n}\n}`);\n  const l = a.applyColormap ? g`fragColor = applyBackgroundBlend(overlay(ve.r, u_minValue, u_maxValue, hillshade, alpha));` : g`hillshade *= alpha;\nfragColor = applyBackgroundBlend(vec4(hillshade, hillshade, hillshade, alpha));`;\n  o.code.add(g`\n    void main() {\n      vec2 pixelLocation = getPixelLocation(uv);\n      if (isOutside(pixelLocation)) {\n        fragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n        return;\n      }\n\n      vec4 currentPixel = getPixel(pixelLocation);\n      if (currentPixel.a == 0.0) {\n        fragColor = applyBackgroundBlend(vec4(0.0, 0.0, 0.0, 0.0));\n        return;\n      }\n\n      //mirror edge pixels\n      vec2 axy = vec2(-1.0, -1.0);\n      vec2 bxy = vec2(0.0, -1.0);\n      vec2 cxy = vec2(1.0, -1.0);\n      vec2 dxy = vec2(-1.0, 0.0);\n      vec2 fxy = vec2(1.0, 0.0);\n      vec2 gxy = vec2(-1.0, 1.0);\n      vec2 hxy = vec2(0.0, 1.0);\n      vec2 ixy = vec2(1.0, 1.0);\n      vec2 onePixel = 1.0 / u_srcImageSize;\n      if (pixelLocation.s < onePixel.s) {\n        axy[0] = 1.0;\n        dxy[0] = 1.0;\n        gxy[0] = 1.0;\n      }\n      if (pixelLocation.t < onePixel.t) {\n        axy[1] = 1.0;\n        bxy[1] = 1.0;\n        cxy[1] = 1.0;\n      }\n      if (pixelLocation.s > 1.0 - onePixel.s) {\n        cxy[0] = -1.0;\n        fxy[0] = -1.0;\n        ixy[0] = -1.0;\n      }\n      if (pixelLocation.t > 1.0 - onePixel.t) {\n        gxy[1] = -1.0;\n        hxy[1] = -1.0;\n        ixy[1] = -1.0;\n      }\n\n      // calculate hillshade\n      vec4 va = texture(u_image, pixelLocation + onePixel * axy);\n      vec4 vb = texture(u_image, pixelLocation + onePixel * bxy);\n      vec4 vc = texture(u_image, pixelLocation + onePixel * cxy);\n      vec4 vd = texture(u_image, pixelLocation + onePixel * dxy);\n      vec4 ve = texture(u_image, pixelLocation);\n      vec4 vf = texture(u_image, pixelLocation + onePixel * fxy);\n      vec4 vg = texture(u_image, pixelLocation + onePixel * gxy);\n      vec4 vh = texture(u_image, pixelLocation + onePixel * hxy);\n      vec4 vi = texture(u_image, pixelLocation + onePixel * ixy);\n\n      // calculate the rate of z change along the x, y, and diagonal direction\n      float dzx = (vc + 2.0 * vf + vi - va - 2.0 * vd - vg).r * u_factor.s;\n      float dzy = (vg + 2.0 * vh + vi - va - 2.0 * vb - vc).r * u_factor.t;\n      float dzd = sqrt(1.0 + dzx * dzx + dzy * dzy);\n      float hillshade = 0.0;\n\n      // traditional single light source\n      if (u_hillshadeType == 0){\n        float cosDelta = u_sinZsinAs[0] * dzy - u_sinZcosAs[0] * dzx;\n        float z = (u_cosZs[0] + cosDelta) / dzd;\n        if (z < 0.0)  z = 0.0;\n        hillshade = z;\n      } else {\n        // multi-directional with 6 light sources\n        for (int k = 0; k < 6; k++) {\n        float cosDelta = u_sinZsinAs[k] * dzy - u_sinZcosAs[k] * dzx;\n        float z = (u_cosZs[k] + cosDelta) / dzd;\n        if (z < 0.0) z = 0.0;\n        hillshade = hillshade + z * u_weights[k];\n        if (k == 5) break;\n        }\n      }\n\n      // set color\n      float alpha = getNeighborHoodAlpha(va.a, vb.a, vc.a, vd.a, ve.a, vf.a, vg.a, vh.a, vi.a);\n      alpha *= u_opacity;\n      ${l}\n    }\n  `);\n}\nconst z = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  ColorizerHillshadeUniforms: y,\n  ColorizerStretchUniforms: _,\n  ColorizerUniforms: v,\n  build: h\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { v as C, z as R, _ as a, y as b, h as c };"],
  "mappings": "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",
  "names": ["e", "t", "l", "o", "t", "o", "l", "o", "e", "t", "s", "i", "l", "a", "o", "i", "t", "e", "s"]
}
