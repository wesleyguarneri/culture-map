{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/views/3d/environment/CloudsTechniqueConfiguration.js", "../../../../../../node_modules/@arcgis/core/views/3d/environment/CloudsPresets.js", "../../../../../../node_modules/@arcgis/core/chunks/Clouds.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { _ as e } from \"../../../chunks/tslib.es6.js\";\nimport has from \"../../../core/has.js\";\nimport { CloudsTextureChannels as o } from \"./CloudsData.js\";\nimport { parameter as t, ShaderTechniqueConfiguration as r } from \"../webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration.js\";\nvar s;\n!function (e) {\n  e[e.SIXTEEN = 0] = \"SIXTEEN\", e[e.HUNDRED = 1] = \"HUNDRED\", e[e.TWOHUNDRED = 2] = \"TWOHUNDRED\", e[e.COUNT = 3] = \"COUNT\";\n}(s || (s = {}));\nclass i extends r {\n  constructor() {\n    super(...arguments), this.steps = s.SIXTEEN, this.writeTextureChannels = o.RG;\n  }\n}\ne([t({\n  count: s.COUNT\n})], i.prototype, \"steps\", void 0), e([t({\n  constValue: has(\"esri-mobile\") ? 1024 : 2048\n})], i.prototype, \"cubeMapSize\", void 0), e([t()], i.prototype, \"writeTextureChannels\", void 0);\nexport { i as CloudsTechniqueConfiguration, s as RayMarchingSteps };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { RayMarchingSteps as s } from \"./CloudsTechniqueConfiguration.js\";\nclass i {\n  constructor(s, i, t, e, n, o, h, r, a = .5) {\n    this.coverage = s, this.density = i, this.absorption = t, this.cloudSize = e, this.detailSize = n, this.smoothness = o, this.cloudHeight = h, this.raymarchingSteps = r, this.median = a;\n  }\n}\nconst t = new i([0, .6], [.03, .03], [0, 0], [.9, .9], [.8, .8], [.7, .7], [.05, .05], s.SIXTEEN),\n  e = {\n    sunny: t,\n    cloudy: new i([.3, .65], [.2, .4], [0, 0], [.85, .85], [.75, .75], [.3, .4], [1, 1], s.TWOHUNDRED, .6),\n    rainy: new i([.6, .8], [.5, .8], [.1, .5], [.9, .9], [.75, .75], [.5, .5], [1, 1], s.TWOHUNDRED, .4),\n    snowy: new i([.25, .75], [.3, .3], [0, 0], [.95, .95], [.7, .7], [.69, .75], [.3, 1], s.HUNDRED, .65),\n    foggy: new i([.8, .8], [.5, .5], [0, 0], [.95, .95], [.9, .9], [.55, .55], [.3, .3], s.SIXTEEN),\n    default: t\n  };\nexport { i as CloudPresets, e as cloudPresets };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { lerp as t } from \"../core/mathUtils.js\";\nimport { create as e } from \"../core/libs/gl-matrix-2/factories/mat3f64.js\";\nimport { set as a } from \"../core/libs/gl-matrix-2/math/vec2.js\";\nimport { create as o } from \"../core/libs/gl-matrix-2/factories/vec2f64.js\";\nimport { cloudPresets as i } from \"../views/3d/environment/CloudsPresets.js\";\nimport { RayMarchingSteps as s } from \"../views/3d/environment/CloudsTechniqueConfiguration.js\";\nimport { atlasSize as n, tileRows as r, tileSize as l, textureScale as c, weatherMapScale as d } from \"../views/3d/environment/NoiseTextureAtlasDimensions.js\";\nimport { ScreenSpacePass as u } from \"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js\";\nimport { Float2PassUniform as f } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { FloatPassUniform as m } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { NoParameters as h, glsl as p } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix3PassUniform as g } from \"../views/3d/webgl-engine/core/shaderModules/Matrix3PassUniform.js\";\nimport { ShaderBuilder as v } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as y } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nclass w extends h {\n  constructor() {\n    super(...arguments), this.cloudRadius = 0, this.cloudSize = 0, this.detailSize = 0, this.absorption = 0, this.density = 0, this.smoothness = 0, this.cloudHeight = 0, this.coverage = 0, this.raymarchingSteps = i.default.raymarchingSteps, this.weatherTile = o(), this.viewMatrix = e();\n  }\n}\nfunction S(e) {\n  const o = new v();\n  o.include(u, !1);\n  const i = o.fragment;\n  return i.uniforms.add(new m(\"cloudRadius\", t => t.cloudRadius), new m(\"power\", e => t(35, 120, e.absorption)), new m(\"sigmaE\", t => 1 + t.absorption), new m(\"density\", e => t(0, .3, e.density)), new m(\"cloudSize\", e => t(0, .02, Math.max(.01, 1 - e.cloudSize))), new m(\"detailSize\", e => t(0, .2, Math.max(.01, 1 - e.detailSize))), new m(\"smoothness\", e => t(0, .5, 1 - e.smoothness)), new m(\"cloudHeight\", e => t(0, 1500, e.cloudHeight)), new m(\"coverage\", t => t.coverage), new g(\"view\", t => t.viewMatrix), new y(\"cloudShapeTexture\", t => null != t.noiseTexture ? t.noiseTexture.textureAtlas : null), new f(\"cloudVariables\", t => a(x, t.coverage, t.absorption))), i.constants.add(\"halfCubeMapSize\", \"float\", .5 * e.cubeMapSize), i.code.add(p`\n    const int STEPS = ${e.steps === s.SIXTEEN ? p`16` : e.steps === s.HUNDRED ? p`100` : p`200`};\n    const int STEPS_LIGHT = 6;\n    const float stepL = 300.0 / float(STEPS_LIGHT);\n    const float cloudStart = 1500.0;\n\n    vec3 rayDirection(vec2 fragCoord) {\n      vec2 xy = fragCoord - halfCubeMapSize;\n      return normalize(vec3(-xy, -halfCubeMapSize));\n    }\n\n    float remap(float x, float low1, float high1, float low2, float high2) {\n      return low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n    }\n\n    float saturate(float x) {\n      return clamp(x, 0.0, 1.0);\n    }`), i.code.add(p`\n    float getCloudShape(vec3 pos, float pOffset) {\n      const float textureWidth = ${p.float(n)};\n      const float dataWidth = ${p.float(n)};\n      const float tileRows = ${p.float(r)};\n      const vec3 atlasDimensions = vec3(${p.float(l)}, ${p.float(l)}, tileRows * tileRows);\n\n      //Change from Y being height to Z being height\n      vec3 p = float(${p.float(c)}) * pos.xzy;\n\n      //Pixel coordinates of point in the 3D data\n      vec3 coord = vec3(mod(p - pOffset * atlasDimensions, atlasDimensions));\n      float f = fract(coord.z);\n      float level = floor(coord.z);\n      float tileY = floor(level / tileRows);\n      float tileX = level - tileY * tileRows;\n\n      //The data coordinates are offset by the x and y tile, the two boundary cells between each tile pair and the initial boundary cell on the first row/column\n      vec2 offset = atlasDimensions.x * vec2(tileX, tileY) + 2.0 * vec2(tileX, tileY) + 1.0;\n      vec2 pixel = coord.xy + offset;\n      vec2 data = texture(cloudShapeTexture, mod(pixel, dataWidth) / textureWidth).xy;\n\n      return 1.0 - mix(data.x, data.y, f);\n    }\n\n    float getCloudMap(vec2 p){\n      // Shift the texture center to origin to avoid seam artifacts\n      vec2 uv = (${p.float(d)} * p) / ${p.float(n)} + 0.5;\n\n      return texture(cloudShapeTexture, uv).a;\n    }\n    `), i.code.add(p`float clouds(vec3 p) {\nfloat cloud = saturate(0.5 * mix(0.0, 1.0, min(2.0 * coverage, 1.0)));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat cloudMap = getCloudMap(cloudSize * p.xy);\ncloud = mix(cloud, min(2.0 * (coverage), 1.0) * cloudMap, min(2.0 * (1.0 - coverage), 1.0));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat shape = getCloudShape(8.0 * cloudSize * p, 0.0);\ncloud = saturate(remap(cloud, smoothness * shape, 1.0, 0.0, 1.0));\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nfloat heightFraction = saturate((length(p) - cloudRadius - cloudStart) / cloudHeight);\ncloud *= saturate(remap(heightFraction, 0.0, 0.25, 0.0, 1.0)) * smoothstep(1.0, 0.25, heightFraction);\nif (cloud <= 0.0) {\nreturn 0.0;\n}\nreturn density * saturate(remap(cloud, 0.35 * smoothness * getCloudShape(detailSize * p, 0.0), 1.0, 0.0, 1.0));\n}`), i.code.add(p`vec2 sphereIntersections(vec3 start, vec3 dir, float radius) {\nfloat a = dot(dir, dir);\nfloat b = 2.0 * dot(dir, start);\nfloat c = dot(start, start) - (radius * radius);\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) {\nreturn vec2(1e5, -1e5);\n}\nreturn vec2((-b - sqrt(d)) / (2.0 * a), (-b + sqrt(d)) / (2.0 * a));\n}\nfloat HenyeyGreenstein(float g, float costh) {\nreturn (1.0 / (4.0 * 3.1415))  * ((1.0 - g * g) / pow(1.0 + g * g - 2.0 * g * costh, 1.5));\n}`), i.code.add(\"\\n    float multipleOctaves(float extinction, float mu, float stepL) {\\n      float attenuation = 1.0;\\n      float contribution = 1.0;\\n      float phaseAttenuation = 1.0;\\n      float luminance = 0.0;\\n\\n      for (int i = 0; i < 4; i++) {\\n        float phase = mix(HenyeyGreenstein(0.0, mu), HenyeyGreenstein(0.3 * phaseAttenuation, mu), 0.7);\\n        luminance += contribution * phase * exp(-stepL * extinction * sigmaE * attenuation);\\n        attenuation *= 0.2;\\n        contribution *= 0.6;\\n        phaseAttenuation *= 0.5;\\n      }\\n\\n      return luminance;\\n    }\"), i.code.add(p`float lightRay(vec3 org, vec3 p, float phaseFunction, float mu, vec3 sunDirection) {\nfloat lightRayDensity = clouds(p);\nlightRayDensity += clouds(p + sunDirection * 1.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 2.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 3.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 4.0 * stepL);\nlightRayDensity += clouds(p + sunDirection * 5.0 * stepL);\nfloat beersLaw = multipleOctaves(lightRayDensity, mu, stepL);\nreturn mix(beersLaw * 2.0 * (1.0 - (exp(-stepL * lightRayDensity * 2.0 * sigmaE ))), beersLaw, 0.5 + 0.5 * mu);\n}`), i.code.add(p`float mainRay(vec3 org, vec3 dir, vec3 sunDirection, float distToStart, float totalDistance, out float totalTransmittance) {\nif (dir.z < 0.0) {\nreturn 0.0;\n}\ntotalTransmittance = 1.0;\nfloat stepS = totalDistance / float(STEPS);\nfloat cameraHeight = length(org);\nfloat mu = 0.5 + 0.5 * dot(sunDirection, dir);\nfloat phaseFunction = mix(HenyeyGreenstein(-0.3, mu), HenyeyGreenstein(0.3, mu), 0.7);\nvec3 p = org + distToStart  * dir;\nfloat dist = distToStart;\nfloat shading = 0.0;\nfor (int i = 0; i < STEPS; i++) {\nfloat sampleDensity = clouds(p);\nfloat sampleSigmaE = sampleDensity * sigmaE;\nif (sampleDensity > 0.0 ) {\nfloat ambient = mix((1.2), (1.6), saturate((length(p) - cloudRadius - cloudStart) / cloudHeight));\nfloat luminance = sampleDensity * (ambient + power * phaseFunction * lightRay(org, p, phaseFunction, mu, sunDirection));\nfloat transmittance = exp(-sampleSigmaE * stepS);\nshading += totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE;\ntotalTransmittance *= transmittance;\nif (totalTransmittance <= 0.001) {\ntotalTransmittance = 0.0;\nbreak;\n}\n}\ndist += stepS;\np = org + dir * dist;\n}\nreturn shading;\n}`), i.code.add(p`void main() {\nif (coverage ==  0.0) {\nfragColor = vec4(0.0, 1.0, 0.0, 1.0);\nreturn;\n}\nvec3 rayDir = rayDirection(gl_FragCoord.xy);\nrayDir = normalize(view * rayDir);\nvec3 viewPos = vec3(0, 0, cloudRadius + 1.0);\nbool hitsPlanet = rayDir.z < 0.0;\nfloat hazeFactor = smoothstep(-0.01, mix(0.0, 0.075, cloudVariables.x), abs(dot(rayDir, vec3(0, 0, 1))));\nfloat totalTransmittance = 1.0;\nfloat shading = 0.0;\nif (hitsPlanet) {\nshading = clamp(1.0 - cloudVariables.y, 0.6, 1.0) * (1.0 - hazeFactor);\ntotalTransmittance = hazeFactor;\nfragColor = vec4(shading, totalTransmittance, shading, totalTransmittance);\nreturn;\n}\nvec2 rayStartIntersect = sphereIntersections(viewPos, rayDir, cloudRadius + cloudStart);\nvec2 rayEndIntersect = sphereIntersections(viewPos, rayDir, cloudRadius + cloudStart + cloudHeight);\nfloat distToStart = rayStartIntersect.y;\nfloat totalDistance = rayEndIntersect.y - distToStart;\nvec3 sunDirection = normalize(vec3(0, 0, 1));\nshading = 0.5 * mainRay(viewPos, rayDir, sunDirection, distToStart, totalDistance, totalTransmittance);\nshading = mix(clamp(1.0 - cloudVariables.y, 0.6, 1.0), shading, hazeFactor);\ntotalTransmittance = mix(0.0, totalTransmittance, hazeFactor);\nfragColor = vec4(shading, totalTransmittance, shading, totalTransmittance);\n}`), o;\n}\nconst x = o(),\n  b = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    CloudsPassParameters: w,\n    build: S\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { w as C, b as a, S as b };"],
  "mappings": "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",
  "names": ["s", "e", "i", "s", "t", "e", "n", "o", "r", "a", "n", "e", "o", "i", "t", "s", "r"]
}
