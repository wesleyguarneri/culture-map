{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/chunks/MeasurementArrow.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { addProjViewLocalOrigin as e } from \"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";\nimport { Float4PassUniform as o } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as t } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as r } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as i } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { VertexAttribute as d } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nfunction n(n) {\n  const s = new i(),\n    {\n      vertex: a,\n      fragment: l\n    } = s;\n  e(a, n), a.uniforms.add(new t(\"width\", e => e.width)), s.attributes.add(d.POSITION, \"vec3\"), s.attributes.add(d.NORMAL, \"vec3\"), s.attributes.add(d.UV0, \"vec2\"), s.attributes.add(d.LENGTH, \"float\"), s.varyings.add(\"vtc\", \"vec2\"), s.varyings.add(\"vlength\", \"float\"), s.varyings.add(\"vradius\", \"float\"), a.code.add(r`void main(void) {\nvec3 bitangent = normal;\nvtc = uv0;\nvlength = length;\nvradius = 0.5 * width;\nvec4 pos = view * vec4(position + vradius * bitangent * uv0.y, 1.0);\ngl_Position = proj * pos;\n}`), l.uniforms.add(new t(\"outlineSize\", e => e.outlineSize), new o(\"outlineColor\", e => e.outlineColor), new t(\"stripeLength\", e => e.stripeLength), new o(\"stripeEvenColor\", e => e.stripeEvenColor), new o(\"stripeOddColor\", e => e.stripeOddColor));\n  const v = 1 / Math.sqrt(2);\n  return l.code.add(r`\n    const float INV_SQRT2 = ${r.float(v)};\n\n    vec4 arrowColor(vec2 tc, float len) {\n      float d = INV_SQRT2 * (tc.x - abs(tc.y));\n      d = min(d, INV_SQRT2 * (len - tc.x - abs(tc.y)));\n      d = min(d, 1.0 - abs(tc.y));\n\n      if (d < 0.0) {\n        return vec4(0.0);\n      } else if (d < outlineSize) {\n        return outlineColor;\n      } else {\n        return fract(0.5 / stripeLength * tc.x * vradius) >= 0.5 ? stripeOddColor : stripeEvenColor;\n      }\n    }\n\n    void main(void) {\n      vec2 ntc = vec2(vtc.x / vradius, vtc.y);\n      vec4 color = arrowColor(ntc, vlength / vradius);\n      if (color.a == 0.0) {\n        discard;\n      }\n      fragColor = color;\n    }\n  `), s;\n}\nconst s = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: n\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { s as M, n as b };"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAUA,SAAS,EAAEA,IAAG;AACZ,QAAMC,KAAI,IAAIC,GAAE,GACd;AAAA,IACE,QAAQ;AAAA,IACR,UAAU;AAAA,EACZ,IAAID;AACN,IAAE,GAAGD,EAAC,GAAG,EAAE,SAAS,IAAI,IAAIE,GAAE,SAAS,CAAAC,OAAKA,GAAE,KAAK,CAAC,GAAGF,GAAE,WAAW,IAAI,EAAE,UAAU,MAAM,GAAGA,GAAE,WAAW,IAAI,EAAE,QAAQ,MAAM,GAAGA,GAAE,WAAW,IAAI,EAAE,KAAK,MAAM,GAAGA,GAAE,WAAW,IAAI,EAAE,QAAQ,OAAO,GAAGA,GAAE,SAAS,IAAI,OAAO,MAAM,GAAGA,GAAE,SAAS,IAAI,WAAW,OAAO,GAAGA,GAAE,SAAS,IAAI,WAAW,OAAO,GAAG,EAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOzT,GAAG,EAAE,SAAS,IAAI,IAAIC,GAAE,eAAe,CAAAC,OAAKA,GAAE,WAAW,GAAG,IAAIA,GAAE,gBAAgB,CAAAA,OAAKA,GAAE,YAAY,GAAG,IAAID,GAAE,gBAAgB,CAAAC,OAAKA,GAAE,YAAY,GAAG,IAAIA,GAAE,mBAAmB,CAAAA,OAAKA,GAAE,eAAe,GAAG,IAAIA,GAAE,kBAAkB,CAAAA,OAAKA,GAAE,cAAc,CAAC;AACpP,QAAM,IAAI,IAAI,KAAK,KAAK,CAAC;AACzB,SAAO,EAAE,KAAK,IAAI;AAAA,8BACU,EAAE,MAAM,CAAC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAwBrC,GAAGF;AACN;AACA,IAAM,IAAI,OAAO,OAAO,OAAO,eAAe;AAAA,EAC5C,WAAW;AAAA,EACX,OAAO;AACT,GAAG,OAAO,aAAa;AAAA,EACrB,OAAO;AACT,CAAC,CAAC;",
  "names": ["n", "s", "o", "e"]
}
