import {
  K,
  ee,
  oe
} from "./chunk-FANZDDJF.js";
import "./chunk-5I2NNRUD.js";
import {
  E,
  N
} from "./chunk-NH2TONNG.js";
import {
  p
} from "./chunk-L6LZ5TYL.js";
import "./chunk-BO5GTO4F.js";
import {
  m
} from "./chunk-ROATEOHC.js";
import "./chunk-BIWDYV6F.js";
import {
  $
} from "./chunk-4MXR7W7N.js";
import "./chunk-6UYQMUGI.js";
import "./chunk-D3XZUGMN.js";
import "./chunk-YFQ32AQX.js";
import "./chunk-L4AYSXFJ.js";
import "./chunk-POQ3T5EH.js";
import {
  j,
  x
} from "./chunk-LPEFONL3.js";
import "./chunk-SSMSHZ2C.js";
import "./chunk-DM4WHMQY.js";
import "./chunk-DON3YPGT.js";
import {
  ot,
  rt
} from "./chunk-C7NRYPDG.js";
import "./chunk-Z3GMSC63.js";
import "./chunk-F35MWZH7.js";
import "./chunk-ED7UGR2X.js";
import "./chunk-YA5CTHMT.js";
import "./chunk-4QBFFLOC.js";
import "./chunk-O437BSYE.js";
import "./chunk-YZNT6QWD.js";
import "./chunk-YVOGHYE3.js";
import "./chunk-IBOZJLSO.js";
import "./chunk-PFMGJTQM.js";
import {
  Z
} from "./chunk-Q7SRMLJZ.js";
import "./chunk-PQ4T66BG.js";
import "./chunk-SWPHGZYB.js";
import "./chunk-DWASPXVI.js";
import "./chunk-J55F4AC2.js";
import "./chunk-LNRZHZOQ.js";
import "./chunk-DI6VABAK.js";
import "./chunk-5EBAJR7X.js";
import "./chunk-5JA2JHV3.js";
import "./chunk-FUKSTKFU.js";
import "./chunk-MIQZ6UDY.js";
import "./chunk-JOJZ6YC5.js";
import "./chunk-L4TOCXR5.js";
import "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import "./chunk-7WP676SE.js";
import "./chunk-SGSUM5YO.js";
import "./chunk-SG5TCCCK.js";
import "./chunk-6A7CWJED.js";
import "./chunk-DUTZNK67.js";
import "./chunk-IN6BQCWS.js";
import "./chunk-CRNUMTSV.js";
import "./chunk-JM7HAEY6.js";
import "./chunk-A3NNJ7XA.js";
import "./chunk-OKJHJ3CY.js";
import "./chunk-XTVPEVHA.js";
import "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import "./chunk-4ZZRP4MA.js";
import "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import {
  i
} from "./chunk-CVB43GGP.js";
import "./chunk-XWXBNAOW.js";
import "./chunk-GWC3DAGP.js";
import "./chunk-EODIWR2E.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-FYAEQPUY.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-7RMVJCDW.js";
import "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import "./chunk-NYQ5CYNR.js";
import "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import "./chunk-AXVPJBVW.js";
import "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import {
  G
} from "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import "./chunk-6WHTZNUH.js";
import "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import {
  d
} from "./chunk-XNUH25NY.js";
import "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import "./chunk-4Z5SGKRM.js";
import "./chunk-ANKOCGE2.js";
import "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  s3
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import {
  b,
  s as s2
} from "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-WYIDUUN2.js";
import "./chunk-DXLOWWK7.js";
import {
  __async
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/layers/graphics/sources/WFSSourceWorker.js
var w = "esri.layers.WFSLayer";
var R = class {
  constructor() {
    this._customParameters = null, this._queryEngine = null, this._supportsPagination = true;
  }
  destroy() {
    this._queryEngine?.destroy(), this._queryEngine = null;
  }
  load(_0) {
    return __async(this, arguments, function* (e, r = {}) {
      const {
        getFeatureUrl: s4,
        getFeatureOutputFormat: o,
        fields: n2,
        geometryType: i2,
        featureType: u,
        maxRecordCount: c,
        maxTotalRecordCount: p2,
        maxPageCount: d2,
        objectIdField: g,
        customParameters: y
      } = e, {
        spatialReference: _,
        getFeatureSpatialReference: w2
      } = oe(s4, u, e.spatialReference);
      try {
        yield x(w2, _);
      } catch {
        throw new s("unsupported-projection", "Projection not supported", {
          inSpatialReference: w2,
          outSpatialReference: _
        });
      }
      s2(r), this._customParameters = y, this._featureType = u, this._fieldsIndex = Z.fromLayerJSON({
        fields: n2,
        dateFieldsTimeReference: n2.some((e2) => "esriFieldTypeDate" === e2.type) ? {
          timeZoneIANA: i
        } : null
      }), this._geometryType = i2, this._getFeatureUrl = s4, this._getFeatureOutputFormat = o, this._getFeatureSpatialReference = w2, this._maxRecordCount = c, this._maxTotalRecordCount = p2, this._maxPageCount = d2, this._objectIdField = g, this._spatialReference = _;
      let R2 = yield this._snapshotFeatures(r);
      if (R2.errors.length > 0 && (this._supportsPagination = false, R2 = yield this._snapshotFeatures(r), R2.errors.length > 0)) throw R2.errors[0];
      return this._queryEngine = new $({
        fieldsIndex: this._fieldsIndex,
        geometryType: i2,
        hasM: false,
        hasZ: false,
        objectIdField: g,
        spatialReference: _,
        timeInfo: null,
        featureStore: new m({
          geometryType: i2,
          hasM: false,
          hasZ: false
        })
      }), this._queryEngine.featureStore.addMany(R2.features), {
        warnings: T(R2),
        extent: (yield this._queryEngine.fetchRecomputedExtents()).fullExtent
      };
    });
  }
  applyEdits() {
    return __async(this, null, function* () {
      throw new s("wfs-source:editing-not-supported", "applyEdits() is not supported on WFSLayer");
    });
  }
  queryFeatures() {
    return __async(this, arguments, function* (e = {}, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
    });
  }
  queryFeatureCount() {
    return __async(this, arguments, function* (e = {}, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
    });
  }
  queryObjectIds() {
    return __async(this, arguments, function* (e = {}, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t.signal);
    });
  }
  queryExtent() {
    return __async(this, arguments, function* (e = {}, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
    });
  }
  querySnapping(_0) {
    return __async(this, arguments, function* (e, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e, t.signal);
    });
  }
  refresh(t) {
    return __async(this, null, function* () {
      return this._customParameters = t.customParameters, this._maxRecordCount = t.maxRecordCount, this._maxTotalRecordCount = t.maxTotalRecordCount, this._maxPageCount = t.maxPageCount, this._snapshotTask?.abort(), this._snapshotTask = d((e) => this._snapshotFeatures({
        signal: e
      })), this._snapshotTask.promise.then((e) => {
        this._queryEngine.featureStore.clear(), this._queryEngine.featureStore.addMany(e.features);
        for (const t2 of T(e)) n.getLogger(w).warn(new s3("wfs-layer:refresh-warning", t2.message, t2.details));
        e.errors?.length && n.getLogger(w).warn(new s3("wfs-layer:refresh-error", "Refresh completed with errors", {
          errors: e.errors
        }));
      }, () => {
        this._queryEngine.featureStore.clear();
      }), yield this._waitSnapshotComplete(), {
        extent: (yield this._queryEngine.fetchRecomputedExtents()).fullExtent
      };
    });
  }
  _waitSnapshotComplete() {
    return __async(this, null, function* () {
      if (this._snapshotTask && !this._snapshotTask.finished) {
        try {
          yield this._snapshotTask.promise;
        } catch {
        }
        return this._waitSnapshotComplete();
      }
    });
  }
  _snapshotFeatures(e) {
    return __async(this, null, function* () {
      const t = e?.signal, r = this._maxTotalRecordCount, o = this._maxPageCount, n2 = this._supportsPagination ? yield ee(this._getFeatureUrl, this._featureType.typeName, {
        customParameters: this._customParameters,
        signal: t
      }) : void 0;
      let i2 = [];
      const u = [];
      if (null == n2) try {
        i2 = yield this._singleQuery(t);
      } catch (l) {
        b(l) || u.push(l);
      }
      else {
        const e2 = Math.min(n2, r), a = F(this, Math.max(1, Math.min(Math.ceil(e2 / this._maxRecordCount), o)), t);
        yield Promise.allSettled(Array.from({
          length: 10
        }).map(() => S(a, i2, u)));
      }
      return s2(t), {
        features: i2,
        totalRecordCount: n2,
        maxTotalRecordCount: r,
        maxPageCount: o,
        errors: u
      };
    });
  }
  _singleQuery(e) {
    return __async(this, null, function* () {
      const t = yield K(this._getFeatureUrl, this._featureType.typeName, this._getFeatureSpatialReference, this._getFeatureOutputFormat, {
        customParameters: this._customParameters,
        signal: e
      });
      return this._processGeoJSON(t, {
        signal: e
      });
    });
  }
  _pageQuery(e, t) {
    return __async(this, null, function* () {
      const r = e * this._maxRecordCount, a = yield K(this._getFeatureUrl, this._featureType.typeName, this._getFeatureSpatialReference, this._getFeatureOutputFormat, {
        customParameters: this._customParameters,
        startIndex: r,
        count: this._maxRecordCount,
        signal: t
      });
      return this._processGeoJSON(a, {
        startIndex: r,
        signal: t
      });
    });
  }
  _processGeoJSON(e, t) {
    E(e, this._getFeatureSpatialReference.wkid);
    const {
      startIndex: r,
      signal: s4
    } = t;
    s2(s4);
    const o = N(e, {
      geometryType: this._geometryType,
      hasZ: false,
      objectIdField: this._objectIdField
    });
    if (!G(this._spatialReference, this._getFeatureSpatialReference)) for (const a of o) null != a.geometry && (a.geometry = ot(j(rt(a.geometry, this._geometryType, false, false), this._getFeatureSpatialReference, this._spatialReference)));
    let l = r ?? 1;
    for (const a of o) {
      const e2 = {};
      p(this._fieldsIndex, e2, a.attributes, true), a.attributes = e2, null == e2[this._objectIdField] && (a.objectId = e2[this._objectIdField] = l++);
    }
    return o;
  }
};
function* F(e, t, r) {
  for (let a = 0; a < t; a++) yield e._pageQuery(a, r);
}
function S(e, t, r) {
  return __async(this, null, function* () {
    let a = e.next();
    for (; !a.done; ) {
      try {
        const e2 = yield a.value;
        t.push(...e2);
      } catch (o) {
        b(o) || r.push(o);
      }
      a = e.next();
    }
  });
}
function T(e) {
  const t = [];
  return null != e.totalRecordCount && (e.features.length < e.totalRecordCount && t.push({
    name: "wfs-layer:maxRecordCount-too-low",
    message: `Could only fetch ${e.features.length} of ${e.totalRecordCount} in ${e.maxPageCount} queries. Try increasing the value of WFSLayer.maxRecordCount.`,
    details: {
      recordCount: e.features.length,
      totalRecordCount: e.totalRecordCount
    }
  }), e.totalRecordCount > e.maxTotalRecordCount && t.push({
    name: "wfs-layer:large-dataset",
    message: `The number of ${e.totalRecordCount} features exceeds the maximum allowed of ${e.maxTotalRecordCount}.`,
    details: {
      recordCount: e.features.length,
      totalRecordCount: e.totalRecordCount,
      maxTotalRecordCount: e.maxTotalRecordCount
    }
  })), t;
}
export {
  R as default
};
//# sourceMappingURL=WFSSourceWorker-6MY5AHTY.js.map
