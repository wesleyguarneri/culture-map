{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/VertexStream.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/brushes/BrushBitmap.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/shaders/sources/shaderRepository.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/shaders/sources/resolver.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BackgroundPrograms.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/AFeatureTile.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/FreeList.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/PooledUint32Array.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/shaders/TileInfoPrograms.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/FeatureDisplayList.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/ReshufflePlan.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/Buffer.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/MappedMesh.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/util/Reader.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/mesh/meshDebugUtils.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/FeatureTile.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/brushes/BrushClip.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/brushes/BrushOverlay.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushStencil.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushTileDebugInfo.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/brushes.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/Mesh2D.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/ClippingInfo.js", "../../../../../../node_modules/@arcgis/core/views/2d/engine/webgl/WGLContainer.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { vertexLayoutHash as t } from \"./shaderGraph/techniques/mesh/utils.js\";\nimport { BufferObject as e } from \"../../../webgl/BufferObject.js\";\nimport { DataType as r, Usage as s, PrimitiveType as i } from \"../../../webgl/enums.js\";\nimport { VertexArrayObject as o } from \"../../../webgl/VertexArrayObject.js\";\nimport { VertexElementDescriptor as a } from \"../../../webgl/VertexElementDescriptor.js\";\nclass h {\n  constructor(i, h) {\n    this._rctx = i, this._attributes = [{\n      name: \"position\",\n      offset: 0,\n      type: r.SHORT,\n      count: 2\n    }], this.layout = {\n      hash: t(this._attributes),\n      attributes: this._attributes,\n      stride: 4\n    }, this._vertexBuffer = e.createVertex(i, s.STATIC_DRAW, new Uint16Array(h)), this._vao = new o(i, new Map([[\"a_position\", 0]]), {\n      geometry: [new a(\"a_position\", 2, r.SHORT, 0, 4)]\n    }, {\n      geometry: this._vertexBuffer\n    }), this._count = h.length / 2;\n  }\n  bind() {\n    this._rctx.bindVAO(this._vao);\n  }\n  unbind() {\n    this._rctx.bindVAO(null);\n  }\n  dispose() {\n    this._vao.dispose();\n  }\n  draw() {\n    this._rctx.bindVAO(this._vao), this._rctx.drawArrays(i.TRIANGLE_STRIP, 0, this._count);\n  }\n}\nexport { h as default };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { textureBindingBitmap as e } from \"../definitions.js\";\nimport t from \"../VertexStream.js\";\nimport i from \"./WGLBrush.js\";\nimport { TextureSamplingMode as s, BlendFactor as n, CompareFunction as a } from \"../../../../webgl/enums.js\";\nconst r = {\n    nearest: {\n      defines: [],\n      samplingMode: s.NEAREST,\n      mips: !1\n    },\n    bilinear: {\n      defines: [],\n      samplingMode: s.LINEAR,\n      mips: !1\n    },\n    bicubic: {\n      defines: [\"bicubic\"],\n      samplingMode: s.LINEAR,\n      mips: !1\n    },\n    trilinear: {\n      defines: [],\n      samplingMode: s.LINEAR_MIPMAP_LINEAR,\n      mips: !0\n    }\n  },\n  o = (e, t, i) => {\n    if (\"dynamic\" === i.samplingMode) {\n      const {\n          state: i\n        } = e,\n        s = t.resolution / t.pixelRatio / i.resolution,\n        n = Math.round(e.pixelRatio) !== e.pixelRatio,\n        a = s > 1.05 || s < .95;\n      return i.rotation || a || n || t.isSourceScaled || t.rotation ? r.bilinear : r.nearest;\n    }\n    return r[i.samplingMode];\n  };\nclass d extends i {\n  constructor() {\n    super(...arguments), this._desc = {\n      vsPath: \"raster/bitmap\",\n      fsPath: \"raster/bitmap\",\n      attributes: new Map([[\"a_pos\", 0]])\n    };\n  }\n  dispose() {\n    this._quad && this._quad.dispose();\n  }\n  prepareState({\n    context: e\n  }) {\n    e.setBlendingEnabled(!0), e.setColorMask(!0, !0, !0, !0), e.setStencilWriteMask(0), e.setStencilTestEnabled(!0);\n  }\n  draw(i, s) {\n    const {\n      context: r,\n      renderingOptions: d,\n      painter: l,\n      requestRender: c,\n      allowDelayedRender: m\n    } = i;\n    if (!s.source || !s.isReady) return;\n    const p = o(i, s, d),\n      u = l.materialManager.getProgram(this._desc, p.defines);\n    if (m && null != c && !u.compiled) return void c();\n    i.timeline.begin(this.name), \"additive\" === s.blendFunction ? r.setBlendFunctionSeparate(n.ONE, n.ONE, n.ONE, n.ONE) : r.setBlendFunctionSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA), r.setStencilFunction(a.EQUAL, s.stencilRef, 255), this._quad || (this._quad = new t(r, [0, 0, 1, 0, 0, 1, 1, 1]));\n    const {\n      coordScale: f,\n      computedOpacity: _,\n      transforms: M\n    } = s;\n    s.setSamplingProfile(p), s.bind(i.context, e), r.useProgram(u), u.setUniformMatrix3fv(\"u_dvsMat3\", M.displayViewScreenMat3), u.setUniform1i(\"u_texture\", e), u.setUniform2fv(\"u_coordScale\", f), u.setUniform1f(\"u_opacity\", _), this._quad.draw(), i.timeline.end(this.name);\n  }\n}\nexport { d as default };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nconst e = {\n  background: {\n    \"background.frag\": \"uniform lowp vec4 u_color;\\nvoid main() {\\ngl_FragColor = u_color;\\n}\",\n    \"background.vert\": \"attribute vec2 a_pos;\\nuniform highp mat3 u_dvsMat3;\\nuniform mediump vec2 u_coord_range;\\nuniform mediump float u_depth;\\nvoid main() {\\nvec3 v_pos = u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0);\\ngl_Position = vec4(v_pos.xy, 0.0, 1.0);\\n}\"\n  },\n  bitBlit: {\n    \"bitBlit.frag\": \"uniform lowp sampler2D u_tex;\\nuniform lowp float u_opacity;\\nvarying mediump vec2 v_uv;\\nvoid main() {\\nlowp vec4 color = texture2D(u_tex, v_uv);\\ngl_FragColor = color * u_opacity;\\n}\",\n    \"bitBlit.vert\": \"attribute vec2 a_pos;\\nattribute vec2 a_tex;\\nvarying mediump vec2 v_uv;\\nvoid main(void) {\\ngl_Position = vec4(a_pos , 0.0, 1.0);\\nv_uv = a_tex;\\n}\"\n  },\n  blend: {\n    \"blend.frag\": \"precision mediump float;\\nuniform sampler2D u_layerTexture;\\nuniform lowp float u_opacity;\\nuniform lowp float u_inFadeOpacity;\\n#ifndef NORMAL\\nuniform sampler2D u_backbufferTexture;\\n#endif\\nvarying mediump vec2 v_uv;\\nfloat rgb2v(in vec3 c) {\\nreturn max(c.x, max(c.y, c.z));\\n}\\nvec3 rgb2hsv(in vec3 c) {\\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\nvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\\nvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\\nfloat d = q.x - min(q.w, q.y);\\nfloat e = 1.0e-10;\\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);\\n}\\nvec3 hsv2rgb(in vec3 c) {\\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\nvec3 tint(in vec3 Cb, in vec3 Cs) {\\nfloat vIn = rgb2v(Cb);\\nvec3 hsvTint = rgb2hsv(Cs);\\nvec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);\\nreturn hsv2rgb(hsvOut);\\n}\\nfloat overlay(in float Cb, in float Cs) {\\nreturn (1.0 - step(0.5, Cs)) * (1.0 - 2.0 * (1.0 - Cs ) * (1.0 - Cb)) + step(0.5, Cs) * (2.0 * Cs * Cb);\\n}\\nfloat colorDodge(in float Cb, in float Cs) {\\nreturn (Cb == 0.0) ? 0.0 : (Cs == 1.0) ? 1.0 : min(1.0, Cb / (1.0 - Cs));\\n}\\nfloat colorBurn(in float Cb, in float Cs) {\\nreturn (Cb == 1.0) ? 1.0 : (Cs == 0.0) ? 0.0 : 1.0 - min(1.0, (1.0 - Cb) / Cs);\\n}\\nfloat hardLight(in float Cb, in float Cs) {\\nreturn (1.0 - step(0.5, Cs)) * (2.0 * Cs * Cb) + step(0.5, Cs) * (1.0 - 2.0 * (1.0 - Cs) * (1.0 - Cb));\\n}\\nfloat reflectBlend(in float Cb, in float Cs) {\\nreturn (Cs == 1.0) ? Cs : min(Cb * Cb / (1.0 - Cs), 1.0);\\n}\\nfloat softLight(in float Cb, in float Cs) {\\nif (Cs <= 0.5) {\\nreturn Cb - (1.0 - 2.0 * Cs) * Cb * (1.0 - Cb);\\n}\\nif (Cb <= 0.25) {\\nreturn Cb + (2.0 * Cs - 1.0) * Cb * ((16.0 * Cb - 12.0) * Cb + 3.0);\\n}\\nreturn Cb + (2.0 * Cs - 1.0) * (sqrt(Cb) - Cb);\\n}\\nfloat vividLight(in float Cb, in float Cs) {\\nreturn (1.0 - step(0.5, Cs)) * colorBurn(Cb, 2.0 * Cs) + step(0.5, Cs) * colorDodge(Cb, (2.0 * (Cs - 0.5)));\\n}\\nfloat minv3(in vec3 c) {\\nreturn min(min(c.r, c.g), c.b);\\n}\\nfloat maxv3(in vec3 c) {\\nreturn max(max(c.r, c.g), c.b);\\n}\\nfloat lumv3(in vec3 c) {\\nreturn dot(c, vec3(0.3, 0.59, 0.11));\\n}\\nfloat satv3(vec3 c) {\\nreturn maxv3(c) - minv3(c);\\n}\\nvec3 clipColor(vec3 color) {\\nfloat lum = lumv3(color);\\nfloat mincol = minv3(color);\\nfloat maxcol = maxv3(color);\\nif (mincol < 0.0) {\\ncolor = lum + ((color - lum) * lum) / (lum - mincol);\\n}\\nif (maxcol > 1.0) {\\ncolor = lum + ((color - lum) * (1.0 - lum)) / (maxcol - lum);\\n}\\nreturn color;\\n}\\nvec3 setLum(vec3 cbase, vec3 clum) {\\nfloat lbase = lumv3(cbase);\\nfloat llum = lumv3(clum);\\nfloat ldiff = llum - lbase;\\nvec3 color = cbase + vec3(ldiff);\\nreturn clipColor(color);\\n}\\nvec3 setLumSat(vec3 cbase, vec3 csat, vec3 clum)\\n{\\nfloat minbase = minv3(cbase);\\nfloat sbase = satv3(cbase);\\nfloat ssat = satv3(csat);\\nvec3 color;\\nif (sbase > 0.0) {\\ncolor = (cbase - minbase) * ssat / sbase;\\n} else {\\ncolor = vec3(0.0);\\n}\\nreturn setLum(color, clum);\\n}\\nvoid main() {\\nvec4 src = texture2D(u_layerTexture, v_uv);\\n#ifdef NORMAL\\ngl_FragColor = src *  u_opacity;\\n#else\\nvec4 dst = texture2D(u_backbufferTexture, v_uv);\\nvec3 Cs = src.a == 0.0 ? src.rgb : vec3(src.rgb / src.a);\\nvec3 Cb = dst.a == 0.0 ? dst.rgb : vec3(dst.rgb / dst.a);\\nfloat as = u_opacity * src.a;\\nfloat ab = dst.a;\\n#ifdef DESTINATION_OVER\\ngl_FragColor = vec4(as * Cs * (1.0 - ab) + ab * Cb, as + ab - as * ab);\\n#endif\\n#ifdef SOURCE_IN\\nvec4 color = vec4(as * Cs * ab, as * ab);\\nvec4 fadeColor = (1.0 - u_opacity) * u_inFadeOpacity * vec4(ab * Cb, ab);\\ngl_FragColor = color + fadeColor;\\n#endif\\n#ifdef DESTINATION_IN\\nvec4 color = vec4(ab * Cb * as, ab * as);\\nvec4 fadeColor = (1.0 - u_opacity) * u_inFadeOpacity * vec4(ab * Cb, ab);\\ngl_FragColor = color + fadeColor;\\n#endif\\n#ifdef SOURCE_OUT\\ngl_FragColor = vec4(as * Cs * (1.0 - ab), as * (1.0 - ab));\\n#endif\\n#ifdef DESTINATION_OUT\\ngl_FragColor = vec4(ab * Cb * (1.0 - as), ab * (1.0 - as));\\n#endif\\n#ifdef SOURCE_ATOP\\ngl_FragColor = vec4(as * Cs * ab + ab * Cb * (1.0 - as), ab);\\n#endif\\n#ifdef DESTINATION_ATOP\\ngl_FragColor = vec4(as * Cs * (1.0 - ab) + ab * Cb * as, as);\\n#endif\\n#ifdef XOR\\ngl_FragColor = vec4(as * Cs * (1.0 - ab) + ab * Cb * (1.0 - as),\\nas * (1.0 - ab) + ab * (1.0 - as));\\n#endif\\n#ifdef MULTIPLY\\ngl_FragColor = vec4(as * Cs * ab * Cb + (1.0 - ab) * as * Cs + (1.0 - as) * ab * Cb,\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef SCREEN\\ngl_FragColor = vec4((Cs + Cb - Cs * Cb) * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef OVERLAY\\nvec3 f = vec3(overlay(Cb.r, Cs.r), overlay(Cb.g, Cs.g), overlay(Cb.b, Cs.b));\\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef DARKEN\\ngl_FragColor = vec4(min(Cs, Cb) * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef LIGHTER\\ngl_FragColor = vec4(as * Cs + ab * Cb, as + ab);\\n#endif\\n#ifdef LIGHTEN\\ngl_FragColor = vec4(max(Cs, Cb) * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef COLOR_DODGE\\nvec3 f = clamp(vec3(colorDodge(Cb.r, Cs.r), colorDodge(Cb.g, Cs.g), colorDodge(Cb.b, Cs.b)), vec3(0.0), vec3(1.0));\\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef COLOR_BURN\\nvec3 f = vec3(colorBurn(Cb.r, Cs.r), colorBurn(Cb.g, Cs.g), colorBurn(Cb.b, Cs.b));\\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef HARD_LIGHT\\nvec3 f = vec3(hardLight(Cb.r, Cs.r), hardLight(Cb.g, Cs.g), hardLight(Cb.b, Cs.b));\\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef SOFT_LIGHT\\nvec3 f = vec3(softLight(Cb.r, Cs.r), softLight(Cb.g, Cs.g), softLight(Cb.b, Cs.b));\\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef DIFFERENCE\\ngl_FragColor = vec4(abs(Cb - Cs) * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef EXCLUSION\\nvec3 f = Cs + Cb - 2.0 * Cs * Cb;\\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef INVERT\\ngl_FragColor = vec4((1.0 - Cb) * as * ab + Cb * ab * (1.0 - as), ab);\\n#endif\\n#ifdef VIVID_LIGHT\\nvec3 f = vec3(clamp(vividLight(Cb.r, Cs.r), 0.0, 1.0),\\nclamp(vividLight(Cb.g, Cs.g), 0.0, 1.0),\\nclamp(vividLight(Cb.b, Cs.b), 0.0, 1.0));\\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef HUE\\nvec3 f = setLumSat(Cs,Cb,Cb);\\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef SATURATION\\nvec3 f = setLumSat(Cb,Cs,Cb);\\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef COLOR\\nvec3 f = setLum(Cs,Cb);\\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef LUMINOSITY\\nvec3 f = setLum(Cb,Cs);\\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef PLUS\\ngl_FragColor = clamp(vec4(src.r + Cb.r, src.g + Cb.g, src.b + Cb.b, as + ab), 0.0, 1.0);\\n#endif\\n#ifdef MINUS\\ngl_FragColor = vec4(clamp(vec3(Cb.r - src.r, Cb.g - src.g, Cb.b - src.b), 0.0, 1.0), ab * as);\\n#endif\\n#ifdef AVERAGE\\nvec3 f = (Cb + Cs) / 2.0;\\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#ifdef REFLECT\\nvec3 f = clamp(vec3(reflectBlend(Cb.r, Cs.r),\\nreflectBlend(Cb.g, Cs.g),\\nreflectBlend(Cb.b, Cs.b)), vec3(0.0), vec3(1.0));\\ngl_FragColor = vec4(f * as * ab + Cs * as * (1.0 - ab) + Cb * ab *(1.0 - as),\\nas + ab * (1.0 - as));\\n#endif\\n#endif\\n}\",\n    \"blend.vert\": \"attribute vec2 a_position;\\nvarying mediump vec2 v_uv;\\nvoid main(void) {\\ngl_Position = vec4(a_position , 0.0, 1.0);\\nv_uv = (a_position + 1.0) / 2.0;\\n}\"\n  },\n  debug: {\n    overlay: {\n      \"overlay.frag\": \"precision mediump float;\\nvarying vec4 v_color;\\nvoid main(void) {\\ngl_FragColor = v_color;\\n}\",\n      \"overlay.vert\": \"attribute vec3 a_PositionAndFlags;\\nuniform mat3 u_dvsMat3;\\nuniform vec4 u_colors[4];\\nuniform float u_opacities[4];\\nvarying vec4 v_color;\\nvoid main(void) {\\nvec2 position = a_PositionAndFlags.xy;\\nfloat flags = a_PositionAndFlags.z;\\nint colorIndex = int(mod(flags, 4.0));\\nvec4 color;\\nfor (int i = 0; i < 4; i++) {\\ncolor = u_colors[i];\\nif (i == colorIndex) {\\nbreak;\\n}\\n}\\nint opacityIndex = int(mod(floor(flags / 4.0), 4.0));\\nfloat opacity;\\nfor (int i = 0; i < 4; i++) {\\nopacity = u_opacities[i];\\nif (i == opacityIndex) {\\nbreak;\\n}\\n}\\nv_color = color * opacity;\\ngl_Position = vec4((u_dvsMat3 * vec3(position, 1.0)).xy, 0.0, 1.0);\\n}\"\n    }\n  },\n  dot: {\n    dot: {\n      \"dot.frag\": \"precision mediump float;\\nvarying vec4 v_color;\\nvarying float v_dotRatio;\\nvarying float v_invEdgeRatio;\\nuniform highp float u_tileZoomFactor;\\nvoid main()\\n{\\nfloat dist = length(gl_PointCoord - vec2(.5, .5)) * 2.;\\nfloat alpha = smoothstep(0., 1., v_invEdgeRatio * (dist - v_dotRatio) + 1.);\\ngl_FragColor = v_color * alpha;\\n}\",\n      \"dot.vert\": \"precision highp float;\\nattribute vec2 a_pos;\\nuniform sampler2D u_texture;\\nuniform highp mat3 u_dvsMat3;\\nuniform highp float u_tileZoomFactor;\\nuniform highp float u_dotSize;\\nuniform highp float u_pixelRatio;\\nvarying vec2 v_pos;\\nvarying vec4 v_color;\\nvarying float v_dotRatio;\\nvarying float v_invEdgeRatio;\\nconst float EPSILON = 0.000001;\\nvoid main()\\n{\\nmat3 tileToTileTexture = mat3(  1., 0., 0.,\\n0., -1., 0.,\\n0., 1., 1.  );\\nvec3 texCoords = tileToTileTexture * vec3(a_pos.xy / 512., 1.);\\nv_color = texture2D(u_texture, texCoords.xy);\\nfloat smoothEdgeWidth = max(u_dotSize / 2., 1.) ;\\nfloat z = 0.;\\nz += 2.0 * step(v_color.a, EPSILON);\\ngl_PointSize = (smoothEdgeWidth + u_dotSize);\\ngl_Position = vec4((u_dvsMat3 * vec3(a_pos + .5, 1.)).xy, z, 1.);\\nv_dotRatio = u_dotSize / gl_PointSize;\\nv_invEdgeRatio = -1. / ( smoothEdgeWidth / gl_PointSize );\\ngl_PointSize  *= (u_pixelRatio * u_tileZoomFactor);\\n}\"\n    }\n  },\n  filtering: {\n    \"bicubic.glsl\": \"vec4 computeWeights(float v) {\\nfloat b = 1.0 / 6.0;\\nfloat v2 = v * v;\\nfloat v3 = v2 * v;\\nfloat w0 = b * (-v3 + 3.0 * v2 - 3.0 * v + 1.0);\\nfloat w1 = b * (3.0 * v3  - 6.0 * v2 + 4.0);\\nfloat w2 = b * (-3.0 * v3 + 3.0 * v2 + 3.0 * v + 1.0);\\nfloat w3 = b * v3;\\nreturn vec4(w0, w1, w2, w3);\\n}\\nvec4 bicubicOffsetsAndWeights(float v) {\\nvec4 w = computeWeights(v);\\nfloat g0 = w.x + w.y;\\nfloat g1 = w.z + w.w;\\nfloat h0 = 1.0 - (w.y / g0) + v;\\nfloat h1 = 1.0 + (w.w / g1) - v;\\nreturn vec4(h0, h1, g0, g1);\\n}\\nvec4 sampleBicubicBSpline(sampler2D sampler, vec2 coords, vec2 texSize) {\\nvec2 eX = vec2(1.0 / texSize.x, 0.0);\\nvec2 eY = vec2(0.0, 1.0 / texSize.y);\\nvec2 texel = coords * texSize - 0.5;\\nvec3 hgX = bicubicOffsetsAndWeights(fract(texel).x).xyz;\\nvec3 hgY = bicubicOffsetsAndWeights(fract(texel).y).xyz;\\nvec2 coords10 = coords + hgX.x * eX;\\nvec2 coords00 = coords - hgX.y * eX;\\nvec2 coords11 = coords10 + hgY.x * eY;\\nvec2 coords01 = coords00 + hgY.x * eY;\\ncoords10 = coords10 - hgY.y * eY;\\ncoords00 = coords00 - hgY.y * eY;\\nvec4 color00 = texture2D(sampler, coords00);\\nvec4 color10 = texture2D(sampler, coords10);\\nvec4 color01 = texture2D(sampler, coords01);\\nvec4 color11 = texture2D(sampler, coords11);\\ncolor00 = mix(color00, color01, hgY.z);\\ncolor10 = mix(color10, color11, hgY.z);\\ncolor00 = mix(color00, color10, hgX.z);\\nreturn color00;\\n}\",\n    \"bilinear.glsl\": \"vec4 sampleBilinear(sampler2D sampler, vec2 coords, vec2 texSize) {\\nvec2 texelStart = floor(coords * texSize);\\nvec2 coord0 = texelStart / texSize;\\nvec2 coord1 = (texelStart +  vec2(1.0, 0.0)) / texSize;\\nvec2 coord2 = (texelStart +  vec2(0.0, 1.0)) / texSize;\\nvec2 coord3 = (texelStart +  vec2(1.0, 1.0)) / texSize;\\nvec4 color0 = texture2D(sampler, coord0);\\nvec4 color1 = texture2D(sampler, coord1);\\nvec4 color2 = texture2D(sampler, coord2);\\nvec4 color3 = texture2D(sampler, coord3);\\nvec2 blend = fract(coords * texSize);\\nvec4 color01 = mix(color0, color1, blend.x);\\nvec4 color23 = mix(color2, color3, blend.x);\\nvec4 color = mix(color01, color23, blend.y);\\n#ifdef NNEDGE\\nfloat alpha = floor(color0.a * color1.a * color2.a * color3.a + 0.5);\\ncolor = color * alpha + (1.0 - alpha) * texture2D(sampler, coords);\\n#endif\\nreturn color;\\n}\",\n    \"epx.glsl\": \"vec4 sampleEPX(sampler2D sampler, float size, vec2 coords, vec2 texSize) {\\nvec2 invSize = 1.0 / texSize;\\nvec2 texel = coords * texSize;\\nvec2 texel_i = floor(texel);\\nvec2 texel_frac = fract(texel);\\nvec4 colorP = texture2D(sampler, texel_i * invSize);\\nvec4 colorP1 = vec4(colorP);\\nvec4 colorP2 = vec4(colorP);\\nvec4 colorP3 = vec4(colorP);\\nvec4 colorP4 = vec4(colorP);\\nvec4 colorA = texture2D(sampler, (texel_i - vec2(0.0, 1.0)) * invSize);\\nvec4 colorB = texture2D(sampler, (texel_i + vec2(1.0, 0.0)) * invSize);\\nvec4 colorC = texture2D(sampler, (texel_i - vec2(1.0, 0.0)) * invSize);\\nvec4 colorD = texture2D(sampler, (texel_i + vec2(0.0, 1.0)) * invSize);\\nif (colorC == colorA && colorC != colorD && colorA != colorB) {\\ncolorP1 = colorA;\\n}\\nif (colorA == colorB && colorA != colorC && colorB != colorD) {\\ncolorP2 = colorB;\\n}\\nif (colorD == colorC && colorD != colorB && colorC != colorA) {\\ncolorP3 = colorC;\\n}\\nif (colorB == colorD && colorB != colorA && colorD != colorC) {\\ncolorP4 = colorD;\\n}\\nvec4 colorP12 = mix(colorP1, colorP2, texel_frac.x);\\nvec4 colorP34 = mix(colorP1, colorP2, texel_frac.x);\\nreturn mix(colorP12, colorP34, texel_frac.y);\\n}\"\n  },\n  fx: {\n    integrate: {\n      \"integrate.frag\": \"precision mediump float;\\nuniform lowp sampler2D u_sourceTexture;\\nuniform lowp sampler2D u_maskTexture;\\nuniform mediump float u_zoomLevel;\\nuniform highp float u_timeDelta;\\nuniform highp float u_animationTime;\\nvarying highp vec2 v_texcoord;\\n#include <materials/utils.glsl>\\nvoid main()\\n{\\n#ifdef DELTA\\nvec4 texel = texture2D(u_sourceTexture, v_texcoord);\\nvec4 data0 = texture2D(u_maskTexture, v_texcoord);\\nfloat flags = data0.r * 255.0;\\nfloat groupMinZoom = data0.g * 255.0;\\nfloat epsilon = 5.;\\nfloat wouldClip = float(groupMinZoom < epsilon);\\nfloat direction = wouldClip * 1.0 + (1.0 - wouldClip) * -1.0;\\nfloat dt = u_timeDelta / max(u_animationTime, 0.0001);\\nvec4 nextState = vec4(texel + direction * dt);\\ngl_FragColor =  vec4(nextState);\\n#elif defined(UPDATE)\\nvec4 texel = texture2D(u_sourceTexture, v_texcoord);\\ngl_FragColor = texel;\\n#endif\\n}\",\n      \"integrate.vert\": \"precision mediump float;\\nattribute vec2 a_pos;\\nvarying highp vec2 v_texcoord;\\nvoid main()\\n{\\nv_texcoord = a_pos;\\ngl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\\n}\"\n    }\n  },\n  heatmap: {\n    heatmapResolve: {\n      \"heatmapResolve.frag\": \"precision highp float;\\n#ifdef HEATMAP_PRECISION_HALF_FLOAT\\n#define COMPRESSION_FACTOR 4.0\\n#else\\n#define COMPRESSION_FACTOR 1.0\\n#endif\\nuniform sampler2D u_texture;\\nuniform sampler2D u_gradient;\\nuniform vec2 u_densityMinAndInvRange;\\nuniform float u_densityNormalization;\\nvarying vec2 v_uv;\\nvoid main() {\\nvec4 data = texture2D(u_texture, v_uv);\\nfloat density = data.r * COMPRESSION_FACTOR;\\ndensity *= u_densityNormalization;\\ndensity = (density - u_densityMinAndInvRange.x) * u_densityMinAndInvRange.y;\\nvec4 color = texture2D(u_gradient, vec2(density, 0.5));\\ngl_FragColor = vec4(color.rgb * color.a, color.a);\\n}\",\n      \"heatmapResolve.vert\": \"precision highp float;\\nattribute vec2 a_pos;\\nvarying vec2 v_uv;\\nvoid main() {\\nv_uv = a_pos;\\ngl_Position = vec4(a_pos * 2.0 - 1.0, 1., 1.);\\n}\"\n    }\n  },\n  highlight: {\n    \"blur.frag\": \"varying mediump vec2 v_texcoord;\\nuniform mediump vec4 u_direction;\\nuniform mediump mat4 u_channelSelector;\\nuniform mediump float u_sigma;\\nuniform sampler2D u_texture;\\nmediump float gauss1(mediump vec2 dir) {\\nreturn exp(-dot(dir, dir) / (2.0 * u_sigma * u_sigma));\\n}\\nmediump vec4 selectChannel(mediump vec4 sample) {\\nreturn u_channelSelector * sample;\\n}\\nvoid accumGauss1(mediump float i, inout mediump float tot, inout mediump float weight) {\\nmediump float w = gauss1(i * u_direction.xy);\\ntot += selectChannel(texture2D(u_texture, v_texcoord + i * u_direction.zw))[3] * w;\\nweight += w;\\n}\\nvoid main(void) {\\nmediump float tot = 0.0;\\nmediump float weight = 0.0;\\naccumGauss1(-5.0, tot, weight);\\naccumGauss1(-4.0, tot, weight);\\naccumGauss1(-3.0, tot, weight);\\naccumGauss1(-2.0, tot, weight);\\naccumGauss1(-1.0, tot, weight);\\naccumGauss1(0.0, tot, weight);\\naccumGauss1(1.0, tot, weight);\\naccumGauss1(2.0, tot, weight);\\naccumGauss1(3.0, tot, weight);\\naccumGauss1(4.0, tot, weight);\\naccumGauss1(5.0, tot, weight);\\ngl_FragColor = vec4(0.0, 0.0, 0.0, tot / weight);\\n}\",\n    \"highlight.frag\": \"varying mediump vec2 v_texcoord;\\nuniform sampler2D u_texture;\\nuniform mediump float u_sigma;\\nuniform sampler2D u_shade;\\nuniform mediump vec2 u_minMaxDistance;\\nmediump float estimateDistance() {\\nmediump float y = texture2D(u_texture, v_texcoord)[3];\\nconst mediump float y0 = 0.5;\\nmediump float m0 = 1.0 / (sqrt(2.0 * 3.1415) * u_sigma);\\nmediump float d = (y - y0) / m0;\\nreturn d;\\n}\\nmediump vec4 shade(mediump float d) {\\nmediump float mappedDistance = (d - u_minMaxDistance.x) / (u_minMaxDistance.y - u_minMaxDistance.x);\\nmappedDistance = clamp(mappedDistance, 0.0, 1.0);\\nreturn texture2D(u_shade, vec2(mappedDistance, 0.5));\\n}\\nvoid main(void) {\\nmediump float d = estimateDistance();\\ngl_FragColor = shade(d);\\n}\",\n    \"textured.vert\": \"attribute mediump vec2 a_position;\\nattribute mediump vec2 a_texcoord;\\nvarying mediump vec2 v_texcoord;\\nvoid main(void) {\\ngl_Position = vec4(a_position, 0.0, 1.0);\\nv_texcoord = a_texcoord;\\n}\"\n  },\n  magnifier: {\n    \"magnifier.frag\": \"uniform lowp vec4 u_background;\\nuniform mediump sampler2D u_readbackTexture;\\nuniform mediump sampler2D u_maskTexture;\\nuniform mediump sampler2D u_overlayTexture;\\nuniform bool u_maskEnabled;\\nuniform bool u_overlayEnabled;\\nvarying mediump vec2 v_texCoord;\\nconst lowp float barrelFactor = 1.1;\\nlowp vec2 barrel(lowp vec2 uv) {\\nlowp vec2 uvn = uv * 2.0 - 1.0;\\nif (uvn.x == 0.0 && uvn.y == 0.0) {\\nreturn vec2(0.5, 0.5);\\n}\\nlowp float theta = atan(uvn.y, uvn.x);\\nlowp float r = pow(length(uvn), barrelFactor);\\nreturn r * vec2(cos(theta), sin(theta)) * 0.5 + 0.5;\\n}\\nvoid main(void)\\n{\\nlowp vec4 color = texture2D(u_readbackTexture, barrel(v_texCoord));\\ncolor = (color + (1.0 - color.a) * u_background);\\nlowp float mask = u_maskEnabled ? texture2D(u_maskTexture, v_texCoord).a : 1.0;\\ncolor *= mask;\\nlowp vec4 overlayColor = u_overlayEnabled ? texture2D(u_overlayTexture, v_texCoord) : vec4(0);\\ngl_FragColor = overlayColor + (1.0 - overlayColor.a) * color;\\n}\",\n    \"magnifier.vert\": \"precision mediump float;\\nattribute mediump vec2 a_pos;\\nuniform mediump vec4 u_drawPos;\\nvarying mediump vec2 v_texCoord;\\nvoid main(void)\\n{\\nv_texCoord = a_pos;\\ngl_Position = vec4(u_drawPos.xy + vec2(a_pos - 0.5) * u_drawPos.zw, 0.0, 1.0);\\n}\"\n  },\n  materials: {\n    \"attributeData.glsl\": \"uniform highp sampler2D filterFlags;\\nuniform highp sampler2D animation;\\nuniform highp sampler2D gpgpu;\\nuniform highp sampler2D visualVariableData;\\nuniform highp sampler2D dataDriven0;\\nuniform highp sampler2D dataDriven1;\\nuniform highp sampler2D dataDriven2;\\nuniform float size;\\nhighp vec2 getAttributeDataCoords(in highp vec3 id) {\\nhighp vec3  texel = unpackDisplayIdTexel(id);\\nhighp float u32 = float(int(texel.r) + int(texel.g) * 256 + int(texel.b) * 256 * 256);\\nhighp float col = mod(u32, size);\\nhighp float row = (u32 - col) / size;\\nhighp float u = col / size;\\nhighp float v = row / size;\\nreturn vec2(u, v);\\n}\\nhighp vec2 getAttributeDataTextureCoords(in highp vec3 id) {\\nreturn (getAttributeDataCoords(id) * 2.0) - 1.0 + (.5 / vec2(size));\\n}\\nhighp vec4 getFilterData(in highp vec3 id) {\\nvec2 coords = getAttributeDataCoords(id);\\nreturn texture2D(filterFlags, coords);\\n}\\nhighp vec4 getAnimation(in highp vec3 id) {\\nhighp vec2 coords = getAttributeDataCoords(id);\\nreturn texture2D(animation, coords);\\n}\\nhighp vec4 getVisualVariableData(in highp vec3 id) {\\nhighp vec2 coords = getAttributeDataCoords(id);\\nreturn texture2D(visualVariableData, coords);\\n}\\nhighp vec4 getDataDriven0(in highp vec3 id) {\\nhighp vec2 coords = getAttributeDataCoords(id);\\nreturn texture2D(dataDriven0, coords);\\n}\\nhighp vec4 getDataDriven1(in highp vec3 id) {\\nhighp vec2 coords = getAttributeDataCoords(id);\\nreturn texture2D(dataDriven1, coords);\\n}\\nhighp vec4 getGPGPU(in highp vec3 id) {\\nhighp vec2 coords = getAttributeDataCoords(id);\\nreturn texture2D(gpgpu, coords);\\n}\\nhighp vec4 getDataDriven2(in highp vec3 id) {\\nhighp vec2 coords = getAttributeDataCoords(id);\\nreturn texture2D(dataDriven2, coords);\\n}\\nfloat u88VVToFloat(in vec2 v) {\\nbool isMagic = v.x == 255.0 && v.y == 255.0;\\nif (isMagic) {\\nreturn NAN_MAGIC_NUMBER;\\n}\\nreturn (v.x + v.y * float(0x100)) - 32768.0;\\n}\",\n    \"barycentric.glsl\": \"float inTriangle(vec3 bary) {\\nvec3 absBary = abs(bary);\\nreturn step((absBary.x + absBary.y + absBary.z), 1.05);\\n}\\nvec3 xyToBarycentric(in vec2 pos, in vec2 v0,  in vec2 v1, in vec2 v2) {\\nmat3 xyToBarycentricMat3 = mat3(\\nv1.x * v2.y - v2.x * v1.y, v2.x * v0.y - v0.x * v2.y, v0.x * v1.y - v1.x * v0.y,\\nv1.y - v2.y, v2.y - v0.y, v0.y - v1.y,\\nv2.x - v1.x, v0.x - v2.x, v1.x - v0.x\\n);\\nfloat A2 = v0.x * (v1.y - v2.y) + v1.x * (v2.y - v0.y) + v2.x * (v0.y - v1.y);\\nreturn (1. / A2) * xyToBarycentricMat3 * vec3(1., pos);\\n}\",\n    \"constants.glsl\": \"const float C_DEG_TO_RAD = 3.14159265359 / 180.0;\\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\\nconst float C_RAD_TO_DEG = 180.0 / 3.141592654;\\nconst float POSITION_PRECISION = 1.0 / 8.0;\\nconst float FILL_POSITION_PRECISION = 1.0 / 1.0;\\nconst float SOFT_EDGE_RATIO = 1.0;\\nconst float THIN_LINE_WIDTH_FACTOR = 1.1;\\nconst float THIN_LINE_HALF_WIDTH = 1.0;\\nconst float EXTRUDE_SCALE_PLACEMENT_PADDING = 1.0 / 4.0;\\nconst float OFFSET_PRECISION = 1.0 / 8.0;\\nconst float OUTLINE_SCALE = 1.0 / 5.0;\\nconst float SDF_FONT_SIZE = 24.0;\\nconst float MAX_SDF_DISTANCE = 8.0;\\nconst float PLACEMENT_PADDING = 8.0;\\nconst float EPSILON = 0.00001;\\nconst float EPSILON_HITTEST = 0.05;\\nconst int MAX_FILTER_COUNT = 2;\\nconst int ATTR_VV_SIZE = 0;\\nconst int ATTR_VV_COLOR = 1;\\nconst int ATTR_VV_OPACITY = 2;\\nconst int ATTR_VV_ROTATION = 3;\\nconst highp float NAN_MAGIC_NUMBER = 1e-30;\\nconst int BITSET_GENERIC_LOCK_COLOR = 1;\\nconst int BITSET_GENERIC_CONSIDER_ALPHA_ONLY = 4;\\nconst int BITSET_MARKER_ALIGNMENT_MAP = 0;\\nconst int BITSET_MARKER_OUTLINE_ALLOW_COLOR_OVERRIDE = 2;\\nconst int BITSET_MARKER_SCALE_SYMBOLS_PROPORTIONALLY = 3;\\nconst int BITSET_TYPE_FILL_OUTLINE = 0;\\nconst int BITSET_FILL_RANDOM_PATTERN_OFFSET = 2;\\nconst int BITSET_FILL_HAS_UNRESOLVED_REPLACEMENT_COLOR = 3;\\nconst int BITSET_FILL_HAS_PATTERN_HEIGHT_PRECISION_FACTOR = 5;\\nconst int BITSET_FILL_HAS_PATTERN_WIDTH_PRECISION_FACTOR = 6;\\nconst int BITSET_LINE_SCALE_DASH = 2;\",\n    fill: {\n      \"common.glsl\": \"#include <materials/symbologyTypeUtils.glsl>\\n#ifdef PATTERN\\nuniform mediump vec2 u_mosaicSize;\\nvarying mediump float v_sampleAlphaOnly;\\n#endif\\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\\nuniform lowp vec4 u_isActive[ 2 ];\\nuniform highp float u_dotValue;\\nuniform highp float u_tileDotsOverArea;\\nuniform highp float u_dotTextureDotCount;\\nuniform mediump float u_tileZoomFactor;\\n#endif\\nvarying highp vec3 v_id;\\nvarying lowp vec4 v_color;\\nvarying lowp float v_opacity;\\nvarying mediump vec4 v_aux1;\\n#ifdef PATTERN\\nvarying mediump vec2 v_tileTextureCoord;\\n#endif\\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\\nvarying lowp float v_isOutline;\\n#endif\\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\\nvarying highp vec2 v_dotTextureCoords;\\nvarying highp vec4 v_dotThresholds[ 2 ];\\n#endif\",\n      \"fill.frag\": \"precision highp float;\\n#include <materials/constants.glsl>\\n#include <materials/utils.glsl>\\n#include <materials/fill/common.glsl>\\n#ifdef PATTERN\\nuniform lowp sampler2D u_texture;\\n#endif\\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\\nuniform mediump mat4 u_dotColors[ 2 ];\\nuniform sampler2D u_dotTextures[ 2 ];\\nuniform vec4 u_dotBackgroundColor;\\n#endif\\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\\n#include <materials/shared/line/common.glsl>\\n#include <materials/shared/line/line.frag>\\nlowp vec4 drawLine() {\\nfloat v_lineWidth = v_aux1.x;\\nvec2  v_normal    = v_aux1.yz;\\nLineData inputs = LineData(\\nv_color,\\nv_normal,\\nv_lineWidth,\\nv_opacity,\\nv_id\\n);\\nreturn shadeLine(inputs);\\n}\\n#endif\\nlowp vec4 drawFill() {\\nlowp vec4 out_color = vec4(0.);\\n#ifdef HITTEST\\nout_color = v_color;\\n#elif defined(PATTERN)\\nmediump vec4 v_tlbr = v_aux1;\\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\\nlowp vec4 color = texture2D(u_texture, samplePos);\\nif (v_sampleAlphaOnly > 0.5) {\\ncolor.rgb = vec3(color.a);\\n}\\nout_color = v_opacity * v_color * color;\\n#elif SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY && !defined(HIGHLIGHT)\\nvec4 textureThresholds0 = texture2D(u_dotTextures[0], v_dotTextureCoords);\\nvec4 textureThresholds1 = texture2D(u_dotTextures[1], v_dotTextureCoords);\\nvec4 difference0 = v_dotThresholds[0] - textureThresholds0;\\nvec4 difference1 = v_dotThresholds[1] - textureThresholds1;\\n#ifdef DD_DOT_BLENDING\\nvec4 isPositive0 = step(0.0, difference0);\\nvec4 isPositive1 = step(0.0, difference1);\\nfloat weightSum = dot(isPositive0, difference0) + dot(isPositive1, difference1);\\nfloat lessThanEqZero = step(weightSum, 0.0);\\nfloat greaterThanZero = 1.0 - lessThanEqZero ;\\nfloat divisor = (weightSum + lessThanEqZero);\\nvec4 weights0 = difference0 * isPositive0 / divisor;\\nvec4 weights1 = difference1 * isPositive1 / divisor;\\nvec4 dotColor = u_dotColors[0] * weights0 + u_dotColors[1] * weights1;\\nvec4 preEffectColor = greaterThanZero * dotColor + lessThanEqZero * u_dotBackgroundColor;\\n#else\\nfloat diffMax = max(max4(difference0), max4(difference1));\\nfloat lessThanZero = step(diffMax, 0.0);\\nfloat greaterOrEqZero = 1.0 - lessThanZero;\\nvec4 isMax0 = step(diffMax, difference0);\\nvec4 isMax1 = step(diffMax, difference1);\\nvec4 dotColor = u_dotColors[0] * isMax0 + u_dotColors[1] * isMax1;\\nvec4 preEffectColor = greaterOrEqZero * dotColor + lessThanZero * u_dotBackgroundColor;\\n#endif\\nout_color = preEffectColor;\\n#else\\nout_color = v_opacity * v_color;\\n#endif\\n#ifdef HIGHLIGHT\\nout_color.a = 1.0;\\n#endif\\nreturn out_color;\\n}\\nvoid main() {\\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\\nif (v_isOutline > 0.5) {\\ngl_FragColor = drawLine();\\n} else {\\ngl_FragColor = drawFill();\\n}\\n#else\\ngl_FragColor = drawFill();\\n#endif\\n}\",\n      \"fill.vert\": \"#include <materials/symbologyTypeUtils.glsl>\\n#define PACKED_LINE\\nprecision highp float;\\nattribute float a_bitset;\\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\\nattribute float a_inverseArea;\\nvec4 a_color = vec4(0.0, 0.0, 0.0, 1.0);\\nvec2 a_zoomRange = vec2(0.0, 10000.0);\\n#else\\nattribute vec4 a_color;\\nattribute vec4 a_aux2;\\nattribute vec4 a_aux3;\\n#ifndef SYMBOLOGY_TYPE_IS_SIMPLE_LIKE\\nattribute vec4 a_aux1;\\nattribute vec2 a_zoomRange;\\n#else\\nvec2 a_zoomRange = vec2(0.0, 10000.0);\\n#endif\\n#endif\\nuniform vec2 u_tileOffset;\\nuniform vec2 u_maxIntNumOfCrossing;\\n#include <util/encoding.glsl>\\n#include <materials/vcommon.glsl>\\n#include <materials/fill/common.glsl>\\n#include <materials/fill/hittest.glsl>\\nconst float INV_SCALE_COMPRESSION_FACTOR = 1.0 / 128.0;\\nconst float MAX_REPRESENTABLE_INT = 16777216.0;\\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\\nvec4 dotThreshold(vec4 featureAttrOverFeatureArea, float dotValue, float tileDotsOverArea) {\\nreturn featureAttrOverFeatureArea * (1.0 / dotValue)  * (1.0 / tileDotsOverArea);\\n}\\n#endif\\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\\n#include <materials/shared/line/common.glsl>\\n#include <materials/shared/line/line.vert>\\nvoid drawLine(out lowp vec4 out_color, out highp vec3 out_pos) {\\nLineData outputs = buildLine(\\nout_pos,\\na_id,\\na_pos,\\na_color,\\n(a_aux3.xy - 128.) / 16.,\\n(a_aux3.zw - 128.) / 16.,\\n0.,\\na_aux2.z / 16.,\\na_bitset,\\nvec4(0.),\\nvec2(0.),\\na_aux2.w / 16.\\n);\\nv_id      = outputs.id;\\nv_opacity = outputs.opacity;\\nv_aux1    = vec4(outputs.lineHalfWidth, outputs.normal, 0.);\\nout_color = outputs.color;\\n}\\n#endif\\nvoid drawFill(out lowp vec4 out_color, out highp vec3 out_pos) {\\nfloat a_bitSet = a_bitset;\\nout_color = getColor(a_color, a_bitSet, BITSET_GENERIC_LOCK_COLOR);\\nv_opacity = getOpacity();\\nv_id      = norm(a_id);\\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\\nmat3 tileToTileNormalized = mat3(  2. / 512.,  0.,  0.,\\n0., -2. / 512.,  0.,\\n-1.,  1.,  1.  );\\nout_pos   = tileToTileNormalized * vec3((a_pos * FILL_POSITION_PRECISION), 1.);\\n#else\\nout_pos   = u_dvsMat3 * vec3(a_pos * FILL_POSITION_PRECISION, 1.);\\n#endif\\n#ifdef PATTERN\\nvec4  a_tlbr   = a_aux1;\\nfloat a_width  = a_aux2.x;\\nfloat a_height = a_aux2.y;\\nvec2  a_offset = a_aux2.zw;\\nvec2  a_scale  = a_aux3.xy;\\nfloat a_angle  = a_aux3.z;\\nif (getBit(a_bitset, BITSET_FILL_HAS_PATTERN_WIDTH_PRECISION_FACTOR) > 0.5) {\\na_width *= INV_SCALE_COMPRESSION_FACTOR;\\n}\\nif (getBit(a_bitset, BITSET_FILL_HAS_PATTERN_HEIGHT_PRECISION_FACTOR) > 0.5) {\\na_height *= INV_SCALE_COMPRESSION_FACTOR;\\n}\\nvec2 scale = INV_SCALE_COMPRESSION_FACTOR * a_scale;\\nfloat width = u_zoomFactor * a_width * scale.x;\\nfloat height = u_zoomFactor * a_height * scale.y;\\nfloat angle = C_256_TO_RAD * a_angle;\\nfloat sinA = sin(angle);\\nfloat cosA = cos(angle);\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nif (getBit(a_bitset, BITSET_FILL_RANDOM_PATTERN_OFFSET) > 0.5) {\\nfloat id = rgba2float(vec4(a_id, 0.0));\\ndx = rand(vec2(id, 0.0));\\ndy = rand(vec2(0.0, id));\\n}\\nmat3 patternMatrix = mat3(cosA / width, sinA / height, 0,\\n-sinA / width, cosA / height, 0,\\ndx,            dy,           1);\\nvec2 patternSize = vec2(a_width, a_height);\\nvec2 numPatternsPerMaxInt = vec2(MAX_REPRESENTABLE_INT) / patternSize;\\nvec2 maxIntCrossingOffsetCorrection = patternSize * fract(u_maxIntNumOfCrossing * numPatternsPerMaxInt);\\nvec2 tileOffset = u_tileOffset + maxIntCrossingOffsetCorrection - 0.5 * patternSize;\\ntileOffset = vec2(tileOffset.x * cosA - tileOffset.y * sinA, tileOffset.x * sinA + tileOffset.y * cosA);\\ntileOffset = mod(tileOffset, patternSize);\\nvec2 symbolOffset = u_zoomFactor * scale * vec2(a_offset - tileOffset) / vec2(width, height);\\nv_tileTextureCoord = (patternMatrix * vec3(a_pos * FILL_POSITION_PRECISION, 1.0)).xy - symbolOffset;\\nv_aux1 = a_tlbr / u_mosaicSize.xyxy;\\nv_sampleAlphaOnly = getBit(a_bitset, BITSET_GENERIC_CONSIDER_ALPHA_ONLY);\\nif (getBit(a_bitSet, BITSET_FILL_HAS_UNRESOLVED_REPLACEMENT_COLOR) > 0.5) {\\n#ifdef VV_COLOR\\nv_sampleAlphaOnly *= (1.0 - float(isNan(VV_ADATA[ATTR_VV_COLOR]))) * (1.0 - getBit(a_bitSet, BITSET_GENERIC_LOCK_COLOR));\\n#else\\nv_sampleAlphaOnly = 0.0;\\n#endif\\n}\\n#elif SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\\nvec4 ddAttributeData0 = getAttributeData2(a_id) * u_isActive[0] * a_inverseArea;\\nvec4 ddAttributeData1 = getAttributeData3(a_id) * u_isActive[1] * a_inverseArea;\\nfloat size = u_tileZoomFactor * 512.0 * 1.0 / u_pixelRatio;\\nv_dotThresholds[0] = dotThreshold(ddAttributeData0, u_dotValue, u_tileDotsOverArea);\\nv_dotThresholds[1] = dotThreshold(ddAttributeData1, u_dotValue, u_tileDotsOverArea);\\nv_dotTextureCoords = (a_pos * FILL_POSITION_PRECISION + 0.5) / size;\\n#endif\\n}\\n#ifdef HITTEST\\nvoid draw(out lowp vec4 out_color, out highp vec3 out_pos) {\\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\\nif (getBit(a_bitset, BITSET_TYPE_FILL_OUTLINE) > 0.5) {\\nout_pos = vec3(0., 0., 2.);\\nreturn;\\n}\\n#endif\\nhittestFill(out_color, out_pos);\\ngl_PointSize = 1.0;\\n}\\n#elif defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE)\\nvoid draw(out lowp vec4 out_color, out highp vec3 out_pos) {\\nv_isOutline = getBit(a_bitset, BITSET_TYPE_FILL_OUTLINE);\\nif (v_isOutline > 0.5) {\\ndrawLine(out_color, out_pos);\\n} else {\\ndrawFill(out_color, out_pos);\\n}\\n}\\n#else\\n#define draw drawFill\\n#endif\\nvoid main()\\n{\\nINIT;\\nhighp vec3 pos  = vec3(0.);\\nhighp vec4 color  = vec4(0.);\\ndraw(color, pos);\\nv_color = color;\\ngl_Position = vec4(clip(v_color, pos, getFilterFlags(), a_zoomRange), 1.0);\\n}\",\n      \"hittest.glsl\": \"#ifdef HITTEST\\n#include <materials/hittest/common.glsl>\\nattribute vec2 a_pos1;\\nattribute vec2 a_pos2;\\nvoid hittestFill(\\nout lowp vec4 out_color,\\nout highp vec3 out_pos\\n) {\\nvec3 pos        = u_viewMat3 * u_tileMat3 * vec3(a_pos  * FILL_POSITION_PRECISION, 1.);\\nvec3 pos1       = u_viewMat3 * u_tileMat3 * vec3(a_pos1 * FILL_POSITION_PRECISION, 1.);\\nvec3 pos2       = u_viewMat3 * u_tileMat3 * vec3(a_pos2 * FILL_POSITION_PRECISION, 1.);\\nfloat hittestDist = u_hittestDist;\\nfloat dist = distPointTriangle(u_hittestPos, pos.xy, pos1.xy, pos2.xy);\\nout_pos = vec3(getAttributeDataTextureCoords(a_id), 0.0);\\nif (dist < 0. || dist >= hittestDist) {\\nout_pos.z += 2.0;\\n}\\nout_color = vec4(1. / 255., 0, 0, dist == 0. ? (1. / 255.) : 0.);\\n}\\n#endif\"\n    },\n    hittest: {\n      \"common.glsl\": \"#ifdef HITTEST\\nuniform float hittestDist;\\nuniform highp vec2 hittestPos;\\nfloat projectScalar(vec2 a, vec2 b) {\\nreturn dot(a, normalize(b));\\n}\\nfloat distPointSegment(vec2 p0, vec2 p1, vec2 p2) {\\nvec2 L = p2 - p1;\\nvec2 A = p0 - p1;\\nfloat projAL = projectScalar(A, L);\\nfloat t = clamp(projAL / length(L), 0., 1.);\\nreturn distance(p0, p1 + t * (p2 - p1));\\n}\\nvoid hittestMarker(out lowp vec4 out_color, out highp vec3 out_pos, in highp vec3 pos, float size) {\\nfloat dist = distance(pos, vec3(hittestPos, 1.));\\nout_pos = vec3(getAttributeDataTextureCoords(a_id), 0.0);\\nif ((dist - size) > hittestDist) {\\nout_pos.z += 2.0;\\n}\\nout_color = vec4(1. / 255., 0, 0, (dist - size) < 0. ? (1. / 255.) : 0.);\\n}\\nfloat intersectPointTriangleBary(vec2 p, vec2 a, vec2 b, vec2 c) {\\nreturn inTriangle(xyToBarycentric(p, a, b, c));\\n}\\nfloat distPointTriangle(vec2 p, vec2 a, vec2 b, vec2 c) {\\nvec2 ba = b - a;\\nvec2 ca = c - a;\\nfloat crossProduct = ba.x * ca.y - ca.x * ba.y;\\nbool isParallel = crossProduct < EPSILON_HITTEST && crossProduct > -EPSILON_HITTEST;\\nif (isParallel) {\\nreturn -1.;\\n}\\nif (intersectPointTriangleBary(p.xy, a, b, c) == 1.) {\\nreturn 0.;\\n}\\nfloat distAB = distPointSegment(p, a, b);\\nfloat distBC = distPointSegment(p, b, c);\\nfloat distCA = distPointSegment(p, c, a);\\nreturn min(min(distAB, distBC), distCA);\\n}\\n#endif\"\n    },\n    icon: {\n      \"common.glsl\": \"#include <util/encoding.glsl>\\nuniform lowp vec2 u_mosaicSize;\\nvarying lowp vec4 v_color;\\nvarying highp vec3 v_id;\\nvarying highp vec4 v_sizeTex;\\nvarying mediump vec3 v_pos;\\nvarying lowp float v_opacity;\\nuniform lowp sampler2D u_texture;\\n#ifdef SDF\\nvarying lowp vec4 v_outlineColor;\\nvarying mediump float v_outlineWidth;\\nvarying mediump float v_distRatio;\\nvarying mediump float v_overridingOutlineColor;\\nvarying mediump float v_isThin;\\n#endif\\n#ifdef SDF\\nvec4 getColor(vec2 v_size, vec2 v_tex) {\\n#ifdef HITTEST\\nlowp vec4 fillPixelColor = vec4(1.0);\\n#else\\nlowp vec4 fillPixelColor = v_color;\\n#endif\\nfloat d = 0.5 - rgba2float(texture2D(u_texture, v_tex));\\nfloat size = max(v_size.x, v_size.y);\\nfloat dist = d * size * SOFT_EDGE_RATIO * v_distRatio;\\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\\nfloat outlineWidth = v_outlineWidth;\\n#ifdef HIGHLIGHT\\noutlineWidth = max(outlineWidth, 4.0 * v_isThin);\\n#endif\\nif (outlineWidth > 0.25) {\\nlowp vec4 outlinePixelColor = v_overridingOutlineColor * v_color + (1.0 - v_overridingOutlineColor) * v_outlineColor;\\nfloat clampedOutlineSize = min(outlineWidth, size);\\noutlinePixelColor *= clamp(0.5 - abs(dist) + clampedOutlineSize * 0.5, 0.0, 1.0);\\nreturn v_opacity * ((1.0 - outlinePixelColor.a) * fillPixelColor + outlinePixelColor);\\n}\\nreturn v_opacity * fillPixelColor;\\n}\\n#else\\nvec4 getColor(vec2 _v_size, vec2 v_tex) {\\nlowp vec4 texColor = texture2D(u_texture, v_tex);\\nreturn v_opacity * texColor * v_color;\\n}\\n#endif\",\n      heatmapAccumulate: {\n        \"common.glsl\": \"varying lowp vec4 v_hittestResult;\\nvarying mediump vec2 v_offsetFromCenter;\\nvarying highp float v_fieldValue;\",\n        \"heatmapAccumulate.frag\": \"precision mediump float;\\n#include <materials/icon/heatmapAccumulate/common.glsl>\\n#ifdef HEATMAP_PRECISION_HALF_FLOAT\\n#define COMPRESSION_FACTOR 0.25\\n#else\\n#define COMPRESSION_FACTOR 1.0\\n#endif\\nuniform lowp sampler2D u_texture;\\nvoid main() {\\n#ifdef HITTEST\\ngl_FragColor = v_hittestResult;\\n#else\\nfloat radius = length(v_offsetFromCenter);\\nfloat shapeWeight = step(radius, 1.0);\\nfloat oneMinusRadiusSquared = 1.0 - radius * radius;\\nfloat kernelWeight = oneMinusRadiusSquared * oneMinusRadiusSquared;\\ngl_FragColor = vec4(shapeWeight * kernelWeight * v_fieldValue * COMPRESSION_FACTOR);\\n#endif\\n}\",\n        \"heatmapAccumulate.vert\": \"precision highp float;\\nattribute vec2 a_vertexOffset;\\nvec4 a_color = vec4(0.0);\\nvec2 a_zoomRange = vec2(0.0, 10000.0);\\nuniform float u_radius;\\nuniform float u_isFieldActive;\\n#include <materials/vcommon.glsl>\\n#include <materials/hittest/common.glsl>\\n#include <materials/icon/heatmapAccumulate/common.glsl>\\nvoid main() {\\nfloat filterFlags = getFilterFlags();\\n#ifdef HITTEST\\nhighp vec4 out_hittestResult = vec4(0.);\\nhighp vec3 out_pos = vec3(0.);\\nvec3 pos = u_viewMat3 * u_tileMat3 * vec3(a_pos * POSITION_PRECISION, 1.0);\\nhittestMarker(out_hittestResult, out_pos, pos, u_radius);\\nv_hittestResult = out_hittestResult;\\ngl_PointSize = 1.;\\ngl_Position = vec4(clip(a_color, out_pos, filterFlags, a_zoomRange), 1.0);\\n#else\\nv_offsetFromCenter = sign(a_vertexOffset);\\nv_fieldValue = getAttributeData2(a_id).x * u_isFieldActive + 1.0 - u_isFieldActive;\\nvec3 centerPos = u_dvsMat3 * vec3(a_pos * POSITION_PRECISION, 1.0);\\nvec3 vertexPos = centerPos + u_displayViewMat3 * vec3(v_offsetFromCenter, 0.0) * u_radius;\\ngl_Position = vec4(clip(a_color, vertexPos, filterFlags, a_zoomRange), 1.0);\\n#endif\\n}\"\n      },\n      \"hittest.glsl\": \"#ifdef HITTEST\\n#include <materials/hittest/common.glsl>\\nattribute vec2 a_vertexOffset1;\\nattribute vec2 a_vertexOffset2;\\nattribute vec2 a_texCoords1;\\nattribute vec2 a_texCoords2;\\nvec2 getTextureCoords(in vec3 bary, in vec2 texCoords0, in vec2 texCoords1, in vec2 texCoords2) {\\nreturn texCoords0 * bary.x + texCoords1 * bary.y + texCoords2 * bary.z;\\n}\\nvoid hittestIcon(\\ninout lowp vec4 out_color,\\nout highp vec3 out_pos,\\nin vec3 pos,\\nin vec3 offset,\\nin vec2 size,\\nin float scaleFactor,\\nin float isMapAligned\\n) {\\nout_pos = vec3(getAttributeDataTextureCoords(a_id), 0.0);\\nvec3 posBase = u_viewMat3 * u_tileMat3  * pos;\\nvec3 offset1 = scaleFactor * vec3(a_vertexOffset1 / 16.0, 0.);\\nvec3 offset2 = scaleFactor * vec3(a_vertexOffset2 / 16.0, 0.);\\nvec2 pos0    = (posBase + getMatrixNoDisplay(isMapAligned) * offset).xy;\\nvec2 pos1    = (posBase + getMatrixNoDisplay(isMapAligned) * offset1).xy;\\nvec2 pos2    = (posBase + getMatrixNoDisplay(isMapAligned) * offset2).xy;\\nvec3 bary0 = xyToBarycentric(u_hittestPos + vec2(-u_hittestDist, -u_hittestDist), pos0, pos1, pos2);\\nvec3 bary1 = xyToBarycentric(u_hittestPos + vec2(0., -u_hittestDist), pos0, pos1, pos2);\\nvec3 bary2 = xyToBarycentric(u_hittestPos + vec2(u_hittestDist, -u_hittestDist), pos0, pos1, pos2);\\nvec3 bary3 = xyToBarycentric(u_hittestPos + vec2(-u_hittestDist, 0.), pos0, pos1, pos2);\\nvec3 bary4 = xyToBarycentric(u_hittestPos, pos0, pos1, pos2);\\nvec3 bary5 = xyToBarycentric(u_hittestPos + vec2(u_hittestDist, 0.), pos0, pos1, pos2);\\nvec3 bary6 = xyToBarycentric(u_hittestPos + vec2(-u_hittestDist, u_hittestDist), pos0, pos1, pos2);\\nvec3 bary7 = xyToBarycentric(u_hittestPos + vec2(0., u_hittestDist), pos0, pos1, pos2);\\nvec3 bary8 = xyToBarycentric(u_hittestPos + vec2(u_hittestDist, u_hittestDist), pos0, pos1, pos2);\\nvec2 tex0 = a_texCoords  / u_mosaicSize;\\nvec2 tex1 = a_texCoords1 / u_mosaicSize;\\nvec2 tex2 = a_texCoords2 / u_mosaicSize;\\nfloat alphaSum = 0.;\\nalphaSum += inTriangle(bary0) * getColor(size, getTextureCoords(bary0, tex0, tex1, tex2)).a;\\nalphaSum += inTriangle(bary1) * getColor(size, getTextureCoords(bary1, tex0, tex1, tex2)).a;\\nalphaSum += inTriangle(bary2) * getColor(size, getTextureCoords(bary2, tex0, tex1, tex2)).a;\\nalphaSum += inTriangle(bary3) * getColor(size, getTextureCoords(bary3, tex0, tex1, tex2)).a;\\nalphaSum += inTriangle(bary4) * getColor(size, getTextureCoords(bary4, tex0, tex1, tex2)).a;\\nalphaSum += inTriangle(bary5) * getColor(size, getTextureCoords(bary5, tex0, tex1, tex2)).a;\\nalphaSum += inTriangle(bary6) * getColor(size, getTextureCoords(bary6, tex0, tex1, tex2)).a;\\nalphaSum += inTriangle(bary7) * getColor(size, getTextureCoords(bary7, tex0, tex1, tex2)).a;\\nout_pos.z += step(alphaSum, .05) * 2.0;\\nout_color = vec4(1. / 255., 0., 0., alphaSum / 255.);\\n}\\n#endif\",\n      \"icon.frag\": \"precision mediump float;\\n#include <materials/constants.glsl>\\n#include <materials/utils.glsl>\\n#include <materials/icon/common.glsl>\\nvoid main()\\n{\\n#ifdef HITTEST\\nvec4 color = v_color;\\n#else\\nvec4 color = getColor(v_sizeTex.xy, v_sizeTex.zw);\\n#endif\\n#ifdef HIGHLIGHT\\ncolor.a = step(1.0 / 255.0, color.a);\\n#endif\\ngl_FragColor = color;\\n}\",\n      \"icon.vert\": \"precision highp float;\\nattribute vec4 a_color;\\nattribute vec4 a_outlineColor;\\nattribute vec4 a_sizeAndOutlineWidth;\\nattribute vec2 a_vertexOffset;\\nattribute vec2 a_texCoords;\\nattribute vec2 a_bitSetAndDistRatio;\\nattribute vec2 a_zoomRange;\\n#include <materials/vcommon.glsl>\\n#include <materials/icon/common.glsl>\\n#include <materials/icon/hittest.glsl>\\nfloat getMarkerScaleFactor(inout vec2 size, in float referenceSize) {\\n#ifdef VV_SIZE\\nfloat f = getSize(size.y) / size.y;\\nfloat sizeFactor = size.y / referenceSize;\\nreturn getSize(referenceSize) / referenceSize;\\n#else\\nreturn 1.;\\n#endif\\n}\\nvoid main()\\n{\\nINIT;\\nfloat a_bitSet = a_bitSetAndDistRatio.x;\\nvec3  pos           = vec3(a_pos * POSITION_PRECISION, 1.0);\\nvec2  size          = a_sizeAndOutlineWidth.xy * a_sizeAndOutlineWidth.xy / 128.0;\\nvec3  offset        = vec3(a_vertexOffset / 16.0, 0.);\\nfloat outlineSize   = a_sizeAndOutlineWidth.z * a_sizeAndOutlineWidth.z / 128.0;\\nfloat isMapAligned  = getBit(a_bitSet, BITSET_MARKER_ALIGNMENT_MAP);\\nfloat referenceSize = a_sizeAndOutlineWidth.w * a_sizeAndOutlineWidth.w / 128.0;\\nfloat scaleSymbolProportionally = getBit(a_bitSet, BITSET_MARKER_SCALE_SYMBOLS_PROPORTIONALLY);\\nfloat scaleFactor               = getMarkerScaleFactor(size, referenceSize);\\nsize.xy     *= scaleFactor;\\noffset.xy   *= scaleFactor;\\noutlineSize *= scaleSymbolProportionally * (scaleFactor - 1.0) + 1.0;\\nvec2 v_tex   = a_texCoords / u_mosaicSize;\\nfloat filterFlags = getFilterFlags();\\nv_color    = getColor(a_color, a_bitSet, BITSET_GENERIC_LOCK_COLOR);\\nv_opacity  = getOpacity();\\nv_id       = norm(a_id);\\nv_pos      = u_dvsMat3 * pos + getMatrix(isMapAligned) * getRotation()  * offset;\\nv_sizeTex  = vec4(size.xy, v_tex.xy);\\n#ifdef SDF\\nv_isThin   = getBit(a_bitSet, BITSET_MARKER_OUTLINE_ALLOW_COLOR_OVERRIDE);\\n#ifdef VV_COLOR\\nv_overridingOutlineColor = v_isThin;\\n#else\\nv_overridingOutlineColor = 0.0;\\n#endif\\nv_outlineWidth = min(outlineSize, max(max(size.x, size.y) - 0.99, 0.0));\\nv_outlineColor = a_outlineColor;\\nv_distRatio = a_bitSetAndDistRatio.y / 128.0;\\n#endif\\n#ifdef HITTEST\\nhighp vec4 out_color = vec4(0.);\\nhighp vec3 out_pos   = vec3(0.);\\nhittestIcon(out_color, out_pos, pos, offset, size, scaleFactor, isMapAligned);\\nv_color = out_color;\\ngl_PointSize = 1.;\\ngl_Position = vec4(clip(v_color, out_pos, filterFlags, a_zoomRange), 1.0);\\n#else\\ngl_Position = vec4(clip(v_color, v_pos, filterFlags, a_zoomRange), 1.0);\\n#endif\\n}\"\n    },\n    label: {\n      \"common.glsl\": \"uniform mediump float u_zoomLevel;\\nuniform mediump float u_mapRotation;\\nuniform mediump float u_mapAligned;\\nuniform mediump vec2 u_mosaicSize;\\nvarying mediump float v_antialiasingWidth;\\nvarying mediump float v_edgeDistanceOffset;\\nvarying mediump vec2 v_tex;\\nvarying mediump vec4 v_color;\\nvarying lowp vec4 v_animation;\",\n      \"label.frag\": \"#include <materials/text/text.frag>\",\n      \"label.vert\": \"precision highp float;\\n#include <materials/vcommon.glsl>\\n#include <materials/text/common.glsl>\\nattribute vec4 a_color;\\nattribute vec4 a_haloColor;\\nattribute vec4 a_texAndSize;\\nattribute vec4 a_refSymbolAndPlacementOffset;\\nattribute vec4 a_glyphData;\\nattribute vec2 a_vertexOffset;\\nattribute vec2 a_texCoords;\\nuniform float u_isHaloPass;\\nuniform float u_isBackgroundPass;\\nuniform float u_mapRotation;\\nuniform float u_mapAligned;\\nfloat getZ(in float minZoom, in float maxZoom, in float angle) {\\nfloat glyphAngle = angle * 360.0 / 254.0;\\nfloat mapAngle = u_mapRotation * 360.0 / 254.0;\\nfloat diffAngle = min(360.0 - abs(mapAngle - glyphAngle), abs(mapAngle - glyphAngle));\\nfloat z = 0.0;\\nz += u_mapAligned * (2.0 * (1.0 - step(minZoom, u_currentZoom)));\\nz += u_mapAligned * 2.0 * step(90.0, diffAngle);\\nz += 2.0 * (1.0 - step(u_currentZoom, maxZoom));\\nreturn z;\\n}\\nvoid main()\\n{\\nINIT;\\nfloat groupMinZoom    = getMinZoom();\\nfloat glyphMinZoom    = a_glyphData.x;\\nfloat glyphMaxZoom    = a_glyphData.y;\\nfloat glyphAngle      = a_glyphData.z;\\nfloat a_isBackground  = a_glyphData.w;\\nfloat a_minZoom          = max(groupMinZoom, glyphMinZoom);\\nfloat a_placementPadding = a_refSymbolAndPlacementOffset.x * EXTRUDE_SCALE_PLACEMENT_PADDING;\\nvec2  a_placementDir     = unpack_u8_nf32(a_refSymbolAndPlacementOffset.zw);\\nfloat a_refSymbolSize    = a_refSymbolAndPlacementOffset.y;\\nfloat fontSize           = a_texAndSize.z;\\nfloat haloSize           = a_texAndSize.w * OUTLINE_SCALE;\\nvec2  vertexOffset = a_vertexOffset * OFFSET_PRECISION;\\nvec3  pos          = vec3(a_pos * POSITION_PRECISION, 1.0);\\nfloat z            = getZ(a_minZoom, glyphMaxZoom, glyphAngle);\\nfloat fontScale    = fontSize / SDF_FONT_SIZE;\\nfloat halfSize     = getSize(a_refSymbolSize) / 2.0;\\nfloat animation    = pow(getAnimationState(), vec4(2.0)).r;\\nfloat isText = 1.0 - a_isBackground;\\nfloat isBackground = u_isBackgroundPass * a_isBackground;\\nvec4  nonHaloColor = (isBackground + isText) * a_color;\\nv_color     = animation * ((1.0 - u_isHaloPass) * nonHaloColor + (u_isHaloPass * a_haloColor));\\nv_opacity   = 1.0;\\nv_tex       = a_texCoords / u_mosaicSize;\\nv_edgeDistanceOffset = u_isHaloPass * haloSize / fontScale / MAX_SDF_DISTANCE;\\nv_antialiasingWidth  = 0.105 * SDF_FONT_SIZE / fontSize / u_pixelRatio;\\nvec2 placementOffset = a_placementDir * (halfSize + a_placementPadding);\\nvec3 glyphOffset     = u_displayMat3 * vec3(vertexOffset + placementOffset, 0.0);\\nvec3 v_pos           = vec3((u_dvsMat3 * pos + glyphOffset).xy, z);\\nfloat isHidden = u_isBackgroundPass * isText + (1.0 - u_isBackgroundPass) * a_isBackground;\\nv_pos.z += 2.0 * isHidden;\\ngl_Position = vec4(v_pos, 1.0);\\n#ifdef DEBUG\\nv_color = vec4(a_color.rgb, z == 0.0 ? 1.0 : 0.645);\\n#endif\\n}\"\n    },\n    line: {\n      \"common.glsl\": \"varying lowp vec4 v_color;\\nvarying highp vec3 v_id;\\nvarying mediump vec2 v_normal;\\nvarying mediump float v_lineHalfWidth;\\nvarying lowp float v_opacity;\\n#ifdef PATTERN\\nvarying mediump vec4 v_tlbr;\\nvarying mediump vec2 v_patternSize;\\n#endif\\n#if defined(PATTERN) || defined(SDF)\\nvarying highp float v_accumulatedDistance;\\n#endif\\n#ifdef SDF\\nvarying mediump float v_lineWidthRatio;\\n#endif\",\n      \"hittest.glsl\": \"#include <materials/hittest/common.glsl>\\n#ifdef HITTEST\\nattribute vec2 a_pos1;\\nattribute vec2 a_pos2;\\nvoid hittestLine(out lowp vec4 out_color, out highp vec3 out_pos, float halfWidth) {\\nvec3 pos        = u_viewMat3 * u_tileMat3 * vec3(a_pos  * POSITION_PRECISION, 1.);\\nvec3 pos1       = u_viewMat3 * u_tileMat3 * vec3(a_pos1 * POSITION_PRECISION, 1.);\\nvec3 pos2       = u_viewMat3 * u_tileMat3 * vec3(a_pos2 * POSITION_PRECISION, 1.);\\nvec3 outTextureCoords = vec3(getAttributeDataTextureCoords(a_id), 0.0);\\nfloat dist = min(distPointSegment(u_hittestPos, pos.xy, pos1.xy),\\ndistPointSegment(u_hittestPos, pos.xy, pos2.xy)) - halfWidth;\\nout_pos = vec3(getAttributeDataTextureCoords(a_id), 0.0);\\nif (dist >= u_hittestDist) {\\nout_pos.z += 2.0;\\n}\\nout_color = vec4(1. / 255., 0, 0, dist <= 0. ? (1. / 255.) : 0.);\\n}\\n#endif\",\n      \"line.frag\": \"precision lowp float;\\n#include <util/encoding.glsl>\\n#include <materials/constants.glsl>\\n#include <materials/symbologyTypeUtils.glsl>\\n#include <materials/line/common.glsl>\\n#include <materials/shared/line/common.glsl>\\n#include <materials/shared/line/line.frag>\\n#ifdef HITTEST\\nvoid main() {\\ngl_FragColor = v_color;\\n}\\n#else\\nvoid main() {\\nLineData inputs = LineData(\\nv_color,\\nv_normal,\\nv_lineHalfWidth,\\nv_opacity,\\n#ifndef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\\n#ifdef PATTERN\\nv_tlbr,\\nv_patternSize,\\n#endif\\n#ifdef SDF\\nv_lineWidthRatio,\\n#endif\\n#if defined(PATTERN) || defined(SDF)\\nv_accumulatedDistance,\\n#endif\\n#endif\\nv_id\\n);\\ngl_FragColor = shadeLine(inputs);\\n}\\n#endif\",\n      \"line.vert\": \"precision highp float;\\nattribute vec4 a_color;\\nattribute vec4 a_offsetAndNormal;\\nattribute vec2 a_accumulatedDistanceAndHalfWidth;\\nattribute vec4 a_tlbr;\\nattribute vec4 a_segmentDirection;\\nattribute vec2 a_aux;\\nattribute vec2 a_zoomRange;\\n#include <materials/vcommon.glsl>\\n#include <materials/symbologyTypeUtils.glsl>\\n#include <materials/line/common.glsl>\\n#include <materials/line/hittest.glsl>\\n#include <materials/shared/line/common.glsl>\\n#include <materials/shared/line/line.vert>\\n#ifdef HITTEST\\nvoid draw() {\\nfloat aa        = 0.5 * u_antialiasing;\\nfloat a_halfWidth = a_accumulatedDistanceAndHalfWidth.y / 16.;\\nfloat a_cimHalfWidth = a_aux.x / 16. ;\\nvec2  a_offset = a_offsetAndNormal.xy / 16.;\\nfloat baseWidth = getBaseLineHalfWidth(a_halfWidth, a_cimHalfWidth);\\nfloat halfWidth = getLineHalfWidth(baseWidth, aa);\\nhighp vec3 pos  = vec3(0.);\\nv_color = vec4(0.);\\nhittestLine(v_color, pos, halfWidth);\\ngl_PointSize = 1.;\\ngl_Position = vec4(clip(v_color, pos, getFilterFlags(), a_zoomRange), 1.0);\\n}\\n#else\\nvoid draw()\\n{\\nhighp vec3 pos = vec3(0.);\\nLineData outputs = buildLine(\\npos,\\na_id,\\na_pos,\\na_color,\\na_offsetAndNormal.xy / 16.,\\na_offsetAndNormal.zw / 16.,\\na_accumulatedDistanceAndHalfWidth.x,\\na_accumulatedDistanceAndHalfWidth.y / 16.,\\na_segmentDirection.w,\\na_tlbr,\\na_segmentDirection.xy / 16.,\\na_aux.x / 16.\\n);\\nv_id              = outputs.id;\\nv_color           = outputs.color;\\nv_normal          = outputs.normal;\\nv_lineHalfWidth   = outputs.lineHalfWidth;\\nv_opacity         = outputs.opacity;\\n#ifndef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\\n#ifdef PATTERN\\nv_tlbr          = outputs.tlbr;\\nv_patternSize   = outputs.patternSize;\\n#endif\\n#ifdef SDF\\nv_lineWidthRatio = outputs.lineWidthRatio;\\n#endif\\n#if defined(PATTERN) || defined(SDF)\\nv_accumulatedDistance = outputs.accumulatedDistance;\\n#endif\\n#endif\\ngl_Position = vec4(clip(outputs.color, pos, getFilterFlags(), a_zoomRange), 1.0);\\n}\\n#endif\\nvoid main() {\\nINIT;\\ndraw();\\n}\"\n    },\n    pie: {\n      \"pie.common.glsl\": \"uniform float outlineWidth;\\nuniform mediump float sectorThreshold;\\nvarying vec3  v_id;\\nvarying vec3  v_pos;\\nvarying vec2  v_offset;\\nvarying vec4  v_color;\\nvarying float v_size;\\nvarying float v_numOfEntries;\\nvarying float v_maxSectorAngle;\\nvarying vec2  v_filteredSectorToColorId[numberOfFields];\\nvarying vec2  v_texCoords;\\nvarying float v_outlineWidth;\\nvarying float v_opacity;\\nstruct FilteredChartInfo {\\nfloat endSectorAngle;\\nint colorId;\\n};\",\n      \"pie.frag\": \"precision highp float;\\n#include <util/atan2.glsl>\\n#include <materials/constants.glsl>\\n#include <materials/utils.glsl>\\n#include <materials/pie/pie.common.glsl>\\nuniform lowp vec4 colors[numberOfFields];\\nuniform lowp vec4 defaultColor;\\nuniform lowp vec4 othersColor;\\nuniform lowp vec4 outlineColor;\\nuniform float donutRatio;\\nlowp vec4 getSectorColor(in int index, in vec2 filteredSectorToColorId[numberOfFields]) {\\nmediump int colorIndex = int(filteredSectorToColorId[index].y);\\nreturn colors[colorIndex];\\n}\\nconst int OTHER_SECTOR_ID = 255;\\n#ifdef HITTEST\\nvec4 getColor() {\\nfloat distanceSize = length(v_offset) * v_size;\\nfloat donutSize = donutRatio * v_size;\\nfloat alpha = step(donutSize, distanceSize) * (1.0 - step(v_size, distanceSize));\\nreturn v_color;\\n}\\n#else\\nvec4 getColor() {\\nfloat angle = 90.0 - C_RAD_TO_DEG * atan2(v_offset.y, v_offset.x);\\nif (angle < 0.0) {\\nangle += 360.0;\\n} else if (angle > 360.0) {\\nangle = mod(angle, 360.0);\\n}\\nint numOfEntries = int(v_numOfEntries);\\nfloat maxSectorAngle = v_maxSectorAngle;\\nlowp vec4 fillColor = (maxSectorAngle > 0.0 || sectorThreshold > 0.0) ? othersColor : defaultColor;\\nlowp vec4 prevColor = vec4(0.0);\\nlowp vec4 nextColor = vec4(0.0);\\nfloat startSectorAngle = 0.0;\\nfloat endSectorAngle = 0.0;\\nif (angle < maxSectorAngle) {\\nfor (int index = 0; index < numberOfFields; ++index) {\\nstartSectorAngle = endSectorAngle;\\nendSectorAngle = v_filteredSectorToColorId[index].x;\\nif (endSectorAngle > angle) {\\nfillColor = getSectorColor(index, v_filteredSectorToColorId);\\nprevColor = sectorThreshold != 0.0 && index == 0 && abs(360.0 - maxSectorAngle) < EPSILON ? othersColor :\\ngetSectorColor(index > 0 ? index - 1 : numOfEntries - 1, v_filteredSectorToColorId);\\nnextColor = sectorThreshold != 0.0 && abs(endSectorAngle - maxSectorAngle) < EPSILON ? othersColor :\\ngetSectorColor(index < numOfEntries - 1 ? index + 1 : 0, v_filteredSectorToColorId);\\nbreak;\\n}\\nif (index == numOfEntries - 1) {\\nbreak;\\n}\\n}\\n} else {\\nprevColor = getSectorColor(numOfEntries - 1, v_filteredSectorToColorId);\\nnextColor = getSectorColor(0, v_filteredSectorToColorId);\\nstartSectorAngle = maxSectorAngle;\\nendSectorAngle = 360.0;\\n}\\nlowp vec4 outlineColor = outlineColor;\\nfloat offset = length(v_offset);\\nfloat distanceSize = offset * v_size;\\nif (startSectorAngle != 0.0 || endSectorAngle != 360.0) {\\nfloat distanceToStartSector = (angle - startSectorAngle);\\nfloat distanceToEndSector = (endSectorAngle - angle);\\nfloat sectorThreshold = 0.6;\\nfloat beginSectorAlpha = smoothstep(0.0, sectorThreshold, distanceToStartSector * offset);\\nfloat endSectorAlpha = smoothstep(0.0, sectorThreshold, distanceToEndSector * offset);\\nif (endSectorAlpha > 0.0) {\\nfillColor = mix(nextColor, fillColor, endSectorAlpha);\\n} else if (beginSectorAlpha > 0.0) {\\nfillColor = mix(prevColor, fillColor, beginSectorAlpha);\\n}\\n}\\nfloat donutSize = donutRatio * (v_size - v_outlineWidth);\\nfloat endOfDonut = donutSize - v_outlineWidth;\\nfloat aaThreshold = 0.75;\\nfloat innerCircleAlpha = endOfDonut - aaThreshold > 0.0 ? smoothstep(endOfDonut - aaThreshold, endOfDonut + aaThreshold, distanceSize) : 1.0;\\nfloat outerCircleAlpha = 1.0 - smoothstep(v_size - aaThreshold, v_size + aaThreshold , distanceSize);\\nfloat circleAlpha = innerCircleAlpha * outerCircleAlpha;\\nfloat startOfOutline = v_size - v_outlineWidth;\\nif (startOfOutline > 0.0 && v_outlineWidth > 0.25) {\\nfloat outlineFactor = smoothstep(startOfOutline - aaThreshold, startOfOutline + aaThreshold, distanceSize);\\nfloat innerLineFactor = donutSize - aaThreshold > 0.0 ? 1.0 - smoothstep(donutSize - aaThreshold, donutSize + aaThreshold , distanceSize) : 0.0;\\nfillColor = mix(fillColor, outlineColor, innerLineFactor + outlineFactor);\\n}\\nreturn v_opacity * circleAlpha * fillColor;\\n}\\n#endif\\nvoid main()\\n{\\nvec4 color = getColor();\\n#ifdef highlight\\ncolor.a = step(1.0 / 255.0, color.a);\\n#endif\\ngl_FragColor = color;\\n}\",\n      \"pie.vert\": \"#include <materials/constants.glsl>\\n#include <materials/utils.glsl>\\n#include <materials/barycentric.glsl>\\n#include <materials/vcommon.glsl>\\n#include <materials/vv.glsl>\\n#include <materials/attributeData.glsl>\\n#include <materials/pie/pie.common.glsl>\\n#include <materials/hittest/common.glsl>\\nattribute float a_bitSet;\\nattribute vec2  a_offset;\\nattribute vec2  a_texCoords;\\nattribute vec2  a_size;\\nattribute float a_referenceSize;\\nattribute vec2  a_zoomRange;\\nint filterValue(in float sectorAngle,\\nin int currentIndex,\\ninout FilteredChartInfo filteredInfo,\\ninout vec2 filteredSectorToColorId[numberOfFields]) {\\nif (sectorAngle > sectorThreshold * 360.0) {\\nfilteredInfo.endSectorAngle += sectorAngle;\\nfilteredSectorToColorId[filteredInfo.colorId] = vec2(filteredInfo.endSectorAngle, currentIndex);\\n++filteredInfo.colorId;\\n}\\nreturn 0;\\n}\\nint filterValues(inout vec2 filteredSectorToColorId[numberOfFields],\\ninout FilteredChartInfo filteredInfo,\\nin float sectorAngles[numberOfFields]) {\\nfor (int index = 0; index < numberOfFields; ++index) {\\nfloat sectorValue = sectorAngles[index];\\nfilterValue(sectorValue, index, filteredInfo, filteredSectorToColorId);\\n}\\nreturn filteredInfo.colorId;\\n}\\nvec2 getMarkerSize(inout vec2 offset, inout vec2 baseSize, inout float outlineSize, in float a_referenceSize, in float bitSet) {\\nvec2 outSize = baseSize;\\n#ifdef VV_SIZE\\nfloat r = getSize(a_referenceSize, currentScale) / a_referenceSize;\\noutSize.xy *= r;\\noffset.xy *= r;\\nfloat scaleSymbolProportionally = getBit(bitSet, BITSET_MARKER_SCALE_SYMBOLS_PROPORTIONALLY);\\noutlineSize *= scaleSymbolProportionally * (r - 1.0) + 1.0;\\n#endif\\nreturn outSize;\\n}\\nvec3 getOffset(in vec2 in_offset, float a_bitSet) {\\nfloat isMapAligned = getBit(a_bitSet, BITSET_MARKER_ALIGNMENT_MAP);\\nvec3  offset       = vec3(in_offset, 0.0);\\nreturn getMatrix(isMapAligned) * offset;\\n}\\nfloat filterNaNValues(in float value) {\\nreturn value != NAN_MAGIC_NUMBER && value > 0.0 ? value : 0.0;\\n}\\nvoid main()\\n{\\nINIT;\\nvec2  a_size   = a_size;\\nvec2  a_offset = a_offset / 16.0;\\nfloat outlineSize = outlineWidth;\\nfloat a_bitSet = a_bitSet;\\nfloat a_referenceSize = a_referenceSize;\\nvec2 a_texCoords = a_texCoords / 4.0;\\nvec2 markerSize = getMarkerSize(a_offset, a_size, outlineSize, a_referenceSize, a_bitSet);\\nfloat filterFlags = getFilterFlags();\\nvec3  pos         = vec3(a_pos / 10.0, 1.0);\\nv_opacity      = getOpacity();\\nv_id           = norm(a_id);\\nv_pos          = displayViewScreenMat3 * pos + getOffset(a_offset, a_bitSet);\\nv_offset       = sign(a_texCoords - 0.5);\\nv_size         = max(markerSize.x, markerSize.y);\\nv_outlineWidth = outlineSize;\\nfloat attributeData[10];\\nvec4 attributeData3 = getDataDriven0(a_id);\\nattributeData[0] = filterNaNValues(attributeData3.x);\\nattributeData[1] = filterNaNValues(attributeData3.y);\\nattributeData[2] = filterNaNValues(attributeData3.z);\\nattributeData[3] = filterNaNValues(attributeData3.w);\\n#if (numberOfFields > 4)\\nvec4 attributeData4 = getDataDriven1(a_id);\\nattributeData[4] = filterNaNValues(attributeData4.x);\\nattributeData[5] = filterNaNValues(attributeData4.y);\\nattributeData[6] = filterNaNValues(attributeData4.z);\\nattributeData[7] = filterNaNValues(attributeData4.w);\\n#endif\\n#if (numberOfFields > 8)\\nvec4 attributeData5 = getDataDriven2(a_id);\\nattributeData[8] = filterNaNValues(attributeData5.x);\\nattributeData[9] = filterNaNValues(attributeData5.y);\\n#endif\\nfloat sum = 0.0;\\nfor (int i = 0; i < numberOfFields; ++i) {\\nsum += attributeData[i];\\n}\\nfloat sectorAngles[numberOfFields];\\nfor (int i = 0; i < numberOfFields; ++i) {\\nsectorAngles[i] = 360.0 * attributeData[i] / sum;\\n}\\nvec2 filteredSectorToColorId[numberOfFields];\\nFilteredChartInfo filteredInfo = FilteredChartInfo(0.0, 0);\\nint numOfEntries = filterValues(filteredSectorToColorId, filteredInfo, sectorAngles);\\nv_numOfEntries = float(numOfEntries);\\nv_maxSectorAngle = filteredInfo.endSectorAngle;\\nv_filteredSectorToColorId = filteredSectorToColorId;\\n#ifdef HITTEST\\nhighp vec3 out_pos = vec3(0.0);\\nv_color            = vec4(0.0);\\nhittestMarker(v_color, out_pos, viewMat3 * tileMat3 *  pos, v_size);\\ngl_PointSize = 1.0;\\ngl_Position = vec4(clip(v_color, out_pos, filterFlags, a_zoomRange), 1.0);\\n#else\\ngl_Position = vec4(clip(v_color, v_pos, filterFlags, a_zoomRange), 1.0);\\n#endif\\n}\"\n    },\n    shared: {\n      line: {\n        \"common.glsl\": \"#if !defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE) && defined(PATTERN)\\nuniform mediump vec2 u_mosaicSize;\\nvarying mediump float v_sampleAlphaOnly;\\n#endif\\nstruct LineData {\\nlowp vec4 color;\\nmediump vec2 normal;\\nmediump float lineHalfWidth;\\nlowp float opacity;\\n#ifndef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\\n#ifdef PATTERN\\nmediump vec4 tlbr;\\nmediump vec2 patternSize;\\n#endif\\n#ifdef SDF\\nmediump float lineWidthRatio;\\n#endif\\n#if defined(PATTERN) || defined(SDF)\\nhighp float accumulatedDistance;\\n#endif\\n#endif\\nhighp vec3 id;\\n};\",\n        \"line.frag\": \"uniform lowp float u_blur;\\n#if !defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE) && !defined(HIGHLIGHT)\\n#if defined(PATTERN) || defined(SDF)\\nuniform sampler2D u_texture;\\nuniform highp float u_pixelRatio;\\n#endif\\n#endif\\n#if defined(SDF) && !defined(HIGHLIGHT) && !defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE)\\nlowp vec4 getLineColor(LineData line) {\\nmediump float adjustedPatternWidth = line.patternSize.x * 2.0 * line.lineWidthRatio;\\nmediump float relativeTexX = fract(line.accumulatedDistance / adjustedPatternWidth);\\nmediump float relativeTexY = 0.5 + 0.25 * line.normal.y;\\nmediump vec2 texCoord = mix(line.tlbr.xy, line.tlbr.zw, vec2(relativeTexX, relativeTexY));\\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\\nfloat dist = d * line.lineHalfWidth;\\nreturn line.opacity * clamp(0.5 - dist, 0.0, 1.0) * line.color;\\n}\\n#elif defined(PATTERN) && !defined(HIGHLIGHT) && !defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE)\\nlowp vec4 getLineColor(LineData line) {\\nmediump float lineHalfWidth = line.lineHalfWidth;\\nmediump float adjustedPatternHeight = line.patternSize.y * 2.0 * lineHalfWidth / line.patternSize.x;\\nmediump float relativeTexY = fract(line.accumulatedDistance / adjustedPatternHeight);\\nmediump float relativeTexX = 0.5 + 0.5 * line.normal.y;\\nmediump vec2 texCoord = mix(line.tlbr.xy, line.tlbr.zw, vec2(relativeTexX, relativeTexY));\\nlowp vec4 color = texture2D(u_texture, texCoord);\\n#ifdef VV_COLOR\\nif (v_sampleAlphaOnly > 0.5) {\\ncolor.rgb = vec3(color.a);\\n}\\n#endif\\nreturn line.opacity * line.color * color;\\n}\\n#else\\nlowp vec4 getLineColor(LineData line) {\\nreturn line.opacity * line.color;\\n}\\n#endif\\nvec4 shadeLine(LineData line)\\n{\\nmediump float thinLineFactor = max(THIN_LINE_WIDTH_FACTOR * step(line.lineHalfWidth, THIN_LINE_HALF_WIDTH), 1.0);\\nmediump float fragDist = length(line.normal) * line.lineHalfWidth;\\nlowp float alpha = clamp(thinLineFactor * (line.lineHalfWidth - fragDist) / (u_blur + thinLineFactor - 1.0), 0.0, 1.0);\\nlowp vec4 out_color = getLineColor(line) * alpha;\\n#ifdef HIGHLIGHT\\nout_color.a = step(1.0 / 255.0, out_color.a);\\n#endif\\n#ifdef ID\\nif (out_color.a < 1.0 / 255.0) {\\ndiscard;\\n}\\nout_color = vec4(line.id, 0.0);\\n#endif\\nreturn out_color;\\n}\",\n        \"line.vert\": \"float getBaseLineHalfWidth(in float lineHalfWidth, in float referenceHalfWidth) {\\n#ifdef VV_SIZE\\nfloat refLineWidth = 2.0 * referenceHalfWidth;\\nreturn 0.5 * (lineHalfWidth / max(referenceHalfWidth, EPSILON)) * getSize(refLineWidth);\\n#else\\nreturn lineHalfWidth;\\n#endif\\n}\\nfloat getLineHalfWidth(in float baseWidth, in float aa) {\\nfloat halfWidth = max(baseWidth + aa, 0.45) + 0.1 * aa;\\n#ifdef HIGHLIGHT\\nhalfWidth = max(halfWidth, 2.0);\\n#endif\\nreturn halfWidth;\\n}\\nvec2 getDist(in vec2 offset, in float halfWidth) {\\nfloat thinLineFactor = max(THIN_LINE_WIDTH_FACTOR * step(halfWidth, THIN_LINE_HALF_WIDTH), 1.0);\\nreturn thinLineFactor * halfWidth * offset;\\n}\\nLineData buildLine(\\nout vec3 out_pos,\\nin vec3 in_id,\\nin vec2 in_pos,\\nin vec4 in_color,\\nin vec2 in_offset,\\nin vec2 in_normal,\\nin float in_accumulatedDist,\\nin float in_lineHalfWidth,\\nin float in_bitSet,\\nin vec4 in_tlbr,\\nin vec2 in_segmentDirection,\\nin float in_referenceHalfWidth\\n)\\n{\\nfloat aa        = 0.5 * u_antialiasing;\\nfloat baseWidth = getBaseLineHalfWidth(in_lineHalfWidth, in_referenceHalfWidth);\\nfloat halfWidth = getLineHalfWidth(baseWidth, aa);\\nfloat z         = 2.0 * step(baseWidth, 0.0);\\nvec2  dist      = getDist(in_offset, halfWidth);\\nvec3  offset    = u_displayViewMat3 * vec3(dist, 0.0);\\nvec3  pos       = u_dvsMat3 * vec3(in_pos * POSITION_PRECISION, 1.0) + offset;\\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\\nvec4  color     = in_color;\\nfloat opacity   = 1.0;\\n#else\\nvec4  color     = getColor(in_color, in_bitSet, BITSET_GENERIC_LOCK_COLOR);\\nfloat opacity   = getOpacity();\\n#ifdef SDF\\nconst float SDF_PATTERN_HALF_WIDTH = 15.5;\\nfloat scaleDash = getBit(in_bitSet, BITSET_LINE_SCALE_DASH);\\nfloat lineWidthRatio = (scaleDash * max(halfWidth - 0.55 * u_antialiasing, 0.25) + (1.0 - scaleDash)) / SDF_PATTERN_HALF_WIDTH;\\n#endif\\n#endif\\n#if !defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE) && defined(PATTERN)\\nv_sampleAlphaOnly = getBit(in_bitSet, BITSET_GENERIC_CONSIDER_ALPHA_ONLY);\\n#endif\\nout_pos = vec3(pos.xy, z);\\nreturn LineData(\\ncolor,\\nin_normal,\\nhalfWidth,\\nopacity,\\n#ifndef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\\n#ifdef PATTERN\\nin_tlbr / u_mosaicSize.xyxy,\\nvec2(in_tlbr.z - in_tlbr.x, in_tlbr.w - in_tlbr.y),\\n#endif\\n#ifdef SDF\\nlineWidthRatio,\\n#endif\\n#if defined(PATTERN) || defined(SDF)\\nin_accumulatedDist * u_zoomFactor + dot(in_segmentDirection, dist),\\n#endif\\n#endif\\nnorm(in_id)\\n);\\n}\"\n      }\n    },\n    \"symbologyTypeUtils.glsl\": \"#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_OUTLINE_FILL || SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_OUTLINE_FILL_SIMPLE\\n#define SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\\n#endif\\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_SIMPLE || SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_OUTLINE_FILL_SIMPLE\\n#define SYMBOLOGY_TYPE_IS_SIMPLE_LIKE\\n#endif\",\n    text: {\n      \"common.glsl\": \"uniform highp vec2 u_mosaicSize;\\nvarying highp vec3 v_id;\\nvarying mediump vec3 v_pos;\\nvarying lowp float v_opacity;\\nvarying lowp vec4 v_color;\\nvarying highp vec2 v_tex;\\nvarying mediump float v_antialiasingWidth;\\nvarying mediump float v_edgeDistanceOffset;\\nvarying lowp float v_transparency;\",\n      \"hittest.glsl\": \"#include <materials/hittest/common.glsl>\",\n      \"text.frag\": \"precision mediump float;\\n#include <materials/text/common.glsl>\\nuniform lowp sampler2D u_texture;\\n#ifdef HITTEST\\nvec4 getColor() {\\nreturn v_color;\\n}\\n#else\\nvec4 getColor()\\n{\\nfloat SDF_CUTOFF = (2.0 / 8.0);\\nfloat SDF_BASE_EDGE_DIST = 1.0 - SDF_CUTOFF;\\nlowp float dist = texture2D(u_texture, v_tex).a;\\nmediump float edge = SDF_BASE_EDGE_DIST - v_edgeDistanceOffset;\\n#ifdef HIGHLIGHT\\nedge /= 2.0;\\n#endif\\nlowp float aa = v_antialiasingWidth;\\nlowp float alpha = smoothstep(edge - aa, edge + aa, dist);\\nreturn alpha * v_color * v_opacity;\\n}\\n#endif\\nvoid main()\\n{\\ngl_FragColor = getColor();\\n}\",\n      \"text.vert\": \"precision highp float;\\n#include <materials/utils.glsl>\\n#include <materials/vcommon.glsl>\\n#include <materials/text/common.glsl>\\n#include <materials/text/hittest.glsl>\\nattribute vec4 a_color;\\nattribute vec4 a_haloColor;\\nattribute vec4 a_texFontSize;\\nattribute vec4 a_aux;\\nattribute vec2 a_zoomRange;\\nattribute vec2 a_vertexOffset;\\nattribute vec2 a_texCoords;\\nuniform float u_isHaloPass;\\nuniform float u_isBackgroundPass;\\nfloat getTextSize(inout vec2 offset, inout float baseSize, in float referenceSize) {\\n#ifdef VV_SIZE\\nfloat r = getSize(referenceSize) / referenceSize;\\nbaseSize *= r;\\noffset.xy *= r;\\nreturn baseSize;\\n#endif\\nreturn baseSize;\\n}\\nvoid main()\\n{\\nINIT;\\nfloat a_isBackground  = a_aux.y;\\nfloat a_referenceSize = a_aux.z * a_aux.z / 256.0;\\nfloat a_bitSet        = a_aux.w;\\nfloat a_fontSize      = a_texFontSize.z;\\nvec2  a_offset        = a_vertexOffset * OFFSET_PRECISION;\\nvec3  in_pos        = vec3(a_pos * POSITION_PRECISION, 1.0);\\nfloat fontSize      = getTextSize(a_offset, a_fontSize, a_referenceSize);\\nfloat fontScale     = fontSize / SDF_FONT_SIZE;\\nvec3  offset        = getRotation() * vec3(a_offset, 0.0);\\nmat3  extrudeMatrix = getBit(a_bitSet, 0) == 1.0 ? u_displayViewMat3 : u_displayMat3;\\nfloat isText = 1.0 - a_isBackground;\\nfloat isBackground = u_isBackgroundPass * a_isBackground;\\nvec4  nonHaloColor  = (isBackground * a_color) + (isText * getColor(a_color, a_bitSet, 1));\\nv_color   = u_isHaloPass * a_haloColor + (1.0 - u_isHaloPass) * nonHaloColor;\\nv_opacity = getOpacity();\\nv_id      = norm(a_id);\\nv_tex     = a_texCoords / u_mosaicSize;\\nv_pos     = u_dvsMat3 * in_pos + extrudeMatrix * offset;\\nfloat isHidden = u_isBackgroundPass * isText + (1.0 - u_isBackgroundPass) * a_isBackground;\\nv_pos.z += 2.0 * isHidden;\\nv_edgeDistanceOffset = u_isHaloPass * OUTLINE_SCALE * a_texFontSize.w / fontScale / MAX_SDF_DISTANCE;\\nv_antialiasingWidth  = 0.105 * SDF_FONT_SIZE / fontSize / u_pixelRatio;\\n#ifdef HITTEST\\nhighp vec3 out_pos  = vec3(0.);\\nv_color = vec4(0.);\\nhittestMarker(v_color, out_pos, u_viewMat3 * u_tileMat3 *  vec3(a_pos * POSITION_PRECISION, 1.0)\\n+ u_tileMat3 * offset, fontSize / 2.);\\ngl_PointSize = 1.;\\ngl_Position = vec4(clip(v_color, out_pos, getFilterFlags(), a_zoomRange), 1.0);\\n#else\\ngl_Position =  vec4(clip(v_color, v_pos, getFilterFlags(), a_zoomRange), 1.0);\\n#endif\\n}\"\n    },\n    \"utils.glsl\": \"float rshift(in float u32, in int amount) {\\nreturn floor(u32 / pow(2.0, float(amount)));\\n}\\nfloat getBit(in float bitset, in int bitIndex) {\\nfloat offset = pow(2.0, float(bitIndex));\\nreturn mod(floor(bitset / offset), 2.0);\\n}\\nconst int highlightReasonsLength = 3;\\nfloat getFilterBit(in float bitset, in int bitIndex) {\\nreturn getBit(bitset, bitIndex + highlightReasonsLength);\\n}\\nfloat getHighlightBit(in float bitset, in int bitIndex) {\\nreturn getBit(bitset, bitIndex);\\n}\\nhighp vec3 unpackDisplayIdTexel(in highp vec3 bitset) {\\nfloat isAggregate = getBit(bitset.b, 7);\\nreturn (1.0 - isAggregate) * bitset + isAggregate * (vec3(bitset.rgb) - vec3(0.0, 0.0, float(0x80)));\\n}\\nvec4 unpack(in float u32) {\\nfloat r = mod(rshift(u32, 0), 255.0);\\nfloat g = mod(rshift(u32, 8), 255.0);\\nfloat b = mod(rshift(u32, 16), 255.0);\\nfloat a = mod(rshift(u32, 24), 255.0);\\nreturn vec4(r, g, b, a);\\n}\\nvec3 norm(in vec3 v) {\\nreturn v /= 255.0;\\n}\\nvec4 norm(in vec4 v) {\\nreturn v /= 255.0;\\n}\\nfloat max4(vec4 target) {\\nreturn max(max(max(target.x, target.y), target.z), target.w);\\n}\\nvec2 unpack_u8_nf32(vec2 bytes) {\\nreturn (bytes - 127.0) / 127.0;\\n}\\nhighp float rand(in vec2 co) {\\nhighp float a = 12.9898;\\nhighp float b = 78.233;\\nhighp float c = 43758.5453;\\nhighp float dt = dot(co, vec2(a,b));\\nhighp float sn = mod(dt, 3.14);\\nreturn fract(sin(sn) * c);\\n}\",\n    \"vcommon.glsl\": \"#include <materials/constants.glsl>\\n#include <materials/utils.glsl>\\n#include <materials/attributeData.glsl>\\n#include <materials/vv.glsl>\\n#include <materials/barycentric.glsl>\\nattribute vec2 a_pos;\\nattribute highp vec3 a_id;\\nuniform highp mat3 displayViewScreenMat3;\\nuniform highp mat3 displayViewMat3;\\nuniform highp mat3 displayMat3;\\nuniform highp mat3 tileMat3;\\nuniform highp mat3 viewMat3;\\nuniform highp float pixelRatio;\\nuniform mediump float zoomFactor;\\nuniform mediump float antialiasing;\\nuniform mediump float currentScale;\\nuniform mediump float currentZoom;\\nuniform mediump float metersPerSRUnit;\\nvec4 VV_ADATA = vec4(0.0);\\nvoid loadVisualVariableData(inout vec4 target) {\\ntarget.rgba = getVisualVariableData(a_id);\\n}\\n#ifdef VV\\n#define INIT loadVisualVariableData(VV_ADATA)\\n#else\\n#define INIT\\n#endif\\nvec4 getColor(in vec4 a_color, in float a_bitSet, int index) {\\n#ifdef VV_COLOR\\nfloat isColorLocked   = getBit(a_bitSet, index);\\nreturn getVVColor(VV_ADATA[ATTR_VV_COLOR], a_color, isColorLocked);\\n#else\\nreturn a_color;\\n#endif\\n}\\nfloat getOpacity() {\\n#ifdef VV_OPACITY\\nreturn getVVOpacity(VV_ADATA[ATTR_VV_OPACITY]);\\n#else\\nreturn 1.0;\\n#endif\\n}\\nfloat getSize(in float in_size, in float currentScale) {\\n#ifdef VV_SIZE\\nreturn getVVSize(in_size, VV_ADATA[ATTR_VV_SIZE], currentScale);\\n#else\\nreturn in_size;\\n#endif\\n}\\nmat3 getRotation() {\\n#ifdef VV_ROTATION\\nreturn getVVRotationMat3(mod(VV_ADATA[ATTR_VV_ROTATION], 360.0));\\n#else\\nreturn mat3(1.0);\\n#endif\\n}\\nfloat getFilterFlags() {\\n#ifdef IGNORES_SAMPLER_PRECISION\\nreturn ceil(getFilterData(a_id).x * 255.0);\\n#else\\nreturn getFilterData(a_id).x * 255.0;\\n#endif\\n}\\nvec4 getAnimationState() {\\nreturn getAnimation(a_id);\\n}\\nfloat getMinZoom() {\\nvec4 data0 = getFilterData(a_id) * 255.0;\\nreturn data0.g;\\n}\\nmat3 getMatrixNoDisplay(float isMapAligned) {\\nreturn isMapAligned * viewMat3 * tileMat3 + (1.0 - isMapAligned) * tileMat3;\\n}\\nmat3 getMatrix(float isMapAligned) {\\nreturn isMapAligned * displayViewMat3 + (1.0 - isMapAligned) * displayMat3;\\n}\\nfloat checkHighlightBit(float filterFlags, int index) {\\nreturn getHighlightBit(filterFlags, index);\\n}\\nfloat checkHighlight(float filterFlags) {\\nfloat result = checkHighlightBit(filterFlags, 0);\\nfor (int i = 1; i < highlightReasonsLength; i++) {\\nresult = result + checkHighlightBit(filterFlags, i);\\n}\\nreturn step(0.1, result);\\n}\\nvec3 clip(inout vec4 color, inout vec3 pos, in float filterFlags, in vec2 minMaxZoom) {\\npos.z += 2.0 * (1.0 - getFilterBit(filterFlags, 0));\\n#ifdef inside\\npos.z += 2.0 * (1.0 - getFilterBit(filterFlags, 1));\\n#elif defined(outside)\\npos.z += 2.0 * getFilterBit(filterFlags, 1);\\n#elif defined(highlight)\\n#if !defined(highlight_all)\\npos.z += 2.0 * (1.0 - checkHighlight(filterFlags));\\n#endif\\n#endif\\npos.z += 2.0 * (step(minMaxZoom.y, currentZoom) + (1.0 - step(minMaxZoom.x, currentZoom)));\\nreturn pos;\\n}\",\n    \"vv.glsl\": \"#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\\n#define VV_SIZE\\n#endif\\n#if defined(VV_COLOR) || defined(VV_SIZE) || defined(VV_OPACITY) || defined(VV_ROTATION)\\n#define VV\\n#endif\\n#ifdef VV_COLOR\\nuniform highp float colorValues[8];\\nuniform vec4 colors[8];\\n#endif\\n#ifdef VV_SIZE_MIN_MAX_VALUE\\nuniform highp vec4 minMaxValueAndSize;\\n#endif\\n#ifdef VV_SIZE_SCALE_STOPS\\nuniform highp float values[8];\\nuniform float sizes[8];\\n#endif\\n#ifdef VV_SIZE_FIELD_STOPS\\nuniform highp float values[8];\\nuniform float sizes[8];\\n#endif\\n#ifdef VV_SIZE_UNIT_VALUE\\nuniform highp float unitMeterRatio;\\n#endif\\n#ifdef VV_OPACITY\\nuniform highp float opacityValues[8];\\nuniform float opacities[8];\\n#endif\\n#ifdef VV_ROTATION\\nuniform lowp float rotationType;\\n#endif\\nbool isNan(float val) {\\nreturn (val == NAN_MAGIC_NUMBER);\\n}\\n#ifdef VV_SIZE_MIN_MAX_VALUE\\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\\nif (isNan(sizeValue)) {\\nreturn fallback;\\n}\\nfloat interpolationRatio = (sizeValue  - minMaxValueAndSize.x) / (minMaxValueAndSize.y - minMaxValueAndSize.x);\\ninterpolationRatio = clamp(interpolationRatio, 0.0, 1.0);\\nreturn minMaxValueAndSize.z + interpolationRatio * (minMaxValueAndSize.w - minMaxValueAndSize.z);\\n}\\n#endif\\n#ifdef VV_SIZE_SCALE_STOPS\\nfloat getVVScaleStopsSize(float currentScale) {\\nfloat outSize;\\nif (currentScale <= values[0]) {\\noutSize = sizes[0];\\n} else {\\nif (currentScale >= values[7]) {\\noutSize = sizes[7];\\n} else {\\nint index;\\nindex = -1;\\nfor (int i = 0; i < 8; i++) {\\nif (values[i] > currentScale) {\\nindex = i;\\nbreak;\\n}\\n}\\nint prevIndex = index - 1;\\nfloat a = currentScale - values[prevIndex];\\nfloat b = values[index] - values[prevIndex];\\noutSize = mix(sizes[prevIndex], sizes[index], a / b);\\n}\\n}\\nreturn outSize;\\n}\\n#endif\\n#ifdef VV_SIZE_FIELD_STOPS\\nconst int VV_SIZE_N = 8;\\nfloat getVVStopsSize(float sizeValue, float fallback) {\\nif (isNan(sizeValue)) {\\nreturn fallback;\\n}\\nif (sizeValue <= values[0]) {\\nreturn sizes[0];\\n}\\nfor (int i = 1; i < VV_SIZE_N; ++i) {\\nif (values[i] >= sizeValue) {\\nfloat f = (sizeValue - values[i-1]) / (values[i] - values[i-1]);\\nreturn mix(sizes[i-1], sizes[i], f);\\n}\\n}\\nreturn sizes[VV_SIZE_N - 1];\\n}\\n#endif\\n#ifdef VV_SIZE_UNIT_VALUE\\nfloat getVVUnitValue(float sizeValue, float fallback) {\\nif (isNan(sizeValue)) {\\nreturn fallback;\\n}\\nreturn sizeValue * (metersPerSRUnit / unitMeterRatio);\\n}\\n#endif\\n#ifdef VV_OPACITY\\nconst int VV_OPACITY_N = 8;\\nfloat getVVOpacity(float opacityValue) {\\nif (isNan(opacityValue)) {\\nreturn 1.0;\\n}\\nif (opacityValue <= opacityValues[0]) {\\nreturn opacities[0];\\n}\\nfor (int i = 1; i < VV_OPACITY_N; ++i) {\\nif (opacityValues[i] >= opacityValue) {\\nfloat f = (opacityValue - opacityValues[i-1]) / (opacityValues[i] - opacityValues[i-1]);\\nreturn mix(opacities[i-1], opacities[i], f);\\n}\\n}\\nreturn opacities[VV_OPACITY_N - 1];\\n}\\n#endif\\n#ifdef VV_ROTATION\\nmat4 getVVRotation(float rotationValue) {\\nif (isNan(rotationValue)) {\\nreturn mat4(1, 0, 0, 0,\\n0, 1, 0, 0,\\n0, 0, 1, 0,\\n0, 0, 0, 1);\\n}\\nfloat rotation = rotationValue;\\nif (rotationType == 1.0) {\\nrotation = 90.0 - rotation;\\n}\\nfloat angle = C_DEG_TO_RAD * rotation;\\nfloat sinA = sin(angle);\\nfloat cosA = cos(angle);\\nreturn mat4(cosA, sinA, 0, 0,\\n-sinA,  cosA, 0, 0,\\n0,     0, 1, 0,\\n0,     0, 0, 1);\\n}\\nmat3 getVVRotationMat3(float rotationValue) {\\nif (isNan(rotationValue)) {\\nreturn mat3(1, 0, 0,\\n0, 1, 0,\\n0, 0, 1);\\n}\\nfloat rotation = rotationValue;\\nif (rotationType == 1.0) {\\nrotation = 90.0 - rotation;\\n}\\nfloat angle = C_DEG_TO_RAD * -rotation;\\nfloat sinA = sin(angle);\\nfloat cosA = cos(angle);\\nreturn mat3(cosA, -sinA, 0,\\nsinA, cosA, 0,\\n0,    0,    1);\\n}\\n#endif\\n#ifdef VV_COLOR\\nconst int VV_COLOR_N = 8;\\nvec4 getVVColor(float colorValue, vec4 fallback, float isColorLocked) {\\nif (isNan(colorValue) || isColorLocked == 1.0) {\\nreturn fallback;\\n}\\nif (colorValue <= colorValues[0]) {\\nreturn colors[0];\\n}\\nfor (int i = 1; i < VV_COLOR_N; ++i) {\\nif (colorValues[i] >= colorValue) {\\nfloat f = (colorValue - colorValues[i-1]) / (colorValues[i] - colorValues[i-1]);\\nreturn mix(colors[i-1], colors[i], f);\\n}\\n}\\nreturn colors[VV_COLOR_N - 1];\\n}\\n#endif\\nfloat getVVSize(in float size, in float vvSize, in float currentScale)  {\\n#ifdef VV_SIZE_MIN_MAX_VALUE\\nreturn getVVMinMaxSize(vvSize, size);\\n#elif defined(VV_SIZE_SCALE_STOPS)\\nfloat outSize = getVVScaleStopsSize(currentScale);\\nreturn isNan(outSize) ? size : outSize;\\n#elif defined(VV_SIZE_FIELD_STOPS)\\nfloat outSize = getVVStopsSize(vvSize, size);\\nreturn isNan(outSize) ? size : outSize;\\n#elif defined(VV_SIZE_UNIT_VALUE)\\nreturn getVVUnitValue(vvSize, size);\\n#else\\nreturn size;\\n#endif\\n}\"\n  },\n  overlay: {\n    overlay: {\n      \"overlay.frag\": \"precision lowp float;\\nuniform lowp sampler2D u_texture;\\nuniform lowp float u_opacity;\\nvarying mediump vec2 v_uv;\\nvoid main() {\\nvec4 color = texture2D(u_texture, v_uv);\\ngl_FragColor = color *  u_opacity;\\n}\",\n      \"overlay.vert\": \"precision mediump float;\\nattribute vec2 a_pos;\\nattribute vec2 a_uv;\\nuniform highp mat3 u_dvsMat3;\\nuniform mediump vec2 u_perspective;\\nuniform highp float u_wrapAroundShift;\\nuniform mediump vec2 u_texSize;\\nvarying mediump vec2 v_uv;\\nvoid main(void) {\\nv_uv = a_uv / u_texSize;\\nfloat w = 1.0 + dot(a_uv, u_perspective);\\nvec3 pos = u_dvsMat3 * vec3(a_pos + vec2(u_wrapAroundShift, 0.0), 1.0);\\ngl_Position = vec4(w * pos.xy, 0.0, w);\\n}\"\n    }\n  },\n  \"post-processing\": {\n    blit: {\n      \"blit.frag\": \"precision mediump float;\\nuniform sampler2D u_texture;\\nvarying vec2 v_uv;\\nvoid main() {\\ngl_FragColor = texture2D(u_texture, v_uv);\\n}\"\n    },\n    bloom: {\n      composite: {\n        \"composite.frag\": \"precision mediump float;\\nvarying vec2 v_uv;\\nuniform sampler2D u_blurTexture1;\\nuniform sampler2D u_blurTexture2;\\nuniform sampler2D u_blurTexture3;\\nuniform sampler2D u_blurTexture4;\\nuniform sampler2D u_blurTexture5;\\nuniform float u_bloomStrength;\\nuniform float u_bloomRadius;\\nuniform float u_bloomFactors[NUMMIPS];\\nuniform vec3 u_bloomTintColors[NUMMIPS];\\nfloat lerpBloomFactor(const in float factor) {\\nfloat mirrorFactor = 1.2 - factor;\\nreturn mix(factor, mirrorFactor, u_bloomRadius);\\n}\\nvoid main() {\\nvec4 color = u_bloomStrength * (\\nlerpBloomFactor(u_bloomFactors[0]) * vec4(u_bloomTintColors[0], 1.0) * texture2D(u_blurTexture1, v_uv) +\\nlerpBloomFactor(u_bloomFactors[1]) * vec4(u_bloomTintColors[1], 1.0) * texture2D(u_blurTexture2, v_uv) +\\nlerpBloomFactor(u_bloomFactors[2]) * vec4(u_bloomTintColors[2], 1.0) * texture2D(u_blurTexture3, v_uv) +\\nlerpBloomFactor(u_bloomFactors[3]) * vec4(u_bloomTintColors[3], 1.0) * texture2D(u_blurTexture4, v_uv) +\\nlerpBloomFactor(u_bloomFactors[4]) * vec4(u_bloomTintColors[4], 1.0) * texture2D(u_blurTexture5, v_uv)\\n);\\ngl_FragColor = clamp(color, 0.0, 1.0);\\n}\"\n      },\n      gaussianBlur: {\n        \"gaussianBlur.frag\": \"precision mediump float;\\nuniform sampler2D u_colorTexture;\\nuniform vec2 u_texSize;\\nuniform vec2 u_direction;\\nvarying vec2 v_uv;\\n#define KERNEL_RADIUS RADIUS\\n#define SIGMA RADIUS\\nfloat gaussianPdf(in float x, in float sigma) {\\nreturn 0.39894 * exp(-0.5 * x * x / ( sigma * sigma)) / sigma;\\n}\\nvoid main() {\\nvec2 invSize = 1.0 / u_texSize;\\nfloat fSigma = float(SIGMA);\\nfloat weightSum = gaussianPdf(0.0, fSigma);\\nvec4 pixelColorSum = texture2D(u_colorTexture, v_uv) * weightSum;\\nfor (int i = 1; i < KERNEL_RADIUS; i ++) {\\nfloat x = float(i);\\nfloat w = gaussianPdf(x, fSigma);\\nvec2 uvOffset = u_direction * invSize * x;\\nvec4 sample1 = texture2D(u_colorTexture, v_uv + uvOffset);\\nvec4 sample2 = texture2D(u_colorTexture, v_uv - uvOffset);\\npixelColorSum += (sample1 + sample2) * w;\\nweightSum += 2.0 * w;\\n}\\ngl_FragColor = pixelColorSum /weightSum;\\n}\"\n      },\n      luminosityHighPass: {\n        \"luminosityHighPass.frag\": \"precision mediump float;\\nuniform sampler2D u_texture;\\nuniform vec3 u_defaultColor;\\nuniform float u_defaultOpacity;\\nuniform float u_luminosityThreshold;\\nuniform float u_smoothWidth;\\nvarying vec2 v_uv;\\nvoid main() {\\nvec4 texel = texture2D(u_texture, v_uv);\\nvec3 luma = vec3(0.299, 0.587, 0.114);\\nfloat v = dot(texel.xyz, luma);\\nvec4 outputColor = vec4(u_defaultColor.rgb, u_defaultOpacity);\\nfloat alpha = smoothstep(u_luminosityThreshold, u_luminosityThreshold + u_smoothWidth, v);\\ngl_FragColor = mix(outputColor, texel, alpha);\\n}\"\n      }\n    },\n    blur: {\n      gaussianBlur: {\n        \"gaussianBlur.frag\": \"precision mediump float;\\nuniform sampler2D u_colorTexture;\\nuniform vec2 u_texSize;\\nuniform vec2 u_direction;\\nuniform float u_sigma;\\nvarying vec2 v_uv;\\n#define KERNEL_RADIUS RADIUS\\nfloat gaussianPdf(in float x, in float sigma) {\\nreturn 0.39894 * exp(-0.5 * x * x / ( sigma * sigma)) / sigma;\\n}\\nvoid main() {\\nvec2 invSize = 1.0 / u_texSize;\\nfloat fSigma = u_sigma;\\nfloat weightSum = gaussianPdf(0.0, fSigma);\\nvec4 pixelColorSum = texture2D(u_colorTexture, v_uv) * weightSum;\\nfor (int i = 1; i < KERNEL_RADIUS; i ++) {\\nfloat x = float(i);\\nfloat w = gaussianPdf(x, fSigma);\\nvec2 uvOffset = u_direction * invSize * x;\\nvec4 sample1 = texture2D(u_colorTexture, v_uv + uvOffset);\\nvec4 sample2 = texture2D(u_colorTexture, v_uv - uvOffset);\\npixelColorSum += (sample1 + sample2) * w;\\nweightSum += 2.0 * w;\\n}\\ngl_FragColor = pixelColorSum /weightSum;\\n}\"\n      },\n      \"radial-blur\": {\n        \"radial-blur.frag\": \"precision mediump float;\\nuniform sampler2D u_colorTexture;\\nvarying vec2 v_uv;\\nconst float sampleDist = 1.0;\\nconst float sampleStrength = 2.2;\\nvoid main(void) {\\nfloat samples[10];\\nsamples[0] = -0.08;\\nsamples[1] = -0.05;\\nsamples[2] = -0.03;\\nsamples[3] = -0.02;\\nsamples[4] = -0.01;\\nsamples[5] =  0.01;\\nsamples[6] =  0.02;\\nsamples[7] =  0.03;\\nsamples[8] =  0.05;\\nsamples[9] =  0.08;\\nvec2 dir = 0.5 - v_uv;\\nfloat dist = sqrt(dir.x * dir.x + dir.y * dir.y);\\ndir = dir / dist;\\nvec4 color = texture2D(u_colorTexture,v_uv);\\nvec4 sum = color;\\nfor (int i = 0; i < 10; i++) {\\nsum += texture2D(u_colorTexture, v_uv + dir * samples[i] * sampleDist);\\n}\\nsum *= 1.0 / 11.0;\\nfloat t = dist * sampleStrength;\\nt = clamp(t, 0.0, 1.0);\\ngl_FragColor = mix(color, sum, t);\\n}\"\n      }\n    },\n    dra: {\n      \"dra.frag\": \"precision mediump float;\\nuniform sampler2D u_minColor;\\nuniform sampler2D u_maxColor;\\nuniform sampler2D u_texture;\\nvarying vec2 v_uv;\\nvoid main() {\\nvec4 minColor = texture2D(u_minColor, vec2(0.5));\\nvec4 maxColor = texture2D(u_maxColor, vec2(0.5));\\nvec4 color = texture2D(u_texture, v_uv);\\nvec3 minColorUnpremultiply = minColor.rgb / minColor.a;\\nvec3 maxColorUnpremultiply = maxColor.rgb / maxColor.a;\\nvec3 colorUnpremultiply = color.rgb / color.a;\\nvec3 range = maxColorUnpremultiply - minColorUnpremultiply;\\ngl_FragColor = vec4(color.a * (colorUnpremultiply - minColorUnpremultiply) / range, color.a);\\n}\",\n      \"min-max\": {\n        \"min-max.frag\": \"#extension GL_EXT_draw_buffers : require\\nprecision mediump float;\\n#define CELL_SIZE 2\\nuniform sampler2D u_minTexture;\\nuniform sampler2D u_maxTexture;\\nuniform vec2 u_srcResolution;\\nuniform vec2 u_dstResolution;\\nvarying vec2 v_uv;\\nvoid main() {\\nvec2 srcPixel = floor(gl_FragCoord.xy) * float(CELL_SIZE);\\nvec2 onePixel = vec2(1.0) / u_srcResolution;\\nvec2 uv = (srcPixel + 0.5) / u_srcResolution;\\nvec4 minColor = vec4(1.0);\\nvec4 maxColor = vec4(0.0);\\nfor (int y = 0; y < CELL_SIZE; ++y) {\\nfor (int x = 0; x < CELL_SIZE; ++x) {\\nvec2 offset = uv + vec2(x, y) * onePixel;\\nminColor = min(minColor, texture2D(u_minTexture, offset));\\nmaxColor = max(maxColor, texture2D(u_maxTexture, offset));\\n}\\n}\\ngl_FragData[0] = minColor;\\ngl_FragData[1] = maxColor;\\n}\"\n      }\n    },\n    \"drop-shadow\": {\n      composite: {\n        \"composite.frag\": \"precision mediump float;\\nuniform sampler2D u_layerFBOTexture;\\nuniform sampler2D u_blurTexture;\\nuniform vec4 u_shadowColor;\\nuniform vec2 u_shadowOffset;\\nuniform highp mat3 u_displayViewMat3;\\nvarying vec2 v_uv;\\nvoid main() {\\nvec3 offset = u_displayViewMat3 * vec3(u_shadowOffset, 0.0);\\nvec4 layerColor = texture2D(u_layerFBOTexture, v_uv);\\nvec4 blurColor = texture2D(u_blurTexture, v_uv - offset.xy / 2.0);\\ngl_FragColor = ((1.0 - layerColor.a) * blurColor.a * u_shadowColor + layerColor);\\n}\"\n      }\n    },\n    \"edge-detect\": {\n      \"frei-chen\": {\n        \"frei-chen.frag\": \"precision mediump float;\\nuniform sampler2D u_colorTexture;\\nuniform vec2 u_texSize;\\nvarying vec2 v_uv;\\nvec2 texel = vec2(1.0 / u_texSize.x, 1.0 / u_texSize.y);\\nmat3 G[9];\\nconst mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\\nconst mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\\nconst mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\\nconst mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\\nconst mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\\nconst mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\\nconst mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\\nconst mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\\nconst mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\\nvoid main() {\\nG[0] = g0,\\nG[1] = g1,\\nG[2] = g2,\\nG[3] = g3,\\nG[4] = g4,\\nG[5] = g5,\\nG[6] = g6,\\nG[7] = g7,\\nG[8] = g8;\\nmat3 I;\\nfloat cnv[9];\\nvec3 sample;\\nfor (float i = 0.0; i < 3.0; i++) {\\nfor (float j = 0.0; j < 3.0; j++) {\\nsample = texture2D(u_colorTexture, v_uv + texel * vec2(i - 1.0,j - 1.0)).rgb;\\nI[int(i)][int(j)] = length(sample);\\n}\\n}\\nfor (int i = 0; i < 9; i++) {\\nfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\\ncnv[i] = dp3 * dp3;\\n}\\nfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\\nfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\\ngl_FragColor = vec4(vec3(sqrt(M / S)), texture2D(u_colorTexture, v_uv).a);\\n}\"\n      },\n      sobel: {\n        \"sobel.frag\": \"precision mediump float;\\nuniform sampler2D u_colorTexture;\\nvarying vec2 v_uv;\\nuniform vec2 u_texSize;\\nvec2 texel = vec2(1.0 / u_texSize.x, 1.0 / u_texSize.y);\\nmat3 G[2];\\nconst mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );\\nconst mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );\\nvoid main() {\\nmat3 I;\\nfloat cnv[2];\\nvec3 sample;\\nG[0] = g0;\\nG[1] = g1;\\nfor (float i = 0.0; i < 3.0; i++) {\\nfor (float j = 0.0; j < 3.0; j++) {\\nsample = texture2D( u_colorTexture, v_uv + texel * vec2(i-1.0,j-1.0) ).rgb;\\nI[int(i)][int(j)] = length(sample);\\n}\\n}\\nfor (int i = 0; i < 2; i++) {\\nfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\\ncnv[i] = dp3 * dp3;\\n}\\ngl_FragColor = vec4(vec3(0.5 * sqrt(cnv[0] * cnv[0] + cnv[1] * cnv[1])), texture2D(u_colorTexture, v_uv).a);\\n}\"\n      }\n    },\n    \"edge-enhance\": {\n      \"edge-enhance.frag\": \"precision mediump float;\\nuniform sampler2D u_colorTexture;\\nvarying vec2 v_uv;\\nuniform vec2 u_texSize;\\nvec2 texel = vec2(1.0 / u_texSize.x, 1.0 / u_texSize.y);\\nmat3 G[2];\\nconst mat3 g0 = mat3( 1.0, 0.0, -1.0, 1.0, 0.0, -1.0, 1.0, 0.0, -1.0 );\\nconst mat3 g1 = mat3( 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, -1.0, -1.0, -1.0 );\\nvoid main() {\\nmat3 I;\\nfloat cnv[2];\\nvec3 sample;\\nG[0] = g0;\\nG[1] = g1;\\nfor (float i = 0.0; i < 3.0; i++) {\\nfor (float j = 0.0; j < 3.0; j++) {\\nsample = texture2D( u_colorTexture, v_uv + texel * vec2(i-1.0,j-1.0) ).rgb;\\nI[int(i)][int(j)] = length(sample);\\n}\\n}\\nfor (int i = 0; i < 2; i++) {\\nfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\\ncnv[i] = dp3 * dp3;\\n}\\nvec4 color = texture2D(u_colorTexture, v_uv);\\ngl_FragColor = vec4(0.5 * sqrt(cnv[0] * cnv[0] + cnv[1] * cnv[1]) * color);\\n}\"\n    },\n    filterEffect: {\n      \"filterEffect.frag\": \"precision mediump float;\\nuniform sampler2D u_colorTexture;\\nuniform mat4 u_coefficients;\\nvarying vec2 v_uv;\\nvoid main() {\\nvec4 color = texture2D(u_colorTexture, v_uv);\\nvec4 rgbw = u_coefficients * vec4(color.a > 0.0 ? color.rgb / color.a : vec3(0.0), 1.0);\\nfloat a = color.a;\\ngl_FragColor = vec4(a * rgbw.rgb, a);\\n}\"\n    },\n    pp: {\n      \"pp.vert\": \"precision mediump float;\\nattribute vec2 a_position;\\nvarying vec2 v_uv;\\nvoid main() {\\ngl_Position = vec4(a_position, 0.0, 1.0);\\nv_uv = (a_position + 1.0) / 2.0;\\n}\"\n    }\n  },\n  raster: {\n    bitmap: {\n      \"bitmap.frag\": \"precision mediump float;\\nvarying highp vec2 v_texcoord;\\nuniform sampler2D u_texture;\\nuniform highp vec2 u_coordScale;\\nuniform lowp float u_opacity;\\n#include <filtering/bicubic.glsl>\\nvoid main() {\\n#ifdef BICUBIC\\nvec4 color = sampleBicubicBSpline(u_texture, v_texcoord, u_coordScale);\\n#else\\nvec4 color = texture2D(u_texture, v_texcoord);\\n#endif\\ngl_FragColor = vec4(color.rgb * u_opacity, color.a * u_opacity);\\n}\",\n      \"bitmap.vert\": \"precision mediump float;\\nattribute vec2 a_pos;\\nuniform highp mat3 u_dvsMat3;\\nuniform highp vec2 u_coordScale;\\nvarying highp vec2 v_texcoord;\\nvoid main()\\n{\\nv_texcoord = a_pos;\\ngl_Position = vec4(u_dvsMat3 * vec3(a_pos * u_coordScale, 1.0), 1.0);\\n}\"\n    },\n    common: {\n      \"common.glsl\": \"uniform sampler2D u_image;\\nuniform int u_bandCount;\\nuniform bool u_flipY;\\nuniform float u_opacity;\\nuniform int u_resampling;\\nuniform vec2 u_srcImageSize;\\n#ifdef APPLY_PROJECTION\\n#include <raster/common/projection.glsl>\\n#endif\\n#ifdef BICUBIC\\n#include <filtering/bicubic.glsl>\\n#endif\\n#ifdef BILINEAR\\n#include <filtering/bilinear.glsl>\\n#endif\\nvec2 getPixelLocation(vec2 coords) {\\nvec2 targetLocation = u_flipY ? vec2(coords.s, 1.0 - coords.t) : coords;\\n#ifdef APPLY_PROJECTION\\ntargetLocation = projectPixelLocation(targetLocation);\\n#endif\\nreturn targetLocation;\\n}\\nbool isOutside(vec2 coords){\\nif (coords.t>1.00001 ||coords.t<-0.00001 || coords.s>1.00001 ||coords.s<-0.00001) {\\nreturn true;\\n} else {\\nreturn false;\\n}\\n}\\nvec4 getPixel(vec2 pixelLocation) {\\n#ifdef BICUBIC\\nvec4 color = sampleBicubicBSpline(u_image, pixelLocation, u_srcImageSize);\\n#elif defined(BILINEAR)\\nvec4 color = sampleBilinear(u_image, pixelLocation, u_srcImageSize);\\n#else\\nvec4 color = texture2D(u_image, pixelLocation);\\n#endif\\nreturn color;\\n}\",\n      \"common.vert\": \"precision mediump float;\\nattribute vec2 a_pos;\\nuniform highp mat3 u_dvsMat3;\\nuniform highp vec2 u_coordScale;\\nuniform highp float u_scale;\\nuniform highp vec2 u_offset;\\nvarying highp vec2 v_texcoord;\\nvoid main()\\n{\\nv_texcoord = a_pos * u_scale + u_offset;\\ngl_Position = vec4(u_dvsMat3 * vec3(a_pos * u_coordScale, 1.0), 1.0);\\n}\",\n      \"contrastBrightness.glsl\": \"uniform float u_contrastOffset;\\nuniform float u_brightnessOffset;\\nvec4 adjustContrastBrightness(vec4 currentPixel, bool isFloat) {\\nvec4 pixelValue = isFloat ? currentPixel * 255.0 : currentPixel;\\nfloat maxI = 255.0;\\nfloat mid = 128.0;\\nfloat c = u_contrastOffset;\\nfloat b = u_brightnessOffset;\\nvec4 v;\\nif (c > 0.0 && c < 100.0) {\\nv = (200.0 * pixelValue - 100.0 * maxI + 2.0 * maxI * b) / (2.0 * (100.0 - c)) + mid;\\n} else if (c <= 0.0 && c > -100.0) {\\nv = (200.0 * pixelValue - 100.0 * maxI + 2.0 * maxI * b) * (100.0 + c) / 20000.0 + mid;\\n} else if (c == 100.0) {\\nv = (200.0 * pixelValue - 100.0 * maxI + (maxI + 1.0) * (100.0 - c) + 2.0 * maxI * b);\\nv = (sign(v) + 1.0) / 2.0;\\n} else if (c == -100.0) {\\nv = vec4(mid, mid, mid, currentPixel.a);\\n}\\nvec3 rgb = clamp(v.rgb / 255.0, 0.0, 1.0);\\nreturn vec4(rgb, currentPixel.a);\\n}\",\n      \"getSurfaceValues.glsl\": \"#include <raster/common/mirror.glsl>\\nvoid getSurfaceValues(sampler2D imageTexture, vec2 texCoord, vec2 srcImageSize, inout float values[10]) {\\nvec2 onePixel = 1.0 / srcImageSize;\\nvec4 va = texture2D(imageTexture, mirror(texCoord + onePixel * vec2(-1.0, -1.0)));\\nvec4 vb = texture2D(imageTexture, mirror(texCoord + onePixel * vec2(0.0, -1.0)));\\nvec4 vc = texture2D(imageTexture, mirror(texCoord + onePixel * vec2(1.0, -1.0)));\\nvec4 vd = texture2D(imageTexture, mirror(texCoord + onePixel * vec2(-1.0, 0.0)));\\nvec4 ve = texture2D(imageTexture, mirror(texCoord));\\nvec4 vf = texture2D(imageTexture, mirror(texCoord + onePixel * vec2(1.0, 0.0)));\\nvec4 vg = texture2D(imageTexture, mirror(texCoord + onePixel * vec2(-1.0, 1.0)));\\nvec4 vh = texture2D(imageTexture, mirror(texCoord + onePixel * vec2(0.0, 1.0)));\\nvec4 vi = texture2D(imageTexture, mirror(texCoord + onePixel * vec2(1.0, 1.0)));\\nfloat alpha = va.a * vb.a * vc.a * vd.a * ve.a * vf.a * vg.a * vh.a * vi.a;\\nvalues[0] = va.r;\\nvalues[1] = vb.r;\\nvalues[2] = vc.r;\\nvalues[3] = vd.r;\\nvalues[4] = ve.r;\\nvalues[5] = vf.r;\\nvalues[6] = vg.r;\\nvalues[7] = vh.r;\\nvalues[8] = vi.r;\\nvalues[9] = alpha;\\n}\",\n      \"inverse.glsl\": \"float invertValue(float value) {\\nfloat s = sign(value);\\nreturn (s * s) / (value + abs(s) - 1.0);\\n}\",\n      \"mirror.glsl\": \"vec2 mirror(vec2 pos) {\\nvec2 pos1 = abs(pos);\\nreturn step(pos1, vec2(1.0, 1.0)) * pos1 + step(1.0, pos1) * (2.0 - pos1);\\n}\",\n      \"projection.glsl\": \"uniform sampler2D u_transformGrid;\\nuniform vec2 u_transformSpacing;\\nuniform vec2 u_transformGridSize;\\nuniform vec2 u_targetImageSize;\\nvec2 projectPixelLocation(vec2 coords) {\\n#ifdef LOOKUP_PROJECTION\\nvec4 pv = texture2D(u_transformGrid, coords);\\nreturn vec2(pv.r, pv.g);\\n#endif\\nvec2 index_image = floor(coords * u_targetImageSize);\\nvec2 oneTransformPixel = vec2(0.25 / u_transformGridSize.s, 1.0 / u_transformGridSize.t);\\nvec2 index_transform = floor(index_image / u_transformSpacing) / u_transformGridSize;\\nvec2 pos = fract((index_image + vec2(0.5, 0.5)) / u_transformSpacing);\\nvec2 srcLocation;\\nvec2 transform_location = index_transform + oneTransformPixel * 0.5;\\nif (pos.s <= pos.t) {\\nvec4 ll_abc = texture2D(u_transformGrid, vec2(transform_location.s, transform_location.t));\\nvec4 ll_def = texture2D(u_transformGrid, vec2(transform_location.s + oneTransformPixel.s, transform_location.t));\\nsrcLocation.s = dot(ll_abc.rgb, vec3(pos, 1.0));\\nsrcLocation.t = dot(ll_def.rgb, vec3(pos, 1.0));\\n} else {\\nvec4 ur_abc = texture2D(u_transformGrid, vec2(transform_location.s + 2.0 * oneTransformPixel.s, transform_location.t));\\nvec4 ur_def = texture2D(u_transformGrid, vec2(transform_location.s + 3.0 * oneTransformPixel.s, transform_location.t));\\nsrcLocation.s = dot(ur_abc.rgb, vec3(pos, 1.0));\\nsrcLocation.t = dot(ur_def.rgb, vec3(pos, 1.0));\\n}\\nreturn srcLocation;\\n}\"\n    },\n    flow: {\n      \"getFadeOpacity.glsl\": \"uniform float u_decayRate;\\nuniform float u_fadeToZero;\\nfloat getFadeOpacity(float x) {\\nfloat cutOff = mix(0.0, exp(-u_decayRate), u_fadeToZero);\\nreturn (exp(-u_decayRate * x) - cutOff) / (1.0 - cutOff);\\n}\",\n      \"getFragmentColor.glsl\": \"vec4 getFragmentColor(vec4 color, float dist, float size, float featheringSize) {\\nfloat featheringStart = clamp(0.5 - featheringSize / size, 0.0, 0.5);\\nif (dist > featheringStart) {\\ncolor *= 1.0 - (dist - featheringStart) / (0.5 - featheringStart);\\n}\\nreturn color;\\n}\",\n      imagery: {\n        \"imagery.frag\": \"precision highp float;\\nvarying vec2 v_texcoord;\\nuniform sampler2D u_texture;\\nuniform float u_Min;\\nuniform float u_Max;\\nuniform float u_featheringSize;\\n#include <raster/flow/vv.glsl>\\nfloat getIntensity(float v) {\\nreturn u_Min + v * (u_Max - u_Min);\\n}\\nvoid main(void) {\\nvec4 sampled = texture2D(u_texture, v_texcoord);\\nfloat intensity = getIntensity(sampled.r);\\ngl_FragColor = getColor(intensity);\\ngl_FragColor.a *= getOpacity(sampled.r);\\ngl_FragColor.a *= sampled.a;\\ngl_FragColor.rgb *= gl_FragColor.a;\\n}\",\n        \"imagery.vert\": \"attribute vec2 a_position;\\nattribute vec2 a_texcoord;\\nuniform mat3 u_dvsMat3;\\nvarying vec2 v_texcoord;\\nvoid main(void) {\\nvec2 xy = (u_dvsMat3 * vec3(a_position, 1.0)).xy;\\ngl_Position = vec4(xy, 0.0, 1.0);\\nv_texcoord = a_texcoord;\\n}\"\n      },\n      particles: {\n        \"particles.frag\": \"precision highp float;\\nvarying vec4 v_color;\\nvarying vec2 v_texcoord;\\nvarying float v_size;\\nuniform float u_featheringSize;\\n#include <raster/flow/getFragmentColor.glsl>\\nvoid main(void) {\\ngl_FragColor = getFragmentColor(v_color, length(v_texcoord - 0.5), v_size, u_featheringSize);\\n}\",\n        \"particles.vert\": \"attribute vec4 a_xyts0;\\nattribute vec4 a_xyts1;\\nattribute vec4 a_typeIdDurationSeed;\\nattribute vec4 a_extrudeInfo;\\nuniform mat3 u_dvsMat3;\\nuniform mat3 u_displayViewMat3;\\nuniform float u_time;\\nuniform float u_trailLength;\\nuniform float u_flowSpeed;\\nvarying vec4 v_color;\\nvarying vec2 v_texcoord;\\nvarying float v_size;\\nuniform float u_featheringSize;\\nuniform float u_introFade;\\n#include <raster/flow/vv.glsl>\\n#include <raster/flow/getFadeOpacity.glsl>\\nvoid main(void) {\\nvec2 position0 = a_xyts0.xy;\\nfloat t0 = a_xyts0.z;\\nfloat speed0 = a_xyts0.w;\\nvec2 position1 = a_xyts1.xy;\\nfloat t1 = a_xyts1.z;\\nfloat speed1 = a_xyts1.w;\\nfloat type = a_typeIdDurationSeed.x;\\nfloat id = a_typeIdDurationSeed.y;\\nfloat duration = a_typeIdDurationSeed.z;\\nfloat seed = a_typeIdDurationSeed.w;\\nvec2 e0 = a_extrudeInfo.xy;\\nvec2 e1 = a_extrudeInfo.zw;\\nfloat animationPeriod = duration + u_trailLength;\\nfloat scaledTime = u_time * u_flowSpeed;\\nfloat randomizedTime = scaledTime + seed * animationPeriod;\\nfloat t = mod(randomizedTime, animationPeriod);\\nfloat fUnclamped = (t - t0) / (t1 - t0);\\nfloat f = clamp(fUnclamped, 0.0, 1.0);\\nfloat clampedTime = mix(t0, t1, f);\\nfloat speed = mix(speed0, speed1, f);\\nvec2 extrude;\\nvec2 position;\\nfloat fadeOpacity;\\nfloat introOpacity;\\nif (type == 2.0) {\\nif (fUnclamped < 0.0 || (fUnclamped > 1.0 && t1 != duration)) {\\ngl_Position = vec4(0.0, 0.0, -2.0, 1.0);\\nreturn;\\n}\\nvec2 ortho = mix(e0, e1, f);\\nvec2 parallel;\\nparallel = normalize(position1 - position0) * 0.5;\\nif (id == 1.0) {\\nextrude = ortho;\\nv_texcoord = vec2(0.5, 0.0);\\n} else if (id == 2.0) {\\nextrude = -ortho;\\nv_texcoord = vec2(0.5, 1.0);\\n} else if (id == 3.0) {\\nextrude = ortho + parallel;\\nv_texcoord = vec2(1.0, 0.0);\\n} else if (id == 4.0) {\\nextrude = -ortho + parallel;\\nv_texcoord = vec2(1.0, 1.0);\\n}\\nfadeOpacity = getFadeOpacity((t - clampedTime) / u_trailLength);\\nintroOpacity = 1.0 - exp(-clampedTime);\\nv_size = getSize(speed);\\nv_color = getColor(speed);\\nv_color.a *= getOpacity(speed);\\nposition = mix(position0, position1, f);\\n} else {\\nif (fUnclamped < 0.0) {\\ngl_Position = vec4(0.0, 0.0, -2.0, 1.0);\\nreturn;\\n}\\nif (id == 1.0) {\\nextrude = e0;\\nv_texcoord = vec2(0.5, 0.0);\\nfadeOpacity = getFadeOpacity((t - t0) / u_trailLength);\\nintroOpacity = 1.0 - exp(-t0);\\nv_size = getSize(speed0);\\nv_color = getColor(speed0);\\nv_color.a *= getOpacity(speed0);\\nposition = position0;\\n} else if (id == 2.0) {\\nextrude = -e0;\\nv_texcoord = vec2(0.5, 1.0);\\nfadeOpacity = getFadeOpacity((t - t0) / u_trailLength);\\nintroOpacity = 1.0 - exp(-t0);\\nv_size = getSize(speed0);\\nv_color = getColor(speed0);\\nv_color.a *= getOpacity(speed0);\\nposition = position0;\\n} else if (id == 3.0) {\\nextrude = mix(e0, e1, f);\\nv_texcoord = vec2(0.5, 0.0);\\nfadeOpacity = getFadeOpacity((t - clampedTime) / u_trailLength);\\nintroOpacity = 1.0 - exp(-clampedTime);\\nv_size = getSize(speed);\\nv_color = getColor(speed);\\nv_color.a *= getOpacity(speed);\\nposition = mix(position0, position1, f);\\n} else if (id == 4.0) {\\nextrude = -mix(e0, e1, f);\\nv_texcoord = vec2(0.5, 1.0);\\nfadeOpacity = getFadeOpacity((t - clampedTime) / u_trailLength);\\nintroOpacity = 1.0 - exp(-clampedTime);\\nv_size = getSize(speed);\\nv_color = getColor(speed);\\nv_color.a *= getOpacity(speed);\\nposition = mix(position0, position1, f);\\n}\\n}\\nvec2 xy = (u_dvsMat3 * vec3(position, 1.0) + u_displayViewMat3 * vec3(extrude * v_size, 0.0)).xy;\\ngl_Position = vec4(xy, 0.0, 1.0);\\nv_color.a *= fadeOpacity;\\nv_color.a *= mix(1.0, introOpacity, u_introFade);\\nv_color.rgb *= v_color.a;\\n}\"\n      },\n      streamlines: {\n        \"streamlines.frag\": \"precision highp float;\\nvarying float v_side;\\nvarying float v_time;\\nvarying float v_totalTime;\\nvarying float v_timeSeed;\\nvarying vec4 v_color;\\nvarying float v_size;\\nuniform float u_time;\\nuniform float u_trailLength;\\nuniform float u_flowSpeed;\\nuniform float u_featheringSize;\\nuniform float u_introFade;\\n#include <raster/flow/getFragmentColor.glsl>\\n#include <raster/flow/getFadeOpacity.glsl>\\nvoid main(void) {\\nfloat t = mod(v_timeSeed * (v_totalTime + u_trailLength) + u_time * u_flowSpeed, v_totalTime + u_trailLength) - v_time;\\nvec4 color = v_color * step(0.0, t) * getFadeOpacity(t / u_trailLength);\\ncolor *= mix(1.0, 1.0 - exp(-v_time), u_introFade);\\ngl_FragColor = getFragmentColor(color, length((v_side + 1.0) / 2.0 - 0.5), v_size, u_featheringSize);\\n}\",\n        \"streamlines.vert\": \"attribute vec3 a_positionAndSide;\\nattribute vec3 a_timeInfo;\\nattribute vec2 a_extrude;\\nattribute float a_speed;\\nuniform mat3 u_dvsMat3;\\nuniform mat3 u_displayViewMat3;\\nvarying float v_time;\\nvarying float v_totalTime;\\nvarying float v_timeSeed;\\nvarying vec4 v_color;\\nvarying float v_side;\\nvarying float v_size;\\nuniform float u_featheringSize;\\n#include <raster/flow/vv.glsl>\\nvoid main(void) {\\nvec4 lineColor = getColor(a_speed);\\nfloat lineOpacity = getOpacity(a_speed);\\nfloat lineSize = getSize(a_speed);\\nvec2 position = a_positionAndSide.xy;\\nv_side = a_positionAndSide.z;\\nvec2 xy = (u_dvsMat3 * vec3(position, 1.0) + u_displayViewMat3 * vec3(a_extrude * lineSize, 0.0)).xy;\\ngl_Position = vec4(xy, 0.0, 1.0);\\nv_time = a_timeInfo.x;\\nv_totalTime = a_timeInfo.y;\\nv_timeSeed = a_timeInfo.z;\\nv_color = lineColor;\\nv_color.a *= lineOpacity;\\nv_color.rgb *= v_color.a;\\nv_size = lineSize;\\n}\"\n      },\n      \"vv.glsl\": \"#define MAX_STOPS 8\\n#ifdef VV_COLOR\\nuniform float u_color_stops[MAX_STOPS];\\nuniform vec4 u_color_values[MAX_STOPS];\\nuniform int u_color_count;\\n#else\\nuniform vec4 u_color;\\n#endif\\n#ifdef VV_OPACITY\\nuniform float u_opacity_stops[MAX_STOPS];\\nuniform float u_opacity_values[MAX_STOPS];\\nuniform int u_opacity_count;\\n#else\\nuniform float u_opacity;\\n#endif\\n#ifdef VV_SIZE\\nuniform float u_size_stops[MAX_STOPS];\\nuniform float u_size_values[MAX_STOPS];\\nuniform int u_size_count;\\n#else\\nuniform float u_size;\\n#endif\\nuniform float u_featheringOffset;\\nvec4 getColor(float x) {\\n#ifdef VV_COLOR\\nvec4 color = u_color_values[0];\\n{\\nfor (int i = 1; i < MAX_STOPS; i++) {\\nif (i >= u_color_count) {\\nbreak;\\n}\\nfloat x1 = u_color_stops[i - 1];\\nif (x < x1) {\\nbreak;\\n}\\nfloat x2 = u_color_stops[i];\\nvec4 y2 = u_color_values[i];\\nif (x < x2) {\\nvec4 y1 = u_color_values[i - 1];\\ncolor = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\\n} else {\\ncolor = y2;\\n}\\n}\\n}\\n#else\\nvec4 color = u_color;\\n#endif\\nreturn color;\\n}\\nfloat getOpacity(float x) {\\n#ifdef VV_OPACITY\\nfloat opacity = u_opacity_values[0];\\n{\\nfor (int i = 1; i < MAX_STOPS; i++) {\\nif (i >= u_opacity_count) {\\nbreak;\\n}\\nfloat x1 = u_opacity_stops[i - 1];\\nif (x < x1) {\\nbreak;\\n}\\nfloat x2 = u_opacity_stops[i];\\nfloat y2 = u_opacity_values[i];\\nif (x < x2) {\\nfloat y1 = u_opacity_values[i - 1];\\nopacity = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\\n} else {\\nopacity = y2;\\n}\\n}\\n}\\n#else\\nfloat opacity = u_opacity;\\n#endif\\nreturn opacity;\\n}\\nfloat getSize(float x) {\\n#ifdef VV_SIZE\\nfloat size = u_size_values[0];\\n{\\nfor (int i = 1; i < MAX_STOPS; i++) {\\nif (i >= u_size_count) {\\nbreak;\\n}\\nfloat x1 = u_size_stops[i - 1];\\nif (x < x1) {\\nbreak;\\n}\\nfloat x2 = u_size_stops[i];\\nfloat y2 = u_size_values[i];\\nif (x < x2) {\\nfloat y1 = u_size_values[i - 1];\\nsize = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\\n} else {\\nsize = y2;\\n}\\n}\\n}\\n#else\\nfloat size = u_size;\\n#endif\\nreturn size + 2.0 * u_featheringSize * u_featheringOffset;\\n}\"\n    },\n    hillshade: {\n      \"hillshade.frag\": \"precision mediump float;\\nvarying highp vec2 v_texcoord;\\n#include <raster/common/common.glsl>\\nuniform int u_hillshadeType;\\nuniform float u_sinZcosAs[6];\\nuniform float u_sinZsinAs[6];\\nuniform float u_cosZs[6];\\nuniform float u_weights[6];\\nuniform vec2 u_factor;\\nuniform float u_minValue;\\nuniform float u_maxValue;\\n#include <raster/lut/colorize.glsl>\\n#include <raster/common/getSurfaceValues.glsl>\\nvec3 rgb2hsv(vec3 c) {\\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\nvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\\nvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\\nfloat d = q.x - min(q.w, q.y);\\nfloat e = 1.0e-10;\\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);\\n}\\nvec3 hsv2rgb(vec3 c) {\\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\nvec4 overlay(float val, float minValue, float maxValue, float hillshade) {\\nval = clamp((val - minValue) / (maxValue - minValue), 0.0, 1.0);\\nvec4 rgb = colorize(vec4(val, val, val, 1.0), 255.0);\\nvec3 hsv = rgb2hsv(rgb.xyz);\\nhsv.z = hillshade;\\nreturn vec4(hsv2rgb(hsv), 1.0) * rgb.a;\\n}\\nvoid main() {\\nvec2 pixelLocation = getPixelLocation(v_texcoord);\\nif (isOutside(pixelLocation)) {\\ngl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\\nreturn;\\n}\\nvec4 currentPixel = getPixel(pixelLocation);\\nif (currentPixel.a == 0.0) {\\ngl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\\nreturn;\\n}\\nfloat pv[10];\\ngetSurfaceValues(u_image, pixelLocation, u_srcImageSize, pv);\\nfloat alpha = pv[9];\\nfloat dzx = (pv[2] + 2.0 * pv[5] + pv[8] - pv[0] - 2.0 * pv[3] - pv[6]) * u_factor.s;\\nfloat dzy = (pv[6] + 2.0 * pv[7] + pv[8] - pv[0] - 2.0 * pv[1] - pv[2]) * u_factor.t;\\nfloat dzd = sqrt(1.0 + dzx * dzx + dzy * dzy);\\nfloat hillshade = 0.0;\\nif (u_hillshadeType == 0){\\nfloat cosDelta = u_sinZsinAs[0] * dzy - u_sinZcosAs[0] * dzx;\\nfloat z = (u_cosZs[0] + cosDelta) / dzd;\\nif (z < 0.0)  z = 0.0;\\nhillshade = z;\\n} else {\\nfor (int k = 0; k < 6; k++) {\\nfloat cosDelta = u_sinZsinAs[k] * dzy - u_sinZcosAs[k] * dzx;\\nfloat z = (u_cosZs[k] + cosDelta) / dzd;\\nif (z < 0.0) z = 0.0;\\nhillshade = hillshade + z * u_weights[k];\\nif (k == 5) break;\\n}\\n}\\n#ifdef APPLY_COLORMAP\\ngl_FragColor = overlay(pv[4], u_minValue, u_maxValue, hillshade) * alpha * u_opacity;\\n#else\\ngl_FragColor = vec4(hillshade, hillshade, hillshade, 1.0) * alpha * u_opacity;\\n#endif\\n}\"\n    },\n    lut: {\n      \"colorize.glsl\": \"uniform sampler2D u_colormap;\\nuniform float u_colormapOffset;\\nuniform float u_colormapMaxIndex;\\nvec4 colorize(vec4 currentPixel, float scaleFactor) {\\nfloat clrIndex = clamp(currentPixel.r * scaleFactor - u_colormapOffset, 0.0, u_colormapMaxIndex);\\nvec2 clrPosition = vec2((clrIndex + 0.5) / (u_colormapMaxIndex + 1.0), 0.0);\\nvec4 color = texture2D(u_colormap, clrPosition);\\nvec4 result = vec4(color.rgb, color.a * currentPixel.a);\\nreturn result;\\n}\",\n      \"lut.frag\": \"precision mediump float;\\nvarying highp vec2 v_texcoord;\\n#include <raster/common/common.glsl>\\n#include <raster/lut/colorize.glsl>\\nvoid main() {\\nvec2 pixelLocation = getPixelLocation(v_texcoord);\\nif (isOutside(pixelLocation)) {\\ngl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\\nreturn;\\n}\\nvec4 currentPixel = getPixel(pixelLocation);\\nvec4 result = colorize(currentPixel, 1.0);\\ngl_FragColor = vec4(result.xyz, 1.0) * result.a * u_opacity;\\n}\"\n    },\n    magdir: {\n      \"magdir.frag\": \"precision mediump float;\\nvarying vec4 v_color;\\nuniform lowp float u_opacity;\\nvoid main() {\\ngl_FragColor = v_color * u_opacity;\\n}\",\n      \"magdir.vert\": \"precision mediump float;\\nattribute vec2 a_pos;\\nattribute vec2 a_offset;\\nattribute vec2 a_vv;\\nuniform highp mat3 u_dvsMat3;\\nuniform highp vec2 u_coordScale;\\nuniform vec2 u_symbolSize;\\nuniform vec2 u_symbolPercentRange;\\nuniform vec2 u_dataRange;\\nuniform float u_rotation;\\nuniform vec4 u_colors[12];\\nvarying vec4 v_color;\\nvoid main()\\n{\\nfloat angle = a_offset.y + u_rotation;\\n#ifndef ROTATION_GEOGRAPHIC\\nangle = 3.14159265359 * 2.0 - angle - 3.14159265359 / 2.0;\\n#endif\\nvec2 offset = vec2(cos(angle), sin(angle)) * a_offset.x;\\n#ifdef DATA_RANGE\\nfloat valuePercentage = clamp((a_vv.y - u_dataRange.x) / (u_dataRange.y - u_dataRange.x), 0.0, 1.0);\\nfloat sizeRatio = u_symbolPercentRange.x + valuePercentage * (u_symbolPercentRange.y - u_symbolPercentRange.x);\\nfloat sizePercentage = clamp(sizeRatio, u_symbolPercentRange.x, u_symbolPercentRange.y);\\n#else\\nfloat sizePercentage = (u_symbolPercentRange.x + u_symbolPercentRange.y) / 2.0;\\n#endif\\nvec2 pos = a_pos + offset * sizePercentage * u_symbolSize;\\nv_color = u_colors[int(a_vv.x)];\\ngl_Position = vec4(u_dvsMat3 * vec3(pos * u_coordScale, 1.0), 1.0);\\n}\"\n    },\n    reproject: {\n      \"reproject.frag\": \"precision mediump float;\\nvarying vec2 v_texcoord;\\n#include <raster/common/common.glsl>\\nvoid main() {\\nvec2 pixelLocation = getPixelLocation(v_texcoord);\\nif (isOutside(pixelLocation)) {\\ngl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\nreturn;\\n}\\nvec4 currentPixel = getPixel(pixelLocation);\\ngl_FragColor = vec4(currentPixel.rgb, 1.0) * currentPixel.a * u_opacity;\\n}\",\n      \"reproject.vert\": \"precision mediump float;\\nattribute vec2 a_position;\\nvarying highp vec2 v_texcoord;\\nvoid main()\\n{\\nv_texcoord = a_position;\\ngl_Position = vec4(2.0 * (a_position - 0.5), 0.0, 1.0);\\n}\"\n    },\n    rfx: {\n      aspect: {\n        \"aspect.frag\": \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texcoord;\\nuniform vec2 u_cellSize;\\nuniform vec2 u_srcImageSize;\\n#include <raster/common/getSurfaceValues.glsl>\\nconst float pi = 3.14159265359;\\nvoid main() {\\nfloat pv[10];\\ngetSurfaceValues(u_image, v_texcoord, u_srcImageSize, pv);\\nfloat alpha = pv[9];\\nfloat dzx = (pv[2] + 2.0 * pv[5] + pv[8] - pv[0] - 2.0 * pv[3] - pv[6]) / (8.0 * u_cellSize[0]);\\nfloat dzy = -(pv[6] + 2.0 * pv[7] + pv[8] - pv[0] - 2.0 * pv[1] - pv[2]) / (8.0 * u_cellSize[1]);\\nalpha *= sign(abs(dzx) + abs(dzy));\\nfloat aspect_rad = (dzx == 0.0) ? (step(0.0, dzy) * 0.5 * pi + step(dzy, 0.0) * 1.5 * pi) : mod((2.5 * pi + atan(dzy, -dzx)), 2.0 * pi);\\nfloat aspect = aspect_rad * 180.0 / pi;\\ngl_FragColor = vec4(aspect, aspect, aspect, 1.0) * alpha;\\n}\"\n      },\n      bandarithmetic: {\n        \"bandarithmetic.frag\": \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texcoord;\\nuniform mediump mat3 u_bandIndexMat3;\\nuniform float u_adjustments[3];\\n#include <raster/common/inverse.glsl>\\nvoid main() {\\nvec4 pv = texture2D(u_image, v_texcoord);\\nvec3 pv2 = u_bandIndexMat3 * pv.rgb;\\nfloat nir = pv2.r;\\nfloat red = pv2.g;\\nfloat index;\\n#ifdef NDXI\\nindex = (nir - red) * invertValue(nir + red);\\n#elif defined(SR)\\nindex = nir * invertValue(red);\\n#elif defined(CI)\\nindex = nir * invertValue(red) - 1.0;\\n#elif defined(SAVI)\\nindex = (nir - red) * invertValue(nir + red + u_adjustments[0]) * (1.0 + u_adjustments[0]);\\n#elif defined(TSAVI)\\nfloat s = u_adjustments[0];\\nfloat a = u_adjustments[1];\\nfloat x = u_adjustments[2];\\nfloat y = -a * s + x * (1.0 + s * s);\\nindex = (s * (nir - s * red - a)) * invertValue(a * nir + red + y);\\n#elif defined(MSAVI)\\nfloat nir2 = 2.0 * nir + 1.0;\\nindex = 0.5 * (nir2 - sqrt(nir2 * nir2 - 8.0 * (nir - red)));\\n#elif defined(GEMI)\\nfloat eta = (2.0 * (nir * nir - red * red) + 1.5 * nir + 0.5 * red) * invertValue(nir + red + 0.5);\\nindex = eta * (1.0 - 0.25 * eta) - (red - 0.125) * invertValue(1.0 - red);\\n#elif defined(PVI)\\nfloat a = u_adjustments[0];\\nfloat b = u_adjustments[1];\\nfloat y = sqrt(1.0 + a * a);\\nindex = (nir - a * red - b) * invertValue(y);\\n#elif defined(VARI)\\nindex = (pv2.g - pv2.r) * invertValue(pv2.g + pv2.r - pv2.b);\\n#elif defined(MTVI)\\nfloat green = pv2.b;\\nfloat v = sqrt(pow((2.0 * nir + 1.0), 2.0) - (6.0 * nir - 5.0 * sqrt(red)) - 0.5);\\nindex = 1.5 * (1.2 * (nir - green) - 2.5 * (red - green)) * invertValue(v);\\n#elif defined(RTVICORE)\\nfloat green = pv2.b;\\nindex = 100.0 * (nir - red) - 10.0 * (nir - green);\\n#elif defined(EVI)\\nfloat blue = pv2.b;\\nfloat denom = nir + 6.0 * red - 7.5 * blue + 1.0;\\nindex =  (2.5 * (nir - red)) * invertValue(denom);\\n#elif defined(WNDWI)\\nfloat g = pv2.r;\\nfloat n = pv2.g;\\nfloat s = pv2.s;\\nfloat a = u_adjustments[0];\\nfloat denom = g + a * n + (1.0 - a) * s;\\nindex = (g - a * n - (1 - a) * s) * invertValue(denom);\\n#elif defined(BAI)\\nindex = invertValue(pow((0.1 - red), 2.0) + pow((0.06 - nir), 2.0));\\n#else\\ngl_FragColor = pv;\\nreturn;\\n#endif\\ngl_FragColor = vec4(index, index, index, pv.a);\\n}\"\n      },\n      compositeband: {\n        \"compositeband.frag\": \"precision mediump float;\\nuniform sampler2D u_image;\\nuniform sampler2D u_image1;\\nuniform sampler2D u_image2;\\n#ifdef ONE_CONSTANT\\nuniform float u_image1Const;\\n#ifdef TWO_CONSTANT\\nuniform float u_image2Const;\\n#endif\\nuniform mat3 u_imageSwap;\\n#endif\\nvarying vec2 v_texcoord;\\nvoid main() {\\nvec4 pv0 = texture2D(u_image, v_texcoord);\\nfloat a = pv0.r;\\nfloat alpha = pv0.a;\\n#ifdef TWO_CONSTANT\\nfloat b = u_image1Const;\\nfloat c = u_image2Const;\\nvec3 abc = u_imageSwap * vec3(a, b, c);\\na = abc.s;\\nb = abc.t;\\nc = abc.p;\\n#elif defined(ONE_CONSTANT)\\nvec4 pv1 = texture2D(u_image1, v_texcoord);\\nfloat b = pv1.r;\\nfloat c = u_image1Const;\\nvec3 abc = u_imageSwap * vec3(a, b, c);\\na = abc.s;\\nb = abc.t;\\nc = abc.p;\\nalpha *= pv1.a;\\n#else\\nvec4 pv1 = texture2D(u_image1, v_texcoord);\\nvec4 pv2 = texture2D(u_image2, v_texcoord);\\nfloat b = pv1.r;\\nfloat c = pv2.r;\\nalpha = alpha * pv1.a * pv2.a;\\n#endif\\ngl_FragColor = vec4(a, b, c, alpha);\\n}\"\n      },\n      computechange: {\n        \"computechange.frag\": \"precision mediump float;\\nuniform sampler2D u_image;\\nuniform sampler2D u_image1;\\n#ifdef ONE_CONSTANT\\nuniform float u_image1Const;\\nuniform mat3 u_imageSwap;\\n#endif\\nvarying vec2 v_texcoord;\\nuniform vec2 u_domainRange;\\n#include <raster/common/inverse.glsl>\\nvoid main() {\\nvec4 pv0 = texture2D(u_image, v_texcoord);\\nfloat a = pv0.r;\\n#ifdef ONE_CONSTANT\\nfloat b = u_image1Const;\\nvec3 abc = u_imageSwap * vec3(a, b, 0);\\na = abc.s;\\nb = abc.t;\\n#else\\nvec4 pv1 = texture2D(u_image1, v_texcoord);\\nfloat b = pv1.r;\\n#endif\\nfloat result = a;\\nfloat alpha = pv0.a;\\n#ifdef DIFFERENCE\\nresult = a - b;\\n#elif defined(RELATIVE)\\nresult = (a - b) * invertValue(max(abs(a), abs(b)));\\n#endif\\nbool isInvalid = result < u_domainRange.s || result > u_domainRange.t;\\nresult = isInvalid ? 0.0 : result;\\nalpha *= float(!isInvalid);\\n#ifdef ROUND_OUTPUT\\nresult = floor(result + 0.5);\\n#endif\\ngl_FragColor = vec4(result, result, result, alpha);\\n}\"\n      },\n      contrast: {\n        \"contrast.frag\": \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texcoord;\\n#include <raster/common/contrastBrightness.glsl>\\nvoid main() {\\nvec4 pv = texture2D(u_image, v_texcoord);\\nvec4 result = adjustContrastBrightness(pv, false) ;\\ngl_FragColor = vec4(result.rgb * 255.0, result.a);\\n}\"\n      },\n      convolution: {\n        \"convolution.frag\": \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texcoord;\\nuniform vec2 u_srcImageSize;\\n#define KERNEL_SIZE_ROWS ROWS\\n#define KERNEL_SIZE_COLS COLS\\nuniform vec2 u_clampRange;\\nuniform float u_kernel[25];\\n#include <raster/common/mirror.glsl>\\nvoid main() {\\nvec3 rgb = vec3(0.0, 0.0, 0.0);\\nvec2 resolution = 1.0 / u_srcImageSize;\\nfloat rowOffset = -float(floor(float(KERNEL_SIZE_ROWS) / 2.0));\\nfloat colOffset = -float(floor(float(KERNEL_SIZE_COLS) / 2.0));\\nfloat alpha = 1.0;\\nfor (int row = 0; row < KERNEL_SIZE_ROWS; row++) {\\nfloat pos_row = rowOffset + float(row);\\nfor (int col = 0; col < KERNEL_SIZE_COLS; col++) {\\nvec2 pos = v_texcoord + vec2(colOffset + float(col), pos_row) * resolution;\\nvec4 pv = texture2D(u_image, mirror(pos));\\nrgb += pv.rgb * u_kernel[row * KERNEL_SIZE_COLS + col];\\nalpha *= pv.a;\\n}\\n}\\nrgb = clamp(rgb, u_clampRange.s, u_clampRange.t);\\ngl_FragColor = vec4(rgb * alpha, alpha);\\n}\"\n      },\n      curvature: {\n        \"curvature.frag\": \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texcoord;\\nuniform float u_zlFactor;\\nuniform vec2 u_srcImageSize;\\n#include <raster/common/getSurfaceValues.glsl>\\nvoid main() {\\nfloat pv[10];\\ngetSurfaceValues(u_image, v_texcoord, u_srcImageSize, pv);\\nfloat alpha = pv[9];\\nfloat d = ((pv[3] + pv[5]) * 0.5 - pv[4]);\\nfloat e = ((pv[1] + pv[7]) * 0.5 - pv[4]);\\nfloat curvature = 0.0;\\n#ifdef STANDARD\\ncurvature = -u_zlFactor * (d + e);\\ngl_FragColor = vec4(curvature, curvature, curvature, alpha);\\n#else\\nfloat f = (-pv[0] + pv[2] + pv[6] - pv[8]) / 4.0;\\nfloat g = (-pv[3] + pv[5]) / 2.0;\\nfloat h = (pv[1] - pv[7]) / 2.0;\\nfloat g2 = g * g;\\nfloat h2 = h * h;\\n#ifdef PROFILE\\ncurvature = (u_zlFactor * (d * g2 + e * h2 + f * g * h)) / (g2 + h2);\\n#else\\ncurvature = (-u_zlFactor * (d * h2 + e * g2 - f * g * h)) / (g2 + h2);\\n#endif\\n#endif\\ngl_FragColor = vec4(curvature, curvature, curvature, alpha);\\n}\"\n      },\n      extractband: {\n        \"extractband.frag\": \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texcoord;\\nuniform mediump mat3 u_bandIndexMat3;\\nvoid main() {\\nvec4 pv = texture2D(u_image, v_texcoord);\\nvec3 pv2 = u_bandIndexMat3 * pv.rgb;\\ngl_FragColor = vec4(pv2, pv.a);\\n}\"\n      },\n      focalstatistics: {\n        \"focalstatistics.frag\": \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texcoord;\\nuniform vec2 u_srcImageSize;\\n#define KERNEL_SIZE_ROWS ROWS\\n#define KERNEL_SIZE_COLS COLS\\nuniform vec2 u_clampRange;\\n#include <raster/common/mirror.glsl>\\n#include <raster/common/inverse.glsl>\\nvoid main() {\\nvec2 resolution = 1.0 / u_srcImageSize;\\nfloat rowOffset = -float(floor(float(KERNEL_SIZE_ROWS) / 2.0));\\nfloat colOffset = -float(floor(float(KERNEL_SIZE_COLS) / 2.0));\\nfloat count = 0.0;\\n#ifdef STDDEV\\nvec3 sum = vec3(0.0, 0.0, 0.0);\\nvec3 sum2 = vec3(0.0, 0.0, 0.0);\\n#endif\\nvec4 currentPixel = texture2D(u_image, v_texcoord);\\nvec3 rgb = currentPixel.rgb;\\nfor (int row = 0; row < KERNEL_SIZE_ROWS; row++) {\\nfloat pos_row = rowOffset + float(row);\\nfor (int col = 0; col < KERNEL_SIZE_COLS; col++) {\\nvec2 pos = v_texcoord + vec2(colOffset + float(col), pos_row) * resolution;\\nvec4 pv = texture2D(u_image, mirror(pos));\\ncount += pv.a;\\n#ifdef MIN\\nrgb = min(rgb, pv.rgb);\\n#elif defined(MAX)\\nrgb = max(rgb, pv.rgb);\\n#elif defined(MEAN)\\nrgb += pv.rgb;\\n#elif defined(STDDEV)\\nsum += pv.rgb;\\nsum2 += (pv.rgb * pv.rgb);\\n#endif\\n}\\n}\\n#ifdef MEAN\\nrgb *= invertValue(count);\\n#elif defined(STDDEV)\\nrgb = sqrt((sum2 - sum * sum * invertValue(count)) * invertValue(count));\\n#endif\\nfloat alpha = step(0.9999, count);\\nrgb = clamp(rgb, u_clampRange.s, u_clampRange.t);\\n#ifdef FILL\\nrgb = (1.0 - currentPixel.a) * rgb + currentPixel.a * currentPixel.rgb;\\n#endif\\ngl_FragColor = vec4(rgb * alpha, alpha);\\n}\"\n      },\n      grayscale: {\n        \"grayscale.frag\": \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texcoord;\\nuniform vec3 u_weights;\\nvoid main() {\\nvec4 pv = texture2D(u_image, v_texcoord);\\nfloat value = dot(u_weights, pv.rgb);\\ngl_FragColor = vec4(value, value, value, pv.a);\\n}\"\n      },\n      local: {\n        \"local.frag\": \"precision mediump float;\\nuniform sampler2D u_image;\\nuniform sampler2D u_image1;\\n#ifdef ONE_CONSTANT\\nuniform float u_image1Const;\\n#ifdef TWO_CONSTANT\\nuniform float u_image2Const;\\n#endif\\nuniform mat3 u_imageSwap;\\n#endif\\nvarying vec2 v_texcoord;\\nuniform vec2 u_domainRange;\\n#include <raster/common/inverse.glsl>\\nvoid main() {\\nvec4 pv0 = texture2D(u_image, v_texcoord);\\nfloat a = pv0.r;\\n#ifdef TWO_IMAGES\\n#ifdef ONE_CONSTANT\\nfloat b = u_image1Const;\\nvec3 abc = u_imageSwap * vec3(a, b, 0);\\na = abc.s;\\nb = abc.t;\\n#else\\nvec4 pv1 = texture2D(u_image1, v_texcoord);\\nfloat b = pv1.r;\\n#endif\\n#elif defined(CONDITIONAL)\\n#ifdef TWO_CONSTANT\\nfloat b = u_image1Const;\\nfloat c = u_image2Const;\\nvec3 abc = u_imageSwap * vec3(a, b, c);\\na = abc.s;\\nb = abc.t;\\nc = abc.p;\\n#elif defined(ONE_CONSTANT)\\nvec4 pv1 = texture2D(u_image1, v_texcoord);\\nfloat b = pv1.r;\\nfloat c = u_image1Const;\\nvec3 abc = u_imageSwap * vec3(a, b, c);\\na = abc.s;\\nb = abc.t;\\nc = abc.p;\\n#else\\nvec4 pv1 = texture2D(u_image1, v_texcoord);\\nvec4 pv2 = texture2D(u_image2, v_texcoord);\\nfloat b = pv1.r;\\nfloat c = pv2.r;\\n#endif\\n#endif\\nfloat result = a;\\nfloat alpha = pv0.a;\\n#ifdef PLUS\\nresult = a + b;\\n#elif defined(MINUS)\\nresult = a - b;\\n#elif defined(TIMES)\\nresult = a * b;\\n#elif defined(DIVIDE)\\nresult = a * invertValue(b);\\nalpha *= float(abs(sign(b)));\\n#elif defined(FLOATDIVIDE)\\nresult = a * invertValue(b);\\nalpha *= float(abs(sign(b)));\\n#elif defined(FLOORDIVIDE)\\nresult = floor(a * invertValue(b));\\nalpha *= float(abs(sign(b)));\\n#elif defined(SQUARE)\\nresult = a * a;\\n#elif defined(SQRT)\\nresult = sqrt(a);\\n#elif defined(POWER)\\nresult = pow(a, b);\\n#elif defined(LN)\\nresult = a <= 0.0 ? 0.0: log(a);\\nalpha *= float(a > 0.0);\\n#elif defined(LOG_1_0)\\nresult = a <= 0.0 ? 0.0: log2(a) * invertValue(log2(10.0));\\nalpha *= float(a > 0.0);\\n#elif defined(LOG_2)\\nresult = a <= 0.0 ? 0.0: log2(a);\\nalpha *= float(a > 0.0);\\n#elif defined(EXP)\\nresult = exp(a);\\n#elif defined(EXP_1_0)\\nresult = pow(10.0, a);\\n#elif defined(EXP_2)\\nresult = pow(2.0, a);\\n#elif defined(ROUNDDOWN)\\nresult = floor(a);\\n#elif defined(ROUNDUP)\\nresult = ceil(a);\\n#elif defined(INT)\\nresult = float(sign(a)) * floor(abs(a));\\n#elif defined(MOD)\\nresult = mod(a, b);\\n#elif defined(NEGATE)\\nresult = -a;\\n#elif defined(ABS)\\nresult = abs(a);\\n#elif defined(ACOS)\\nresult = abs(a) > 1.0 ? 0.0: acos(a);\\nalpha *= step(abs(a), 1.00001);\\n#elif defined(ACOSH)\\nresult = acosh(a);\\n#elif defined(ASIN)\\nresult = abs(a) > 1.0 ? 0.0: asin(a);\\nalpha *= step(abs(a), 1.00001);\\n#elif defined(ASINH)\\nresult = asinh(a);\\n#elif defined(ATAN)\\nresult = atan(a);\\n#elif defined(ATANH)\\nresult = abs(a) > 1.0 ? 0.0: atanh(a);\\nalpha *= step(abs(a), 1.0);\\n#elif defined(ATAN_2)\\nresult = atan(a, b);\\n#elif defined(COS)\\nresult = cos(a);\\n#elif defined(COSH)\\nresult = cosh(a);\\n#elif defined(SIN)\\nresult = sin(a);\\n#elif defined(SINH)\\nresult = sinh(a);\\n#elif defined(TAN)\\nresult = tan(a);\\n#elif defined(TANH)\\nresult = tanh(a);\\n#elif defined(BITWISEAND)\\nresult = a & b;\\n#elif defined(BITWISEOR)\\nresult = a | b;\\n#elif defined(BITWISELEFTSHIFT)\\nresult = a << b;\\n#elif defined(BITWISERIGHTSHIFT)\\nresult = a >> b;\\n#elif defined(BITWISENOT)\\nresult = ~a;\\n#elif defined(BITWISEXOR)\\nresult = a ^ b;\\n#elif defined(BOOLEANAND)\\nresult = float((a != 0.0) && (b != 0.0));\\n#elif defined(BOOLEANNOT)\\nresult = float(a == 0.0);\\n#elif defined(BOOLEANOR)\\nresult = float((a != 0.0) || (b != 0.0));\\n#elif defined(BOOLEANXOR)\\nresult = float((a != 0.0) ^^ (b != 0.0));\\n#elif defined(GREATERTHAN)\\nresult = float(a > b);\\n#elif defined(GREATERTHANEQUAL)\\nresult = float(a >= b);\\n#elif defined(LESSTHAN)\\nresult = float(a < b);\\n#elif defined(LESSTHANEQUAL)\\nresult = float(a <= b);\\n#elif defined(EQUALTO)\\nresult = float(a == b);\\n#elif defined(NOTEQUAL)\\nresult = float(a != b);\\n#elif defined(ISNULL)\\nresult = float(alpha == 0.0);\\nalpha = 1.0;\\n#elif defined(SETNULL)\\nfloat maskValue = float(a == 0.0);\\nresult = maskValue * b;\\nalpha *= maskValue;\\n#elif defined(CONDITIONAL)\\nfloat weight = float(abs(sign(a)));\\nresult = weight * b + (1.0 - weight) * c;\\n#endif\\nbool isInvalid = result < u_domainRange.s || result > u_domainRange.t;\\nresult = isInvalid ? 0.0 : result;\\nalpha *= float(!isInvalid);\\n#ifdef ROUND_OUTPUT\\nresult = floor(result + 0.5);\\n#endif\\ngl_FragColor = vec4(result, result, result, alpha);\\n}\"\n      },\n      mask: {\n        \"mask.frag\": \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texcoord;\\n#define LEN_INCLUDED_RANGES 6\\n#define LEN_NODATA_VALUES 6\\nuniform highp float u_includedRanges[6];\\nuniform highp float u_noDataValues[6];\\nfloat maskFactor(float bandValue, float fromValue, float to) {\\nfloat factor = 1.0;\\nfor (int i = 0; i < LEN_NODATA_VALUES; i++) {\\nfactor *= float(u_noDataValues[i] != bandValue);\\n}\\nfactor *= step(fromValue, bandValue) * step(bandValue, to);\\nreturn factor;\\n}\\nvoid main() {\\nvec4 pv = texture2D(u_image, v_texcoord);\\nfloat redFactor = maskFactor(pv.r, u_includedRanges[0], u_includedRanges[1]);\\n#ifdef MULTI_BAND\\nfloat greenFactor = maskFactor(pv.g, u_includedRanges[2], u_includedRanges[3]);\\nfloat blueFactor = maskFactor(pv.b, u_includedRanges[4], u_includedRanges[5]);\\nfloat maskFactor = redFactor * greenFactor * blueFactor;\\ngl_FragColor = pv * maskFactor;\\n#else\\ngl_FragColor = pv * redFactor;\\n#endif\\n}\"\n      },\n      ndvi: {\n        \"ndvi.frag\": \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texcoord;\\nuniform mediump mat3 u_bandIndexMat3;\\n#include <raster/common/inverse.glsl>\\nvoid main() {\\nvec4 pv = texture2D(u_image, v_texcoord);\\nvec3 pv2 = u_bandIndexMat3 * pv.rgb;\\nfloat nir = pv2.r;\\nfloat red = pv2.g;\\nfloat index = (nir - red) * invertValue(nir + red);\\n#ifdef SCALED\\nindex = floor((index + 1.0) * 100.0 + 0.5);\\n#endif\\ngl_FragColor = vec4(index, index, index, pv.a);\\n}\"\n      },\n      remap: {\n        \"remap.frag\": \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texcoord;\\n#define LEN_REMAP_RANGES 18\\n#define LEN_NODATA_RANGES 12\\nuniform highp float u_rangeMaps[18];\\nuniform highp float u_noDataRanges[12];\\nuniform highp float u_unmatchMask;\\nuniform vec2 u_clampRange;\\nvoid main() {\\nvec4 pv = texture2D(u_image, v_texcoord);\\nfloat factor = 1.0;\\nfloat bandValue = pv.r;\\nfor (int i = 0; i < LEN_NODATA_RANGES; i+=2) {\\nfloat inside = 1.0 - step(u_noDataRanges[i], bandValue) * step(bandValue, u_noDataRanges[i+1]);\\nfactor *= inside;\\n}\\nfloat mapValue = 0.0;\\nfloat includeMask = 0.0;\\nfor (int i = 0; i < LEN_REMAP_RANGES; i+=3) {\\nfloat stepMask = step(u_rangeMaps[i], bandValue) * step(bandValue, u_rangeMaps[i+1]);\\nincludeMask = (1.0 - stepMask) * includeMask + stepMask;\\nmapValue = (1.0 - stepMask) * mapValue + stepMask * u_rangeMaps[i+2];\\n}\\nbandValue = factor * (mapValue + (1.0 - includeMask) * u_unmatchMask * pv.r);\\nfloat bandMask = factor * max(u_unmatchMask, includeMask);\\nbandValue = clamp(bandValue, u_clampRange.s, u_clampRange.t);\\ngl_FragColor = vec4(bandValue, bandValue, bandValue, bandMask * pv.a);\\n}\"\n      },\n      slope: {\n        \"slope.frag\": \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying vec2 v_texcoord;\\nuniform vec2 u_cellSize;\\nuniform float u_zFactor;\\nuniform vec2 u_srcImageSize;\\nuniform float u_pixelSizePower;\\nuniform float u_pixelSizeFactor;\\n#include <raster/common/getSurfaceValues.glsl>\\nvoid main() {\\nfloat pv[10];\\ngetSurfaceValues(u_image, v_texcoord, u_srcImageSize, pv);\\nfloat alpha = pv[9];\\nfloat xf = (u_zFactor + pow(u_cellSize[0], u_pixelSizePower) * u_pixelSizeFactor) / (8.0 * u_cellSize[0]);\\nfloat yf = (u_zFactor + pow(u_cellSize[1], u_pixelSizePower) * u_pixelSizeFactor) / (8.0 * u_cellSize[1]);\\nfloat dzx = (pv[2] + 2.0 * pv[5] + pv[8] - pv[0] - 2.0 * pv[3] - pv[6]) * xf;\\nfloat dzy = -(pv[6] + 2.0 * pv[7] + pv[8] - pv[0] - 2.0 * pv[1] - pv[2]) * yf;\\nfloat rise2run = sqrt(dzx * dzx + dzy * dzy);\\n#ifdef PERCENT_RISE\\nfloat percentRise = rise2run * 100.0;\\ngl_FragColor = vec4(percentRise, percentRise, percentRise, alpha);\\n#else\\nfloat degree = atan(rise2run) * 57.2957795;\\ngl_FragColor = vec4(degree, degree, degree, alpha);\\n#endif\\n}\"\n      },\n      stretch: {\n        \"stretch.frag\": \"precision mediump float;\\nuniform sampler2D u_image;\\nvarying highp vec2 v_texcoord;\\nuniform float u_minCutOff[3];\\nuniform float u_maxCutOff[3];\\nuniform float u_minOutput;\\nuniform float u_maxOutput;\\nuniform float u_factor[3];\\nuniform float u_gamma[3];\\nuniform float u_gammaCorrection[3];\\nfloat stretchOneValue(float val, float minCutOff, float maxCutOff, float minOutput, float maxOutput, float factor, float gamma, float gammaCorrection) {\\nval = clamp(val, minCutOff, maxCutOff);\\nfloat stretchedVal;\\n#ifdef USE_GAMMA\\nfloat tempf = 1.0;\\nfloat outRange = maxOutput - minOutput;\\nfloat relativeVal = (val - minCutOff) / (maxCutOff - minCutOff);\\ntempf -= step(1.0, gamma) * sign(gamma - 1.0) * pow(1.0 / outRange, relativeVal * gammaCorrection);\\nstretchedVal = tempf * outRange * pow(relativeVal, 1.0 / gamma) + minOutput;\\nstretchedVal = clamp(stretchedVal, minOutput, maxOutput);\\n#else\\nstretchedVal = minOutput + (val - minCutOff) * factor;\\n#endif\\n#ifdef ROUND_OUTPUT\\nstretchedVal = floor(stretchedVal + 0.5);\\n#endif\\nreturn stretchedVal;\\n}\\nvoid main() {\\nvec4 currentPixel = texture2D(u_image, v_texcoord);\\nfloat redVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_gamma[0], u_gammaCorrection[0]);\\n#ifdef MULTI_BAND\\nfloat greenVal = stretchOneValue(currentPixel.g, u_minCutOff[1], u_maxCutOff[1], u_minOutput, u_maxOutput, u_factor[1], u_gamma[1], u_gammaCorrection[1]);\\nfloat blueVal = stretchOneValue(currentPixel.b, u_minCutOff[2], u_maxCutOff[2], u_minOutput, u_maxOutput, u_factor[2], u_gamma[2], u_gammaCorrection[2]);\\ngl_FragColor = vec4(redVal, greenVal, blueVal, currentPixel.a);\\n#else\\ngl_FragColor = vec4(redVal, redVal, redVal, currentPixel.a);\\n#endif\\n}\"\n      },\n      vs: {\n        \"vs.vert\": \"precision mediump float;\\nattribute vec2 a_pos;\\nuniform highp mat3 u_dvsMat3;\\nuniform highp vec2 u_coordScale;\\nvarying highp vec2 v_texcoord;\\nvoid main()\\n{\\nv_texcoord = a_pos;\\ngl_Position = vec4(u_dvsMat3 * vec3(a_pos * u_coordScale, 1.0), 1.0);\\n}\"\n      }\n    },\n    scalar: {\n      \"scalar.frag\": \"precision mediump float;\\nuniform lowp float u_opacity;\\nvarying vec2 v_pos;\\nconst vec4 outlineColor = vec4(0.2, 0.2, 0.2, 1.0);\\nconst float outlineSize = 0.02;\\nconst float innerRadius = 0.25;\\nconst float outerRadius = 0.42;\\nconst float innerSquareLength = 0.15;\\nvoid main() {\\nmediump float dist = length(v_pos);\\nmediump float fillalpha1 = smoothstep(outerRadius, outerRadius + outlineSize, dist);\\nfillalpha1 *= (1.0-smoothstep(outerRadius + outlineSize, outerRadius + 0.1 + outlineSize, dist));\\n#ifdef INNER_CIRCLE\\nmediump float fillalpha2 = smoothstep(innerRadius, innerRadius + outlineSize, dist);\\nfillalpha2 *= (1.0-smoothstep(innerRadius + outlineSize, innerRadius + 0.1 + outlineSize, dist));\\n#else\\nmediump float fillalpha2 = (abs(v_pos.x) < innerSquareLength ? 1.0 : 0.0) * (abs(v_pos.y) < innerSquareLength ? 1.0 : 0.0);\\n#endif\\ngl_FragColor = (fillalpha2 + fillalpha1) * outlineColor * u_opacity;\\n}\",\n      \"scalar.vert\": \"precision mediump float;\\nattribute vec2 a_pos;\\nattribute vec2 a_offset;\\nattribute vec2 a_vv;\\nuniform highp mat3 u_dvsMat3;\\nuniform highp vec2 u_coordScale;\\nuniform vec2 u_symbolSize;\\nuniform vec2 u_symbolPercentRange;\\nuniform vec2 u_dataRange;\\nvarying vec2 v_pos;\\nvoid main()\\n{\\n#ifdef DATA_RANGE\\nfloat valuePercentage = clamp((a_vv.y - u_dataRange.x) / (u_dataRange.y - u_dataRange.x), 0.0, 1.0);\\nfloat sizeRatio = u_symbolPercentRange.x + valuePercentage * (u_symbolPercentRange.y - u_symbolPercentRange.x);\\nfloat sizePercentage = clamp(sizeRatio, u_symbolPercentRange.x, u_symbolPercentRange.y);\\n#else\\nfloat sizePercentage = (u_symbolPercentRange.x + u_symbolPercentRange.y) / 2.0;\\n#endif\\nvec2 size = u_symbolSize * sizePercentage;\\nvec2 pos = a_pos + a_offset * size;\\nv_pos = a_offset;\\ngl_Position = vec4(u_dvsMat3 * vec3(pos * u_coordScale, 1.0), 1.0);\\n}\"\n    },\n    stretch: {\n      \"stretch.frag\": \"precision mediump float;\\nvarying highp vec2 v_texcoord;\\n#include <raster/common/common.glsl>\\nuniform float u_minCutOff[3];\\nuniform float u_maxCutOff[3];\\nuniform float u_minOutput;\\nuniform float u_maxOutput;\\nuniform float u_factor[3];\\nuniform bool u_useGamma;\\nuniform float u_gamma[3];\\nuniform float u_gammaCorrection[3];\\n#include <raster/lut/colorize.glsl>\\nfloat stretchOneValue(float val, float minCutOff, float maxCutOff, float minOutput, float maxOutput, float factor, bool useGamma, float gamma, float gammaCorrection) {\\nif (val >= maxCutOff) {\\nreturn maxOutput;\\n} else if (val <= minCutOff) {\\nreturn minOutput;\\n}\\nfloat stretchedVal;\\nif (useGamma) {\\nfloat tempf = 1.0;\\nfloat outRange = maxOutput - minOutput;\\nfloat relativeVal = (val - minCutOff) / (maxCutOff - minCutOff);\\nif (gamma > 1.0) {\\ntempf -= pow(1.0 / outRange, relativeVal * gammaCorrection);\\n}\\nstretchedVal = (tempf * outRange * pow(relativeVal, 1.0 / gamma) + minOutput) / 255.0;\\n} else {\\nstretchedVal = minOutput + (val - minCutOff) * factor;\\n}\\nreturn stretchedVal;\\n}\\nvoid main() {\\nvec2 pixelLocation = getPixelLocation(v_texcoord);\\nif (isOutside(pixelLocation)) {\\ngl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\\nreturn;\\n}\\nvec4 currentPixel = getPixel(pixelLocation);\\n#ifdef NOOP\\ngl_FragColor = vec4(currentPixel.rgb, 1.0) * currentPixel.a * u_opacity;\\nreturn;\\n#endif\\nif (u_bandCount == 1) {\\nfloat grayVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\\n#ifdef APPLY_COLORMAP\\nvec4 result = colorize(vec4(grayVal, grayVal, grayVal, 1.0), u_useGamma ? 255.0 : 1.0);\\ngl_FragColor = vec4(result.xyz, 1.0) * result.a * currentPixel.a * u_opacity;\\n#else\\ngl_FragColor = vec4(grayVal, grayVal, grayVal, 1.0) * currentPixel.a * u_opacity;\\n#endif\\n} else {\\nfloat redVal = stretchOneValue(currentPixel.r, u_minCutOff[0], u_maxCutOff[0], u_minOutput, u_maxOutput, u_factor[0], u_useGamma, u_gamma[0], u_gammaCorrection[0]);\\nfloat greenVal = stretchOneValue(currentPixel.g, u_minCutOff[1], u_maxCutOff[1], u_minOutput, u_maxOutput, u_factor[1], u_useGamma, u_gamma[1], u_gammaCorrection[1]);\\nfloat blueVal = stretchOneValue(currentPixel.b, u_minCutOff[2], u_maxCutOff[2], u_minOutput, u_maxOutput, u_factor[2], u_useGamma, u_gamma[2], u_gammaCorrection[2]);\\ngl_FragColor = vec4(redVal, greenVal, blueVal, 1.0) * currentPixel.a * u_opacity;\\n}\\n}\"\n    }\n  },\n  stencil: {\n    \"stencil.frag\": \"void main() {\\ngl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\\n}\",\n    \"stencil.vert\": \"attribute vec2 a_pos;\\nuniform mat3 u_worldExtent;\\nvoid main() {\\ngl_Position = vec4(u_worldExtent * vec3(a_pos, 1.0), 1.0);\\n}\"\n  },\n  test: {\n    \"TestShader.common.glsl\": \"#ifndef RETURN_RED\\nvarying    vec4      v_color;\\n#endif\\nvarying    vec2      v_offset;\",\n    \"TestShader.frag\": \"precision highp float;\\n#include <test/TestShader.common.glsl>\\nvoid main() {\\nif (v_offset.x > -.5 && v_offset.y > -.5 && v_offset.x < .5 && v_offset.y < .5) {\\ndiscard;\\n}\\n#ifdef RETURN_RED\\ngl_FragColor = vec4(1., 0., 0., 1.);\\n#else\\ngl_FragColor = v_color;\\n#endif\\n}\",\n    \"TestShader.vert\": \"const float POS_PRECISION_FACTOR = 10.;\\nconst float OFFSET_PRECISION_FACTOR = 10.;\\nconst float SIZE_PRECISION_FACTOR = 10.;\\nattribute  vec2      a_pos_packed;\\nattribute  vec2      a_offset_packed;\\nattribute  float     a_size_packed;\\n#ifdef DATA_DRIVEN_COLOR\\nconst float u_dataDrivenColor_validValues[4] = float[4](0., 0., 1., 0.);\\nuniform    vec4      u_dataDrivenColor_colorFallback;\\nuniform    vec4      u_dataDrivenColor_color;\\n#endif\\nuniform    float     u_view_zoomLevel;\\n#include <test/TestShader.common.glsl>\\n#ifdef DATA_DRIVEN_COLOR\\nvec4 getColor(float value) {\\nint index = -1;\\nfor (int i = 0; i < 4; i++) {\\nif (u_dataDrivenColor_validValues[i] == value) {\\nindex = i;\\nbreak;\\n}\\n}\\nif (index == -1) {\\nreturn u_dataDrivenColor_colorFallback;\\n}\\nreturn u_dataDrivenColor_color;\\n}\\n#endif\\nvoid main() {\\nvec2  a_pos = a_pos_packed / POS_PRECISION_FACTOR;\\nvec2  a_offset = a_offset_packed / OFFSET_PRECISION_FACTOR;\\nfloat a_size = a_size_packed / SIZE_PRECISION_FACTOR;\\nvec4 color = vec4(1., 0., 0., 1.);\\n#ifdef DATA_DRIVEN_COLOR\\ncolor = getColor(1.);\\n#endif\\nvec2 offsetScaled = a_offset * a_size;\\nvec4 pos = vec4(a_pos.xy + offsetScaled, 0., 1.);\\ngl_Position = pos;\\n#ifndef RETURN_RED\\nv_color = color;\\n#endif\\nv_offset = a_offset;\\n}\"\n  },\n  tileInfo: {\n    \"tileInfo.frag\": \"uniform mediump sampler2D u_texture;\\nvarying mediump vec2 v_tex;\\nvoid main(void) {\\nlowp vec4 color = texture2D(u_texture, v_tex);\\ncolor.rgb *= color.a;\\ngl_FragColor = color;\\n}\",\n    \"tileInfo.vert\": \"attribute vec2 a_pos;\\nuniform highp mat3 u_dvsMat3;\\nuniform mediump float u_depth;\\nuniform mediump vec2 u_coord_ratio;\\nuniform mediump vec2 u_delta;\\nuniform mediump vec2 u_dimensions;\\nvarying mediump vec2 v_tex;\\nvoid main() {\\nmediump vec2 offset = u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\\nvec3 v_pos = u_dvsMat3 * vec3(offset, 1.0);\\ngl_Position = vec4(v_pos.xy, 0.0, 1.0);\\nv_tex = a_pos;\\n}\"\n  },\n  util: {\n    \"atan2.glsl\": \"float atan2(in float y, in float x) {\\nfloat t0, t1, t2, t3, t4;\\nt3 = abs(x);\\nt1 = abs(y);\\nt0 = max(t3, t1);\\nt1 = min(t3, t1);\\nt3 = 1.0 / t0;\\nt3 = t1 * t3;\\nt4 = t3 * t3;\\nt0 =         - 0.013480470;\\nt0 = t0 * t4 + 0.057477314;\\nt0 = t0 * t4 - 0.121239071;\\nt0 = t0 * t4 + 0.195635925;\\nt0 = t0 * t4 - 0.332994597;\\nt0 = t0 * t4 + 0.999995630;\\nt3 = t0 * t3;\\nt3 = (abs(y) > abs(x)) ? 1.570796327 - t3 : t3;\\nt3 = x < 0.0 ?  3.141592654 - t3 : t3;\\nt3 = y < 0.0 ? -t3 : t3;\\nreturn t3;\\n}\",\n    \"encoding.glsl\": \"const vec4 rgba2float_factors = vec4(\\n255.0 / (256.0),\\n255.0 / (256.0 * 256.0),\\n255.0 / (256.0 * 256.0 * 256.0),\\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\\n);\\nfloat rgba2float(vec4 rgba) {\\nreturn dot(rgba, rgba2float_factors);\\n}\"\n  }\n};\nexport { e as default };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport r from \"./shaderRepository.js\";\nimport { ShaderCompiler as e } from \"../../../../../webgl/ShaderCompiler.js\";\nfunction o(r) {\n  return function (e) {\n    let o = r;\n    return e.split(\"/\").forEach(r => {\n      o && (o = o[r]);\n    }), o;\n  };\n}\nconst t = new e(o(r));\nfunction n(r) {\n  return t.resolveIncludes(r);\n}\nexport { n as resolveIncludes };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { resolveIncludes as r } from \"./sources/resolver.js\";\nconst e = {\n  shaders: {\n    vertexShader: r(\"background/background.vert\"),\n    fragmentShader: r(\"background/background.frag\")\n  },\n  attributes: new Map([[\"a_pos\", 0]])\n};\nexport { e as background };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { set as t, multiply as s } from \"../../../../core/libs/gl-matrix-2/math/mat2d.js\";\nimport { create as i } from \"../../../../core/libs/gl-matrix-2/factories/mat2df32.js\";\nimport { set as r, multiply as e, invert as o } from \"../../../../core/libs/gl-matrix-2/math/mat3.js\";\nimport { create as a } from \"../../../../core/libs/gl-matrix-2/factories/mat3f32.js\";\nimport { s as n, t as m } from \"../../../../chunks/vec32.js\";\nimport { create as l } from \"../../../../core/libs/gl-matrix-2/factories/vec3f32.js\";\nimport { tileSize as c } from \"./definitions.js\";\nimport { TiledDisplayObject as h } from \"./TiledDisplayObject.js\";\nconst f = a(),\n  d = l();\nclass p extends h {\n  constructor(t, s, i, r) {\n    super(t, s, i, r, c, c);\n  }\n  destroy() {\n    super.destroy();\n  }\n  setTransform(o) {\n    const a = this.resolution / o.resolution,\n      n = this.transforms.tileMat3,\n      [m, l] = o.toScreenNoRotation([0, 0], [this.x, this.y]),\n      c = this.width / this.rangeX * a,\n      h = this.height / this.rangeY * a;\n    r(n, c, 0, 0, 0, h, 0, m, l, 1), e(this.transforms.displayViewScreenMat3, o.displayViewMat3, n);\n    const f = this.transforms.labelMat2d,\n      d = window.devicePixelRatio,\n      p = t(i(), c * d, 0, 0, h * d, m * d, l * d);\n    s(f, o.viewMat2d, p);\n  }\n  _createTransforms() {\n    return {\n      labelMat2d: i(),\n      tileMat3: a(),\n      displayViewScreenMat3: a()\n    };\n  }\n  containsScreenPoint(t, s, i) {\n    const r = e(f, t.viewMat3, this.transforms.tileMat3),\n      a = o(f, r);\n    if (null == a) return !0;\n    n(d, ...s, 1);\n    const l = m(d, d, a),\n      c = i * (this.resolution / t.resolution);\n    return l[0] >= -c && l[0] < this.width + c && l[1] >= -c && l[1] < this.height + c;\n  }\n}\nexport { p as AFeatureTile };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nclass t {\n  constructor(a) {\n    if (this.next = null, !Array.isArray(a)) return void (this.data = a);\n    this.data = a[0];\n    let e = this;\n    for (let n = 1; n < a.length; n++) e.next = new t([a[n]]), e = e.next;\n  }\n  *values() {\n    let t = this;\n    for (; t;) yield t.data, t = t.next;\n  }\n  forEach(t) {\n    let a = this;\n    for (; a;) t(a.data), a = a.next;\n  }\n  get last() {\n    return this.next ? this.next.last : this;\n  }\n}\nclass a {\n  constructor(a) {\n    this._head = null, null != a && (this._head = new t(a));\n  }\n  get head() {\n    return this._head;\n  }\n  maxAvailableSpace() {\n    if (null == this._head) return 0;\n    let t = 0;\n    return this._head.forEach(a => {\n      const e = a.end - a.start;\n      t = Math.max(t, e);\n    }), t;\n  }\n  firstFit(t) {\n    if (null == this._head) return null;\n    let a = null,\n      e = this._head;\n    for (; e;) {\n      const n = e.data.end - e.data.start;\n      if (n === t) return a ? a.next = e.next : this._head = e.next, e.data.start;\n      if (n > t) {\n        const a = e.data.start;\n        return e.data.start += t, a;\n      }\n      a = e, e = e.next;\n    }\n    return null;\n  }\n  free(a, e) {\n    const n = a + e;\n    if (null == this._head) {\n      const e = new t({\n        start: a,\n        end: n\n      });\n      return void (this._head = e);\n    }\n    if (n <= this._head.data.start) {\n      if (n === this._head.data.start) return void (this._head.data.start -= e);\n      const r = new t({\n        start: a,\n        end: n\n      });\n      return r.next = this._head, void (this._head = r);\n    }\n    let r = this._head,\n      d = r.next;\n    for (; d;) {\n      if (d.data.start >= n) {\n        if (r.data.end === a) {\n          if (r.data.end += e, r.data.end === d.data.start) {\n            const t = d.data.end - d.data.start;\n            return r.data.end += t, void (r.next = d.next);\n          }\n          return;\n        }\n        if (d.data.start === n) return void (d.data.start -= e);\n        const s = new t({\n          start: a,\n          end: n\n        });\n        return s.next = r.next, void (r.next = s);\n      }\n      r = d, d = d.next;\n    }\n    if (a === r.data.end) return void (r.data.end += e);\n    const s = new t({\n      start: a,\n      end: n\n    });\n    r.next = s;\n  }\n  clear() {\n    this._head = null;\n  }\n}\nexport { a as FreeList, t as List };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport has from \"../../../../core/has.js\";\nimport { assertIsSome as t } from \"../../../../core/maybe.js\";\nimport { FreeList as e } from \"./cpuMapped/FreeList.js\";\nconst r = has(\"esri-2d-log-allocations\");\nclass s {\n  static create(t, e) {\n    const r = e.acquireUint32Array(t);\n    return new s(r, e);\n  }\n  constructor(t, e) {\n    this._array = t, this._pool = e;\n  }\n  get array() {\n    return this._array;\n  }\n  get length() {\n    return this._array.length;\n  }\n  getUint32View(t, e) {\n    return new Uint32Array(this._array.buffer, t + this._array.byteOffset, e);\n  }\n  expand(t) {\n    if (t <= this._array.byteLength) return;\n    const e = this._pool.acquireUint32Array(t);\n    e.set(this._array), this._pool.releaseUint32Array(this._array), this._array = e;\n  }\n  destroy() {\n    this._pool.releaseUint32Array(this._array);\n  }\n}\nclass a {\n  constructor() {\n    this._data = new ArrayBuffer(a.BYTE_LENGTH), this._freeList = new e({\n      start: 0,\n      end: this._data.byteLength\n    });\n  }\n  static get BYTE_LENGTH() {\n    return 16e6;\n  }\n  get buffer() {\n    return this._data;\n  }\n  acquireUint32Array(t) {\n    const e = this._freeList.firstFit(t);\n    return null == e ? null : new Uint32Array(this._data, e, t / Uint32Array.BYTES_PER_ELEMENT);\n  }\n  releaseUint32Array(t) {\n    this._freeList.free(t.byteOffset, t.byteLength);\n  }\n}\nclass i {\n  constructor() {\n    this._pages = [], this._pagesByBuffer = new Map(), this._bytesAllocated = 0;\n  }\n  destroy() {\n    this._pages = [], this._pagesByBuffer = null;\n  }\n  get _bytesTotal() {\n    return this._pages.length * a.BYTE_LENGTH;\n  }\n  acquireUint32Array(e) {\n    if (this._bytesAllocated += e, r && console.log(`Allocating ${e}, (${this._bytesAllocated} / ${this._bytesTotal})`), e >= a.BYTE_LENGTH) return new Uint32Array(e / Uint32Array.BYTES_PER_ELEMENT);\n    for (const t of this._pages) {\n      const r = t.acquireUint32Array(e);\n      if (null != r) return r;\n    }\n    const s = this._addPage().acquireUint32Array(e);\n    return t(s, \"Expected to allocate page\"), s;\n  }\n  releaseUint32Array(t) {\n    this._bytesAllocated -= t.byteLength, r && console.log(`Freeing ${t.byteLength}, (${this._bytesAllocated} / ${this._bytesTotal})`);\n    const e = this._pagesByBuffer.get(t.buffer);\n    e && e.releaseUint32Array(t);\n  }\n  _addPage() {\n    const t = new a();\n    return this._pages.push(t), this._pagesByBuffer.set(t.buffer, t), t;\n  }\n}\nexport { i as ArrayBufferPool, s as PooledUint32Array };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { resolveIncludes as e } from \"./sources/resolver.js\";\nconst r = {\n  shaders: {\n    vertexShader: e(\"tileInfo/tileInfo.vert\"),\n    fragmentShader: e(\"tileInfo/tileInfo.frag\")\n  },\n  attributes: new Map([[\"a_pos\", 0]])\n};\nexport { r as tileInfo };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport \"../../../../core/has.js\";\nimport { FeatureBatchingStrategy as t, FeatureSymbologyDrawOrder as e } from \"./enums.js\";\nimport { List as n } from \"./cpuMapped/FreeList.js\";\nimport { isHittest as i } from \"./shaderGraph/techniques/featureTechniqueUtils.js\";\nimport { PrimitiveType as a, DataType as s } from \"../../../webgl/enums.js\";\nfunction r(t, e) {\n  return t << 16 | 255 & e;\n}\nfunction d(t) {\n  return 255 & t;\n}\nclass h {\n  constructor(t, e, n, i, a) {\n    this.instance = t, this.materialKey = e, this.target = n, this.start = i, this.count = a;\n  }\n  get textureKey() {\n    return d(this.materialKey);\n  }\n  get indexEnd() {\n    return this.start + this.count;\n  }\n  extend(t) {\n    this.count += t;\n  }\n  render(t) {\n    this.instance.techniqueRef.render(t, this);\n  }\n  getStencilReference() {\n    return this.target.stencilRef;\n  }\n  getAttributePrecisionPackFactors() {\n    const t = this.instance.instanceId;\n    return this.target.getMesh(t).getAttributePrecisionPackFactors();\n  }\n  draw(t, e) {\n    i(t) ? this.drawCompute(t.context, e) : this.drawGeometry(t.context, e);\n  }\n  drawCompute(t, e) {\n    const n = this.instance.instanceId,\n      i = this.target.getMesh(n).getComputeVAO(t, e),\n      r = this.start * Uint32Array.BYTES_PER_ELEMENT / 3;\n    t.bindVAO(i), t.drawElements(a.POINTS, this.count / 3, s.UNSIGNED_INT, r), t.bindVAO(null);\n  }\n  drawGeometry(t, e) {\n    const n = this.instance.instanceId,\n      i = this.target.getMesh(n).getGeometryVAO(t, e),\n      r = this.start * Uint32Array.BYTES_PER_ELEMENT;\n    t.bindVAO(i), t.drawElements(a.TRIANGLES, this.count, s.UNSIGNED_INT, r), t.bindVAO(null);\n  }\n}\nclass l {\n  constructor() {\n    this._length = 0, this._minOrderedLength = 0, this._materialKeys = new Set();\n  }\n  static fromDisplayEntities(t, e, n, i) {\n    const a = new l();\n    for (const s of t.values()) for (const t of s.records) {\n      const s = n.getInstance(t.instanceId),\n        d = r(s.instanceId, t.textureKey);\n      a.addRecord(s, d, t.indexStart, t.indexCount, t.vertexStart, t.vertexCount, e, i);\n    }\n    return a;\n  }\n  get length() {\n    return this._length;\n  }\n  get minOrderedLength() {\n    return this._minOrderedLength;\n  }\n  get minUnorderedLength() {\n    return this._materialKeys.size;\n  }\n  render(t) {\n    const {\n      drawPhase: e\n    } = t;\n    for (const n of this.infos()) n.instance.techniqueRef.drawPhase & e && n.render(t);\n  }\n  addRecord(i, a, s, r, d, l, o, c) {\n    let u = s,\n      _ = r;\n    if (_ || (u = d, _ = l), !_) return;\n    if (null == this._head) {\n      const t = new h(i, a, o, u, _);\n      return this._head = new n(t), this._tail = this._head, this._length++, void this._minOrderedLength++;\n    }\n    if (c === t.STRICT_ORDER) return this._insert(i, a, o, u, _, this._tail, null);\n    let g = null,\n      m = this._head;\n    const f = i.instanceId,\n      E = i.techniqueRef.symbologyPlane;\n    if (c === t.STRICT_MARKERS_AND_TEXT && (E === e.MARKER || E === e.TEXT)) return this._insert(i, a, o, u, _, this._tail, null);\n    for (; m;) {\n      const t = m.data.instance,\n        e = t.instanceId,\n        n = t.techniqueRef.symbologyPlane,\n        s = g?.data.instance.instanceId;\n      if (E < n || f === s && f !== e) return this._insert(i, a, o, u, _, g, m);\n      g = m, m = m.next;\n    }\n    this._insert(i, a, o, u, _, g, null);\n  }\n  *infos() {\n    if (null != this._head) for (const t of this._head.values()) yield t;\n  }\n  _insert(t, e, i, a, s, r, d) {\n    if (null == r && null == d) {\n      const r = new h(t, e, i, a, s);\n      return this._head = new n(r), this._tail = this._head, this._length++, void this._minOrderedLength++;\n    }\n    return e !== this._tail.data.materialKey && this._minOrderedLength++, this._materialKeys.add(e), null == r && null != d ? this._insertAtHead(t, e, i, a, s, d) : null != r && null == d ? this._insertAtEnd(t, e, i, a, s, r) : null != r && null != d ? this._insertAtMiddle(t, e, i, a, s, r, d) : void 0;\n  }\n  _insertAtHead(t, e, i, a, s, r) {\n    const d = a + s;\n    if (e === r.data.materialKey && i === r.data.target && d === r.data.start) r.data.start = a, r.data.count += s;else {\n      const d = new h(t, e, i, a, s);\n      this._head = new n(d), this._head.next = r, this._length++;\n    }\n  }\n  _insertAtEnd(t, e, i, a, s, r) {\n    if (r.data.materialKey === e && r.data.indexEnd === a) r.data.count += s;else {\n      const d = new h(t, e, i, a, s);\n      this._tail = new n(d), r.next = this._tail, this._length++;\n    }\n  }\n  _insertAtMiddle(t, e, i, a, s, r, d) {\n    const l = a + s;\n    if (r.data.materialKey === e && r.data.target === i && r.data.indexEnd === a) r.data.count += s, r.data.materialKey === d.data.materialKey && r.data.target === d.data.target && r.data.indexEnd === d.data.start && (r.data.count += d.data.count, r.next = d.next, this._length--);else if (e === d.data.materialKey && i === d.data.target && l === d.data.start) d.data.start = a, d.data.count += s;else {\n      const l = new h(t, e, i, a, s),\n        o = new n(l);\n      r.next = o, o.next = d, this._length++;\n    }\n  }\n}\nexport { l as DisplayList, h as DisplayListInfo };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nclass t {\n  constructor(t) {\n    this._indexOnly = t, this.vertex = {\n      count: 0,\n      operations: []\n    }, this.index = {\n      count: 0,\n      operations: []\n    };\n  }\n  copyRecord(t) {\n    let e = 0;\n    this._indexOnly || (e = this.vertex.count - t.vertexStart, this.vertex.operations.push({\n      srcFrom: t.vertexStart,\n      dstFrom: this.vertex.count,\n      count: t.vertexCount,\n      mutate: 0\n    }), t.vertexStart = this.vertex.count, this.vertex.count += t.vertexCount);\n    let n = !1;\n    if (this._indexOnly && this.index.operations.length >= 1) {\n      const e = this.index.operations[this.index.operations.length - 1];\n      e.srcFrom + e.count === t.indexStart && (e.count += t.indexCount, n = !0);\n    }\n    n || this.index.operations.push({\n      srcFrom: t.indexStart,\n      dstFrom: this.index.count,\n      count: t.indexCount,\n      mutate: e\n    }), t.indexStart = this.index.count, this.index.count += t.indexCount;\n  }\n}\nexport { t as ReshufflePlan };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport \"../../../../../core/has.js\";\nimport { assertIsSome as t } from \"../../../../../core/maybe.js\";\nimport { PooledUint32Array as i } from \"../PooledUint32Array.js\";\nimport { FreeList as e } from \"./FreeList.js\";\nimport { BufferObject as r } from \"../../../../webgl/BufferObject.js\";\nimport { Usage as s } from \"../../../../webgl/enums.js\";\nconst n = 1.25,\n  h = 32767,\n  a = h << 16 | h;\nclass d {\n  constructor(t, e, r, s) {\n    this._pool = s;\n    const n = i.create(e * r * Uint32Array.BYTES_PER_ELEMENT, this._pool);\n    this.size = e, this.strideInt = r, this.bufferType = t, this.dirty = {\n      start: 1 / 0,\n      end: 0\n    }, this.memoryStats = {\n      bytesUsed: 0,\n      bytesReserved: e * r * Uint32Array.BYTES_PER_ELEMENT\n    }, this._gpu = null, this._cpu = n, this.clear();\n  }\n  get elementSize() {\n    return this._cpu.length / this.strideInt;\n  }\n  get intSize() {\n    return this.fillPointer * this.strideInt;\n  }\n  get byteSize() {\n    return this.intSize * Uint32Array.BYTES_PER_ELEMENT;\n  }\n  get invalidated() {\n    return this.bufferSize > 0 && !this._gpu;\n  }\n  get invalidatedComputeBuffer() {\n    return this.bufferSize > 0 && !this._gpuComputeTriangles;\n  }\n  invalidate() {\n    this._invalidateTriangleBuffer(), this._gpu?.dispose(), this._gpu = null;\n  }\n  _invalidateTriangleBuffer() {\n    this._gpuComputeTriangles?.dispose(), this._gpuComputeTriangles = null;\n  }\n  destroy() {\n    this._gpu?.dispose(), this._gpuComputeTriangles?.dispose(), this._cpu?.destroy();\n  }\n  clear() {\n    this.dirty.start = 1 / 0, this.dirty.end = 0, this.freeList = new e({\n      start: 0,\n      end: this._cpu.length / this.strideInt\n    }), this.fillPointer = 0;\n  }\n  ensure(t) {\n    if (this.maxAvailableSpace() >= t) return;\n    if (t * this.strideInt > this._cpu.length - this.fillPointer) {\n      this.invalidate();\n      const i = this._cpu.length / this.strideInt,\n        e = Math.round((i + t) * n),\n        r = e * this.strideInt;\n      this._cpu.expand(r * Uint32Array.BYTES_PER_ELEMENT), this.freeList.free(i, e - i), this.memoryStats.bytesReserved += (e - i) * this.strideInt * Uint32Array.BYTES_PER_ELEMENT;\n    }\n  }\n  set(t, i) {\n    this._cpu.array[t] !== i && (this._cpu.array[t] = i, this.dirty.start = Math.min(t, this.dirty.start), this.dirty.end = Math.max(t + 1, this.dirty.end));\n  }\n  getGPUBuffer(t, i = !1) {\n    if (!this.bufferSize) return null;\n    if (i) {\n      if (\"index\" !== this.bufferType) throw new Error(\"Tired to get triangle buffer, but target is not an index buffer\");\n      return null == this._gpuComputeTriangles && (this._gpuComputeTriangles = this._createComputeBuffer(t)), this._gpuComputeTriangles;\n    }\n    return null == this._gpu && (this._gpu = this._createBuffer(t)), this._gpu;\n  }\n  getView(t, i) {\n    return this._cpu.getUint32View(t, i / Uint32Array.BYTES_PER_ELEMENT);\n  }\n  get bufferSize() {\n    return this._cpu.length / this.strideInt;\n  }\n  maxAvailableSpace() {\n    return this.freeList.maxAvailableSpace();\n  }\n  insert(i, e, r, s) {\n    const n = r * this.strideInt;\n    if (!n) return 0;\n    const h = e * this.strideInt * Uint32Array.BYTES_PER_ELEMENT,\n      a = new Uint32Array(i, h, n),\n      d = this.freeList.firstFit(r);\n    t(d, \"First fit region must be defined\");\n    const u = d * this.strideInt,\n      o = n;\n    if (this._cpu.array.set(a, u), 0 !== s) for (let t = 0; t < a.length; t++) this._cpu.array[t + u] += s;\n    return this.dirty.start = Math.min(this.dirty.start, u), this.dirty.end = Math.max(this.dirty.end, u + o), this.fillPointer = Math.max(this.fillPointer, u + o), this.memoryStats.bytesUsed += r * this.strideInt * Uint32Array.BYTES_PER_ELEMENT, d;\n  }\n  copyFrom(i, e, r, s, n) {\n    const h = r * this.strideInt;\n    if (!h) return 0;\n    const a = e * this.strideInt * Uint32Array.BYTES_PER_ELEMENT,\n      d = i._cpu.getUint32View(a, h),\n      u = this.freeList.firstFit(r);\n    t(u, \"First fit region must be defined\");\n    const o = u * this.strideInt,\n      f = h;\n    if (this._cpu.array.set(d, o), 0 !== s) for (let t = 0; t < h; t++) this._cpu.array[o + t * this.strideInt + n] += s;\n    return this.dirty.start = Math.min(this.dirty.start, o), this.dirty.end = Math.max(this.dirty.end, o + f), this.fillPointer = Math.max(this.fillPointer, o + f), this.memoryStats.bytesUsed += r * this.strideInt * Uint32Array.BYTES_PER_ELEMENT, u;\n  }\n  free(t, i, e) {\n    const r = t * this.strideInt,\n      s = (t + i) * this.strideInt;\n    if (!0 === e) for (let n = t; n !== t + i; n++) this._cpu.array[n * this.strideInt] = a;\n    this.dirty.start = Math.min(this.dirty.start, r), this.dirty.end = Math.max(this.dirty.end, s), this.freeList.free(t, i), this.memoryStats.bytesUsed -= i * this.strideInt * Uint32Array.BYTES_PER_ELEMENT;\n  }\n  upload() {\n    if (this.dirty.end) {\n      if (this._invalidateTriangleBuffer(), null == this._gpu) return this.dirty.start = 1 / 0, void (this.dirty.end = 0);\n      this._gpu.setSubData(this._cpu.array, this.dirty.start, this.dirty.start, this.dirty.end), this.dirty.start = 1 / 0, this.dirty.end = 0;\n    }\n  }\n  reshuffle(t, e) {\n    if (0 === e.length) return;\n    const r = this.byteSize,\n      s = t * this.strideInt * Uint32Array.BYTES_PER_ELEMENT,\n      n = r > s,\n      h = this._cpu,\n      a = i.create(s, this._pool);\n    n || a.array.set(this._cpu.getUint32View(0, this.intSize));\n    for (const i of e) if (n || i.srcFrom !== i.dstFrom || 0 !== i.mutate) {\n      this.dirty.start = Math.min(this.dirty.start, i.dstFrom * this.strideInt), this.dirty.end = Math.max(this.dirty.end, (i.dstFrom + i.count) * this.strideInt);\n      for (let t = 0; t < i.count; t++) {\n        const e = (i.dstFrom + t) * this.strideInt,\n          r = (i.srcFrom + t) * this.strideInt;\n        for (let t = 0; t < this.strideInt; t++) a.array[e + t] = h.array[r + t] + i.mutate;\n      }\n    }\n    this._cpu.destroy(), this._cpu = a, n && this.invalidate(), this.freeList.clear(), this.memoryStats.bytesUsed = this.memoryStats.bytesReserved = s;\n  }\n  _createBuffer(t) {\n    const i = s.DYNAMIC_DRAW;\n    return \"index\" === this.bufferType ? r.createIndex(t, i, this._cpu.array) : r.createVertex(t, i, this._cpu.array);\n  }\n  _createComputeBuffer(t) {\n    const i = s.DYNAMIC_DRAW,\n      e = new Uint32Array(this.fillPointer / 3);\n    for (let r = 0; r < this.fillPointer; r += 3) e[r / 3] = this._cpu.array[r];\n    return r.createIndex(t, i, e);\n  }\n}\nexport { d as MappedBuffer };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { destroyMaybe as e } from \"../../../../../core/maybe.js\";\nimport { i1616to32 as t } from \"../number.js\";\nimport { MappedBuffer as r } from \"./Buffer.js\";\nimport { unpackDataView as i } from \"../shaderGraph/techniques/mesh/dataViewUtils.js\";\nimport { PrimitiveType as s } from \"../../../../webgl/enums.js\";\nimport { VertexArrayObject as f } from \"../../../../webgl/VertexArrayObject.js\";\nconst o = 1e3;\nfunction n(e, t) {\n  const r = [],\n    i = e.attributes.filter(e => t.locations.has(e.name));\n  for (const s of i) r.push({\n    name: s.name,\n    type: s.type,\n    count: s.count,\n    divisor: 0,\n    normalized: s.normalized ?? !1,\n    offset: s.offset,\n    stride: e.stride\n  });\n  return {\n    geometry: r\n  };\n}\nfunction u(e, t) {\n  const r = [],\n    i = e.attributes.filter(e => t.locations.has(e.name));\n  for (const s of i) {\n    r.push({\n      name: s.name,\n      type: s.type,\n      count: s.count,\n      divisor: 0,\n      normalized: s.normalized ?? !1,\n      offset: s.offset,\n      stride: e.stride\n    });\n    const i = t.computeAttributeMap[s.name];\n    null != i && 2 === i.length && (r.push({\n      name: i[0],\n      count: s.count,\n      divisor: 0,\n      type: s.type,\n      normalized: s.normalized ?? !1,\n      offset: s.offset + e.stride,\n      stride: e.stride\n    }), r.push({\n      name: i[1],\n      count: s.count,\n      divisor: 0,\n      type: s.type,\n      normalized: s.normalized ?? !1,\n      offset: s.offset + 2 * e.stride,\n      stride: e.stride\n    }));\n  }\n  return {\n    geometry: r\n  };\n}\nclass a {\n  constructor(e, t) {\n    if (this._bufferPool = e, this._layout = t, this._invalidated = !1, this._position = this._layout.attributes.find(e => \"pos\" === e.name || \"position\" === e.name), !this._position) throw new Error(\"InternalError: Unable to find position attribute\");\n  }\n  destroy() {\n    this._indexBuffer = e(this._indexBuffer), this._vertexBuffer = e(this._vertexBuffer), this._computeVAO?.disposeVAOOnly(), this._geometryVAO?.disposeVAOOnly();\n  }\n  get layout() {\n    return this._layout;\n  }\n  getDrawArgs(e, t, r, i) {\n    return i ? {\n      primitive: s.POINTS,\n      count: t / 3,\n      offset: r / 3\n    } : {\n      primitive: e,\n      count: t,\n      offset: r\n    };\n  }\n  getAttributePrecisionPackFactors() {\n    const e = {};\n    for (const t of this.layout.attributes) t.packPrecisionFactor && (e[t.name] = t.packPrecisionFactor);\n    return e;\n  }\n  getDebugVertexInfo(e = !1) {\n    if (!this._vertexBuffer) return null;\n    const t = this._layout,\n      r = t.stride,\n      s = this._vertexBuffer.getView(0, this._vertexBuffer.byteSize),\n      f = new DataView(s.slice().buffer);\n    let o = s.byteLength / r;\n    e && (o = this._indexBuffer.fillPointer / 3);\n    const n = this._indexBuffer.getView(0, this._indexBuffer.byteSize);\n    let u = 0;\n    const a = [];\n    for (let h = 0; h < o; h++) {\n      if (e) {\n        u = n[3 * h] * r;\n      }\n      const s = {};\n      for (const e of t.attributes) {\n        let t = `${e.offset} ${e.name}`,\n          r = i(f, e, u);\n        if (e.packPrecisionFactor) if (t += ` (precision: ${e.packPrecisionFactor})`, \"number\" == typeof r) r /= e.packPrecisionFactor;else for (let i = 0; i < r.length; i++) r[i] /= e.packPrecisionFactor;\n        s[t] = r;\n      }\n      u += r, a.push(s);\n    }\n    return {\n      vertices: a,\n      layout: t\n    };\n  }\n  _ensure(e, t) {\n    if (this._vertexBuffer && this._indexBuffer) this._indexBuffer.ensure(Math.max(e, 1e3)), this._vertexBuffer.ensure(Math.max(t, 1e3));else {\n      const i = this._layout.stride / Uint32Array.BYTES_PER_ELEMENT;\n      this._indexBuffer = new r(\"index\", Math.max(e, o), 1, this._bufferPool), this._vertexBuffer = new r(\"vertex\", Math.max(t, o), i, this._bufferPool);\n    }\n  }\n  append(e) {\n    const t = e.layout.stride,\n      r = e.indices.byteLength / Uint32Array.BYTES_PER_ELEMENT,\n      i = e.vertices.byteLength / t;\n    this._ensure(r, i);\n    const {\n        vertices: s,\n        indices: f\n      } = e,\n      o = this._vertexBuffer.insert(s, 0, s.byteLength / t, 0);\n    return {\n      vertexFrom: o,\n      indexFrom: this._indexBuffer.insert(f, 0, f.byteLength / 4, o)\n    };\n  }\n  copyRecordFrom(e, r, i, s) {\n    const {\n      indexStart: f,\n      indexCount: o,\n      vertexStart: n,\n      vertexCount: u\n    } = r;\n    this._ensure(o, u);\n    const a = e._position,\n      h = i * (a.packPrecisionFactor ?? 1),\n      d = s * (a.packPrecisionFactor ?? 1),\n      c = a.offset,\n      _ = t(h, d),\n      l = this._vertexBuffer.copyFrom(e._vertexBuffer, n, u, _, c),\n      m = this._indexBuffer.copyFrom(e._indexBuffer, f, o, l - n, 0),\n      x = r.clone();\n    return x.vertexStart = l, x.indexStart = m, x.overlaps = 0, x;\n  }\n  remove(e, t, r, i) {\n    this._indexBuffer.free(e, t), this._vertexBuffer.free(r, i);\n  }\n  upload() {\n    this._invalidated = !0;\n  }\n  getGeometryVAO(e, t) {\n    if (!this._vertexBuffer || !this._indexBuffer || !this._vertexBuffer.bufferSize) return null;\n    if (this._invalidated) {\n      (this._vertexBuffer.invalidated || this._indexBuffer.invalidated) && (this._vertexBuffer.invalidate(), this._indexBuffer.invalidate(), this._geometryVAO?.disposeVAOOnly(), this._geometryVAO = null), this._vertexBuffer.upload(), this._indexBuffer.upload();\n      const r = this._indexBuffer.getGPUBuffer(e, !1),\n        i = this._vertexBuffer.getGPUBuffer(e);\n      this._geometryVAO || (this._geometryVAO = new f(e, t.locations, n(this.layout, t), {\n        geometry: i\n      }, r)), this._invalidated = !1;\n    }\n    return this._geometryVAO;\n  }\n  getComputeVAO(e, t) {\n    if (!this._vertexBuffer || !this._indexBuffer || !this._vertexBuffer.bufferSize) return null;\n    (this._vertexBuffer.invalidated || this._indexBuffer.invalidatedComputeBuffer) && (this._vertexBuffer.invalidate(), this._indexBuffer.invalidate(), this._computeVAO?.disposeVAOOnly(), this._computeVAO = null), this._vertexBuffer.upload(), this._indexBuffer.upload();\n    const r = this._indexBuffer.getGPUBuffer(e, !0),\n      i = this._vertexBuffer.getGPUBuffer(e);\n    return this._computeVAO || (this._computeVAO = new f(e, t.locations, u(this.layout, t), {\n      geometry: i\n    }, r), this._invalidated = !1), this._computeVAO;\n  }\n  get memoryStats() {\n    return {\n      bytesUsed: this._vertexBuffer.memoryStats.bytesUsed + this._indexBuffer.memoryStats.bytesUsed,\n      bytesReserved: this._vertexBuffer.memoryStats.bytesReserved + this._indexBuffer.memoryStats.bytesReserved,\n      vertex: this._vertexBuffer.memoryStats,\n      index: this._indexBuffer.memoryStats\n    };\n  }\n  reshuffle(e) {\n    this._vertexBuffer && this._vertexBuffer.reshuffle(e.vertex.count, e.vertex.operations), this._indexBuffer && this._indexBuffer.reshuffle(e.index.count, e.index.operations);\n  }\n}\nexport { a as MappedMesh };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nclass t {\n  constructor(t) {\n    this._pos = 0, this._buffer = t, this._i32View = new Int32Array(this._buffer), this._f32View = new Float32Array(this._buffer);\n  }\n  readInt32() {\n    return this._i32View[this._pos++];\n  }\n  readF32() {\n    return this._f32View[this._pos++];\n  }\n}\nexport { t as default };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport t from \"../DisplayEntity.js\";\nimport { unpackDataView as e } from \"../shaderGraph/techniques/mesh/dataViewUtils.js\";\nimport i from \"../util/Reader.js\";\nimport { deserializeList as r } from \"../util/serializationUtils.js\";\nfunction o(e) {\n  if (!e) return null;\n  return {\n    entities: r(new i(e.entities), t),\n    vertexData: e.data.map(a)\n  };\n}\nfunction a(t) {\n  const i = t.layout.stride,\n    r = new DataView(t.vertices),\n    o = [],\n    a = t.vertices.byteLength / i;\n  let s = 0;\n  for (let n = 0; n < a; n++) {\n    const a = {};\n    for (const i of t.layout.attributes) {\n      let t = `${i.offset} ${i.name}`,\n        o = e(r, i, s);\n      if (i.packPrecisionFactor) if (t += ` (precision: ${i.packPrecisionFactor})`, \"number\" == typeof o) o /= i.packPrecisionFactor;else for (let e = 0; e < o.length; e++) o[e] /= i.packPrecisionFactor;\n      a[t] = o;\n    }\n    s += i, o.push(a);\n  }\n  return {\n    vertices: o,\n    layout: t.layout\n  };\n}\nexport { o as debugMeshDataInfo };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport has from \"../../../../core/has.js\";\nimport e from \"../../../../core/Logger.js\";\nimport { create as t } from \"../../../../core/libs/gl-matrix-2/factories/mat2df32.js\";\nimport { AFeatureTile as s } from \"./AFeatureTile.js\";\nimport { RESHUFFLING_EXEMPT_MEMORY_BYTES as i, RESHUFFLING_TARGET_MEMORY_EFFICIENCY as r, RESHUFFLING_EXEMPT_DRAW_CALLS as o, RESHUFFLING_TARGET_DRAW_EFFICIENCY as d, tileSize as n } from \"./definitions.js\";\nimport h from \"./DisplayEntity.js\";\nimport { FeatureBatchingStrategy as a } from \"./enums.js\";\nimport { DisplayList as f } from \"./FeatureDisplayList.js\";\nimport { ReshufflePlan as l } from \"./ReshufflePlan.js\";\nimport { LabelMetric as u } from \"./collisions/LabelMetric.js\";\nimport { MappedMesh as m } from \"./cpuMapped/MappedMesh.js\";\nimport { debugMeshDataInfo as p } from \"./mesh/meshDebugUtils.js\";\nimport _ from \"./util/Reader.js\";\nimport { deserializeList as c } from \"./util/serializationUtils.js\";\nconst y = () => e.getLogger(\"esri.views.2d.engine.webgl.FeatureTile\");\nlet g = 0;\nclass b extends s {\n  constructor(e, s, i, r, o = !1) {\n    super(e, s, i, r), this._meshes = new Map(), this._entities = [], this._invalidated = !1, this._nextUploadAllowed = !1, this.tileAge = g++, this._metrics = [], this._entityIds = new Set(), this._entityIdsFromBuffer = new Set(), this._attributeEpoch = 0, this._encounteredEnd = !1, this.visible = !0, this.transforms.labelMat2d = t(), this.enableDeferredUploads = o;\n  }\n  destroy() {\n    super.destroy(), this.clear();\n  }\n  clear() {\n    for (const e of this._meshes.values()) e.destroy();\n    this._meshes.clear(), this._entities = [], this._metrics = [], this._displayList = null, this._invalidated = !0, this._entityIds.clear(), this._nextUploadAllowed = !0;\n  }\n  beforeRender(e) {\n    super.beforeRender(e), this._needsReshuffle && e.reshuffleManager.schedule(this);\n  }\n  tryReady(e) {\n    const t = this._invalidated && !this._uploadAllowed;\n    return !(this._isReady || t || !this._encounteredEnd || !(e >= this._attributeEpoch)) && (has(\"esri-2d-update-debug\") && console.debug(`Tile[${this.key.id}] FeatureTile.ready [epoch=${e}]`), this.ready(), this.requestRender(), !0);\n  }\n  get labelMetrics() {\n    return this._metrics;\n  }\n  get hasData() {\n    return !!this._meshes.size;\n  }\n  get needsUpload() {\n    return this._invalidated;\n  }\n  get _uploadAllowed() {\n    return !this.enableDeferredUploads || this._nextUploadAllowed;\n  }\n  upload() {\n    this._nextUploadAllowed = !0;\n  }\n  getDisplayList(e, t) {\n    if (this._uploadAllowed && this._invalidated) {\n      this._entities.sort((e, t) => {\n        const s = t.sortKey,\n          i = e.sortKey;\n        return i === s ? e.id - t.id : i - s;\n      }), t === a.BATCHING && this.reshuffle(!0), this._displayList = f.fromDisplayEntities(this._entities, this, e, t);\n      for (const e of this._meshes.values()) e.upload();\n      this.debugInfo.display.length = this._displayList.length, this.debugInfo.display.minOrderedLength = this._displayList.minOrderedLength, this.debugInfo.display.minUnorderedLength = this._displayList.minUnorderedLength, this.requestRender(), this._invalidated = !1, this._nextUploadAllowed = !1;\n    }\n    return this._displayList;\n  }\n  getMesh(e) {\n    if (!this._meshes.has(e)) throw new Error(`InternalError: Unable to find VAO for instance: ${e}`);\n    return this._meshes.get(e);\n  }\n  getSortKeys(e) {\n    const t = new Map();\n    for (const {\n      id: s,\n      sortKey: i\n    } of this._entities) if (e.has(s) && t.set(s, i), t.size === e.size) break;\n    return t;\n  }\n  onMessage(e) {\n    switch (e.type) {\n      case \"append\":\n        this._onAppendMessage(e);\n        break;\n      case \"update\":\n        this._onUpdateMessage(e);\n    }\n    if (this._aggregateMemoryStats(), this.requestRender(), e.end) {\n      if (has(\"esri-2d-update-debug\") && console.debug(`Tile[${this.key.id}] FeatureTile.end [epoch=${e.attributeEpoch}]`), !e.attributeEpoch) throw new Error(\"InternalError: Attribute epoch not defined.\");\n      this._attributeEpoch = e.attributeEpoch, this._encounteredEnd = !0;\n    }\n  }\n  _onAppendMessage(e) {\n    if (has(\"esri-2d-update-debug\") && console.debug(`Tile[${this.key.id}] FeatureTile.append`, {\n      append: p(e?.append)\n    }), e.clear && this.clear(), !e.append) return;\n    const t = c(new _(e.append.entities), h);\n    this._insert(t, e.append.data, !1);\n  }\n  _onUpdateMessage(e) {\n    has(\"esri-2d-update-debug\") && console.debug(`Tile[${this.key.id}] FeatureTile.update`, {\n      isPixelBuffer: e.isPixelBuffer,\n      modify: p(e.modify),\n      remove: e.remove\n    });\n    const t = c(new _(e.modify.entities), h),\n      s = t.map(e => e.id),\n      i = e.isPixelBuffer ?? !1,\n      r = [...e.remove, ...s];\n    i ? this._removeByIdsFromBuffer(r) : this._removeByIds(r), this._insert(t, e.modify.data, i);\n  }\n  reshuffle(e = !1) {\n    if (this.destroyed) return;\n    const t = new Map();\n    for (const s of this._entities) for (const i of s.records) {\n      const s = this._meshes.get(i.instanceId);\n      let r = t.get(s);\n      r || (r = new l(e), t.set(s, r)), r.copyRecord(i);\n    }\n    for (const [s, i] of t) s.reshuffle(i);\n    this._invalidated = !0, this._aggregateMemoryStats(), has(\"esri-2d-update-debug\") && y().info(`Tile ${this.key.id} was reshuffled.`);\n  }\n  copyPixelBufferedEntitesFrom(e, t, s, i) {\n    const r = s * n,\n      o = i * n;\n    for (const d of e._entities) {\n      let s = null;\n      for (const i of d.records) if (i.overlaps & t) {\n        const t = e.getMesh(i.instanceId),\n          n = this._ensureMesh(i.instanceId, t.layout).copyRecordFrom(t, i, r, o);\n        s || (s = new h(d.id, d.sortKey), this._entityIdsFromBuffer.add(d.id), this._entities.push(s)), s.records.push(n);\n      }\n    }\n    this._invalidated = !0;\n  }\n  _ensureMesh(e, t) {\n    return this._meshes.has(e) || this._meshes.set(e, new m(this._stage.bufferPool, t)), this._meshes.get(e);\n  }\n  _insert(e, t, s) {\n    if (!e.length) return;\n    this._removeDuplicatedBufferedEntites(e);\n    const i = this._insertVertexData(t);\n    for (const r of e) {\n      for (const e of r.records) e.updateBaseOffsets(i.get(e.instanceId));\n      s ? this._tryInsertBufferedEntity(r) : this._insertEntity(r);\n    }\n    this._invalidated = !0;\n  }\n  _insertVertexData(e) {\n    const t = new Map();\n    for (const s of e) {\n      const {\n          instanceId: e,\n          layout: i\n        } = s,\n        r = this._ensureMesh(e, i).append(s);\n      if (s.metrics) {\n        const e = c(new _(s.metrics), u) ?? [];\n        this._metrics.push(...e);\n      }\n      t.set(e, r);\n    }\n    return t;\n  }\n  _insertEntity(e) {\n    has(\"esri-2d-update-debug\") && this._entityIds.has(e.id) && console.error(`Tile ${this.key.id} insertEnitty: Already have entityId ${e.id}`), this._entityIds.add(e.id), this._entities.push(e);\n  }\n  _tryInsertBufferedEntity(e) {\n    this._entityIds.has(e.id) ? this._removeRecordsFromMesh(e.records) : (this._entityIdsFromBuffer.add(e.id), this._entities.push(e));\n  }\n  _removeDuplicatedBufferedEntites(e) {\n    if (!this._entityIdsFromBuffer.size) return;\n    const t = [];\n    for (const s of e) this._entityIdsFromBuffer.has(s.id) && t.push(s.id);\n    this._removeByIds(t);\n  }\n  _removeByIdsFromBuffer(e) {\n    this._removeByIds(e.filter(e => this._entityIdsFromBuffer.has(e)));\n  }\n  _removeByIds(e) {\n    if (0 === e.length) return;\n    const t = new Set(e),\n      s = [];\n    for (const i of this._entities) t.has(i.id) ? this._remove(i) : s.push(i);\n    this._entities = s, this._invalidated = !0;\n  }\n  _remove(e) {\n    this._removeRecordsFromMesh(e.records), this._entityIds.delete(e.id), this._entityIdsFromBuffer.delete(e.id);\n  }\n  _removeRecordsFromMesh(e) {\n    for (const t of e) {\n      const {\n        instanceId: e,\n        indexStart: s,\n        indexCount: i,\n        vertexStart: r,\n        vertexCount: o\n      } = t;\n      this._meshes.get(e)?.remove(s, i, r, o);\n    }\n  }\n  _aggregateMemoryStats() {\n    this.debugInfo.memory.bytesUsed = 0, this.debugInfo.memory.bytesReserved = 0;\n    for (const [e, t] of this._meshes) this.debugInfo.memory.bytesUsed += t.memoryStats.bytesUsed, this.debugInfo.memory.bytesReserved += t.memoryStats.bytesReserved;\n  }\n  get _needsReshuffle() {\n    if (this.destroyed) return !1;\n    const {\n        bytesUsed: e,\n        bytesReserved: t\n      } = this.debugInfo.memory,\n      s = e / t,\n      {\n        minOrderedLength: n,\n        length: h\n      } = this.debugInfo.display;\n    return t > i && s < r || h > o && n / h < d;\n  }\n}\nexport { b as FeatureTile };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { fromValues as r } from \"../../../../../core/libs/gl-matrix-2/factories/vec4f32.js\";\nimport { createProgramDescriptor as e } from \"../Utils.js\";\nimport t from \"./WGLBrush.js\";\nimport { background as s } from \"../shaders/BackgroundPrograms.js\";\nimport { StencilOperation as o, CompareFunction as i, PrimitiveType as a, DataType as n } from \"../../../../webgl/enums.js\";\nimport { createProgram as l } from \"../../../../webgl/ProgramTemplate.js\";\nconst m = () => e(\"clip\", {\n  geometry: [{\n    location: 0,\n    name: \"a_pos\",\n    count: 2,\n    type: n.SHORT\n  }]\n});\nclass p extends t {\n  constructor() {\n    super(...arguments), this._color = r(0, 1, 0, 1);\n  }\n  dispose() {\n    this._program && this._program.dispose();\n  }\n  prepareState({\n    context: r\n  }) {\n    r.setStencilTestEnabled(!0), r.setBlendingEnabled(!1), r.setFaceCullingEnabled(!1), r.setColorMask(!1, !1, !1, !1), r.setStencilOp(o.KEEP, o.KEEP, o.REPLACE), r.setStencilWriteMask(255), r.setStencilFunction(i.ALWAYS, 0, 255);\n  }\n  draw(r, e) {\n    const {\n        context: t,\n        state: o,\n        requestRender: i,\n        allowDelayedRender: p\n      } = r,\n      c = m(),\n      d = e.getVAO(t, o, c.attributes, c.bufferLayouts);\n    null != d.indexBuffer && (this._program || (this._program = l(t, s)), !p || null == i || this._program.compiled ? (t.useProgram(this._program), this._program.setUniform2fv(\"u_coord_range\", [1, 1]), this._program.setUniform4fv(\"u_color\", this._color), this._program.setUniformMatrix3fv(\"u_dvsMat3\", o.displayMat3), t.bindVAO(d), t.drawElements(a.TRIANGLES, d.indexBuffer.size, n.UNSIGNED_INT, 0), t.bindVAO()) : i());\n  }\n}\nexport { p as default };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { textureBindingBitmap as e } from \"../definitions.js\";\nimport { createProgramDescriptor as t } from \"../Utils.js\";\nimport r from \"./WGLBrush.js\";\nimport { BlendFactor as n, CompareFunction as o, DataType as s } from \"../../../../webgl/enums.js\";\nconst i = () => t(\"overlay\", {\n  geometry: [{\n    location: 0,\n    name: \"a_pos\",\n    count: 2,\n    type: s.FLOAT\n  }],\n  tex: [{\n    location: 1,\n    name: \"a_uv\",\n    count: 2,\n    type: s.UNSIGNED_SHORT\n  }]\n});\nclass a extends r {\n  constructor() {\n    super(...arguments), this._desc = {\n      vsPath: \"overlay/overlay\",\n      fsPath: \"overlay/overlay\",\n      attributes: new Map([[\"a_pos\", 0], [\"a_uv\", 1]])\n    };\n  }\n  dispose() {}\n  prepareState({\n    context: e\n  }) {\n    e.setBlendingEnabled(!0), e.setColorMask(!0, !0, !0, !0), e.setBlendFunctionSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA), e.setStencilWriteMask(0), e.setStencilTestEnabled(!0), e.setStencilFunction(o.GREATER, 255, 255);\n  }\n  draw(t, r) {\n    const {\n      context: n,\n      painter: o,\n      requestRender: s,\n      allowDelayedRender: a\n    } = t;\n    if (!r.isReady) return;\n    const {\n      computedOpacity: u,\n      dvsMat3: d,\n      isWrapAround: c,\n      perspectiveTransform: m,\n      texture: f,\n      wrapAroundShift: l\n    } = r;\n    t.timeline.begin(this.name);\n    const p = o.materialManager.getProgram(this._desc);\n    if (a && null != s && !p.compiled) return void s();\n    const _ = i(),\n      v = r.getVAO(n, _.bufferLayouts, _.attributes);\n    v && (n.bindVAO(v), n.useProgram(p), n.bindTexture(f, e), p.setUniformMatrix3fv(\"u_dvsMat3\", d), p.setUniform1i(\"u_texture\", e), p.setUniform1f(\"u_opacity\", u), p.setUniform2fv(\"u_perspective\", m), p.setUniform2fv(\"u_texSize\", r.textureSize), p.setUniform1f(\"u_wrapAroundShift\", 0), r.draw(t.context), c && (p.setUniform1f(\"u_wrapAroundShift\", l), r.draw(t.context)), n.bindVAO(), t.timeline.end(this.name));\n  }\n}\nexport { a as default };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { fromValues as e } from \"../../../../../core/libs/gl-matrix-2/factories/vec4f32.js\";\nimport { Pos2b as r } from \"../DefaultVertexAttributeLayouts.js\";\nimport t from \"./WGLBrush.js\";\nimport { background as i } from \"../shaders/BackgroundPrograms.js\";\nimport { BufferObject as s } from \"../../../../webgl/BufferObject.js\";\nimport { StencilOperation as o, Face as a, CompareFunction as l, PrimitiveType as n, Usage as d } from \"../../../../webgl/enums.js\";\nimport { createProgram as m } from \"../../../../webgl/ProgramTemplate.js\";\nimport { VertexArrayObject as c } from \"../../../../webgl/VertexArrayObject.js\";\nclass _ extends t {\n  constructor() {\n    super(...arguments), this._color = e(1, 0, 0, 1), this._initialized = !1;\n  }\n  dispose() {\n    this._solidProgram && (this._solidProgram.dispose(), this._solidProgram = null), this._solidVertexArrayObject && (this._solidVertexArrayObject.dispose(), this._solidVertexArrayObject = null);\n  }\n  prepareState({\n    context: e\n  }) {\n    e.setDepthWriteEnabled(!1), e.setDepthTestEnabled(!1), e.setStencilTestEnabled(!0), e.setBlendingEnabled(!1), e.setColorMask(!1, !1, !1, !1), e.setStencilOp(o.KEEP, o.KEEP, o.REPLACE), e.setStencilWriteMask(255);\n  }\n  draw(e, r) {\n    const {\n      context: t,\n      requestRender: i,\n      allowDelayedRender: s\n    } = e;\n    this._initialized || this._initialize(t), !s || null == i || this._solidProgram.compiled ? (t.setStencilFunctionSeparate(a.FRONT_AND_BACK, l.GREATER, r.stencilRef, 255), t.bindVAO(this._solidVertexArrayObject), t.useProgram(this._solidProgram), this._solidProgram.setUniformMatrix3fv(\"u_dvsMat3\", r.transforms.displayViewScreenMat3), this._solidProgram.setUniform2fv(\"u_coord_range\", [r.rangeX, r.rangeY]), this._solidProgram.setUniform1f(\"u_depth\", 0), this._solidProgram.setUniform4fv(\"u_color\", this._color), t.drawArrays(n.TRIANGLE_STRIP, 0, 4), t.bindVAO()) : i();\n  }\n  _initialize(e) {\n    if (this._initialized) return !0;\n    const t = m(e, i);\n    if (!t) return !1;\n    const o = new Int8Array([0, 0, 1, 0, 0, 1, 1, 1]),\n      a = s.createVertex(e, d.STATIC_DRAW, o),\n      l = new c(e, i.attributes, r, {\n        geometry: a\n      });\n    return this._solidProgram = t, this._solidVertexArrayObject = l, this._initialized = !0, !0;\n  }\n}\nexport { _ as default };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { fromValues as e } from \"../../../../../core/libs/gl-matrix-2/factories/vec4f32.js\";\nimport { Pos2b as t } from \"../DefaultVertexAttributeLayouts.js\";\nimport { FeatureTile as r } from \"../FeatureTile.js\";\nimport o from \"./WGLBrush.js\";\nimport { background as i } from \"../shaders/BackgroundPrograms.js\";\nimport { tileInfo as s } from \"../shaders/TileInfoPrograms.js\";\nimport { BufferObject as n } from \"../../../../webgl/BufferObject.js\";\nimport { BlendFactor as l, PrimitiveType as a, Usage as f, TextureWrapMode as m, TextureSamplingMode as u } from \"../../../../webgl/enums.js\";\nimport { createProgram as c } from \"../../../../webgl/ProgramTemplate.js\";\nimport { Texture as d } from \"../../../../webgl/Texture.js\";\nimport { TextureDescriptor as h } from \"../../../../webgl/TextureDescriptor.js\";\nimport { VertexArrayObject as g } from \"../../../../webgl/VertexArrayObject.js\";\nconst _ = 512,\n  x = 512,\n  b = 16,\n  p = 8,\n  T = (x - 2 * p) / 5;\nclass y extends o {\n  constructor() {\n    super(...arguments), this._color = e(1, 0, 0, 1);\n  }\n  dispose() {\n    this._outlineProgram?.dispose(), this._outlineProgram = null, this._tileInfoProgram?.dispose(), this._tileInfoProgram = null, this._outlineVertexArrayObject?.dispose(), this._outlineVertexArrayObject = null, this._tileInfoVertexArrayObject?.dispose(), this._tileInfoVertexArrayObject = null, this._ctx = null;\n  }\n  prepareState({\n    context: e\n  }) {\n    e.setBlendingEnabled(!0), e.setBlendFunctionSeparate(l.ONE, l.ONE_MINUS_SRC_ALPHA, l.ONE, l.ONE_MINUS_SRC_ALPHA), e.setColorMask(!0, !0, !0, !0), e.setStencilWriteMask(0), e.setStencilTestEnabled(!1);\n  }\n  draw(e, t) {\n    const {\n      context: o,\n      requestRender: i,\n      allowDelayedRender: s\n    } = e;\n    if (!t.isReady && t instanceof r && t.hasData) return;\n    if (this._loadWGLResources(o), s && null != i && (!this._outlineProgram.compiled || !this._tileInfoProgram.compiled)) return void i();\n    o.bindVAO(this._outlineVertexArrayObject), o.useProgram(this._outlineProgram), this._outlineProgram.setUniformMatrix3fv(\"u_dvsMat3\", t.transforms.displayViewScreenMat3), this._outlineProgram.setUniform2f(\"u_coord_range\", t.rangeX, t.rangeY), this._outlineProgram.setUniform1f(\"u_depth\", 0), this._outlineProgram.setUniform4fv(\"u_color\", this._color), o.drawArrays(a.LINE_STRIP, 0, 4);\n    const n = this._getTexture(o, t);\n    n ? (o.bindVAO(this._tileInfoVertexArrayObject), o.useProgram(this._tileInfoProgram), o.bindTexture(n, 0), this._tileInfoProgram.setUniformMatrix3fv(\"u_dvsMat3\", t.transforms.displayViewScreenMat3), this._tileInfoProgram.setUniform1f(\"u_depth\", 0), this._tileInfoProgram.setUniform2f(\"u_coord_ratio\", t.rangeX / t.width, t.rangeY / t.height), this._tileInfoProgram.setUniform2f(\"u_delta\", 0, 0), this._tileInfoProgram.setUniform2f(\"u_dimensions\", n.descriptor.width, n.descriptor.height), o.drawArrays(a.TRIANGLE_STRIP, 0, 4), o.bindVAO()) : o.bindVAO();\n  }\n  _loadWGLResources(e) {\n    if (this._outlineProgram && this._tileInfoProgram) return;\n    const r = c(e, i),\n      o = c(e, s),\n      l = new Int8Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      a = n.createVertex(e, f.STATIC_DRAW, l),\n      m = new g(e, i.attributes, t, {\n        geometry: a\n      }),\n      u = new Int8Array([0, 0, 1, 0, 0, 1, 1, 1]),\n      d = n.createVertex(e, f.STATIC_DRAW, u),\n      h = new g(e, s.attributes, t, {\n        geometry: d\n      });\n    this._outlineProgram = r, this._tileInfoProgram = o, this._outlineVertexArrayObject = m, this._tileInfoVertexArrayObject = h;\n  }\n  _getTexture(e, t) {\n    if (!this._ctx) {\n      const e = document.createElement(\"canvas\");\n      e.width = _, e.height = x, this._ctx = e.getContext(\"2d\");\n    }\n    if (!t.tileDebugInfoTexture) {\n      const r = new h();\n      r.wrapMode = m.CLAMP_TO_EDGE, r.samplingMode = u.LINEAR, r.isImmutable = !0, r.width = _, r.height = x, t.tileDebugInfoTexture = new d(e, r);\n    }\n    const r = this._ctx;\n    r.clearRect(0, 0, r.canvas.width, r.canvas.height), r.textAlign = \"left\", r.textBaseline = \"top\", r.font = b - 2 + \"px sans-serif\", r.lineWidth = 2, r.fillStyle = \"white\", r.strokeStyle = \"black\";\n    const {\n      debugSlot: o\n    } = t;\n    let i = p + T * o;\n    const s = `${o}) ${t.key.id} (${t.constructor.name})`;\n    r.strokeText(s, p, i), r.fillText(s, p, i), i += b;\n    const {\n      debugInfo: n\n    } = t;\n    if (n) {\n      const {\n        length: e,\n        minOrderedLength: t,\n        minUnorderedLength: o,\n        triangleCount: s\n      } = n.display;\n      if (e > 0) {\n        const t = `Length: ${e}`;\n        r.strokeText(t, p, i), r.fillText(t, p, i), i += b;\n      }\n      if (t) {\n        const e = `Min ordered length: ${t}`;\n        r.strokeText(e, p, i), r.fillText(e, p, i), i += b;\n      }\n      if (o) {\n        const e = `Min unordered length: ${o}`;\n        r.strokeText(e, p, i), r.fillText(e, p, i), i += b;\n      }\n      if (s > 0) {\n        s > 1e5 && (r.fillStyle = \"red\", r.strokeStyle = \"white\");\n        const e = `Triangle count: ${s}`;\n        r.strokeText(e, p, i), r.fillText(e, p, i), i += b;\n      }\n      const {\n        bytesUsed: l,\n        bytesReserved: a\n      } = n.memory;\n      if (r.fillStyle = \"white\", r.strokeStyle = \"black\", l > 0 || a > 0) {\n        const e = `Memory usage: ${l} of ${a} bytes`;\n        r.strokeText(e, p, i), r.fillText(e, p, i), i += b;\n      }\n    }\n    return t.tileDebugInfoTexture.setData(r.canvas), t.tileDebugInfoTexture;\n  }\n}\nexport { y as default };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport r from \"./webgl/brushes/BrushBitmap.js\";\nimport s from \"./webgl/brushes/BrushClip.js\";\nimport e from \"./webgl/brushes/BrushOverlay.js\";\nimport l from \"./webgl/brushes/WGLBrushStencil.js\";\nimport o from \"./webgl/brushes/WGLBrushTileDebugInfo.js\";\nimport { WGLBrushVTLBackground as b } from \"./webgl/brushes/WGLBrushVTLBackground.js\";\nimport { WGLBrushVTLCircle as i } from \"./webgl/brushes/WGLBrushVTLCircle.js\";\nimport { WGLBrushVTLFill as m } from \"./webgl/brushes/WGLBrushVTLFill.js\";\nimport { WGLBrushVTLLine as u } from \"./webgl/brushes/WGLBrushVTLLine.js\";\nimport { WGLBrushVTLSymbol as t } from \"./webgl/brushes/WGLBrushVTLSymbol.js\";\nconst h = {\n  clip: s,\n  stencil: l,\n  bitmap: r,\n  overlay: e,\n  tileDebugInfo: o,\n  vtlBackground: b,\n  vtlFill: m,\n  vtlLine: u,\n  vtlCircle: i,\n  vtlSymbol: t\n};\nexport { h as brushes };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport e from \"../../../../core/Error.js\";\nimport r from \"../../../../core/Logger.js\";\nimport { e as t } from \"../../../../chunks/earcut.js\";\nimport { set as n } from \"../../../../core/libs/gl-matrix-2/math/vec2.js\";\nimport { create as o } from \"../../../../core/libs/gl-matrix-2/factories/vec2f64.js\";\nimport { convertFromNestedArray as s, convertFromPolygon as i } from \"../../../../layers/graphics/featureConversionUtils.js\";\nimport c from \"../../../../layers/graphics/OptimizedGeometry.js\";\nimport { i1616to32 as a } from \"./number.js\";\nimport { BufferObject as f } from \"../../../webgl/BufferObject.js\";\nimport { PrimitiveType as m, Usage as h, DataType as u } from \"../../../webgl/enums.js\";\nconst l = r => {\n    switch (r.BYTES_PER_ELEMENT) {\n      case 1:\n        return u.UNSIGNED_BYTE;\n      case 2:\n        return u.UNSIGNED_SHORT;\n      case 4:\n        return u.UNSIGNED_INT;\n      default:\n        throw new e(\"Cannot get DataType of array\");\n    }\n  },\n  y = (e, r, t, n) => {\n    let o = 0;\n    for (let s = 1; s < t; s++) {\n      const t = e[2 * (r + s - 1)],\n        n = e[2 * (r + s - 1) + 1];\n      o += (e[2 * (r + s)] - t) * (e[2 * (r + s) + 1] + n);\n    }\n    return n ? o > 0 : o < 0;\n  },\n  x = ({\n    coords: e,\n    lengths: r\n  }, n) => {\n    const o = [];\n    for (let s = 0, i = 0; s < r.length; i += r[s], s += 1) {\n      const c = i,\n        a = [];\n      for (; s < r.length - 1 && y(e, i + r[s], r[s + 1], n); s += 1, i += r[s]) a.push(i + r[s] - c);\n      const f = e.slice(2 * c, 2 * (i + r[s])),\n        m = t(f, a, 2);\n      for (const e of m) o.push(e + c);\n    }\n    return o;\n  };\nclass g {\n  constructor(e, r, t, n = !1) {\n    this._cache = {}, this.vertices = e, this.indices = r, this.primitiveType = t, this.isMapSpace = n;\n  }\n  static fromPath(e) {\n    const r = s(new c(), e.path, !1, !1),\n      t = r.coords,\n      n = new Uint32Array(x(r, !0)),\n      o = new Uint32Array(t.length / 2);\n    for (let s = 0; s < o.length; s++) o[s] = a(Math.floor(t[2 * s]), Math.floor(t[2 * s + 1]));\n    return new g({\n      geometry: o\n    }, n, m.TRIANGLES);\n  }\n  static fromGeometry(t, n) {\n    const o = n.geometry?.type;\n    switch (o) {\n      case \"polygon\":\n        return g.fromPolygon(t, n.geometry);\n      case \"extent\":\n        return g.fromMapExtent(t, n.geometry);\n      default:\n        return r.getLogger(\"esri.views.2d.engine.webgl.Mesh2D\").error(new e(\"mapview-bad-type\", `Unable to create a mesh from type ${o}`, n)), g.fromScreenExtent({\n          xmin: 0,\n          ymin: 0,\n          xmax: 1,\n          ymax: 1\n        });\n    }\n  }\n  static fromPolygon(e, r) {\n    const t = i(new c(), r, !1, !1),\n      s = t.coords,\n      f = new Uint32Array(x(t, !1)),\n      h = new Uint32Array(s.length / 2),\n      u = o(),\n      l = o();\n    for (let o = 0; o < h.length; o++) n(u, s[2 * o], s[2 * o + 1]), e.toScreen(l, u), h[o] = a(Math.floor(l[0]), Math.floor(l[1]));\n    return new g({\n      geometry: h\n    }, f, m.TRIANGLES, !0);\n  }\n  static fromScreenExtent({\n    xmin: e,\n    xmax: r,\n    ymin: t,\n    ymax: n\n  }) {\n    const o = {\n        geometry: new Uint32Array([a(e, t), a(r, t), a(e, n), a(e, n), a(r, t), a(r, n)])\n      },\n      s = new Uint32Array([0, 1, 2, 3, 4, 5]);\n    return new g(o, s, m.TRIANGLES);\n  }\n  static fromMapExtent(e, r) {\n    const [t, n] = e.toScreen([0, 0], [r.xmin, r.ymin]),\n      [o, s] = e.toScreen([0, 0], [r.xmax, r.ymax]),\n      i = {\n        geometry: new Uint32Array([a(t, n), a(o, n), a(t, s), a(t, s), a(o, n), a(o, s)])\n      },\n      c = new Uint32Array([0, 1, 2, 3, 4, 5]);\n    return new g(i, c, m.TRIANGLES);\n  }\n  destroy() {\n    null != this._cache.indexBuffer && this._cache.indexBuffer.dispose();\n    for (const e in this._cache.vertexBuffers) null != this._cache.vertexBuffers[e] && this._cache.vertexBuffers[e].dispose();\n  }\n  get elementType() {\n    return l(this.indices);\n  }\n  getIndexBuffer(e, r = h.STATIC_DRAW) {\n    return this._cache.indexBuffer || (this._cache.indexBuffer = f.createIndex(e, r, this.indices)), this._cache.indexBuffer;\n  }\n  getVertexBuffers(e, r = h.STATIC_DRAW) {\n    return this._cache.vertexBuffers || (this._cache.vertexBuffers = Object.keys(this.vertices).reduce((t, n) => ({\n      ...t,\n      [n]: f.createVertex(e, r, this.vertices[n])\n    }), {})), this._cache.vertexBuffers;\n  }\n}\nexport { g as default };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport e from \"../../../../core/Error.js\";\nimport t from \"../../../../core/Logger.js\";\nimport { watch as r } from \"../../../../core/reactiveUtils.js\";\nimport { create as s } from \"../../../../core/libs/gl-matrix-2/factories/mat3f32.js\";\nimport { DisplayObject as i } from \"../DisplayObject.js\";\nimport a from \"./Mesh2D.js\";\nimport { createScreenExtent as o } from \"../../support/clippingUtils.js\";\nimport { VertexArrayObject as h } from \"../../../webgl/VertexArrayObject.js\";\nclass c extends i {\n  constructor(e, t) {\n    super(), this._clip = t, this._cache = {}, this.stage = e, this._handle = r(() => t.version, () => this._invalidate()), this.ready();\n  }\n  static fromClipArea(e, t) {\n    return new c(e, t);\n  }\n  _destroyGL() {\n    null != this._cache.mesh && (this._cache.mesh.destroy(), this._cache.mesh = null), null != this._cache.vao && (this._cache.vao.dispose(), this._cache.vao = null);\n  }\n  destroy() {\n    this._destroyGL(), this._handle.remove();\n  }\n  getVAO(e, t, r, s) {\n    const [i, a] = t.size;\n    if (\"geometry\" !== this._clip.type && this._lastWidth === i && this._lastHeight === a || (this._lastWidth = i, this._lastHeight = a, this._destroyGL()), null == this._cache.vao) {\n      const i = this._createMesh(t, this._clip),\n        a = i.getIndexBuffer(e),\n        o = i.getVertexBuffers(e);\n      this._cache.mesh = i, this._cache.vao = new h(e, r, s, o, a);\n    }\n    return this._cache.vao;\n  }\n  _createTransforms() {\n    return {\n      displayViewScreenMat3: s()\n    };\n  }\n  _invalidate() {\n    this._destroyGL(), this.requestRender();\n  }\n  _createMesh(r, s) {\n    switch (s.type) {\n      case \"rect\":\n        return a.fromScreenExtent(o(s, r.size[0], r.size[1]));\n      case \"path\":\n        return a.fromPath(s);\n      case \"geometry\":\n        return a.fromGeometry(r, s);\n      default:\n        return t.getLogger(\"esri.views.2d.engine.webgl.ClippingInfo\").error(new e(\"mapview-bad-type\", \"Unable to create ClippingInfo mesh from clip of type: ${clip.type}\")), a.fromScreenExtent({\n          xmin: 0,\n          ymin: 0,\n          xmax: 1,\n          ymax: 1\n        });\n    }\n  }\n}\nexport { c as default };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport \"../../../../core/has.js\";\nimport { brushes as s } from \"../brushes.js\";\nimport { Container as e } from \"../Container.js\";\nimport r from \"./ClippingInfo.js\";\nimport { WGLDrawPhase as i } from \"./enums.js\";\nclass n extends e {\n  set clips(s) {\n    super.clips = s, this._updateClippingInfo(s);\n  }\n  renderChildren(s) {\n    s.painter.setPipelineState(null), null == this._renderPasses && (this._renderPasses = this.prepareRenderPasses(s.painter));\n    for (const r of this._renderPasses) try {\n      r.render(s);\n    } catch (e) {}\n  }\n  prepareRenderPasses(e) {\n    return [e.registerRenderPass({\n      name: \"clip\",\n      brushes: [s.clip],\n      target: () => this._clippingInfos,\n      drawPhase: i.MAP | i.LABEL | i.LABEL_ALPHA | i.DEBUG | i.HIGHLIGHT\n    })];\n  }\n  _updateClippingInfo(s) {\n    null != this._clippingInfos && (this._clippingInfos.forEach(s => s.destroy()), this._clippingInfos = null), null != s && s.length && (this._clippingInfos = s.items.map(s => r.fromClipArea(this.stage, s))), this.requestRender();\n  }\n}\nexport { n as default };"],
  "mappings": "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",
  "names": ["h", "i", "t", "o", "r", "o", "e", "t", "i", "s", "n", "a", "d", "l", "c", "m", "p", "u", "h", "f", "_", "e", "o", "r", "e", "t", "n", "e", "n", "f", "e", "d", "n", "p", "r", "t", "s", "i", "o", "a", "m", "l", "c", "h", "t", "a", "e", "n", "r", "d", "s", "r", "s", "t", "e", "a", "i", "n", "r", "n", "r", "t", "e", "d", "h", "n", "i", "a", "s", "l", "o", "c", "u", "_", "N", "g", "m", "f", "E", "S", "t", "e", "n", "n", "h", "a", "d", "t", "e", "r", "s", "i", "u", "o", "f", "o", "n", "e", "t", "r", "i", "s", "u", "a", "f", "h", "d", "c", "_", "l", "m", "x", "t", "o", "e", "n", "t", "s", "a", "i", "r", "b", "p", "e", "s", "i", "r", "o", "n", "t", "N", "d", "a", "h", "p", "t", "r", "e", "o", "i", "c", "d", "i", "a", "t", "e", "r", "n", "o", "s", "u", "d", "c", "m", "f", "l", "p", "_", "t", "r", "e", "i", "s", "o", "a", "l", "_", "b", "p", "y", "t", "r", "e", "o", "i", "s", "n", "l", "a", "m", "u", "d", "h", "c", "h", "p", "d", "a", "y", "u", "s", "n", "l", "r", "y", "e", "t", "n", "o", "s", "x", "i", "c", "a", "f", "m", "g", "h", "u", "c", "s", "e", "t", "r", "i", "a", "o", "g", "n", "n", "s", "r", "e", "h", "E", "c"]
}
