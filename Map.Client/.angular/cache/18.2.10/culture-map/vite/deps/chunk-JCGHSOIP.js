import {
  l as l5
} from "./chunk-PA5PVFOE.js";
import {
  A,
  I as I5
} from "./chunk-XVYR2JNI.js";
import {
  a as a9,
  s as s9
} from "./chunk-KGPFLNKT.js";
import {
  a as a10
} from "./chunk-M66N34RL.js";
import {
  n as n10
} from "./chunk-4E3ADDPV.js";
import {
  u as u8
} from "./chunk-ONNA6736.js";
import {
  i as i3
} from "./chunk-PR6QK2UX.js";
import {
  d2 as d4,
  f,
  o as o4,
  u2 as u7
} from "./chunk-6YVA5E7L.js";
import {
  s as s8
} from "./chunk-UOIZXQPU.js";
import {
  n as n9,
  r as r8,
  t as t3,
  u as u6
} from "./chunk-74INNEIP.js";
import {
  N
} from "./chunk-GOKBAMCG.js";
import {
  r as r7
} from "./chunk-E3P3LIVT.js";
import {
  o as o3
} from "./chunk-TGHJVD7I.js";
import {
  d as d3,
  y as y3
} from "./chunk-Z3XBAPJ2.js";
import {
  t
} from "./chunk-5XOZP4XS.js";
import {
  e as e10,
  s as s7,
  u as u5
} from "./chunk-ZVFENZUF.js";
import {
  H as H2,
  I as I4,
  L as L3,
  s as s5
} from "./chunk-YYETZJJB.js";
import {
  a as a8,
  c,
  d as d2,
  h as h2,
  l as l4,
  o as o2,
  r as r5,
  s as s6
} from "./chunk-H6HXZTAS.js";
import {
  e as e9
} from "./chunk-VHERB2HE.js";
import {
  D
} from "./chunk-YLE5AYZV.js";
import {
  a as a7
} from "./chunk-CZQYBYHB.js";
import {
  C as C2,
  I as I3,
  i as i2
} from "./chunk-YFQ32AQX.js";
import {
  r as r6,
  t as t2
} from "./chunk-KDJZAYOF.js";
import {
  F as F2,
  H,
  O as O2,
  Z,
  de,
  ge,
  k as k2,
  ye
} from "./chunk-VCFSVEDB.js";
import {
  e as e7
} from "./chunk-O2DTA3XK.js";
import {
  T,
  V as V2,
  _ as _4,
  et,
  k,
  z as z2
} from "./chunk-ZE47C44H.js";
import {
  I,
  p as p3
} from "./chunk-W5ERGD4Y.js";
import {
  I as I2,
  L as L2
} from "./chunk-7B5YPLFX.js";
import {
  l as l3,
  o
} from "./chunk-KKD7A2GN.js";
import {
  F,
  V as V3
} from "./chunk-N4KQPPPI.js";
import {
  a as a6
} from "./chunk-VWML4J2J.js";
import {
  j
} from "./chunk-JYODC3YQ.js";
import {
  e as e8
} from "./chunk-TYQXPPSP.js";
import {
  e as e6
} from "./chunk-SWPHGZYB.js";
import {
  a as a4,
  n as n7,
  r as r3
} from "./chunk-TNWXOQKO.js";
import {
  n as n8
} from "./chunk-IMVP5ADD.js";
import {
  a as a5,
  r as r4
} from "./chunk-H7WPOTQH.js";
import {
  u as u4
} from "./chunk-K226GFDN.js";
import {
  n as n5
} from "./chunk-5I6J67HP.js";
import {
  l as l2
} from "./chunk-YVULORT6.js";
import {
  n as n4
} from "./chunk-EDSMXTFO.js";
import {
  G as G3
} from "./chunk-OGZAGPIO.js";
import {
  u as u3
} from "./chunk-IHVSZYZS.js";
import {
  e as e5
} from "./chunk-3ZXOUEQG.js";
import {
  G as G2,
  K,
  P as P2,
  U as U2,
  X,
  Y,
  e as e4,
  g,
  p as p2,
  q,
  r as r2,
  s as s4,
  u as u2,
  v,
  x,
  z
} from "./chunk-AXVPJBVW.js";
import {
  _ as _3,
  n as n6
} from "./chunk-OXEPWRM7.js";
import {
  G,
  O,
  s3
} from "./chunk-JJS7PR2U.js";
import {
  U,
  _,
  i2 as i,
  m2 as m
} from "./chunk-SYATLP3H.js";
import {
  C,
  P,
  d
} from "./chunk-6WHTZNUH.js";
import {
  V
} from "./chunk-EITGQLII.js";
import {
  _ as _2,
  b as b2,
  y as y2
} from "./chunk-XNUH25NY.js";
import {
  e as e3
} from "./chunk-4Z5SGKRM.js";
import {
  S as S2
} from "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import {
  a3
} from "./chunk-DDYVXG4F.js";
import {
  $,
  L,
  a as a2,
  b,
  h,
  s as s2,
  w
} from "./chunk-HJY2YILU.js";
import {
  e as e2
} from "./chunk-7DA6A5LD.js";
import {
  e,
  n as n3,
  u
} from "./chunk-2MMLMOWS.js";
import {
  l
} from "./chunk-4323ZVPF.js";
import {
  a,
  n2,
  s2 as s
} from "./chunk-WYIDUUN2.js";
import {
  S,
  has,
  n,
  p,
  r2 as r
} from "./chunk-DXLOWWK7.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/enums.js
var e11;
var s10;
!function(e12) {
  e12[e12.KTX2 = 1] = "KTX2", e12[e12.Basis = 2] = "Basis", e12[e12.DDS_S3TC = 4] = "DDS_S3TC", e12[e12.PNG = 8] = "PNG", e12[e12.JPG = 16] = "JPG", e12[e12.KTX_ETC2 = 32] = "KTX_ETC2";
}(e11 || (e11 = {})), function(e12) {
  e12[e12.None = 0] = "None", e12[e12.Color = 1] = "Color", e12[e12.MetallicRoughness = 2] = "MetallicRoughness", e12[e12.Normal = 4] = "Normal", e12[e12.Occlusion = 8] = "Occlusion", e12[e12.Emissive = 16] = "Emissive", e12[e12.AlphaMask = 32] = "AlphaMask", e12[e12.ColorTextures = 19] = "ColorTextures", e12[e12.GeometryTextures = 36] = "GeometryTextures", e12[e12.GeometryTexturesPBR = 44] = "GeometryTexturesPBR", e12[e12.AllTextures = 37] = "AllTextures", e12[e12.AllTexturesPBR = 63] = "AllTexturesPBR";
}(s10 || (s10 = {}));

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/I3SClientMaterialUtil.js
function c2(o6) {
  return __async(this, null, function* () {
    const t5 = [], r10 = [];
    if (null == o6) {
      return {
        material: {
          alphaMode: "opaque",
          alphaCutoff: 0.1,
          doubleSided: true,
          cullFace: 0,
          normalTextureId: -1,
          emissiveTextureId: -1,
          occlusionTextureId: -1,
          emissiveFactor: [0, 0, 0],
          metallicRoughness: {
            baseColorFactor: [1, 1, 1, 1],
            baseColorTextureId: -1,
            metallicRoughnessTextureId: -1,
            metallicFactor: 0,
            roughnessFactor: 0.6000000238418579
          },
          wrapTextures: false,
          hasParametersFromSource: true
        },
        requiredTextures: t5,
        textureData: r10
      };
    }
    const a13 = d5(o6);
    "auto" === o6.alphaMode && console.warn('alphaMode "auto" not supported by I3S PBRMaterial - defaulting to "blend".');
    const n11 = u6({
      normalTexture: o6.normalTexture,
      emissiveTexture: a13 ? o6.emissiveTexture : null,
      emissiveFactor: a13 ? u4.toUnitRGB(o6.emissiveColor) : null,
      occlusionTexture: a13 ? o6.occlusionTexture : null,
      metallicRoughnessTexture: a13 ? o6.metallicRoughnessTexture : null,
      metallicFactor: a13 ? o6.metallic : null,
      roughnessFactor: a13 ? o6.roughness : null
    }), c5 = n11 ? t3[0] : a13 ? o6.metallic : 0, g4 = n11 ? t3[1] : a13 ? o6.roughness : 0;
    return {
      material: {
        alphaMode: "auto" === o6.alphaMode ? "blend" : o6.alphaMode,
        alphaCutoff: o6.alphaCutoff,
        doubleSided: o6.doubleSided,
        cullFace: o6.doubleSided ? e10.None : e10.Back,
        normalTextureId: yield m2(o6.normalTexture, t5, r10, s10.Normal),
        emissiveTextureId: a13 ? yield m2(o6.emissiveTexture, t5, r10, s10.Emissive) : -1,
        occlusionTextureId: a13 ? yield m2(o6.occlusionTexture, t5, r10, s10.Occlusion) : -1,
        emissiveFactor: a13 && null != o6.emissiveColor ? u4.toUnitRGB(o6.emissiveColor) : [0, 0, 0],
        metallicRoughness: {
          baseColorFactor: null != o6.color ? u4.toUnitRGBA(o6.color) : [1, 1, 1, 1],
          baseColorTextureId: yield m2(o6.colorTexture, t5, r10, s10.Color),
          metallicRoughnessTextureId: a13 ? yield m2(o6.metallicRoughnessTexture, t5, r10, s10.MetallicRoughness) : -1,
          metallicFactor: c5,
          roughnessFactor: g4
        },
        wrapTextures: true,
        hasParametersFromSource: n11
      },
      requiredTextures: t5,
      textureData: r10
    };
  });
}
function m2(e12, s12, l7, i4) {
  return __async(this, null, function* () {
    if (null == e12) return -1;
    const u9 = l7.length, c5 = e12.data, m4 = e12.url;
    if (null != c5) {
      if (c5 instanceof HTMLImageElement || c5 instanceof HTMLCanvasElement) {
        const e13 = r7(c5);
        return l7.push({
          id: u9,
          usage: i4,
          data: e13,
          encoding: e11.PNG,
          downsampled: false
        }), s12.push({
          id: u9,
          usage: i4,
          encodings: [{
            name: void 0,
            encoding: e11.PNG
          }]
        }), u9;
      }
      if (c5 instanceof HTMLVideoElement) return -1;
      if (c5 instanceof ImageData) throw new s("ImageData textures not supported yet for client side I3S nodes");
      if (c5 instanceof t) throw new s("EncodedMeshTexture textures not supported yet for client side I3S nodes");
    } else if (null != m4) {
      const e13 = new Image();
      e13.src = m4;
      const o6 = yield i(e13, e13.src, false, void 0), r10 = r7(o6);
      return l7.push({
        id: u9,
        usage: i4,
        data: r10,
        encoding: e11.PNG,
        downsampled: false
      }), s12.push({
        id: u9,
        usage: i4,
        encodings: [{
          name: void 0,
          encoding: e11.PNG
        }]
      }), u9;
    }
    return -1;
  });
}
function d5(e12) {
  return e12.hasOwnProperty("metallicRoughnessTexture");
}

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/I3SClientNodeLoader.js
var h3 = class {
  constructor(e12, t5, o6, r10) {
    this._uid = e12, this._worker = r10, this._id2Meta = /* @__PURE__ */ new Map(), this._oid2Meta = /* @__PURE__ */ new Map(), this._indexSR = t5.indexSR, this._vertexSR = t5.vertexSR, this._renderSR = t5.renderSR, this._localMode = t5.localMode, this._memCache = o6.newCache(`sl-client-mesh-data-${this._uid}`);
  }
  get uid() {
    return this._uid;
  }
  get worker() {
    return this._worker;
  }
  get indexSR() {
    return this._indexSR;
  }
  get renderSR() {
    return this._renderSR;
  }
  createMeshNodeInfo(e12, t5) {
    const o6 = `mesh${t5}`, r10 = e12.extent, n11 = r10.spatialReference, s12 = this._indexSR, i4 = p4(r10, e12.origin);
    a9(i4, n11, i4, s12);
    return {
      type: "mesh",
      id: o6,
      version: M(e12),
      oid: t5,
      mbs: i4,
      componentNodeIds: [],
      unloadedMesh: e12,
      nodeIndex: null,
      loadMeshPromise: null
    };
  }
  addMeshNode(t5, o6) {
    if (null != this.getMeshNodeIndex(o6.oid)) throw new s(`I3SClientNodeLoader: client side mesh for feature oid=${o6.oid} already exists`);
    o6.nodeIndex = t5, this._id2Meta.set(o6.id, o6), this._oid2Meta.set(o6.oid, o6);
  }
  getMeshNodeIndex(e12) {
    const t5 = this._oid2Meta.get(e12);
    return null == t5 || "mesh" !== t5.type ? null : t5.nodeIndex;
  }
  getMeshNodeInfo(e12) {
    const t5 = this._oid2Meta.values();
    for (const o6 of t5) if ("mesh" === o6.type && o6.id === e12) return o6;
    return null;
  }
  removeNode(e12) {
    const t5 = this._id2Meta.get(e12);
    null != t5 && (this._id2Meta.delete(e12), "mesh" === t5.type && this._oid2Meta.delete(t5.oid));
  }
  loadNodeJSON(t5) {
    return __async(this, null, function* () {
      const o6 = this._id2Meta.get(t5);
      if (null == o6) throw new s(`I3SClientNodeLoader::loadNodeJSON unable to find node ${t5}`);
      switch (o6.type) {
        case "mesh":
          return this._loadMeshNodeJSON(o6);
        case "mesh-component":
          return f2(o6);
        default:
          throw new s(`I3SClientNodeLoader::loadNodeJSON unable to handle node ${t5}`);
      }
    });
  }
  _loadMeshNodeJSON(e12) {
    return __async(this, null, function* () {
      const t5 = e12.id, o6 = (yield this._getMeshData(e12)).loadedMesh;
      if (null == o6.components || 0 === o6.components.length) return {
        id: t5,
        version: null,
        mbs: e12.mbs,
        obb: null,
        sharedResource: null,
        geometryData: null,
        attributeData: null,
        featureData: null,
        children: null
      };
      const r10 = [], n11 = o6.components;
      for (let s12 = 0; s12 < n11.length; ++s12) {
        const o7 = `${t5}-component${s12}`, n12 = {
          type: "mesh-component",
          id: o7,
          mbs: e12.mbs,
          componentIndex: s12,
          meshNodeInfo: e12,
          textureData: /* @__PURE__ */ new Map()
        };
        this._id2Meta.set(n12.id, n12), e12.componentNodeIds.push(o7), r10.push({
          id: n12.id,
          href: null,
          mbs: n12.mbs,
          obb: null
        });
      }
      return {
        id: t5,
        version: null,
        mbs: e12.mbs,
        obb: null,
        sharedResource: null,
        geometryData: null,
        attributeData: null,
        featureData: null,
        children: r10
      };
    });
  }
  updateNodeIndex(e12, t5, o6) {
    const r10 = this._id2Meta.get(e12);
    r10 && "mesh" === r10.type && (r10.nodeIndex = o6);
  }
  loadNodeData(o6, n11) {
    return __async(this, null, function* () {
      const s12 = this._id2Meta.get(o6);
      if (null == s12 || "mesh-component" !== s12.type) throw new s(`Failed to load client node data for node ${o6} (unexpected node info)`);
      const i4 = s12.meshNodeInfo, a13 = yield this._getMeshData(i4), l7 = a13.loadedMesh, d7 = i4.oid;
      if (null == l7.components) throw new s(`Failed to load client node data for node ${o6} (unexpected null reference)`);
      const u9 = l7.components[s12.componentIndex], {
        material: c5,
        requiredTextures: h7,
        textureData: f4
      } = yield c2(u9.material);
      if (null != f4) for (const e12 of f4) null != e12 && s12.textureData.set(e12.id, e12);
      const p5 = {
        params: {
          material: c5
        },
        type: "ArrayBufferView"
      }, {
        vertexSpace: g4,
        origin: M5,
        transform: S6
      } = l7, _7 = [M5.x, M5.y, M5.z ?? 0];
      a13.projectionPromise || (n3(this._worker, "SceneLayerWorker is needed to project mesh"), a13.projectionPromise = this._worker.project({
        positions: l7.vertexAttributes.position,
        localMatrix: S6?.localMatrix,
        vertexSpace: g4.toJSON(),
        origin: _7,
        inSpatialReference: l7.spatialReference.toJSON(),
        outSpatialReference: this._vertexSR.toJSON(),
        localMode: this._localMode
      }, n11));
      const {
        projected: w5,
        original: b6,
        projectedOrigin: N4
      } = yield a13.projectionPromise;
      l7.vertexAttributes.position = b6;
      const {
        transformed: v2,
        original: D5
      } = yield x2(u9, a13, this._worker, n11);
      l7.vertexAttributes.normal = D5, s2(n11);
      const {
        geometryBuffer: I7,
        geometryDescriptor: R4
      } = y4(w5, u9.faces, v2, l7.vertexAttributes.uv, l7.vertexAttributes.color, d7);
      return {
        geometryData: {
          featureDataPosition: N4,
          featureIds: [],
          geometries: [p5]
        },
        attributeDataInfo: {
          attributeData: {},
          loadedAttributes: []
        },
        geometryBuffer: I7,
        geometryDescriptor: R4,
        requiredTextures: h7,
        textureData: f4,
        normalReferenceFrame: this._vertexSR.isGeographic ? "east-north-up" : "vertex-reference-frame"
      };
    });
  }
  loadAttributes(e12, t5, o6) {
    return __async(this, null, function* () {
      const r10 = e12.numFeatures, n11 = {};
      for (const {
        field: {
          name: s12
        }
      } of t5) n11[s12] = new Array(r10);
      return n11;
    });
  }
  loadTextures(e12, t5, o6) {
    return __async(this, null, function* () {
      const r10 = e12.id, n11 = this._id2Meta.get(r10);
      if (null == n11 || "mesh-component" !== n11.type) throw new Error(`Failed to load textures for node ${e12.id} (unexpected node info)`);
      const s12 = [];
      for (const i4 of t5) s12.push(n11.textureData.get(i4.id) || null);
      return s12;
    });
  }
  _getMeshData(e12) {
    return __async(this, null, function* () {
      const t5 = e12.version, r10 = this._memCache.get(t5);
      if (null == r10) {
        if (null != e12.loadMeshPromise) return e12.loadMeshPromise;
        const r11 = (r12, n11) => __async(this, null, function* () {
          const s12 = e12.unloadedMesh.clone();
          try {
            yield s12.load();
          } catch (l7) {
            n11(l7);
          }
          const i4 = s12.memoryUsage, a13 = {
            loadedMesh: s12,
            projectionPromise: null,
            normalsTransformPromise: null,
            usedMemoryInBytes: i4
          };
          this._memCache.put(t5, a13, i4, e6), e12.loadMeshPromise = null, r12(a13);
        });
        return e12.loadMeshPromise = new Promise((e13, t6) => r11(e13, t6)), e12.loadMeshPromise;
      }
      return r10;
    });
  }
};
function f2(e12) {
  return __async(this, null, function* () {
    return {
      id: e12.id,
      version: e12.meshNodeInfo.version,
      mbs: e12.mbs,
      obb: null,
      sharedResource: null,
      geometryData: null,
      attributeData: null,
      featureData: null,
      children: null,
      isEmpty: false
    };
  });
}
function p4(e12, t5) {
  const {
    spatialReference: o6
  } = e12, r10 = [1, -1], n11 = [0.5 * e12.width, 0.5 * e12.height, e12.hasZ ? 0.5 * (e12.zmax - e12.zmin) : 0], s12 = o6.isGeographic ? o6.metersPerUnit : 1, i4 = e12.center;
  let a13 = 0;
  if (e12.hasZ) for (let l7 = 0; l7 < 2; ++l7) for (let e13 = 0; e13 < 2; ++e13) for (let o7 = 0; o7 < 2; ++o7) {
    const d7 = (i4.x + r10[l7] * n11[0] - t5.x) * s12, u9 = (i4.y + r10[e13] * n11[1] - t5.y) * s12, c5 = i4.z + r10[o7] * n11[2] - t5.z;
    a13 = Math.max(d7 * d7 + u9 * u9 + c5 * c5, a13);
  }
  else for (let l7 = 0; l7 < 2; ++l7) for (let e13 = 0; e13 < 2; ++e13) {
    const o7 = (i4.x + r10[l7] * n11[0] - t5.x) * s12, d7 = (i4.y + r10[e13] * n11[1] - t5.y) * s12;
    a13 = Math.max(o7 * o7 + d7 * d7, a13);
  }
  return k([t5.x, t5.y, t5.z], Math.sqrt(a13));
}
function x2(e12, o6, r10, n11) {
  return __async(this, null, function* () {
    const {
      transform: d7,
      vertexAttributes: u9
    } = o6.loadedMesh, c5 = "source" === e12.shading ? u9.normal : null;
    if (!(null != c5 && null != d7 && (0 !== d7.rotationAngle || !G2(d7.scale, _3)))) return {
      transformed: c5,
      original: u9.normal
    };
    if (!o6.normalsTransformPromise) {
      n3(r10, "SceneLayerWorker is needed to transform mesh normals");
      const e13 = e8();
      j(e13, d7.localMatrix), o6.normalsTransformPromise = r10.transformNormals({
        normalMatrix: e13,
        normals: c5
      }, n11);
    }
    return o6.normalsTransformPromise;
  });
}
function y4(e12, t5, o6, r10, n11, s12) {
  const i4 = 1, a13 = t5.length / 3, l7 = 3 * a13;
  let d7 = 0, u9 = 0, c5 = false, m4 = 0, h7 = false, f4 = 0, p5 = false, x5 = 0, y6 = 0, M5 = 0;
  d7 += S3, d7 += S3, u9 = d7, d7 += 3 * l7 * _5, null != o6 && (c5 = true, m4 = d7, d7 += 3 * l7 * _5), null != r10 && (h7 = true, f4 = d7, d7 += 2 * l7 * _5), null != n11 && (p5 = true, x5 = d7, d7 += 4 * l7 * w2), y6 = d7, d7 += i4 * b3, M5 = d7, d7 += 2 * i4 * S3;
  const N4 = new ArrayBuffer(d7), v2 = new Uint8Array(N4);
  g2(v2, 0, l7), g2(v2, S3, i4);
  const D5 = new Float32Array(N4, u9), I7 = null != o6 ? new Float32Array(N4, m4) : null, R4 = null != r10 ? new Float32Array(N4, f4) : null, j3 = null != n11 ? new Uint8Array(N4, x5) : null;
  for (let g4 = 0; g4 < a13; ++g4) {
    const s13 = 3 * g4;
    for (let i5 = 0; i5 < 3; ++i5) {
      const a14 = t5[s13 + i5], l8 = 3 * a14, d8 = 9 * g4 + 3 * i5;
      if (D5[d8] = e12[l8], D5[d8 + 1] = e12[l8 + 1], D5[d8 + 2] = e12[l8 + 2], null != I7 && (I7[d8] = o6[l8], I7[d8 + 1] = o6[l8 + 1], I7[d8 + 2] = o6[l8 + 2]), null != R4) {
        const e13 = 2 * a14, t6 = 6 * g4 + 2 * i5;
        R4[t6] = r10[e13], R4[t6 + 1] = r10[e13 + 1];
      }
      if (null != j3) {
        const e13 = 4 * a14, t6 = 12 * g4 + 4 * i5;
        j3[t6] = n11[e13], j3[t6 + 1] = n11[e13 + 1], j3[t6 + 2] = n11[e13 + 2], j3[t6 + 3] = n11[e13 + 3];
      }
    }
  }
  g2(v2, y6, s12), g2(v2, y6 + S3, s12 / 2 ** 32), g2(v2, M5, 0), g2(v2, M5 + S3, a13 - 1);
  return {
    geometryBuffer: N4,
    geometryDescriptor: {
      isDraco: false,
      isLegacy: true,
      color: p5,
      normal: c5,
      uv0: h7,
      uvRegion: false,
      featureIndex: true
    }
  };
}
function g2(e12, t5, o6) {
  e12[t5] = 255 & o6, e12[t5 + 1] = 255 & o6 >> 8, e12[t5 + 2] = 255 & o6 >> 16, e12[t5 + 3] = 255 & o6 >> 24;
}
function M(e12) {
  const t5 = e12.metadata.displaySource?.source;
  if (null == t5 || !Array.isArray(t5) || !t5.length || t5[0] instanceof File) return n5();
  const o6 = t5;
  let r10 = "";
  for (const n11 of o6) r10 += n11.makeHash();
  return r10 + JSON.stringify(e12.transform?.toJSON() ?? "") + (a7(e12.vertexSpace) ? JSON.stringify(e12.vertexSpace.origin) : "") + JSON.stringify(e12.spatialReference);
}
var S3 = 4;
var _5 = 4;
var w2 = 1;
var b3 = 8;

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/I3SFrameTask.js
var a11 = class extends S2 {
  constructor() {
    super(), this.referenceCount = 0, this.callbacks = new Array(), this.runIndex = 0;
  }
  get running() {
    return this.callbacks.some((r10) => r10.running);
  }
  runTask(r10) {
    this._sort();
    const s12 = this.callbacks, t5 = {
      numIndexLoading: 0,
      numNodesLoading: 0
    };
    for (let e12 = 0; e12 < s12.length && !r10.done; ++e12) s12[e12].priority = s12[e12].runTask(r10, t5), this.runIndex = e12;
  }
  _sort() {
    const r10 = this.callbacks;
    let s12 = r10.length;
    for (let t5 = this.runIndex; t5 > 0; t5--) {
      const e12 = r10[t5 - 1];
      let o6 = t5;
      for (; o6 < r10.length && e12.priority <= r10[o6].priority && (o6 !== s12 || e12.priority < r10[o6].priority); ) r10[o6 - 1] = r10[o6], o6++;
      r10[o6 - 1] = e12, s12 = o6 - 1;
    }
    this.runIndex = 0;
  }
  add(r10) {
    this._sort(), r10.priority = 1 / 0, this.callbacks.unshift(r10), this.notifyChange("running");
  }
  remove(r10) {
    S(this.callbacks, r10), this.runIndex = this.callbacks.length, this._sort(), this.notifyChange("running");
  }
};
e3([y({
  readOnly: true
})], a11.prototype, "running", null), a11 = e3([a3("esri.views.3d.layers.i3s.I3SFrameTask")], a11);
var l6 = class {
  constructor(r10, s12) {
    this.task = r10, this.handle = s12;
  }
};
var c3 = /* @__PURE__ */ new Map();
function h4(r10, s12) {
  let t5 = c3.get(r10);
  if (null == t5) {
    const s13 = new a11(), e12 = r10.registerTask(I3.I3S_CONTROLLER, s13);
    t5 = new l6(s13, e12), c3.set(r10, t5);
  }
  return t5.task.add(s12), e2(() => {
    if (null == t5) return;
    t5.task.remove(s12);
    t5.task.callbacks.length > 0 || (c3.delete(r10), t5.handle.remove(), t5.task.destroy()), t5 = null;
  });
}

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/ValidatedNode.js
var s11 = class {
  constructor(s12, t5, i4, e12, h7, o6, r10, c5) {
    this.id = s12, this.mbs = t5, this.obb = i4, this.version = e12, this.resources = h7, this.children = o6, this.lodSelection = r10, this.numFeatures = c5;
  }
};

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/I3SIndex.js
var N2 = class {
  constructor(e12, t5, i4, n11, s12) {
    this.childOffset = e12, this.childCount = t5, this.visibilityCache = i4, this.ref = n11, this.node = s12, this.useAsHole = 0, this.filterImpact = o2.NotChecked, this.traversalState = null, this.parent = -1;
  }
  invalidateBounds() {
    this.node?.invalidateServiceBVsInRenderSR(), this.ref?.invalidateServiceBVsInRenderSR();
  }
};
var b4 = class {
  constructor(e12 = new Array(), t5 = new Array()) {
    this.nodes = e12, this.children = t5, this.lastTraversed = 0, this.numNodesWithLoadedChildren = 0;
  }
};
var I6 = class {
  get _useNodePages() {
    return this._pageSize > 0;
  }
  constructor(t5, i4, n11, s12, o6, r10, d7, h7, u9, c5, g4, _7, f4, m4, v2, p5) {
    this.viewingMode = t5, this._layer = i4, this._streamDataController = s12, this._clientNodeLoader = o6, this._viewportQueries = r10, this._logger = d7, this.holeFilling = h7, this._isLoaded = u9, this._isReloading = c5, this._isSelected = g4, this._enable = _7, this._needsUpdate = f4, this._canRequest = m4, this._computeVisibilityObb = v2, this._computeNodeFiltering = p5, this._dirty = true, this._nodePages = /* @__PURE__ */ new Map(), this._clientNodePage = null, this._pageSize = 0, this._rootIndex = 0, this._lodMetric = d2.None, this._lodConversion = (e12) => e12, this._isEditable = false, this._urlPrefix = "", this._loadingNodes = /* @__PURE__ */ new Set(), this._loadingPages = /* @__PURE__ */ new Set(), this._failedNodes = /* @__PURE__ */ new Set(), this._failedPages = /* @__PURE__ */ new Set(), this._indexMissing = 1, this._maxUnloadedPrio = Number.NEGATIVE_INFINITY, this._maxProcessingPrio = Number.POSITIVE_INFINITY, this._version = R(0), this._visibilityCacheVersion = R(0), this._maxLevel = 1, this._featureEstimate = {
      estimate: 0,
      leavesReached: false
    }, this._unloadedMemoryEstimate = 0, this._missingPagesAndNodes = new l({
      deallocator: null
    }), this._prefetchNodes = new l({
      deallocator: null
    }), this._updates = new P3(this._missingPagesAndNodes), this._imModificationUncategorized = new l({
      deallocator: null
    }), this.ignoreServiceObb = false, this.progressiveLoadPenalty = 0, this._pageQueue = new Array(), this._newPages = new Array(), this.needNodeElevationRange = false, this.layerHasModifications = false, this._layerHasFilter = false, this._frameNumber = 0, this._traverseDescendantsQueue = [0], this._traverseDescendantsNestingLevel = 0, this._isEditable = r3() && null != i4.associatedLayer?.infoFor3D, i4.serviceUpdateTimeStamp?.lastUpdate && (this._lastUpdate = `${i4.serviceUpdateTimeStamp.lastUpdate}`), this._maxLodLevel = this._viewportQueries ? this._viewportQueries.maxLodLevel : 1, this._init(n11);
  }
  _init(e12) {
    if ("page" === e12.type) {
      const t5 = e12.rootPage;
      switch (this._urlPrefix = e12.urlPrefix, this._pageSize = e12.pageSize, e12.lodMetric) {
        case "maxScreenThreshold":
          this._lodMetric = d2.MaxScreenThreshold;
          break;
        case "maxScreenThresholdSQ":
          this._lodMetric = d2.MaxScreenThreshold, this._lodConversion = k3;
      }
      if (this._isEditable) {
        this._rootIndex = -1;
        const i4 = M2(e12.rootIndex, e12.pageSize), n11 = t5.nodes[i4], s12 = {
          nodes: [{
            index: this._rootIndex,
            children: [e12.rootIndex],
            mesh: void 0,
            obb: n11.obb,
            lodThreshold: n11.lodThreshold
          }]
        };
        this._addPage(E(this._rootIndex, this._pageSize), s12), this.getNode(-1).serviceObbInIndexSR = void 0;
      } else this._rootIndex = e12.rootIndex;
      this._addPage(E(e12.rootIndex, this._pageSize), t5), this._updateParentsAndLevel();
    } else if ("node" === e12.type) {
      this._urlPrefix = e12.urlPrefix;
      const t5 = new b4();
      if (this._nodePages.set(0, t5), this._isEditable) {
        this._clientNodePage = new b4();
        const t6 = {
          id: "-1",
          version: null,
          mbs: e12.rootNode.mbs,
          obb: e12.rootNode.obb,
          sharedResource: null,
          geometryData: null,
          attributeData: null,
          featureData: null,
          children: [{
            id: "root",
            href: "../root",
            mbs: e12.rootNode.mbs,
            obb: e12.rootNode.obb
          }]
        };
        this._rootIndex = this._makeClientRefNode(new s6(t6.id, null), -1);
        const i5 = this._validateNode(t6.id, t6);
        i5 && this._addNode(i5, this._rootIndex);
      } else this._rootIndex = this._makeRefNode(new s6(e12.rootNode.id, null), -1);
      const i4 = this._validateNode(e12.rootNode.id, e12.rootNode);
      i4 && this._addNode(i4, 0);
    }
  }
  addClientNodeToIndex(e12, t5) {
    const i4 = -1, n11 = new s6(e12, t5), s12 = this._makeClientRefNode(n11, i4);
    return this._linkChildToParentNode(i4, s12), this.requestUpdate(), s12;
  }
  removeClientNodeFromIndex(e12, t5, i4) {
    this._destroyClientRefNode(e12, t5, i4), this.requestUpdate();
  }
  _loadPage(e12) {
    this._loadingPages.add(e12);
    const i4 = this._urlPrefix + e12;
    this._streamDataController.request(i4, "json").then((t5) => {
      this._pageQueue.push({
        pageIndex: e12,
        page: t5
      });
    }).catch((i5) => {
      this._loadingPages.delete(e12), b(i5) || (this._failedPages.add(e12), this._logger.error("#loadPage()", this._layer, `Error when loading page ${e12}`, i5));
    });
  }
  _addQueuedPages(e12) {
    for (; this._pageQueue.length > 0 && !e12.done; ) {
      const {
        pageIndex: t5,
        page: i4
      } = this._pageQueue.shift();
      this._addPage(t5, i4), this._loadingPages.delete(t5), e12.madeProgress(), this.needNodeElevationRange && this._newPages.push(t5);
    }
    this._updateParentsAndLevel();
  }
  _invalidateElevationRangeForNewPages(e12) {
    if (this.needNodeElevationRange) for (; this._newPages.length > 0 && !e12.done; ) {
      const e13 = this._nodePages.get(this._newPages.shift());
      e13?.nodes.forEach((e14) => {
        let t5 = e14.parent;
        for (; null != t5 && t5 !== this._rootIndex; ) {
          const e15 = this.getNode(t5);
          e15 && !Number.isNaN(e15?.elevationRangeMin) && (e15.invalidateElevationRange(), this.invalidateBoundingVolumeCache(t5)), t5 = this.getParentIndex(t5);
        }
      });
    }
  }
  _addPage(e12, t5) {
    const i4 = [], s12 = [], o6 = t5.nodes.map((t6, o7) => {
      const r11 = i4.length, a13 = t6.children ? t6.children.length : 0;
      s12.push(this._rootIndex);
      for (let e13 = 0; e13 < a13; e13++) i4.push(t6.children[e13]);
      const l7 = `${t6.index}`, d7 = I2.fromJSON(t6.obb), u9 = k(d7.center, d7.radius), c5 = t6.mesh?.attribute, g4 = t6.mesh?.geometry, _7 = t6.mesh?.material, f4 = {
        hasSharedResource: false,
        isEmpty: null == g4,
        attributes: null != c5?.resource ? `${c5.resource}` : void 0,
        geometry: null != g4?.resource ? `${g4.resource}` : void 0,
        texture: null != _7?.resource ? `${_7.resource}` : void 0,
        geometryDefinition: g4 ? g4.definition : -1,
        materialDefinition: _7 ? _7.definition : -1
      }, m4 = new h2(l7, V4(o7, e12, this._pageSize), u9, a13, 0, f4, this._lastUpdate, this._lodMetric, this._lodConversion(t6.lodThreshold), g4 ? g4.featureCount : null);
      return m4.serviceObbInIndexSR = d7, m4.visibilityObbInRenderSR = this._computeVisibilityObb(m4), m4.vertexCount = g4 ? g4.vertexCount : 0, new N2(r11, a13, x3(this._visibilityCacheVersion), null, m4);
    }), r10 = new b4(o6, i4);
    -1 === e12 ? this._clientNodePage = r10 : this._nodePages.set(e12, r10);
  }
  _updateParentsAndLevel() {
    const e12 = new Array(), t5 = (t6, i4, n11) => {
      const s12 = this._getPage(t6);
      if (null != s12) {
        const o6 = M2(t6, this._pageSize), r10 = s12.nodes[o6];
        r10.parent = null != i4 ? i4 : -1;
        const a13 = r10.node;
        null != a13 && (a13.level = n11, e12.push(t6));
      }
    };
    for (t5(this._rootIndex, null, 0); e12.length; ) {
      const i4 = e12.pop(), n11 = this.getNode(i4);
      if (null != n11) for (let e13 = 0; e13 < n11.childCount; e13++) {
        t5(this.getChildIndex(n11.index, e13), i4, n11.level + 1), this._maxLevel = Math.max(this._maxLevel, n11.level + 1);
      }
    }
  }
  _getPage(e12) {
    const t5 = E(e12, this._pageSize);
    return this._getPageFromPageIndex(t5);
  }
  _getPageFromPageIndex(e12) {
    return e12 < 0 ? this._clientNodePage : this._nodePages.get(e12);
  }
  _getNodeInternal(e12) {
    const t5 = this._getPage(e12);
    return null == t5 ? null : (t5.lastTraversed = this._frameNumber, t5.nodes[M2(e12, this._pageSize)]);
  }
  _addNode(e12, t5) {
    e12.children && this.populateChildren(t5, e12.children);
    const i4 = this.getParent(t5), n11 = null != i4 ? i4.level + 1 : 0;
    this._maxLevel = Math.max(this._maxLevel, e12.children ? n11 + 1 : n11);
    const {
      lodMetric: s12,
      maxError: o6
    } = A2(e12.lodSelection), r10 = this._getNodeInternal(t5), a13 = new h2(e12.id, t5, e12.mbs, r10.childCount, n11, e12.resources, e12.version, s12, o6, e12.numFeatures);
    r10.node = a13, e12.obb && (a13.serviceObbInIndexSR = I2.fromJSON(e12.obb)), a13.visibilityObbInRenderSR = this._computeVisibilityObb(a13);
    const l7 = r10.ref;
    return null != l7 && (null == l7.serviceMbsInIndexSR && (l7.serviceMbsInIndexSR = e12.mbs), a13.shareServiceBVsInRenderSRWith(l7), l7.visibilityObbInRenderSR = a13.visibilityObbInRenderSR), a13;
  }
  _makeRefNode(e12, t5) {
    const i4 = this._nodePages.get(0);
    if (t5 < -1) return this._makeClientRefNode(e12, t5);
    if (null == i4) return -1;
    const n11 = i4.nodes.length, s12 = new N2(0, 0, x3(this._visibilityCacheVersion), e12, null);
    return i4.nodes.push(s12), s12.parent = t5, e12.invalidateServiceBVsInRenderSR(), n11;
  }
  _makeClientRefNode(e12, t5) {
    const i4 = this._clientNodePage;
    if (null == i4) return -1;
    if (t5 >= 0) throw new Error("I3SIndex::client side nodes can not be made children of service side nodes.");
    const n11 = -(i4.nodes.length + 1), s12 = new N2(0, 0, x3(this._visibilityCacheVersion), e12, null);
    return i4.nodes.push(s12), s12.parent = t5, e12.invalidateServiceBVsInRenderSR(), n11;
  }
  _linkChildToParentNode(e12, t5) {
    const i4 = this._clientNodePage;
    if (null == i4 || e12 >= 0) return;
    const n11 = M2(e12, this._pageSize), s12 = M2(t5, this._pageSize), o6 = i4.nodes[n11], r10 = o6.childOffset;
    i4.children.splice(o6.childOffset + o6.childCount, 0, t5);
    const a13 = 1;
    o6.childCount += a13, null != o6.node && (o6.node.childCount += a13);
    for (const l7 of i4.nodes) l7.childOffset > r10 && (l7.childOffset += a13);
    i4.nodes[s12].parent = e12, this._updateParentBoundingInformation(e12);
  }
  _destroyClientRefNode(e12, t5, i4) {
    const n11 = this._clientNodePage;
    if (null == n11) return;
    const s12 = this.getParentIndex(e12);
    if (null == s12) return;
    const o6 = /* @__PURE__ */ new Set(), r10 = /* @__PURE__ */ new Map(), a13 = (e13) => {
      const i5 = M2(e13, this._pageSize), s13 = n11.nodes[i5];
      if (s13.childCount > 0) for (let t6 = s13.childOffset; t6 < s13.childOffset + s13.childCount; ++t6) a13(n11.children[t6]);
      const r11 = s13.node?.id ?? s13.ref?.id;
      if (null == r11) throw new Error("Node has no id");
      t5(r11, e13), o6.add(s13);
    };
    a13(e12);
    const l7 = n11.nodes, d7 = n11.children, h7 = n11.nodes.map(() => -1), u9 = [], c5 = [];
    for (let g4 = 0; g4 < l7.length; ++g4) {
      const e13 = l7[g4];
      if (o6.has(e13)) continue;
      const t6 = u9.length, n12 = V4(g4, -1, this._pageSize), s13 = V4(t6, -1, this._pageSize);
      if (e13.node && (e13.node.index = s13), h7[g4] = s13, u9.push(e13), n12 !== s13) {
        const t7 = e13.node?.id ?? e13.ref?.id;
        if (null == t7) throw new Error("Node has no id");
        i4(t7, n12, s13), r10.set(n12, s13);
      }
    }
    for (let g4 = 0; g4 < u9.length; ++g4) {
      const e13 = V4(g4, -1, this._pageSize), t6 = u9[g4], i5 = c5.length;
      for (let n12 = t6.childOffset; n12 < t6.childOffset + t6.childCount; ++n12) {
        const t7 = d7[n12];
        if (t7 >= 0) c5.push(t7);
        else {
          const i6 = M2(t7, this._pageSize), n13 = l7[i6];
          if (o6.has(n13)) continue;
          const s13 = h7[i6];
          c5.push(s13), n13.parent = e13;
        }
      }
      t6.childOffset = i5, t6.childCount = c5.length - i5, t6.node && (t6.node.childCount = t6.childCount);
    }
    n11.nodes = u9, n11.children = c5, this._updateParentBoundingInformation(h7[M2(s12, this._pageSize)]);
  }
  _updateParentBoundingInformation(e12) {
    let t5 = e12;
    do {
      let e13 = null;
      const n11 = this._clientNodeLoader.indexSR, a13 = this._clientNodeLoader.renderSR, l7 = this._getNodeInternal(t5);
      if (null == l7) return;
      for (let r10 = 0; r10 < l7.childCount; r10++) {
        const l8 = this.getChildIndex(t5, r10), d8 = this._getNodeInternal(l8), h7 = null != d8 ? d8.ref || d8.node : null;
        if (null != h7 && h7.serviceMbsInIndexSR[3] > 0) if (null == e13) e13 = T(h7.serviceMbsInIndexSR, D2);
        else {
          const t6 = F3, s12 = z3, r11 = T2;
          a9(h7.serviceMbsInIndexSR, n11, t6, a13), a9(e13, n11, s12, a13), et(t6, s12, r11), a9(r11, a13, e13, n11);
        }
      }
      const d7 = l7.ref || l7.node;
      null != d7 && (null != e13 ? (d7.serviceMbsInIndexSR ??= _4(), T(e13, d7.serviceMbsInIndexSR)) : ge(d7.serviceMbsInIndexSR), d7.invalidateServiceBVsInRenderSR(), d7.geometryObbInRenderSR = null), this.invalidateNodeVisibilityCacheInternal(l7), t5 = this.getParentIndex(t5);
    } while (null != t5);
  }
  populateChildren(e12, t5) {
    const i4 = this._getNodeInternal(e12), n11 = this._getPage(e12);
    i4.childOffset = n11.children.length, i4.childCount = t5.length;
    for (let s12 = 0; s12 < t5.length; s12++) {
      const i5 = this._makeRefNode(t5[s12], e12);
      n11.children.push(i5);
    }
  }
  getNode(e12) {
    const t5 = this._getNodeInternal(e12);
    return null != t5 ? t5.node : null;
  }
  getIndexById(e12) {
    let t5;
    return this._forAllNodes((i4, n11) => {
      (null != i4.node && i4.node.id === e12 || null != i4.ref && i4.ref.id === e12) && (t5 = n11);
    }), t5;
  }
  getNodeById(e12) {
    const t5 = this.getIndexById(e12);
    return null != t5 && t5 >= 0 ? this.getNode(t5) : null;
  }
  getChildIndex(e12, t5) {
    const i4 = this._getPage(e12);
    if (null == i4) return -1;
    const n11 = i4.nodes[M2(e12, this._pageSize)];
    return i4.children[n11.childOffset + t5];
  }
  getParentIndex(e12) {
    const t5 = this._getPage(e12);
    return null != t5 && e12 !== this._rootIndex ? t5.nodes[M2(e12, this._pageSize)].parent : null;
  }
  getParent(e12) {
    const t5 = this.getParentIndex(e12);
    return null != t5 ? this.getNode(t5) : null;
  }
  isLeaf(e12) {
    const t5 = this._getNodeInternal(e12);
    return null != t5 && 0 === t5.childCount;
  }
  get rootNode() {
    return this.getNode(this._rootIndex);
  }
  get isEditable() {
    return this._isEditable;
  }
  removeAllGeometryObbs() {
    this._forAllNodes((e12) => {
      null != e12.node && (e12.node.geometryObbInRenderSR = null);
    });
  }
  invalidateVisibilityCache() {
    this._visibilityCacheVersion = R(this._visibilityCacheVersion);
  }
  invalidateNodeVisibilityCache(e12) {
    const t5 = this._getNodeInternal(e12);
    null != t5 && this.invalidateNodeVisibilityCacheInternal(t5);
  }
  invalidateNodeVisibilityCacheInternal(e12) {
    e12.visibilityCache = x3(this._visibilityCacheVersion);
  }
  invalidateBoundingVolumeCache(e12) {
    const t5 = this._getNodeInternal(e12);
    null != t5 && (t5?.invalidateBounds(), this.invalidateNodeVisibilityCacheInternal(t5));
  }
  updateElevationChanged(e12) {
    const t5 = this._getNodeInternal(e12);
    if (null == t5) return;
    if (!this.needNodeElevationRange) return void this.invalidateBoundingVolumeCache(e12);
    const i4 = null != t5.node ? t5.node : t5.ref;
    null != i4 && i4.invalidateElevationRange();
  }
  invalidateGeometryVisibility(e12) {
    const t5 = this._getNodeInternal(e12), i4 = t5?.node;
    i4 && (i4.geometryObbInRenderSR = null, i4.invalidateServiceBVsInRenderSR());
  }
  invalidateVisibilityObbs() {
    null != this.rootNode && this.traverse(this.rootNode, (e12) => (e12.visibilityObbInRenderSR = this._computeVisibilityObb(e12), e12.geometryObbInRenderSR = null, true));
  }
  _isElevationRangeUpToDate(e12) {
    if (!this.needNodeElevationRange) return true;
    const t5 = e12?.node ?? e12?.ref;
    return !t5 || t5.elevationRangeValid;
  }
  updateElevationRange(e12) {
    this._updateElevationRangeInternal(e12, null);
  }
  _updateElevationRangeInternal(e12, t5) {
    const i4 = this._getNodeInternal(e12);
    if (!i4) return false;
    const n11 = i4?.node ?? i4?.ref;
    if (!n11) return false;
    if (n11.elevationRangeValid) return t5?.expandElevationRange(n11), true;
    const s12 = new e9();
    let o6 = false;
    for (let l7 = 0; l7 < i4.childCount; l7++) {
      const t6 = this.getChildIndex(e12, l7), i5 = this._updateElevationRangeInternal(t6, s12);
      o6 = o6 || !i5;
    }
    if (0 === i4.childCount || o6) {
      const e13 = !i4.node?.resources.isEmpty;
      this._viewportQueries.expandElevationRange(n11, e13, s12);
    }
    const r10 = n11.elevationRangeMin, a13 = n11.elevationRangeMax;
    return r10 === s12.elevationRangeMin && a13 === s12.elevationRangeMax ? (t5?.expandElevationRange(n11), true) : (i4.node?.setElevationRange(s12), i4.ref?.setElevationRange(s12), this.invalidateBoundingVolumeCache(e12), t5?.expandElevationRange(n11), true);
  }
  isNodeVisible(e12) {
    const t5 = this._getNodeInternal(e12);
    if (null == t5) return true;
    const i4 = t5.ref;
    if (null != i4 && !i4.serviceMbsInIndexSR) return true;
    if (this._isElevationRangeUpToDate(t5) && C3(t5.visibilityCache, this._visibilityCacheVersion)) return w3(t5.visibilityCache);
    const n11 = t5.node, s12 = this._viewportQueries;
    if (n11) {
      const e13 = s12.ensureElevationAgnosticBoundingVolume(n11), i5 = s12.isElevationAgnosticBoundingVolumeVisible(e13);
      let o7 = i5;
      if (this.needNodeElevationRange && i5) {
        const t6 = s12.getNodeObbInRenderSRIndependentOfElevationOffset(n11);
        null != t6 && (o7 = s12.isObbVisibleIndependentOfElevation(e13, t6));
      }
      if (!o7) return t5.visibilityCache = S4(false, this._visibilityCacheVersion), false;
    }
    if (this._layerHasFilter && this._computeNodeFiltering && (null != n11 || null != i4) && t5.filterImpact === o2.NotChecked) {
      const e13 = null != n11 ? n11.serviceMbsInIndexSR : null != i4 ? i4.serviceMbsInIndexSR : null;
      t5.filterImpact = null != e13 ? this._computeNodeFiltering(e13) : o2.Unmodified;
    }
    const o6 = null != n11 && t5.filterImpact === o2.Culled;
    let r10 = !(null != n11 && n11.imModificationImpact === r5.Culled) && !o6;
    if (r10) {
      const t6 = !n11 || i4 && !n11.visibilityObbInRenderSR ? i4 ?? null : n11;
      if (null != t6) {
        this.needNodeElevationRange && this.updateElevationRange(e12);
        r10 = s12.isNodeVisible(t6);
      }
    }
    return t5.visibilityCache = S4(r10, this._visibilityCacheVersion), r10;
  }
  isGeometryVisible(e12) {
    if (!this.isNodeVisible(e12)) return false;
    const t5 = this._getNodeInternal(e12);
    return !!(null == t5?.node?.geometryObbInRenderSR || this.layerHasModifications && t5.node.imModificationImpact === r5.NotChecked) || this._viewportQueries.isGeometryVisible(t5.node);
  }
  _traverseCoverage(e12, t5, i4, n11, s12) {
    const o6 = this._getPage(e12);
    if (null == o6 || 0 === t5.childCount) return;
    const r10 = t5.childOffset + t5.childCount, a13 = new Array();
    for (let l7 = t5.childOffset; l7 < r10; ++l7) {
      const e13 = o6.children[l7], t6 = this._getNodeInternal(e13);
      null != t6?.node && this.isGeometryVisible(e13) && a13.push(t6);
    }
    n11 /= a13.length;
    for (const l7 of a13) {
      const e13 = l7.node.index;
      this._isLoaded(e13) || this._isReloading(e13) ? (s12.delta = Math.max(s12.delta, i4), s12.coverage += n11) : this._traverseCoverage(e13, l7, i4 + 1, n11, s12);
    }
  }
  useNodeAsHole(e12) {
    if ("off" === this.holeFilling) return false;
    const t5 = this._getNodeInternal(e12);
    if (null == t5) return false;
    if ("always" === this.holeFilling) return true;
    if (C3(t5.useAsHole, this._version)) return w3(t5.useAsHole);
    const i4 = {
      delta: 0,
      coverage: 0
    };
    this._traverseCoverage(e12, t5, 0, 1, i4);
    const n11 = i4.delta * i4.coverage <= 0.5;
    return t5.useAsHole = S4(n11, this._version), n11;
  }
  get maxLevel() {
    return this._maxLevel;
  }
  get dirty() {
    return this._dirty;
  }
  destroy() {
    this._updates.add.prune(), this._updates.update.prune();
  }
  requestUpdate() {
    this._dirty = true, this._indexMissing = 1, this._version = R(this._version);
  }
  imModificationsChanged(e12) {
    this.layerHasModifications = e12, this._forAllNodes(({
      node: e13
    }) => {
      null != e13 && (e13.imModificationImpact = r5.NotChecked, e13.visibilityObbInRenderSR = this._computeVisibilityObb(e13), e13.hasModifications && this.invalidateGeometryVisibility(e13.index));
    }), this.invalidateVisibilityCache();
  }
  layerFilterChanged(e12) {
    this._layerHasFilter = e12, this._forAllNodes((e13) => {
      if (null != e13) {
        e13.filterImpact = o2.NotChecked;
        const t5 = e13.node;
        null != t5 && this.invalidateNodeVisibilityCache(t5.index);
      }
    }), this.invalidateVisibilityCache();
  }
  update(e12, t5, i4) {
    if (!this._dirty) return;
    this._pageQueue.length > 0 && this._addQueuedPages(t5), this._invalidateElevationRangeForNewPages(t5), this._maxUnloadedPrio = Number.NEGATIVE_INFINITY, this._maxProcessingPrio = Number.NEGATIVE_INFINITY, this._missingPagesAndNodes.clear(), this._prefetchNodes.clear(), this._updates.reset(e12), y5.clear();
    let n11 = true;
    const s12 = new L4(), o6 = new L4(), r10 = this._imModificationUncategorized;
    r10.clear();
    const a13 = /* @__PURE__ */ new Set();
    let l7 = 0;
    const d7 = (a14, d8, h8) => {
      const u9 = E(a14, this._pageSize);
      if (null == d8) {
        let e13 = this._entryPriority(a14);
        return e13 === 1 / 0 && (e13 = this._entryPriority(h8)), y5.set(u9, Math.max(e13, y5.get(u9) || 0)), this._loadingPages.has(u9) || this._failedPages.has(u9) || (this._missingPagesAndNodes.push(u9), ++l7), void (this._maxProcessingPrio = Math.max(this._maxProcessingPrio, e13));
      }
      const g4 = d8.node;
      if (this._updateNodeFeatureEstimate(g4, o6), null == g4) {
        const e13 = this._entryPriority(a14);
        return this._loadingNodes.has(a14) || this._failedNodes.has(a14) || (this._missingPagesAndNodes.push(a14), y5.set(a14, e13)), void (this._maxProcessingPrio = Math.max(this._maxProcessingPrio, e13));
      }
      const _7 = this._getPage(a14);
      if (0 === this._missingPagesAndNodes.length && !this._useNodePages) for (let e13 = 0; e13 < d8.childCount; e13++) {
        const t6 = _7.children[d8.childOffset + e13], i5 = this._getNodeInternal(t6);
        null == i5 || i5.node || this._loadingNodes.has(t6) || this._failedNodes.has(t6) || (y5.set(t6, this._entryPriority(t6)), this._prefetchNodes.push(t6));
      }
      if (g4.failed || g4.resources.isEmpty) return void (n11 && d8.childCount > 0 && this._isSelected(g4) && (n11 = false));
      if (this._isLoaded(a14)) {
        if (s12.known += g4.memory, ++s12.knownNodes, this._isSelected(g4) ? d8.childCount > 0 && (n11 = false) : (s12.unremoved += g4.memory, n11 = false), this._needsUpdate(g4)) {
          const e13 = this._entryPriority(a14);
          y5.set(a14, e13), this._maxProcessingPrio = Math.max(this._maxProcessingPrio, e13), this._updates.update.push(a14);
        }
        return;
      }
      if (g4.memory && (s12.known += g4.memory, ++s12.knownNodes), !this._isSelected(g4)) return void (this._isReloading(a14) && this._updates.remove.push(a14));
      if (d8.childCount > 0 && (n11 = false), g4.memory ? (s12.missing += g4.memory, s12.known += g4.memory, ++s12.knownNodes) : ++s12.missingNodes, e12.includes(g4.index)) return this._maxProcessingPrio = Math.max(this._maxProcessingPrio, this._entryPriority(a14)), void (this._updates.cancel = this._updates.cancel.filter((e13) => e13 !== g4.index));
      if (!t5.done && this._enable(g4)) return void t5.madeProgress();
      const f4 = this._entryPriority(a14);
      y5.set(a14, f4), this._maxProcessingPrio = Math.max(this._maxProcessingPrio, f4), this._updates.add.push(a14), this.layerHasModifications && i4 && null != g4 && g4.imModificationImpact === r5.NotChecked && r10.push(a14);
    };
    this.traverseVisible(d7, a13), this._frameNumber++, this._missingPagesAndNodes.sort((e13, t6) => e13 - t6), this._missingPagesAndNodes.filterInPlace((e13, t6) => t6 < 1 || this._missingPagesAndNodes.data[t6 - 1] !== e13), this._missingPagesAndNodes.sort((e13, t6) => y5.get(e13) - y5.get(t6)), this._missingPagesAndNodes.length > 0 && (this._maxUnloadedPrio = y5.get(this._missingPagesAndNodes.back()), this._prefetchNodes.clear()), this._removeUnusedNodePages(a13, l7);
    const h7 = this._updates.add;
    h7.length > 0 && this.layerHasModifications && (r10.length > 0 && i4?.(r10), h7.filterInPlace((e13) => {
      const t6 = this._getNodeInternal(e13), i5 = null == t6?.node || t6.node.imModificationImpact !== r5.Culled;
      return i5 || this.invalidateNodeVisibilityCache(e13), i5;
    })), this._unloadedMemoryEstimate = s12.missing - s12.unremoved, s12.knownNodes > 3 && s12.missingNodes > 0 && (this._unloadedMemoryEstimate += s12.known / s12.knownNodes * s12.missingNodes), this._unloadedMemoryEstimate = 0.8 * Math.max(0, this._unloadedMemoryEstimate), this._featureEstimate.estimate = this._computeFeatureEstimate(o6), this._featureEstimate.leavesReached = n11, this._updates.add.filterInPlace((e13) => y5.get(e13) >= this._maxUnloadedPrio).sort((e13, t6) => y5.get(e13) - y5.get(t6)), this._updates.update.sort((e13, t6) => y5.get(e13) - y5.get(t6)), this._indexMissing = this._loadingPages.size + this._loadingNodes.size + this._missingPagesAndNodes.length, this._dirty = this._indexMissing > 0, y5.clear();
  }
  checkFeatureTarget(e12, t5) {
    const i4 = this._viewportQueries.updateScreenSpaceErrorBias(t5);
    let n11 = t5, s12 = t5, o6 = i4, r10 = 10;
    for (; r10--; ) {
      const i5 = new L4();
      this._updateFeatureEstimate(n11, i5);
      if (this._computeFeatureEstimate(i5) <= e12) {
        if (n11 >= t5 || i5.missingNodes > 0 || 0 === r10) break;
        o6 = n11, n11 = 0.5 * (n11 + s12);
      } else s12 = n11, n11 = 0.5 * (n11 + o6);
    }
    return this._version = R(this._version), this._viewportQueries.updateScreenSpaceErrorBias(i4), Math.min(t5, n11);
  }
  _removeUnusedNodePages(e12, t5) {
    if (!this._useNodePages) return;
    const i4 = e12.size, n11 = this._nodePages, s12 = n11.size + this._loadingPages.size + t5;
    if (s12 > B && s12 > i4) {
      const t6 = new Array();
      for (const [i5, s13] of n11) 0 !== s13.numNodesWithLoadedChildren || e12.has(i5) || t6.push([s13.lastTraversed, i5]);
      t6.sort((e13, t7) => e13[0] - t7[0]).some((e13) => {
        const t7 = e13[1];
        return this._deleteNodePage(t7), n11.size <= B;
      });
    }
  }
  _updateFeatureEstimate(e12, t5) {
    this._version = R(this._version), this._viewportQueries.updateScreenSpaceErrorBias(e12), this.traverseVisible((e13, i4) => this._updateNodeFeatureEstimate(null != i4 ? i4.node : void 0, t5));
  }
  _updateNodeFeatureEstimate(e12, t5) {
    null == e12 || e12.failed || null == e12.numFeatures || this._isSelected(e12) && (null != e12.numFeatures ? (t5.missing += e12.numFeatures, t5.known += e12.numFeatures, ++t5.knownNodes) : ++t5.missingNodes);
  }
  _computeFeatureEstimate(e12) {
    let t5 = e12.known - e12.unremoved;
    return e12.knownNodes > 3 && e12.missingNodes > 0 && (t5 += e12.known / e12.knownNodes * e12.missingNodes), Math.max(0, t5);
  }
  load() {
    return this._load(this._missingPagesAndNodes);
  }
  prefetch() {
    return this._prefetchNodes.sort((e12, t5) => y5.get(e12) - y5.get(t5)), this._load(this._prefetchNodes);
  }
  _load(e12) {
    if (0 === e12.length || !this._canRequest()) return false;
    for (; e12.length > 0 && this._canRequest(); ) {
      const t5 = e12.pop();
      this._useNodePages && t5 >= 0 ? this._loadPage(t5) : this._loadNode(t5);
    }
    return true;
  }
  get isLoading() {
    return this._indexMissing > 0;
  }
  get isPrefetching() {
    return this._prefetchNodes.length > 0;
  }
  get indexLoading() {
    return this._loadingPages.size + this._loadingNodes.size;
  }
  get indexMissing() {
    return this._indexMissing;
  }
  get unloadedMemoryEstimate() {
    return this._unloadedMemoryEstimate;
  }
  get updates() {
    return this._updates;
  }
  get featureEstimate() {
    return this._featureEstimate;
  }
  get maxPriority() {
    return Math.max(this._maxProcessingPrio, this._maxUnloadedPrio);
  }
  nodeTraversalState(e12) {
    if (null == e12) return null;
    const t5 = e12.index, i4 = this._getNodeInternal(t5);
    if (!i4) return null;
    let n11 = i4?.traversalState;
    if (n11 && C3(n11.version, this._version)) return n11;
    const s12 = this._viewportQueries.getLodLevel(e12), o6 = this._viewportQueries.hasLOD(e12);
    let r10 = true;
    if (o6) {
      const e13 = this.getParentIndex(t5);
      if (null != e13) {
        const t6 = this._getNodeInternal(e13), i5 = t6?.traversalState;
        r10 = !!i5 && s12 > i5.lodLevel;
      } else r10 = s12 > 0;
    } else r10 = 0 === e12.childCount;
    return n11 ? (n11.lodLevel = s12, n11.isChosen = r10, n11.version = S4(true, this._version), n11) : (n11 = new l4(o6, r10, s12, S4(true, this._version)), i4.traversalState = n11, n11);
  }
  _loadNode(e12) {
    return __async(this, null, function* () {
      this._loadingNodes.add(e12);
      const i4 = this._getNodeInternal(e12).ref;
      if (null == i4) return void this._failedNodes.add(e12);
      const n11 = i4.id, s12 = this._urlPrefix + n11, o6 = () => {
        this._loadingNodes.delete(e12), 0 === this._missingPagesAndNodes.length && 0 === this._loadingNodes.size && this.requestUpdate();
      };
      let r10 = null;
      try {
        r10 = e12 >= 0 ? yield this._streamDataController.request(s12, "json") : yield this._clientNodeLoader.loadNodeJSON(n11);
      } catch (d7) {
        return o6(), void (b(d7) || (this._logger.error("#loadNode()", this._layer, "Error loading node: " + s12), this._failedNodes.add(e12)));
      }
      o6();
      const a13 = this._validateNode(n11, r10);
      if (null == a13) return;
      a13.obb && this.invalidateNodeVisibilityCache(e12);
      const l7 = this._addNode(a13, e12);
      this.nodeTraversalState(l7);
    });
  }
  _validateNode(e12, t5) {
    if (null == t5 || "object" != typeof t5 || t5.id !== e12) return this._logger.error("#validateNode()", this._layer, `Invalid node. Wrong type or wrong id "${e12}"`), null;
    if (!Array.isArray(t5.mbs)) return this._logger.error("#validateNode()", this._layer, `Invalid bounding volume on node ${e12}.`), null;
    t5.sharedResource && "./shared" !== t5.sharedResource.href && "./shared/" !== t5.sharedResource.href && this._logger.warn("#validateNode()", this._layer, `Invalid shared resource href on node "${e12}"`);
    const i4 = t5.geometryData;
    null == i4 || Array.isArray(i4) && 0 === i4.length || Array.isArray(i4) && 1 === i4.length && "./geometries/0" === i4[0].href || this._logger.warn("#validateNode()", this._layer, `Invalid geometry data on node "${e12}"`);
    const n11 = t5.attributeData, s12 = this._layer.attributeStorageInfo;
    null == n11 || Array.isArray(n11) && !n11.some((e13, t6) => e13.href !== `./attributes/${s12?.[t6]?.key ?? `f_${t6}`}/0`) || this._logger.warn("#validateNode()", this._layer, `Invalid attribute data on node "${e12}"`), t5.featureData && t5.featureData.length > 1 && this._logger.warn("#validateNode()", this._layer, `Node ${e12} has ${t5.featureData.length} bundles. Only the first bundle will be loaded.`);
    const o6 = t5.hasOwnProperty("obb") && !this.ignoreServiceObb ? t5.obb : void 0, r10 = t5.featureData && 1 === t5.featureData.length && t5.featureData[0].featureRange ? t5.featureData[0].featureRange[1] - t5.featureData[0].featureRange[0] + 1 : void 0, a13 = (t6) => {
      if (null == t6) return null;
      const i5 = (t7) => this._logger.error("#validateNode()", this._layer, `Invalid node reference on node ${e12}: ${t7}`);
      if ("number" == typeof t6.id) i5(`id ${t6.id} is a number instead of a string.`);
      else if ("string" != typeof t6.id || !Array.isArray(t6.mbs)) return i5("Missing or invalid id."), null;
      if (!Array.isArray(t6.mbs)) return i5(`Invalid bounding volume on reference ${t6.id}.`), null;
      t6.href && t6.href !== "../" + t6.id && this._logger.error("#validateNode()", this._layer, `Invalid node href on node "${e12}"`);
      const n12 = new s6(`${t6.id}`, t6.mbs);
      return n12.serviceObbInIndexSR = !this.ignoreServiceObb && t6.hasOwnProperty("obb") && t6.obb ? I2.fromJSON(t6.obb) : null, n12.visibilityObbInRenderSR = this._computeVisibilityObb(n12), n12;
    }, l7 = Array.isArray(t5.children) ? t5.children.map(a13).filter((e13) => null != e13) : null, h7 = t5.featureData?.length ?? false, u9 = true === t5.isEmpty;
    return new s11(e12, t5.mbs, o6, "string" == typeof t5.version ? t5.version : null, {
      isEmpty: !h7 && u9,
      hasSharedResource: null != t5.sharedResource,
      attributes: t5.attributeData ? e12 : void 0,
      texture: t5.textureData && t5.textureData.length > 0 ? e12 : void 0,
      geometry: null != t5.geometryData ? e12 : void 0
    }, l7, Array.isArray(t5.lodSelection) ? t5.lodSelection : null, r10);
  }
  resetFailedNodes() {
    this._failedNodes.clear(), this._failedPages.clear(), this._forAllNodes((e12) => {
      null != e12.node && (e12.node.failed = false);
    });
  }
  _entryPriority(e12) {
    const t5 = this._getNodeInternal(e12), i4 = this.getParentIndex(e12);
    if (null == t5 || null == i4 && null == t5.node) return null == i4 ? 1 / 0 : this._entryPriority(i4);
    let n11 = 0;
    if (t5.node && null != i4) {
      const e13 = this._getNodeInternal(i4).traversalState;
      null != e13 && (n11 = e13.lodLevel);
    }
    let s12 = this.progressiveLoadPenalty;
    for (let r10 = e12; null != r10; r10 = this.getParentIndex(r10)) if (this._isLoaded(r10)) {
      s12 = 0;
      break;
    }
    const o6 = null != t5.ref ? this._viewportQueries.distToPOI(t5.ref) : null != t5.node ? this._viewportQueries.distToPOI(t5.node) : 0;
    return -o6 - n11 * (o6 + this.progressiveLoadPenalty) + s12;
  }
  traverseVisible(e12, t5) {
    const i4 = this._getNodeInternal(this._rootIndex);
    null != i4 ? this._traverseVisible(this._rootIndex, null, i4, e12, t5) : e12(this._rootIndex, null, null);
  }
  _traverseVisible(e12, t5, i4, n11, s12) {
    const o6 = E(e12, this._pageSize);
    if (s12 && s12.add(o6), i4.node && 0 === i4.childCount) return void (this.isGeometryVisible(e12) && n11(e12, i4, t5));
    if (!this.isNodeVisible(e12)) return;
    if (n11(e12, i4, t5), null == i4.node) return;
    const r10 = this.nodeTraversalState(i4.node);
    if (r10?.nodeHasLOD && r10.lodLevel === this._maxLodLevel) return;
    const a13 = this._getPageFromPageIndex(o6);
    for (let l7 = 0; l7 < i4.childCount; l7++) {
      const t6 = a13.children[i4.childOffset + l7], o7 = this._getNodeInternal(t6);
      if (o7) this._traverseVisible(t6, e12, o7, n11, s12);
      else {
        if (s12) {
          const e13 = E(t6, this._pageSize);
          s12.add(e13);
        }
        n11(t6, null, e12);
      }
    }
  }
  traverse(e12, t5) {
    t5(e12) && this.traverseDescendants(e12, t5);
  }
  traverseDescendants(e12, t5) {
    ++this._traverseDescendantsNestingLevel;
    const i4 = e12.index, n11 = this._pageSize, s12 = E(i4, n11), o6 = this._getPageFromPageIndex(s12);
    if (null == o6) return;
    const r10 = this._frameNumber, a13 = this._nodePages;
    o6.lastTraversed = r10;
    const l7 = M2(i4, n11), d7 = o6.nodes[l7], {
      childCount: h7
    } = d7;
    if (0 === h7) return;
    const u9 = 1 === this._traverseDescendantsNestingLevel ? this._traverseDescendantsQueue : [0];
    let c5 = 0;
    const g4 = [];
    {
      const {
        childOffset: e13,
        childCount: t6
      } = d7, {
        children: i5
      } = o6;
      u9.length = 2 ** Math.ceil(Math.log2(c5 + t6));
      for (let n12 = e13; n12 < e13 + t6; ++n12) {
        const e14 = i5[n12];
        e14 >= 0 ? (u9[c5] = e14, ++c5) : g4.push(e14);
      }
    }
    if (g4.length > 0) {
      const e13 = this._clientNodePage;
      if (e13) {
        const i5 = e13.children;
        let n12 = 0;
        for (; n12 < g4.length; ) {
          const s13 = g4[n12];
          ++n12;
          const o7 = -s13 - 1, r11 = e13.nodes[o7], a14 = r11.node;
          if (!a14) continue;
          if (!t5(a14)) continue;
          const {
            childCount: l8
          } = r11;
          if (0 === l8) continue;
          const {
            childOffset: d8
          } = r11, h8 = d8 + l8;
          for (let e14 = d8; e14 < h8; ++e14) g4.push(i5[e14]);
        }
      }
    }
    if (c5 > 0) {
      let e13 = 0;
      if (n11 > 0) {
        let i5 = s12 * n11, l8 = o6, d8 = l8.nodes;
        for (; e13 < c5; ) {
          const s13 = u9[e13];
          let o7;
          if (++e13, i5 <= s13 && s13 < i5 + n11) o7 = l8;
          else {
            const e14 = s13 / n11 | 0, t6 = a13.get(e14);
            if (void 0 === t6) continue;
            o7 = t6, o7.lastTraversed = r10, l8 = o7, d8 = l8.nodes, i5 = n11 * e14;
          }
          const h8 = d8[s13 - i5], g5 = h8.node;
          if (null == g5) continue;
          if (false === t5(g5)) continue;
          const {
            childCount: _7
          } = h8;
          if (0 === _7) continue;
          const f4 = c5 + _7;
          for (u9.length < f4 && (u9.length = 2 ** Math.ceil(Math.log2(c5 + _7))); u9.length < c5 + _7; ) u9.length += u9.length;
          const m4 = o7.children, {
            childOffset: v2
          } = h8, p5 = v2 + _7;
          for (let e14 = v2; e14 < p5; ++e14) u9[c5] = m4[e14], ++c5;
        }
      } else {
        const i5 = a13.get(0);
        if (i5) for (; e13 < c5; ) {
          const n12 = u9[e13];
          ++e13;
          const s13 = i5.nodes[n12], o7 = s13.node;
          if (!o7) continue;
          if (!t5(o7)) continue;
          const {
            childCount: r11
          } = s13;
          if (0 === r11) continue;
          u9.length = Math.max(u9.length, 2 ** Math.ceil(Math.log2(c5 + r11)));
          const a14 = i5.children, {
            childOffset: l8
          } = s13, d8 = l8 + r11;
          for (let e14 = l8; e14 < d8; ++e14) u9[c5] = a14[e14], ++c5;
        }
      }
    }
    --this._traverseDescendantsNestingLevel;
  }
  updateChildrenLoaded(e12, t5) {
    let i4 = this.getNode(e12);
    for (; null != i4; ) {
      const e13 = i4.childrenLoaded, n11 = e13 + t5;
      i4.childrenLoaded = n11;
      const s12 = 0 === e13 ? 1 : 0 === n11 ? -1 : 0, o6 = i4.index;
      if (0 !== s12) {
        this._getPage(o6).numNodesWithLoadedChildren += s12;
      }
      i4 = this.getParent(o6);
    }
  }
  checkChildrenLoadedInvariant() {
    if (null == this.rootNode) return true;
    const e12 = [], t5 = (i4) => {
      let n11 = this._isLoaded(i4.index) || this._isReloading(i4.index) ? 1 : 0;
      return this.traverseDescendants(i4, (e13) => (n11 += t5(e13), false)), i4.childrenLoaded !== n11 && e12.push(i4.index), n11;
    };
    return t5(this.rootNode), e12.length && this._logger.error("childrenLoaded invariant broken at following nodes: " + e12.join(",")), e12.length > 0;
  }
  updateElevationInfo(e12, t5) {
    this.needNodeElevationRange = t5 && !!e12 && ("relative-to-ground" === e12.mode || "relative-to-scene" === e12.mode || "on-the-ground" === e12.mode), this._viewportQueries.updateElevationInfo(e12), this.invalidateAllElevationRanges();
  }
  invalidateAllElevationRanges() {
    this._forAllNodes((e12) => {
      e12?.invalidateBounds(), e12.node?.invalidateElevationRange(), e12.ref?.invalidateElevationRange();
    });
  }
  _forAllNodes(e12) {
    if (null != this._clientNodePage) {
      const t5 = this._clientNodePage;
      for (let i4 = 0; i4 < t5.nodes.length; i4++) e12(t5.nodes[i4], -(i4 + 1));
    }
    for (const [t5, i4] of this._nodePages) {
      const n11 = t5 * this._pageSize;
      for (let t6 = 0; t6 < i4.nodes.length; t6++) e12(i4.nodes[t6], n11 + t6);
    }
  }
  clearCaches() {
    if (this._useNodePages) {
      const e12 = this._nodePages, t5 = /* @__PURE__ */ new Set();
      this.traverseVisible((e13) => t5.add(E(e13, this._pageSize)));
      for (const [i4, n11] of e12) if (0 !== n11.numNodesWithLoadedChildren || t5.has(i4)) for (const e13 of n11.nodes) e13.traversalState = null;
      else this._deleteNodePage(i4);
    }
  }
  _deleteNodePage(e12) {
    this._nodePages.delete(e12);
  }
  get test() {
  }
};
var y5 = /* @__PURE__ */ new Map();
var P3 = class {
  constructor(t5) {
    this.missing = t5, this.update = new l({
      deallocator: null
    }), this.add = new l({
      deallocator: null
    }), this.remove = new l({
      deallocator: null
    }), this.cancel = [];
  }
  reset(e12) {
    this.add.clear(), this.update.clear(), this.cancel = e12;
  }
};
function x3(e12) {
  return de(e12, -2);
}
function R(e12) {
  return de(e12, 2);
}
function S4(e12, t5) {
  return t5 + (e12 ? 1 : 0);
}
function C3(e12, t5) {
  return (-2 & e12) === t5;
}
function w3(e12) {
  return !(1 & ~e12);
}
function E(e12, t5) {
  return e12 < 0 ? -1 : t5 > 0 ? e12 / t5 | 0 : 0;
}
function M2(e12, t5) {
  return e12 < 0 ? -e12 - 1 : 0 === t5 ? e12 : e12 % t5;
}
function V4(e12, t5, i4) {
  return -1 === t5 ? -(e12 + 1) : 0 === i4 ? e12 : t5 * i4 + e12;
}
var O3 = [["maxScreenThreshold", d2.MaxScreenThreshold], ["screenSpaceRelative", d2.ScreenSpaceRelative], ["removedFeatureDiameter", d2.RemovedFeatureDiameter], ["distanceRangeFromDefaultCamera", d2.DistanceRangeFromDefaultCamera]];
function A2(e12) {
  if (e12) {
    for (let t5 = 0; t5 < e12.length; t5++) for (const i4 of O3) if (i4[0] === e12[t5].metricType) return {
      lodMetric: i4[1],
      maxError: e12[t5].maxError
    };
  }
  return {
    lodMetric: d2.None,
    maxError: 0
  };
}
var L4 = class {
  constructor() {
    this.known = 0, this.knownNodes = 0, this.missing = 0, this.missingNodes = 0, this.unremoved = 0;
  }
};
function k3(e12) {
  return Math.sqrt(e12 * (4 / Math.PI));
}
var D2 = _4();
var F3 = _4();
var z3 = _4();
var T2 = _4();
var B = has("esri-mobile") ? 100 : 300;

// ../../../node_modules/@arcgis/core/views/3d/layers/support/I3SLayerView.js
var a12;
!function(a13) {
  a13[a13.FadeIn = 0] = "FadeIn", a13[a13.FadeOut = 1] = "FadeOut";
}(a12 || (a12 = {}));

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/I3SLodHandling.js
var o5 = class {
  constructor(e12) {
    this._layerView = e12, this._lodGlobalDirty = false;
  }
  startNodeLoading(e12, i4, s12) {
    this._maxLodLevel = s12.maxLodLevel, this._index = i4, this._removeNodes = e12;
  }
  shouldLoadNode(e12) {
    if (null == e12) return false;
    const i4 = this._index.nodeTraversalState(e12);
    return !!this._isChosenMaxLOD(i4) || !!i4.isChosen && this._childrenRequireLoading(e12);
  }
  setLodGlobalDirty() {
    this._lodGlobalDirty = true;
  }
  get requiresLODGlobalHandling() {
    return null != this._index && true === this._lodGlobalDirty;
  }
  lodGlobalHandling(e12) {
    if (!this.requiresLODGlobalHandling) return false;
    this._lodGlobalDirty = false;
    const i4 = this._layerView.view.resourceController.memoryController.usedMemory, s12 = Math.max(0, Math.floor(10 * (i4 - 1)));
    t4.clear(), this._lodGlobalHandling(this._index.rootNode, s12, false, !!this._layerView.nodeCrossfadingEnabled);
    const o6 = t4.length;
    this._removeNodes(t4, e12);
    const d7 = t4.length < o6;
    return 0 !== t4.length && (this._lodGlobalDirty = true), t4.clear(), d7;
  }
  _lodGlobalHandling(e12, o6, d7, l7) {
    if (null == e12) return false;
    const n11 = e12.index, r10 = this._index, a13 = this._layerView, h7 = r10.nodeTraversalState(e12), u9 = this._isChosenMaxLOD(h7), _7 = e12.resources.isEmpty;
    if (u9 && _7) return e12.childrenLoaded > 0 && this._removeChildrenRecursive(e12), true;
    const c5 = a13.isNodeLoaded(n11);
    if (l7 && c5 && u9) {
      const i4 = !d7 && this.hasNoVisibleChildren(e12);
      a13.fadeNode(n11, a12.FadeIn, !i4);
    }
    const x5 = c5 && (!a13.isNodeFullyFadedIn || a13.isNodeFullyFadedIn(n11));
    if (c5 && (a13.updateNodeState(n11, u9 ? c.Leaf : c.Hole), u9)) return x5 && this._removeChildrenRecursive(e12), x5;
    const L5 = e12.childCount > 0;
    let y6 = L5;
    if (L5) for (let i4 = 0; i4 < e12.childCount; i4++) {
      const e13 = r10.getChildIndex(n11, i4), s12 = r10.getNode(e13);
      if (null != s12) {
        !r10.isGeometryVisible(e13) || this._lodGlobalHandling(s12, o6, d7 || x5, l7) || (y6 = false);
      } else r10.isNodeVisible(e13) && (y6 = false);
    }
    const m4 = c5 && !u9 && (y6 || t4.length < o6);
    m4 && t4.push(n11), !l7 || m4 || !c5 || d7 || y6 || a13.fadeNode(n11, a12.FadeIn, false);
    const N4 = e12.resources.isEmpty;
    return y6 || x5 && !m4 || N4;
  }
  _removeChildrenRecursive(e12) {
    this._index.traverseDescendants(e12, (e13) => ((this._layerView.isNodeLoaded(e13.index) || this._layerView.isNodeReloading(e13.index)) && t4.push(e13.index), e13.childrenLoaded > 0));
  }
  hasNoVisibleChildren(e12) {
    let i4 = true;
    return this._index.traverseDescendants(e12, (e13) => !(!i4 || !this._index.isNodeVisible(e13.index)) && (this._layerView.isNodeLoaded(e13.index) ? (i4 = false, false) : e13.childrenLoaded > 0)), i4;
  }
  _childrenRequireLoading(e12) {
    let i4 = false, s12 = true;
    return this._index.traverseDescendants(e12, (e13) => {
      if (!s12 || !this._index.isNodeVisible(e13.index)) return false;
      const o6 = this._index.nodeTraversalState(e13);
      return this._isChosenMaxLOD(o6) && this._index.isGeometryVisible(e13.index) && (i4 = true), this._layerView.isNodeLoaded(e13.index) ? (s12 = false, false) : e13.childrenLoaded > 0;
    }), s12 && i4;
  }
  _isChosenMaxLOD(e12) {
    return e12.isChosen && (!e12.nodeHasLOD || e12.lodLevel === this._maxLodLevel);
  }
};
var t4 = new l({
  deallocator: null
});

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/I3SMaterialUtil.js
function h5(e12, o6, a13) {
  const s12 = /* @__PURE__ */ new Map(), t5 = (e13, o7) => {
    if (null == e13) return -1;
    const r10 = s12.get(e13.id);
    if (r10) return r10.usage |= o7, r10.id;
    const a14 = s12.size;
    return s12.set(e13.id, {
      id: a14,
      usage: o7
    }), a14;
  }, l7 = o6.pbrMetallicRoughness, i4 = l7?.baseColorFactor, u9 = o6.emissiveFactor, p5 = has("disable-feature:diffuse-rendering-i3s") || a13 ? n9({
    normalTexture: o6.normalTexture,
    emissiveTexture: o6.emissiveTexture,
    emissiveFactor: o6.emissiveFactor,
    occlusionTexture: o6.occlusionTexture,
    metallicRoughnessTexture: l7?.metallicRoughnessTexture,
    metallicFactor: l7?.metallicFactor,
    roughnessFactor: l7?.roughnessFactor
  }) : u6({
    normalTexture: o6.normalTexture,
    emissiveTexture: o6.emissiveTexture,
    emissiveFactor: o6.emissiveFactor,
    occlusionTexture: o6.occlusionTexture,
    metallicRoughnessTexture: l7?.metallicRoughnessTexture,
    metallicFactor: l7?.metallicFactor,
    roughnessFactor: l7?.roughnessFactor
  }), h7 = p5 ? t3[0] : l7?.metallicFactor ?? r8[0], x5 = p5 ? t3[1] : l7?.roughnessFactor ?? r8[1], F5 = "mask" === o6.alphaMode ? s10.Color | s10.AlphaMask : s10.Color, b6 = {
    baseColorFactor: i4 ? [i4[0], i4[1], i4[2], i4[3]] : [1, 1, 1, 1],
    baseColorTextureId: t5(l7?.baseColorTexture, F5),
    metallicRoughnessTextureId: t5(l7?.metallicRoughnessTexture, s10.MetallicRoughness),
    metallicFactor: h7,
    roughnessFactor: x5
  }, C5 = {
    alphaMode: o6.alphaMode,
    alphaCutoff: o6.alphaCutoff,
    doubleSided: o6.doubleSided,
    cullFace: "none" === o6.cullFace ? e10.None : "back" === o6.cullFace ? e10.Back : "front" === o6.cullFace ? e10.Front : e10.None,
    normalTextureId: t5(o6.normalTexture, s10.Normal),
    emissiveTextureId: t5(o6.emissiveTexture, s10.Emissive),
    occlusionTextureId: t5(o6.occlusionTexture, s10.Occlusion),
    emissiveFactor: u9 ? [u9[0], u9[1], u9[2]] : [0, 0, 0],
    metallicRoughness: b6,
    wrapTextures: false,
    hasParametersFromSource: p5
  }, P6 = [];
  return s12.forEach(({
    usage: o7
  }, r10) => {
    const a14 = null != e12 && e12[r10] && e12[r10].formats, s13 = a14 ? T3(a14.map(({
      name: e13,
      format: o8
    }) => ({
      name: e13,
      encoding: f3[o8]
    }))) : [];
    P6.push({
      id: r10,
      usage: o7,
      encodings: s13
    });
  }), {
    material: C5,
    textures: P6
  };
}
function T3(e12) {
  return e12.sort((e13, o6) => e13.encoding - o6.encoding);
}
var f3 = {
  ktx2: e11.KTX2,
  basis: e11.Basis,
  dds: e11.DDS_S3TC,
  png: e11.PNG,
  jpg: e11.JPG,
  "ktx-etc2": e11.KTX_ETC2
};
var x4 = {
  [u5.KTX2_ENCODING]: e11.Basis,
  [u5.BASIS_ENCODING]: e11.Basis,
  [u5.DDS_ENCODING]: e11.DDS_S3TC,
  "image/png": e11.PNG,
  "image/jpg": e11.JPG,
  "image/jpeg": e11.JPG,
  "image/ktx": e11.KTX_ETC2
};
function F4(o6) {
  const a13 = o6?.materialDefinitions ? Object.keys(o6.materialDefinitions)[0] : null, s12 = o6?.textureDefinitions ? Object.keys(o6.textureDefinitions)[0] : null, t5 = a13 ? o6.materialDefinitions?.[a13] : null, l7 = s12 ? o6.textureDefinitions?.[s12] : null, i4 = b5();
  if (null != t5) {
    const o7 = t5.params;
    o7.diffuse && (i4.metallicRoughness.baseColorFactor = [o7.diffuse[0], o7.diffuse[1], o7.diffuse[2], 1]), null != o7.doubleSided && (i4.doubleSided = o7.doubleSided, i4.cullFace = o7.doubleSided ? e10.None : e10.Back), "none" !== o7.cullFace && "front" !== o7.cullFace && "back" !== o7.cullFace || (i4.cullFace = "none" === o7.cullFace ? e10.None : "back" === o7.cullFace ? e10.Back : e10.Front), o7.transparency && (i4.metallicRoughness.baseColorFactor[3] = e5(1 - o7.transparency, 0, 1)), (o7.useVertexColorAlpha || i4.metallicRoughness.baseColorFactor[3] < 1) && (i4.alphaMode = "blend");
  }
  const u9 = [];
  if (null != l7) {
    const e12 = 0;
    !l7.wrap || "repeat" !== l7.wrap[0] && "repeat" !== l7.wrap[1] || (i4.wrapTextures = true);
    let o7 = s10.Color;
    "rgba" === l7.channels && (i4.alphaMode = "blend", o7 |= s10.AlphaMask);
    const a14 = l7.images.length - 1, s13 = l7.images[a14], t6 = (e13) => e13?.split("/").pop(), n11 = Array.isArray(l7.encoding) ? T3(l7.encoding.map((e13, o8) => ({
      name: t6(s13.href[o8]),
      encoding: x4[e13] || 0
    }))) : [{
      name: t6(s13.href),
      encoding: x4[l7.encoding] || 0
    }];
    u9.push({
      id: e12,
      usage: o7,
      encodings: n11
    }), i4.metallicRoughness.baseColorTextureId = e12;
  }
  return {
    material: i4,
    textures: u9
  };
}
var b5 = () => ({
  alphaMode: "opaque",
  alphaCutoff: o3,
  doubleSided: true,
  cullFace: e10.None,
  normalTextureId: -1,
  emissiveTextureId: -1,
  occlusionTextureId: -1,
  emissiveFactor: [0, 0, 0],
  metallicRoughness: {
    baseColorFactor: [0.8, 0.8, 0.8, 1],
    baseColorTextureId: -1,
    metallicRoughnessTextureId: -1,
    metallicFactor: 0,
    roughnessFactor: 0.6
  },
  wrapTextures: false,
  hasParametersFromSource: true
});
function C4(e12, o6, a13, s12) {
  if (null == e12?.data) return null;
  const t5 = e12.data, l7 = s12.renderingContext.parameters.maxMaxAnisotropy, n11 = l7 > 1, i4 = a13 || !o6.wrapTextures ? P4 : S5, c5 = N3(e12.encoding), m4 = e12.usage & s10.Color ? "opaque" === o6.alphaMode ? 3 : 4 : 3;
  return new N(t5, {
    mipmap: n11,
    maxAnisotropy: l7,
    encoding: c5,
    wrap: i4,
    components: m4,
    noUnpackFlip: true
  });
}
var P4 = {
  s: D.CLAMP_TO_EDGE,
  t: D.CLAMP_TO_EDGE
};
var S5 = {
  s: D.REPEAT,
  t: D.REPEAT
};
function M3(o6, l7, n11, u9, c5, m4) {
  const p5 = m4.rendererTextureUsage, h7 = (e12) => w4(u9, n11, e12 & p5), T5 = l7.metallicRoughness.baseColorFactor, f4 = e5(l7.metallicRoughness.baseColorFactor[3], 0, 1);
  o6.baseColor = [T5[0], T5[1], T5[2], f4], o6.hasParametersFromSource = !!l7.hasParametersFromSource, o6.usePBR = m4.usePBR, o6.mrrFactors = [l7.metallicRoughness.metallicFactor, l7.metallicRoughness.roughnessFactor, l7.hasParametersFromSource ? t3[2] : r8[2]], o6.emissiveFactor = l7.emissiveFactor, o6.isIntegratedMesh = m4.isIntegratedMesh, o6.textureAlphaCutoff = "mask" === l7.alphaMode ? l7.alphaCutoff : o3, o6.alphaDiscardMode = "opaque" === l7.alphaMode ? s7.Opaque : "mask" === l7.alphaMode ? s7.Mask : s7.MaskBlend;
  const x5 = [], F5 = h7(s10.Color | s10.AlphaMask);
  null != F5 && (o6.baseColorTexture = new s9(c5, F5), x5.push(o6.baseColorTexture.loadPromise));
  const b6 = h7(s10.MetallicRoughness);
  null != b6 && (o6.metallicRoughnessTexture = new s9(c5, b6), x5.push(o6.metallicRoughnessTexture.loadPromise));
  const C5 = h7(s10.Emissive);
  null != C5 && (o6.emissionTexture = new s9(c5, C5), x5.push(o6.emissionTexture.loadPromise));
  const P6 = h7(s10.Occlusion);
  null != P6 && (o6.occlusionTexture = new s9(c5, P6), x5.push(o6.occlusionTexture.loadPromise));
  const S6 = h7(s10.Normal);
  return null != S6 && (o6.normalTexture = new s9(c5, S6), x5.push(o6.normalTexture.loadPromise)), o6.commonMaterialParameters.hasSlicePlane = m4.slicePlaneEnabled, o6.commonMaterialParameters.doubleSided = l7.doubleSided, o6.commonMaterialParameters.cullFace = l7.cullFace, o6.ellipsoidMode = a10(m4.viewSpatialReference), Promise.all(x5);
}
function R2(e12) {
  const r10 = !!e12.compressedTextureS3TC, a13 = !!e12.compressedTextureETC, s12 = has("disable-feature:i3s-basis") ? 0 : e11.Basis | e11.KTX2, t5 = e11.JPG | e11.PNG, l7 = s12 | e11.DDS_S3TC;
  return t5 | (r10 ? l7 : 0) | (a13 ? s12 : 0);
}
function D3(e12, o6) {
  if (null != o6) return e12.find((e13) => !!(e13.encoding & o6));
}
function w4(e12, o6, a13) {
  if (null == e12 || a13 === s10.None) return null;
  for (let r10 = 0; r10 < e12.length; r10++) {
    const s12 = e12[r10];
    if (null != s12 && s12.usage & a13) {
      const e13 = o6[r10];
      return null != e13 ? e13.id : null;
    }
  }
  return null;
}
function N3(e12) {
  switch (e12) {
    case e11.KTX2:
      return u5.KTX2_ENCODING;
    case e11.Basis:
      return u5.BASIS_ENCODING;
    case e11.DDS_S3TC:
      return u5.DDS_ENCODING;
    case e11.PNG:
      return "image/png";
    case e11.JPG:
      return "image/jpeg";
    case e11.KTX_ETC2:
      return "image/ktx";
    default:
      return "";
  }
}

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/I3SNodeLoader.js
var d6 = class _d {
  constructor(e12, t5, r10, i4, o6, n11) {
    if (this._streamDataController = t5, this._logger = r10, this._defaultGeometrySchema = i4, this._requiredAttributes = o6, this._options = n11, this._logLayer = e12, this._layerUrl = e12.parsedUrl.path, this._geometryDefinitions = e12.geometryDefinitions, e12.materialDefinitions) {
      const t6 = e12.textureSetDefinitions;
      this._materialAndTextures = e12.materialDefinitions.map((r11) => h5(t6, r11, "integrated-mesh" === e12.type));
    }
  }
  _load(e12, t5, r10) {
    return this._streamDataController.request(e12, t5, r10);
  }
  _loadAttribute(e12, t5, r10) {
    const i4 = `${this._layerUrl}/nodes/${e12.resources.attributes}/attributes/${t5.key}/0`;
    return this._load(i4, "binary", r10).then((e13) => I(t5, e13));
  }
  loadAttributes(e12, t5, r10) {
    return __async(this, null, function* () {
      const o6 = yield Promise.allSettled(t5.map((t6) => this._loadAttribute(e12, t6.attributeStorageInfo, r10))), n11 = {};
      for (let s12 = 0; s12 < t5.length; ++s12) {
        const r11 = o6[s12], a13 = t5[s12];
        if ("fulfilled" === r11.status) {
          const e13 = r11.value;
          n11[a13.name] = e13;
        } else {
          const t6 = r11.reason;
          a2(t6), this._logger.error("#loadAttributes", this._logLayer, `Failed to load attributeData for '${a13.name}' on node '${e12.id}'`, t6);
        }
      }
      return n11;
    });
  }
  loadNodeData(r10, i4) {
    return __async(this, null, function* () {
      const o6 = null != this._requiredAttributes && r10.resources.attributes ? _2(this.loadAttributes(r10, this._requiredAttributes, i4)) : null, {
        bufferDefinition: n11,
        bufferIndex: s12
      } = _6(this._geometryDefinitions, r10), u9 = !!r10.resources.geometry, f4 = u9 ? _2(this._loadGeometry(r10.resources.geometry, s12, i4)) : null, d7 = r10.resources.hasSharedResource ? yield this._loadShared(r10, i4) : null, y6 = r10.resources.materialDefinition, b6 = this._materialAndTextures && null != y6 && y6 >= 0 ? this._materialAndTextures[y6] : null != d7 ? F4(d7) : null, D5 = b6?.material, p5 = b6?.textures ?? [], x5 = `${r10.id}`, A3 = !u9 && this._options.loadFeatureData, w5 = A3 ? yield this._loadFeatureData(x5, i4) : null, T5 = A3 ? m3(w5) : c4(D5), $5 = null == T5 ? h6(w5) : null, j3 = p5.length > 0 ? _2(this.loadTextures(r10, p5, i4)) : null;
      let I7 = null, S6 = null;
      if (f4) {
        I7 = y2(yield f4);
        const e12 = g3(this._defaultGeometrySchema, d7);
        S6 = p3(n11, e12);
      }
      const U4 = j3 ? y2(yield j3) : null, q3 = o6 ? y2(yield o6) : {}, B3 = q3 ? {
        attributeData: q3,
        loadedAttributes: this._requiredAttributes
      } : null;
      if (null != T5) return {
        geometryData: T5,
        attributeDataInfo: B3,
        geometryBuffer: I7,
        geometryDescriptor: S6,
        requiredTextures: p5,
        textureData: U4
      };
      if (null != $5) return {
        pointData: $5,
        attributeDataInfo: B3,
        geometryBuffer: I7,
        geometryDescriptor: S6,
        requiredTextures: p5,
        textureData: U4
      };
      throw new Error();
    });
  }
  static _addAbsoluteHrefTexture(e12, t5) {
    const r10 = e12.textureDefinitions;
    if (null != r10) for (const i4 of Object.keys(r10)) for (const e13 of r10[i4].images) Array.isArray(e13.href) ? e13.hrefConcat = e13.href.map((e14) => _(e14, t5)) : e13.hrefConcat = _(e13.href, t5);
  }
  static _fixTextureEncodings(e12) {
    const t5 = e12.textureDefinitions;
    if (null != t5) for (const r10 in t5) {
      const e13 = t5[r10];
      if (Array.isArray(e13.encoding)) for (let t6 = 0; t6 < e13.encoding.length; t6++) {
        const r11 = e13.encoding[t6];
        "data:" === r11.substring(0, 5) && (e13.encoding[t6] = r11.substring(5));
      }
      else {
        const t6 = e13.encoding;
        "data:" === t6.substring(0, 5) && (e13.encoding = t6.substring(5));
      }
    }
  }
  _loadShared(e12, t5) {
    return __async(this, null, function* () {
      if (null == e12.resources.geometry) return {};
      const r10 = `${this._layerUrl}/nodes/${e12.resources.geometry}/shared`, i4 = yield this._load(r10, "json", t5);
      return _d._fixTextureEncodings(i4), _d._addAbsoluteHrefTexture(i4, r10), i4;
    });
  }
  _loadTexture(e12, t5, r10, i4, o6, s12) {
    let a13 = false;
    return o6 === e11.DDS_S3TC || o6 === e11.KTX2 || o6 === e11.Basis ? this._load(e12, "binary", s12).then((e13) => ({
      id: t5,
      usage: r10,
      data: e13,
      encoding: o6,
      downsampled: a13
    })) : this._load(e12, "image", s12).then((e13) => {
      let n11 = e13;
      const s13 = 4096, u9 = 2;
      if (i4 && e13.width * e13.height >= s13) {
        const t6 = Math.ceil(e13.width / u9), r11 = Math.ceil(e13.height / u9), i5 = document.createElement("canvas");
        i5.width = t6, i5.height = r11;
        i5.getContext("2d").drawImage(e13, 0, 0, t6, r11), n11 = i5, a13 = true;
      }
      return {
        id: t5,
        usage: r10,
        data: n11,
        encoding: o6,
        downsampled: a13
      };
    });
  }
  loadTextures(e12, t5, r10) {
    const i4 = !!this._options.uncompressedTextureDownsamplingEnabled, o6 = this._options.textureUsageMask;
    return Promise.all(t5.map((t6) => {
      if (!(t6.usage & o6)) return null;
      const n11 = D3(t6.encodings, this._options.textureEncodings);
      if (null == n11) return this._logger.error("#loadTextures", this._logLayer, `No known encoding for texture found on node ${e12.id}`), Promise.reject();
      const s12 = e12.resources.texture || e12.id, a13 = `${this._layerUrl}/nodes/${s12}/textures/${n11.name}`;
      return this._loadTexture(a13, t6.id, t6.usage, i4, n11.encoding, r10);
    }));
  }
  _loadFeatureData(e12, t5) {
    const r10 = `${this._layerUrl}/nodes/${e12}/features/0`;
    return this._load(r10, "json", t5);
  }
  _loadGeometry(e12, t5, r10) {
    const i4 = `${this._layerUrl}/nodes/${e12}/geometries/${t5}`;
    return this._load(i4, "binary", r10);
  }
};
function c4(e12) {
  return {
    featureIds: [],
    geometries: [{
      type: "ArrayBufferView",
      params: {
        material: e12
      }
    }],
    featureDataPosition: [0, 0, 0]
  };
}
function m3(e12) {
  if (!e12) return null;
  for (const t5 of e12.featureData) {
    const e13 = t5.geometries;
    if (null != e13) for (const r10 of e13) return {
      featureIds: [t5.id],
      featureDataPosition: t5.position,
      geometries: [r10]
    };
  }
  return null;
}
function h6(e12) {
  if (!e12) return null;
  const t5 = new Array();
  for (const r10 of e12.featureData) null != r10.position && t5.push({
    featureIds: [r10.id],
    featureDataPosition: r10.position,
    geometries: []
  });
  return t5;
}
function g3(e12, t5) {
  if (!e12 || !t5?.materialDefinitions) return e12;
  const i4 = Object.keys(t5.materialDefinitions)[0];
  return !t5.materialDefinitions[i4].params.vertexRegions && e12.vertexAttributes.region && delete (e12 = a(e12)).vertexAttributes.region, e12;
}
function _6(e12, t5) {
  const r10 = {
    bufferDefinition: null,
    bufferIndex: 0
  }, i4 = t5.resources.geometryDefinition;
  if (null == e12 || null == i4 || i4 < 0) return r10;
  const o6 = i4 >= 0 ? e12[i4].geometryBuffers : null;
  if (null == o6) return r10;
  for (let n11 = 0; n11 < o6.length; n11++) {
    const e13 = o6[n11];
    if (null == e13.compressedAttributes) r10.bufferIndex = n11, r10.bufferDefinition = o6[n11];
    else if ("draco" === e13.compressedAttributes.encoding && !has("disable-feature:i3s-draco")) return r10.bufferIndex = n11, r10.bufferDefinition = e13, r10;
  }
  return r10;
}

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/I3SStreamDataController.js
var r9 = class {
  constructor(e12, t5, r10) {
    this._requester = e12, this._customParameters = t5, this._apiKey = r10, this._activeRequests = /* @__PURE__ */ new Set();
  }
  get busy() {
    return this._requester.busy;
  }
  request(r10, s12, o6) {
    const a13 = new AbortController(), l7 = w(o6, () => a13.abort()), i4 = {
      signal: a13.signal,
      query: __spreadProps(__spreadValues({}, this._customParameters), {
        token: this._apiKey
      })
    }, n11 = this._requester.request(r10, s12, i4), u9 = {
      response: n11,
      abortController: a13,
      abortHandle: l7
    };
    return this._activeRequests.add(u9), $(n11, () => {
      u9.abortController = null, u9.abortHandle?.remove(), u9.abortHandle = null, this._activeRequests.delete(u9);
    }), n11;
  }
  cancelAll() {
    this._activeRequests.forEach((e12) => {
      e12.abortController?.abort(), e12.abortController = null, e12.abortHandle?.remove();
    }), this._activeRequests.clear();
  }
};

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/I3SViewportQueries.js
var k4 = 1e5;
var H3 = class {
  get _frustumMbsCenter() {
    return this._frustumMbs;
  }
  get _frustumMbsRadius() {
    return this._frustumMbs[3];
  }
  get _frustumPlanes() {
    return this._frustum;
  }
  constructor(e12, t5, i4, s12, n11, r10, o6, a13, c5 = {}) {
    this._indexSR = e12, this._renderCoordsHelper = t5, this._clippingArea = n11, this._elevationProvider = r10, this._viewingMode = o6, this._options = c5, this._frustum = H2(), this._frustumMbs = n8(), this._useFrustumCulling = false, this._poi = n6(), this._elevationContext = null, this.minDistance = 1 / 0, this.maxDistance = 0, this.maxLodLevel = 2, this._tmpObb = new I2(), this._tmp1 = n6(), this._tmp2 = n6(), this._tmp3 = n6(), this._tmp0 = n6(), this._screenspaceErrorBias = c5.screenspaceErrorBias || 1, this._progressiveLoadFactor = c5.progressiveLoadFactor || 1, this.updateCamera(i4, s12);
    const u9 = this._renderCoordsHelper.spatialReference;
    this._renderSR = u9, this._renderSRSphericalPCPF = a6(u9), this._isGlobalMode = u9 === this._renderSRSphericalPCPF, this.updateElevationInfo(a13), this._tmpPoint = e7(0, 0, 0, e12), this._isECEFOBBInLocalMode = this._indexSR.isWGS84 && (u9.isWebMercator || O(u9)), this._indexSREllipsoidRadius = s3(this._indexSR).radius, this._indexSRSphericalPCPF = a6(e12), this._projectorIndexSRToIndexSRSphericalPCPF = G3(this._indexSR, this._indexSRSphericalPCPF);
  }
  updateElevationInfo(e12) {
    null != e12 ? (this._elevationContext = o4.fromElevationInfo(e12), this._elevationContext.updateFeatureExpressionInfoContext(u7(d4(e12, false)))) : this._elevationContext = null;
  }
  updateCamera(n11, r10) {
    if (this._useFrustumCulling = r10, r10) {
      L3(n11.viewMatrix, n11.projectionMatrix, this._frustum, X2);
      {
        const r11 = n11.eye, o6 = Z2;
        z(o6, n11.viewForward);
        const a13 = Y2;
        K(a13, X2[4], r11);
        const c5 = 0.5 * P2(a13, a13) / P2(o6, a13), u9 = this._frustumMbs;
        q(u9, r11, o6, c5);
        const l7 = 1 + c5;
        u9[3] = l7;
      }
    }
    this._screenSizeFactor = 1 / (n11.perScreenPixelRatio / 2), this._camPos = n11.eye, this.minDistance = 1 / 0, this.maxDistance = 0;
  }
  setPointOfInterest(e12) {
    this._poi = e12;
  }
  updateScreenSpaceErrorBias(e12) {
    const t5 = this._screenspaceErrorBias;
    return this._screenspaceErrorBias = e12, t5;
  }
  updateClippingArea(e12) {
    this._clippingArea = e12;
  }
  expandElevationRange(e12, t5, i4) {
    if (null == this._elevationContext) return;
    const s12 = e12.serviceMbsInIndexSR;
    if (!s12) return;
    const n11 = "relative-to-scene" === this._elevationContext.mode ? "scene" : "ground";
    if (this._elevationProvider.getSphereElevationBounds) {
      const e13 = this._elevationProvider.getSphereElevationBounds(s12, this._indexSR, n11);
      return void (e13 && i4.expandElevationRange(e13));
    }
    const r10 = s12[0], o6 = s12[1], a13 = s12[2], c5 = this._elevationProvider.getElevation(r10, o6, a13, this._indexSR, n11);
    c5 && i4.expandElevationRangeValues(c5, c5);
    const u9 = t5 ? null : this._elevationProvider.getRootElevationBounds?.();
    u9 && i4.expandElevationRange(u9);
  }
  getServiceMbsInRenderSR(e12) {
    const t5 = e12.serviceMbsInRenderSR;
    if (ye(t5)) return t5;
    e12.serviceMbsInIndexSR && a5(t5, e12.serviceMbsInIndexSR);
    const i4 = e12.elevationRangeMin;
    if (this._elevationContext && Number.isFinite(i4)) {
      let s12 = 0, n11 = 0;
      const r10 = e12.elevationRangeMax;
      switch (this._elevationContext.mode) {
        case "relative-to-ground":
        case "relative-to-scene":
          s12 = this._elevationContext.geometryZWithOffset(t5[2], this._renderCoordsHelper) + i4 - t5[2], n11 = r10 - i4;
          break;
        case "on-the-ground":
          s12 = i4 - t5[2], n11 = r10 - i4;
      }
      t5[2] += s12 + 0.5 * n11, t5[3] += 0.5 * n11;
    } else this._elevationContext && t5[3] < k4 && (this._tmpPoint.x = t5[0], this._tmpPoint.y = t5[1], this._tmpPoint.z = t5[2], t5[2] = f(this._tmpPoint, this._elevationProvider, this._elevationContext, this._renderCoordsHelper));
    return a9(t5, this._indexSR, t5, this._renderSR), t5;
  }
  getAndUpdateVisibilityObbInRenderSR(e12) {
    {
      const t6 = e12.visibilityObbInRenderSR;
      if (t6) return t6;
    }
    const t5 = 0.01 * this._indexSREllipsoidRadius, {
      serviceMbsInIndexSR: i4,
      serviceObbInIndexSR: s12
    } = e12;
    if (null == s12 || !i4 || !s12.isValid || this._isECEFOBBInLocalMode && (s12.halfSizeX > t5 || s12.halfSizeY > t5 || s12.halfSizeZ > t5)) return null;
    {
      let t6 = e12.serviceObbInRenderSR;
      if (null == t6) t6 = new I2(), e12.serviceObbInRenderSR = t6;
      else if (t6.isValid) return t6;
      const n11 = i4[3];
      let r10 = 0, o6 = 0;
      const a13 = s12.centerZ, c5 = this._renderCoordsHelper, u9 = this._elevationContext;
      if (u9 && e12.elevationRangeValid) {
        const t7 = e12.elevationRangeMin, i5 = e12.elevationRangeMax;
        switch (u9.mode) {
          case "relative-to-ground":
          case "relative-to-scene":
            r10 = u9.geometryZWithOffset(a13, c5) + t7 - a13, o6 = i5 - t7;
            break;
          case "on-the-ground":
            r10 = t7 - a13, o6 = i5 - t7;
        }
      } else if (u9 && n11 < k4) {
        const e13 = this._tmpPoint;
        e13.x = s12.centerX, e13.y = s12.centerY, e13.z = a13, r10 = f(e13, this._elevationProvider, u9, c5) - a13;
      }
      const l7 = o6 > 0, h7 = l7 ? this._tmpObb : t6;
      return s12.transform(h7, this._indexSR, this._renderSR, r10, this._renderSRSphericalPCPF, this._indexSRSphericalPCPF, this._projectorIndexSRToIndexSRSphericalPCPF), l7 && L2(h7, 0, o6, this._viewingMode, t6), t6;
    }
  }
  getNodeObbInRenderSRIndependentOfElevationOffset(e12) {
    {
      const t6 = e12.visibilityObbInRenderSR ?? e12.serviceObbInRenderSR ?? null;
      if (t6?.isValid) return t6;
    }
    const t5 = e12.serviceObbInIndexSR;
    return t5 ? (t5.transform(ee, this._indexSR, this._renderSR, void 0, this._renderSRSphericalPCPF, this._indexSRSphericalPCPF, this._projectorIndexSRToIndexSRSphericalPCPF), ee) : null;
  }
  ensureElevationAgnosticBoundingVolume(e12) {
    return -1 === e12.elevationAgnosticBoundingVolume[3] && e12.level > 0 && (this._viewingMode === l3.Global ? this._updateElevationAgnosticBoundingVolumeGlobal(e12) : this._updateElevationAgnosticBoundingVolumeLocal(e12)), e12.elevationAgnosticBoundingVolume;
  }
  _updateElevationAgnosticBoundingVolumeGlobal(t5) {
    const s12 = this.getNodeObbInRenderSRIndependentOfElevationOffset(t5), o6 = t5.elevationAgnosticBoundingVolume;
    let a13, c5 = -1;
    if (s12) {
      const t6 = te;
      s12.getCenter(t6), z(t6, t6), a13 = t6, s12.getCorners(ie);
      for (const s13 of ie) {
        z(s13, s13);
        const n11 = P2(s13, t6);
        if (n11 <= 0) return void (o6[3] = -1);
        const r10 = Math.sqrt(1 - n11 * n11);
        c5 = Math.max(c5, r10);
      }
    } else {
      const i4 = t5.serviceMbsInRenderSR;
      if (!ye(i4)) return void (o6[3] = -1);
      {
        const t6 = r2(te, V2(i4)), s13 = i4[3], u10 = Y(t6);
        if (u10 < s13) return void (o6[3] = -1);
        c5 = s13 / u10, z(t6, t6), a13 = t6;
      }
    }
    r4(o6, a13);
    const u9 = 1e-3;
    o6[3] = c5 + u9;
  }
  _updateElevationAgnosticBoundingVolumeLocal(e12) {
    const t5 = e12.elevationAgnosticBoundingVolume, i4 = this.getNodeObbInRenderSRIndependentOfElevationOffset(e12);
    if (i4) {
      const e13 = i4.getCenter(te);
      e13[2] = 0, r4(t5, e13);
      let s12 = 0;
      const n11 = se;
      i4.getCorners(ie);
      for (const t6 of ie) {
        t6[2] = 0;
        const e14 = X(n11, t6);
        s12 = Math.max(s12, e14);
      }
      t5[3] = Math.sqrt(s12);
    } else {
      const i5 = e12.serviceMbsInRenderSR;
      if (ye(i5)) {
        const e13 = r2(te, V2(i5));
        e13[2] = 0, r4(t5, e13), t5[3] = i5[3];
      }
    }
  }
  isNodeVisible(e12) {
    const t5 = this.getServiceMbsInRenderSR(e12);
    if (!this._isMBSinClippingArea(t5)) return false;
    if (!this._useFrustumCulling) return true;
    const i4 = this.getAndUpdateVisibilityObbInRenderSR(e12);
    return i4 ? i4.doesIntersectFrustumConservativeApproximation(this._frustum) : s5(this._frustum, z2(t5));
  }
  isElevationAgnosticBoundingVolumeVisible(e12) {
    return !this._useFrustumCulling || -1 === e12[3] || (this._viewingMode === l3.Global ? this._isConeVisibleInFrustum(e12) : this._isCylinderVisibleInFrustum(e12));
  }
  _isConeVisibleInFrustum(n11) {
    if (!this._isConeVisibleInFrustumMbs(n11)) return false;
    const r10 = n11[3];
    if (-1 === r10 || r10 > 0.9) return true;
    const o6 = this._frustumPlanes, c5 = this._frustumMbsCenter, u9 = n11, l7 = P2(u9, c5), h7 = this._frustumMbsRadius, d7 = l7 - h7, m4 = l7 + h7;
    if (d7 <= 0) return true;
    const _7 = g(K2, u9, d7), p5 = g(Q, u9, m4), f4 = r10 / Math.sqrt(1 - r10 * r10);
    for (const v2 of o6) {
      const n12 = F(v2), r11 = z($2, n12), o7 = P2(r11, u9);
      if (Math.abs(1 - o7) < 0.01) continue;
      const c6 = ne;
      g(c6, u9, o7), K(c6, c6, r11), z(c6, c6);
      const l8 = re;
      q(l8, _7, c6, d7 * f4);
      if (V3(v2, l8) <= 0) continue;
      q(l8, p5, c6, m4 * f4);
      if (V3(v2, l8) <= 0) continue;
      return false;
    }
    return true;
  }
  _isConeVisibleInFrustumMbs(e12) {
    const t5 = e12[3];
    if (t5 > 0.9) return true;
    const s12 = this._frustumMbsRadius, n11 = this._frustumMbsCenter, o6 = Y(n11);
    if (o6 <= s12) return true;
    const u9 = e12, l7 = P2(u9, n11);
    {
      const e13 = g(J, u9, l7);
      if (U2(e13, n11) < s12) return true;
    }
    const h7 = l7 / o6;
    if (l7 <= 0) {
      return -h7 < s12;
    }
    const d7 = Math.sqrt(1 - h7 * h7);
    if (d7 < t5) return true;
    const m4 = s12 / o6;
    return d7 * Math.sqrt(1 - m4 * m4) - m4 * h7 < t5;
  }
  isObbVisibleIndependentOfElevation(e12, t5) {
    if (!this._useFrustumCulling) return true;
    if (-1 === e12[3]) return true;
    const s12 = this._frustumMbsRadius, n11 = this._frustumMbsCenter, r10 = this._frustumPlanes, o6 = ie;
    if (t5.getCorners(o6), this._viewingMode === l3.Global) {
      const t6 = e12, c5 = P2(t6, n11), u9 = c5 - s12, l7 = c5 + s12;
      if (u9 <= 0) return true;
      for (const e13 of r10) {
        let s13 = true;
        for (const n12 of o6) {
          const r11 = P2(n12, t6), o7 = oe;
          if (g(o7, n12, u9 / r11), V3(e13, o7) <= 0) {
            s13 = false;
            break;
          }
          const c6 = oe;
          if (g(c6, n12, l7 / r11), V3(e13, c6) <= 0) {
            s13 = false;
            break;
          }
        }
        if (s13) return false;
      }
    } else {
      const e13 = n11[2] - s12, t6 = n11[2] + s12;
      for (const i4 of r10) {
        let s13 = true;
        const n12 = F(i4), r11 = n12[0], a13 = n12[1], c5 = n12[2], u9 = i4[3];
        for (const i5 of o6) {
          const n13 = r11 * i5[0] + a13 * i5[1] + u9;
          if (n13 + c5 * e13 <= 0 || n13 + c5 * t6 <= 0) {
            s13 = false;
            break;
          }
        }
        if (s13) return false;
      }
    }
    return true;
  }
  _isCylinderVisibleInFrustum(e12) {
    const t5 = this._frustumMbsCenter, i4 = this._frustumMbsRadius, s12 = r2(J, t5);
    s12[2] = 0;
    const r10 = e12[3];
    return U2(s12, e12) <= r10 + i4;
  }
  isGeometryVisible(e12) {
    if (!this._useFrustumCulling) return true;
    const t5 = e12.geometryObbInRenderSR;
    return t5?.doesIntersectFrustumConservativeApproximation(this._frustum) ?? this.isNodeVisible(e12);
  }
  _isMBSinClippingArea(e12) {
    return null == this._clippingArea || O2(this._clippingArea, e12) !== F2.OUTSIDE;
  }
  _screenSpaceDiameterMbs(e12, t5) {
    const i4 = this.getServiceMbsInRenderSR(e12), s12 = Math.sqrt(p2(V2(i4), this._camPos)), n11 = s12 - i4[3];
    return this._updateMinMaxDistance(s12), n11 < 0 ? 0.5 * Number.MAX_VALUE : t5 / n11 * this._screenSizeFactor;
  }
  calcCameraDistance(e12) {
    return this.calcCameraDistanceToCenter(e12) - this.getServiceMbsInRenderSR(e12)[3];
  }
  calcCameraDistanceToCenter(e12) {
    const t5 = this.getServiceMbsInRenderSR(e12), i4 = x(V2(t5), this._camPos);
    return this._updateMinMaxDistance(i4), i4;
  }
  calcAngleDependentLoD(e12) {
    const t5 = this.getServiceMbsInRenderSR(e12), i4 = t5[3], s12 = (Math.abs(t5[0] * (t5[0] - this._camPos[0]) + t5[1] * (t5[1] - this._camPos[1]) + t5[2] * (t5[2] - this._camPos[2])) / s4(V2(t5)) + i4) / x(V2(t5), this._camPos);
    return Math.min(1, s12);
  }
  hasLOD(e12) {
    return e12.lodMetric !== d2.None;
  }
  _getDistanceGlobeMode(e12, t5) {
    const s12 = s4(V2(t5)), n11 = s4(e12) - s12;
    g(this._tmp0, e12, P2(e12, V2(t5)) / v(e12));
    const r10 = p2(V2(t5), this._tmp0), o6 = t5[3];
    if (r10 <= o6 * o6) return Math.abs(n11);
    {
      const r11 = g(this._tmp0, V2(t5), 1 / s12), c5 = s12, u9 = o6 * o6 / 2 / c5, d7 = g(this._tmp1, r11, c5 - u9), p5 = e12, f4 = e4(this._tmp2, p5, d7), v2 = e4(this._tmp2, f4, g(this._tmp3, r11, P2(r11, f4))), g4 = u2(this._tmp2, d7, g(this._tmp2, v2, o6 / s4(v2)));
      let b6 = x(p5, g4);
      if (n11 >= 2e5) {
        const e13 = e4(this._tmp1, p5, g4);
        let t6 = P2(e13, r11) / s4(e13);
        t6 < 0.08 && (t6 = 1e-4), b6 /= t6;
      }
      return b6;
    }
  }
  _getDistance(e12, t5) {
    return this._isGlobalMode ? this._getDistanceGlobeMode(e12, t5) : W(e12, t5);
  }
  _updateMinMaxDistance(e12) {
    e12 > 0 ? (this.minDistance = Math.min(this.minDistance, e12), this.maxDistance = Math.max(this.maxDistance, e12)) : (this.minDistance = 0, this.maxDistance = Math.max(this.maxDistance, -e12));
  }
  getLodLevel(e12) {
    if (e12.lodMetric === d2.None) return 0;
    if (0 === e12.childCount) return this.maxLodLevel;
    if (this._useFrustumCulling && this._progressiveLoadFactor < 1) {
      const t5 = this._progressiveLoadFactor * this._screenspaceErrorBias, i4 = this._screenspaceErrorBias;
      return this.evaluateLODmetric(e12, t5) ? this.evaluateLODmetric(e12, i4) ? 2 : 1 : 0;
    }
    return this.evaluateLODmetric(e12, this._screenspaceErrorBias) ? this.maxLodLevel : 0;
  }
  evaluateLODmetric(e12, t5) {
    switch (e12.lodMetric) {
      case d2.ScreenSpaceRelative: {
        const i4 = this.getServiceMbsInRenderSR(e12), s12 = this._getDistance(this._camPos, i4), n11 = 2 * s12 / this._screenSizeFactor, r10 = s12 + i4[3];
        return this._updateMinMaxDistance(r10), e12.maxError * t5 <= n11;
      }
      case d2.MaxScreenThreshold: {
        let i4 = this._screenSpaceDiameterMbs(e12, e12.serviceMbsInIndexSR[3] * t5);
        return this._options.angleDependentLoD && (i4 *= this.calcAngleDependentLoD(e12)), i4 < e12.maxError;
      }
      case d2.RemovedFeatureDiameter:
        return this._screenSpaceDiameterMbs(e12, e12.maxError) * t5 < 10;
      case d2.DistanceRangeFromDefaultCamera:
        return this.calcCameraDistance(e12) > e12.maxError * t5;
    }
    return false;
  }
  distToPOI(e12) {
    const t5 = this.getServiceMbsInRenderSR(e12);
    return x(V2(t5), this._poi) - t5[3];
  }
  distCameraToPOI() {
    return x(this._camPos, this._poi);
  }
};
function W(e12, t5) {
  const i4 = e12[0] - t5[0], s12 = e12[1] - t5[1], n11 = e12[2] - t5[2], r10 = i4 * i4 + s12 * s12, o6 = t5[3];
  if (r10 <= o6 * o6) return Math.abs(n11);
  const a13 = Math.sqrt(r10) - o6;
  return Math.sqrt(n11 * n11 + a13 * a13);
}
var Z2 = n6();
var X2 = I4();
var Y2 = n6();
var J = n6();
var K2 = n6();
var Q = n6();
var $2 = n6();
var ee = new I2();
var te = n6();
var ie = [n6(), n6(), n6(), n6(), n6(), n6(), n6(), n6()];
var se = n6();
var ne = n6();
var re = n6();
var oe = n6();

// ../../../node_modules/@arcgis/core/layers/graphics/controllers/I3SOnDemandController.js
var O4 = 100;
var P5 = 2;
var U3 = 1e4;
var q2 = 1e-4;
var G4 = 1.2;
var Q2 = 500;
var j2 = 1.5;
var T4 = class extends n4(S2) {
  get isMeshPyramid() {
    return "mesh-pyramids" === this.layer.profile || "MeshPyramid" === this.layer.store?.lodType;
  }
  get isGraphics3D() {
    return "points" === this.layer.profile;
  }
  get useMaximumNumberOfFeatures() {
    return !this.isMeshPyramid && (null == this.layer.priority || "High" === this.layer.priority);
  }
  get indexStreamController() {
    const e12 = this.layerView.view.resourceController.createStreamDataRequester(A.I3S_INDEX);
    return new r9(e12, this.layer.customParameters, this.layer.apiKey);
  }
  get dataStreamController() {
    const e12 = this.layerView.view.resourceController.createStreamDataRequester(A.I3S_DATA);
    return new r9(e12, this.layer.customParameters, this.layer.apiKey);
  }
  get crsVertex() {
    return H(this.layer);
  }
  get crsIndex() {
    return Z(this.layer);
  }
  get layer() {
    return this.layerView.i3slayer;
  }
  get running() {
    return this.updating;
  }
  get rootNodeVisible() {
    if (this._index) {
      const e12 = this._index.rootNode;
      if (e12) return this._updateViewData(), this._index.isNodeVisible(e12.index);
    }
    return true;
  }
  get index() {
    return this._index;
  }
  get requiredAttributes() {
    return this._requiredAttributes;
  }
  constructor(e12) {
    super(e12), this.screenSizeFactor = 0, this.featureTarget = 5e4, this.fixedFeatureTarget = false, this.updating = true, this.updatingProgress = 1, this.leavesReached = false, this.worker = null, this._featureLOD = 1, this._stableFeatureLOD = false, this._isIdle = false, this._cameraDirty = true, this._invisibleDirty = false, this._idleStateCallbacks = null, this._newLoadingNodes = new l({
      deallocator: null
    }), this._modificationsNodeFilteringArray = new l(), this._downloadingCount = 0, this._loadingNodes = /* @__PURE__ */ new Map(), this._updatingNodes = /* @__PURE__ */ new Map(), this._progressMaxNumNodes = 1, this._requiredAttributes = new Array(), this._requiredAttributesDirty = true, this._updatesDisabled = false, this.disableIDBCache = false, this._disableMemCache = false, this._restartNodeLoading = false, this._fields = null, this._attributeStorageInfo = null, this._idleQueue = new i2(), this._elevationUpdateNodes = new l({
      deallocator: null
    }), this._errorCount = 0;
  }
  initialize() {
    const {
      layerView: e12,
      layer: t5
    } = this;
    this._disableMemCache = !e12.loadCachedGPUData || !e12.addCachedGPUData, this._lodHandling = new o5(e12), this._defaultGeometrySchema = t5.store.defaultGeometrySchema, this.disableIDBCache = has("disable-feature:idb-cache"), "fields" in t5 && (this._fields = t5.fields, this._attributeStorageInfo = t5.attributeStorageInfo), this.addResolvingPromise(Promise.all([t5.indexInfo, t5.when(), e12.when()]).then(([s12]) => {
      if (this.destroyed || !e12 || e12.destroyed || !s12) return;
      const {
        view: r10,
        clientGeometry: a13
      } = e12, {
        resourceController: l7
      } = r10;
      if (this._setClippingArea(r10.clippingArea), this.addHandles([d(() => r10?.pointsOfInterest?.focus?.renderLocation, (e13) => this._pointOfInterestChanged(e13), P), d(() => r10.quality, () => this._setCameraDirty(), C), d(() => e12.contentVisible, (e13) => {
        const t6 = e13 ? () => this._updateIdleState(true) : () => this._updateViewData(), i4 = e13 ? () => this._updateIdleState(false) : () => {
        };
        e13 && null != this._index && this._index.invalidateAllElevationRanges(), this._idleStateCallbacks ? (e13 || this.cancelNodeLoading(), this.restartNodeLoading(), this._idleStateCallbacks.idleBegin = t6, this._idleStateCallbacks.idleEnd = i4) : this._idleStateCallbacks = l7.scheduler.registerIdleStateCallbacks(t6, i4);
      }, P), h4(e12.view.resourceController.scheduler, this), d(() => e12.uncompressedTextureDownsamplingEnabled, () => this.restartNodeLoading()), d(() => [this.featureTarget, this.fixedFeatureTarget], () => {
        this._setCameraDirty(), this._stableFeatureLOD = false;
      }), d(() => r10.state?.contentCamera, () => this._setCameraDirty()), d(() => t5.elevationInfo, (e13) => this._elevationInfoChanged(e13)), d(() => e12.lodFactor, () => this._setCameraDirty()), d(() => e12.availableFields, () => this._requiredFieldsChange()), d(() => e12.holeFilling, (e13) => null != this._index && (this._index.holeFilling = e13))]), this._viewportQueries = new H3(this.crsIndex, r10.renderCoordsHelper, r10.state.contentCamera, !r10.state.fixedContentCamera || this.isGraphics3D, this._clippingArea, this.isMeshPyramid ? r10.basemapTerrain : r10.elevationProvider, o(r10.viewingMode), this.layer.elevationInfo, {
        progressiveLoadFactor: this._getProgressiveLoadFactor(),
        screenspaceErrorBias: this._lod,
        angleDependentLoD: this._lod < 0.5
      }), this._clientNodeLoader = new h3(this.layer.uid, {
        indexSR: this.crsIndex,
        vertexSR: this.crsVertex,
        renderSR: r10.renderCoordsHelper.spatialReference,
        localMode: "local" === r10.viewingMode
      }, r10.resourceController.memoryController, this.worker), this._index = new I6(o(r10.viewingMode), t5, s12, this.indexStreamController, this._clientNodeLoader, this._viewportQueries, n2.getLogger(this), e12.holeFilling, (t6) => e12.isNodeLoaded(t6), (t6) => e12.isNodeReloading(t6), (e13) => this._shouldLoadNode(e13), (e13) => this._enableFromGPUCache(e13, c.Leaf), (e13) => this._needsUpdate(e13), () => !this.indexStreamController.busy, (t6) => e12.computeVisibilityObb?.(t6) ?? null, e12?.computeNodeFiltering ? (t6) => e12.computeNodeFiltering(t6) : void 0), this._index.updateElevationInfo(this.layer.elevationInfo, this.isMeshPyramid || this.isGraphics3D), this._index.imModificationsChanged(!!e12.hasModifications), this._index.layerFilterChanged(!!e12.hasGeometryFilter), null != a13) {
        for (const e13 of a13) this._addMesh(e13.mesh, e13.oid);
        this.addHandles(a13.on("change", (e13) => {
          for (const t6 of e13.removed) this._removeMesh(t6.oid);
          for (const t6 of e13.added) this._addMesh(t6.mesh, t6.oid);
        }));
      }
      this._startNodeLoading();
    }));
  }
  updateNodeModificationStatus(e12) {
    const t5 = this._index, i4 = this.layerView;
    null != t5 && i4?.updateNodeModificationStatus && (this._modificationsNodeFilteringArray.clear(), e12.forAll((e13) => {
      const i5 = t5.getNode(e13);
      null != i5 && this._modificationsNodeFilteringArray.push(i5);
    }), i4.updateNodeModificationStatus(this._modificationsNodeFilteringArray), this._invisibleDirty = true);
  }
  destroy() {
    this.cancelNodeLoading(), this._idleStateCallbacks && (this._isIdle = false, this._idleStateCallbacks.remove(), this._idleStateCallbacks = null), this._nodeLoader = null, E2.prune(), null != k5 && (k5.hide(), k5 = null);
  }
  get viewportQueries() {
    return this._viewportQueries;
  }
  _getRequiredAttributes() {
    if (null == this._attributeStorageInfo || !this._fields || !this.layerView.availableFields) return [];
    const e12 = this._attributeStorageInfo, t5 = this._fields, i4 = this.layer.objectIdField;
    return this.layerView.availableFields.map((i5) => {
      const s12 = H4(e12, i5), r10 = H4(t5, i5);
      return s12 >= 0 && r10 >= 0 ? {
        index: s12,
        name: t5[r10].name,
        field: t5[r10],
        attributeStorageInfo: e12[s12]
      } : null;
    }).filter((e13) => null != e13 && e13.name !== i4);
  }
  _requiredFieldsChange() {
    const e12 = this._getRequiredAttributes();
    R3(this._requiredAttributes, e12) || (this._requiredAttributes = e12, this._requiredAttributesDirty = false, this.restartNodeLoading());
  }
  requestUpdate() {
    this._requiredAttributesDirty = true, this.restartNodeLoading();
  }
  _setClippingArea(e12) {
    const t5 = u3();
    u8(e12, t5, this.layerView.view.renderSpatialReference) ? this._clippingArea = t5 : this._clippingArea = null;
  }
  _pointOfInterestChanged(e12) {
    null != this._viewportQueries && (this._viewportQueries.setPointOfInterest(e12), null != this._index && (this._index.progressiveLoadPenalty = z4.distancePenalty * this._viewportQueries.distCameraToPOI(), this._index.requestUpdate()));
  }
  updateClippingArea(e12) {
    this._setClippingArea(e12), null != this._viewportQueries && null != this._index && (this._viewportQueries.updateClippingArea(this._clippingArea), this._index.invalidateVisibilityCache()), this._setCameraDirty();
  }
  _setCameraDirty() {
    this._cameraDirty = true, this._lodHandling.setLodGlobalDirty(), this._evaluateUpdating();
  }
  _addMesh(e12, t5) {
    if (null == this._index) return;
    const i4 = this._clientNodeLoader.createMeshNodeInfo(e12, t5), s12 = this._index.addClientNodeToIndex(i4.id, i4.mbs);
    this._clientNodeLoader.addMeshNode(s12, i4), this._evaluateUpdating(), this.notifyChange("rootNodeVisible");
  }
  _removeMesh(e12) {
    const t5 = this._clientNodeLoader.getMeshNodeIndex(e12);
    if (null != t5) {
      if (null == this._index) throw new Error("delayed removal of client side i3s node geometry not supported yet.");
      {
        const e13 = (e14, t6) => {
          this.layerView.removeNode(t6), this._clientNodeLoader.removeNode(e14), this.layerView.deleteCachedNodeData && null != e14 && this.layerView.deleteCachedNodeData(e14), this.layerView.deleteCachedGPUData?.(this.layerView.loadCachedGPUData?.(t6));
        }, i4 = (e14, t6, i5) => {
          this._clientNodeLoader.updateNodeIndex(e14, t6, i5), this.layerView.updateNodeIndex && this.layerView.updateNodeIndex(t6, i5);
        };
        this._index.removeClientNodeFromIndex(t5, e13, i4), this.notifyChange("rootNodeVisible");
      }
    }
  }
  updateElevationChanged(e12, t5) {
    const i4 = this._index;
    if (null == i4?.rootNode || null == t5) return null;
    this.crsIndex.equals(t5) || (i3(e12, t5, B2, this.crsIndex), e12 = B2);
    const s12 = this._elevationUpdateNodes;
    return s12.clear(), k2(e12, i4.rootNode, i4, (e13) => s12.push(e13.index)), s12.length && (s12.forAll((e13) => i4.updateElevationChanged(e13)), this._setCameraDirty()), s12;
  }
  removeAllGeometryObbs() {
    null != this._index && this._index.removeAllGeometryObbs();
  }
  getRenderMbs(e12) {
    return null != this._viewportQueries ? this._viewportQueries.getServiceMbsInRenderSR(e12) : null;
  }
  _elevationInfoChanged(e12) {
    null != this._index && (this._index.updateElevationInfo(e12, this.isMeshPyramid || this.isGraphics3D), this._setCameraDirty());
  }
  restartNodeLoading() {
    this._restartNodeLoading = true, this.cancelNodeLoading(), this._evaluateUpdating();
  }
  schedule(e12, t5) {
    return this._idleQueue.push(e12, t5);
  }
  reschedule(e12, t5) {
    return this._idleQueue.unshift(e12, t5);
  }
  get _isIntegratedMesh() {
    return "integrated-mesh" === this.layer.type;
  }
  get unloadedMemoryEstimate() {
    return null != this._index && this.layerView.contentVisible ? this._index.unloadedMemoryEstimate * this._lodDropFactor : 0;
  }
  _loadNodeData(e12, t5) {
    return __async(this, null, function* () {
      return e12.index < 0 ? this._clientNodeLoader.loadNodeData(e12.id, t5) : this._nodeLoader.loadNodeData(e12, t5);
    });
  }
  _loadAttributes(e12, t5, i4) {
    return __async(this, null, function* () {
      return (e12.index < 0 ? this._clientNodeLoader : this._nodeLoader).loadAttributes(e12, t5, i4);
    });
  }
  get indexDepth() {
    return null != this._index ? this._index.maxLevel : 0;
  }
  set disableMemCache(e12) {
    this.layerView.loadCachedGPUData && this.layerView.addCachedGPUData ? this._disableMemCache = e12 : this._disableMemCache = true;
  }
  runTask(e12, t5) {
    return this.layerView.contentVisible ? this.layerView.visible && null != this._index ? (this._processWithErrorLogging(e12, t5), this._index.maxPriority) : -1 / 0 : (this._updateViewData(), this._evaluateUpdating(), -1 / 0);
  }
  _processWithErrorLogging(e12, t5) {
    try {
      this._process(e12, t5);
    } catch (s12) {
      this._errorCount < 50 ? n2.getLogger(this).error(`Error during processing: ${s12} at ${s12.stack}`) : 50 === this._errorCount && n2.getLogger(this).error("Too many errors for this layer. Further errors will not be displayed."), this._errorCount++;
    }
  }
  _process(e12, t5) {
    this._restartNodeLoading && this._startNodeLoading(), null != this._nodeLoader && null != this._index && (this._updateViewData(), this._invisibleDirty && this._removeInvisibleNodes(e12) && (this._invisibleDirty = false), this._isIntegratedMesh && (e12.enabled = false), e12.run(() => this._processIndex(e12)), this._updateFeatureLOD(), e12.run(() => this._processCache(e12)), this._isIntegratedMesh && (e12.enabled = true), e12.run(() => this._processNodes(e12, t5)), this._idleQueue.runTask(e12), e12.run(() => this._prefetchIndex()), t5.numIndexLoading += this._index.indexLoading, t5.numNodesLoading += this._downloadingCount, e12.run(() => this._lodHandling.lodGlobalHandling(e12)), this._evaluateUpdating());
  }
  _processIndex(e12) {
    if (null == this._index) return false;
    if (this._index.dirty) {
      this._newLoadingNodes.clear(), this._index.update(Array.from(this._loadingNodes.keys()), e12, (e13) => this.updateNodeModificationStatus(e13)), this._disableMemCache || (this._newLoadingNodes.pushArray(this._index.updates.add.data, this._index.updates.add.length), this._newLoadingNodes.pushArray(this._index.updates.missing.data, this._index.updates.missing.length));
      const t5 = this._index.featureEstimate.leavesReached;
      this._index.isLoading || t5 === this._get("leavesReached") || this._set("leavesReached", t5);
    }
    return this._index.load();
  }
  _prefetchIndex() {
    return !(null == this._index || this._loadingNodes.size > 0 || this._index.updates.add.length > 0) && this._index.prefetch();
  }
  _updateFeatureLOD() {
    if (!this.useMaximumNumberOfFeatures || null == this._index || null == this._viewportQueries) return;
    const e12 = !this._index.isLoading, t5 = this.featureTarget * this._baseLOD, i4 = this._index.featureEstimate;
    if (i4.estimate = i4.estimate || t5 / 2, this._index.indexMissing > Q2) {
      if (this._featureLOD <= q2) return;
      this._featureLOD /= j2, this._stableFeatureLOD = false;
    } else if (e12 && i4.estimate < t5) {
      if (i4.leavesReached || this._featureLOD >= U3 || this._stableFeatureLOD) return;
      const e13 = Math.min(10, Math.max(t5 / i4.estimate, 1.001));
      this._featureLOD *= e13;
      const s12 = this._lod, r10 = this._index.checkFeatureTarget(t5, s12);
      r10 !== s12 && (this._featureLOD = r10 / this._baseLOD, this._stableFeatureLOD = true);
    } else {
      if (!(i4.estimate > t5 * G4 || e12 && i4.estimate > t5)) return;
      if (this._featureLOD <= q2) return;
      this._featureLOD /= 1 + 0.25 * (i4.estimate / t5 - 1), this._stableFeatureLOD = false;
    }
    this._featureLOD = Math.min(U3, Math.max(q2, this._featureLOD)), this._viewportQueries.updateScreenSpaceErrorBias(this._lod), this._index.requestUpdate();
  }
  _processCache(e12) {
    const t5 = this._index;
    if (null == t5) return false;
    for (; this._newLoadingNodes.length > 0 && !e12.done; ) {
      const i4 = this._newLoadingNodes.pop();
      for (let s12 = t5.getParent(i4); null != s12 && !this.layerView.isNodeLoaded(s12.index); s12 = t5.getParent(s12.index)) if (this._enableFromGPUCache(s12, c.Hole)) {
        e12.madeProgress();
        break;
      }
    }
    return e12.hasProgressed;
  }
  _processNodes(e12, t5) {
    if (null == this._index) return false;
    let i4 = (this._isIdle ? O4 : P5) - this._loadingNodes.size;
    const s12 = this._index.updates;
    for (s12.cancel.forEach(this._cancelNode, this), s12.cancel = []; s12.remove.length > 0 && !e12.done; ) this.layerView.removeNode(s12.remove.pop()), e12.madeProgress();
    for (; s12.update.length > 0 && !e12.done; ) {
      const t6 = this._index.getNode(s12.update.pop());
      null != t6 && (this._updateLoadedNode(t6), e12.madeProgress());
    }
    for (; s12.add.length > 0 && !e12.done && i4 > 0; ) {
      --i4;
      const r10 = this._index.getNode(s12.add.back());
      if (null == r10 || r10.cacheState !== a8.Cached && !this._hasNodeLoadToken(t5)) break;
      s12.add.pop(), this._loadNode(r10), e12.madeProgress();
    }
    return e12.hasProgressed;
  }
  _cancelAllNodes() {
    this._loadingNodes.forEach((e12) => e12.abort()), this._loadingNodes.clear(), this._updatingNodes.forEach((e12) => e12.abort()), this._updatingNodes.clear();
  }
  _cancelNode(e12) {
    const t5 = this._loadingNodes.get(e12);
    t5 && (t5.abort(), this._loadingNodes.delete(e12));
  }
  _hasNodeLoadToken(e12) {
    return !(!this._isIdle && e12.numNodesLoading + this._loadingNodes.size >= P5) && this._downloadingCount < I5 && !this.dataStreamController.busy;
  }
  _evaluateUpdating() {
    let e12 = false, t5 = 0;
    if (this.layerView) {
      if (this.layerView.contentVisible) {
        const i4 = (null != this._index ? this._index.indexMissing : 0) + 3 * (null != this._index ? this._index.updates.add.length : 0) + 2 * this._loadingNodes.size;
        e12 = !!(i4 > 0 || this._updatingNodes.size > 0 || this._restartNodeLoading || this._cameraDirty || this._idleQueue.running || this._lodHandling && this._lodHandling.requiresLODGlobalHandling || null != this._index && this._index.isPrefetching), 0 === i4 && (this._progressMaxNumNodes = 1), this._progressMaxNumNodes = Math.max(i4, this._progressMaxNumNodes), t5 = 1 - i4 / this._progressMaxNumNodes;
      } else e12 = this._cameraDirty, t5 = e12 ? 0 : 1;
      this.updating = e12, this.updatingProgress = t5;
    }
  }
  _updateViewData() {
    if (!this._cameraDirty || null == this._index || null == this._viewportQueries) return;
    const e12 = this.layerView.view, {
      contentCamera: t5,
      fixedContentCamera: i4
    } = e12.state;
    this.screenSizeFactor = 1 / (t5.perScreenPixelRatio / 2), this._viewportQueries.updateCamera(t5, !i4 || this.isGraphics3D), this._viewportQueries.setPointOfInterest(e12.pointsOfInterest.focus.renderLocation), this._viewportQueries.updateScreenSpaceErrorBias(this._lod), this._index.invalidateVisibilityCache(), this._index.progressiveLoadPenalty = z4.distancePenalty * this._viewportQueries.distCameraToPOI(), this._index.requestUpdate(), this._stableFeatureLOD = false, this._invisibleDirty = true, this._cameraDirty = false, this.notifyChange("rootNodeVisible");
  }
  _getProgressiveLoadFactor() {
    return this.layerView.view.quality < 1 ? 1 : this.layerView.progressiveLoadFactor;
  }
  get _lod() {
    return this._featureLOD * this._baseLOD;
  }
  get _baseLOD() {
    const e12 = this.layerView.lodFactor;
    return this.fixedFeatureTarget ? 1 : (e12 > 0 ? e12 : 1) * this.layerView.view.quality;
  }
  get _lodDropFactor() {
    if (this.fixedFeatureTarget) return 1;
    return (Math.min(this.layerView.view.quality, 0.5) - l5) / (0.5 - l5);
  }
  isGeometryVisible(e12) {
    return !!this._index?.isGeometryVisible(e12.index);
  }
  updateVisibility(e12) {
    this._index?.invalidateNodeVisibilityCache(e12);
  }
  invalidateGeometryVisibility(e12) {
    this._index?.invalidateGeometryVisibility(e12);
  }
  invalidateVisibilityObbs() {
    this._index?.invalidateVisibilityObbs();
  }
  modificationsChanged() {
    this._index?.imModificationsChanged(!!this.layerView.hasModifications), this._invisibleDirty = true;
  }
  _shouldLoadNode(e12) {
    return !(!this._lodHandling.shouldLoadNode(e12) || this._shouldDropNode(e12)) && !(null == this._index || !this._index.isGeometryVisible(e12.index));
  }
  _shouldDropNode(e12) {
    if (null == this._viewportQueries) return false;
    const t5 = this._lodDropFactor;
    if (t5 >= 1 || !this._lodHandling.hasNoVisibleChildren(e12)) return false;
    return Math.abs(this._viewportQueries.calcCameraDistanceToCenter(e12)) - this._viewportQueries.minDistance > (this._viewportQueries.maxDistance - this._viewportQueries.minDistance) * t5;
  }
  _startNodeLoading() {
    this._restartNodeLoading = false;
    const e12 = this._index;
    if (this._updatesDisabled || null == e12 || null == this._viewportQueries) return;
    this._updateViewData(), this._requiredAttributesDirty && (this._requiredAttributes = this._getRequiredAttributes(), this._requiredAttributesDirty = false);
    const t5 = {
      textureEncodings: this.layerView.supportedTextureEncodings,
      uncompressedTextureDownsamplingEnabled: this.layerView.uncompressedTextureDownsamplingEnabled,
      textureUsageMask: this.layerView.rendererTextureUsage,
      loadFeatureData: this.useMaximumNumberOfFeatures
    };
    this._nodeLoader = new d6(this.layer, this.dataStreamController, n2.getLogger(this), this._defaultGeometrySchema, this._requiredAttributes, t5), e12.requestUpdate(), this._lodHandling.startNodeLoading((e13, t6) => this._removeNodes(e13, t6, $3.fadeout), e12, {
      maxLodLevel: this._viewportQueries.maxLodLevel
    }), this._evaluateUpdating();
  }
  isNodeLoading() {
    return null != this._nodeLoader && null != this._index;
  }
  cancelNodeLoading() {
    this.isNodeLoading() && (this.indexStreamController.cancelAll(), this.dataStreamController.cancelAll(), this._idleQueue.cancelAll(), this._cancelAllNodes(), this._nodeLoader = null, this._evaluateUpdating());
  }
  _removeInvisibleNodes(e12) {
    const t5 = this._index;
    if (null == t5 || null == this._viewportQueries) return false;
    E2.clear(), this.layerView.getLoadedNodeIndices(E2);
    const i4 = 0 === this._viewportQueries.maxDistance, s12 = i4 ? () => false : (e13) => this._shouldDropNode(e13);
    return E2.filterInPlace((e13) => {
      const i5 = t5.getNode(e13);
      return null == i5 || !t5.isGeometryVisible(e13) || s12(i5);
    }), E2.length > 0 && this._lodHandling.setLodGlobalDirty(), this._removeNodes(E2, e12, $3.pop), !(i4 && this._lodDropFactor < 1) && (0 === E2.length || (E2.clear(), false));
  }
  markNodeToRemove(e12) {
    E2.push(e12);
  }
  removeMarkedNodes() {
    this._removeNodes(E2, C2, $3.pop);
  }
  _removeNodes(e12, t5, i4) {
    if (0 !== e12.length && !t5.done) for (null != this._index && this._index.requestUpdate(); e12.length > 0 && !t5.done; ) {
      const s12 = e12.pop(), r10 = this._index;
      i4 === $3.fadeout && this.layerView.nodeFadeoutEnabled && null != r10 && r10.isGeometryVisible(s12) ? this.layerView.fadeNode(s12, a12.FadeOut, true) : this.layerView.removeNode(s12), t5.madeProgress();
    }
  }
  _needsUpdate(e12) {
    if (e12.resources.isEmpty || this._updatingNodes.has(e12.index)) return false;
    const t5 = this.layerView.getLoadedAttributes(e12.index);
    return null != t5 && t5 !== this._requiredAttributes;
  }
  _updateLoadedNode(e12) {
    return __async(this, null, function* () {
      const t5 = new AbortController();
      this._updatingNodes.set(e12.index, t5), this._evaluateUpdating();
      try {
        const i4 = R3(this.layerView.getLoadedAttributes(e12.index), this._requiredAttributes);
        let s12 = null;
        s12 = i4 ? this.layerView.getAttributeData(e12.index) : yield this._loadAttributes(e12, this._requiredAttributes, t5.signal), yield this.schedule(() => this.layerView.updateAttributes(e12.index, {
          loadedAttributes: this._requiredAttributes,
          attributeData: s12
        }, t5.signal), t5.signal);
      } catch (i4) {
        if (!b(i4)) return this.layerView.updateAttributes(e12.index, {
          loadedAttributes: this._requiredAttributes,
          attributeData: {}
        }, t5.signal);
      }
      this._updatingNodes.delete(e12.index), this._evaluateUpdating();
    });
  }
  _loadNode(e12) {
    if (this._loadingNodes.has(e12.index)) return void n2.getLogger(this).error("already loading node " + e12.index);
    const t5 = new AbortController();
    this._loadingNodes.set(e12.index, t5), this._evaluateUpdating(), this._loadAndAddNode(e12, t5.signal).then((i4) => {
      i4 && null != this._index && this._loadingNodes.get(e12.index) === t5 && (this._loadingNodes.delete(e12.index), this._index.requestUpdate());
    }).catch((e13) => {
      if (!b(e13)) throw e13;
    }).finally(() => {
      this._loadingNodes.get(e12.index) === t5 && this._loadingNodes.delete(e12.index), this._evaluateUpdating();
    });
  }
  _loadAndAddNode(e12, t5) {
    return e12.cacheState === a8.Uncached ? this._loadUncached(e12, t5).then(() => false) : this._loadCached(e12, t5).then((t6) => !t6 && (e12.cacheState = a8.Uncached, true)).catch((t6) => !b(t6) && (e12.cacheState = a8.Uncached, true));
  }
  _enableFromGPUCache(e12, t5) {
    if (this._disableMemCache || null == this._index) return false;
    if (t5 === c.Hole && !this._index.useNodeAsHole(e12.index)) return true;
    const i4 = this._loadCachedGPUData(e12);
    return !!i4 && (this.layerView.addCachedGPUData(e12, i4, t5), this._nodeAdded(), true);
  }
  _loadCachedGPUData(e12) {
    const t5 = this.layerView.loadCachedGPUData(e12.index);
    return null != t5?.attributeInfo && R3(t5.attributeInfo.loadedAttributes, this._requiredAttributes) ? t5 : (this.layerView.deleteCachedGPUData(t5), null);
  }
  _nodeAdded() {
    null != this._index && this._index.requestUpdate(), this._lodHandling.setLodGlobalDirty(), this._evaluateUpdating();
  }
  updateLoadStatus(e12, t5) {
    const i4 = this._index;
    null != i4 && i4.updateChildrenLoaded(e12, t5 ? 1 : -1);
  }
  _loadCached(e12, t5) {
    return __async(this, null, function* () {
      if (this._enableFromGPUCache(e12, c.Leaf)) return true;
      const i4 = this.layerView;
      if (this.disableIDBCache || !i4.loadCachedNodeData || !i4.addCachedNodeData) return false;
      const s12 = (t6, i5) => this._nodeLoader.loadTextures(e12, t6, i5), r10 = (t6, i5) => this._clientNodeLoader.loadTextures(e12, t6, i5), a13 = e12.index >= 0 ? s12 : r10, d7 = yield this.schedule(() => i4.loadCachedNodeData(e12, t5, a13), t5);
      if (null == d7) return false;
      const o6 = this._requiredAttributes, n11 = yield this.reschedule(() => this._loadAttributes(e12, o6, t5), t5);
      return yield this.reschedule(() => i4.addCachedNodeData(e12, d7, {
        loadedAttributes: o6,
        attributeData: n11
      }, t5), t5), this._nodeAdded(), true;
    });
  }
  _loadUncached(e12, t5) {
    return this._downloadingCount++, this._loadNodeData(e12, t5).catch((e13) => {
      throw this._downloadingCount--, e13;
    }).then((i4) => (this._downloadingCount--, this.schedule(() => this.layerView.addNode(e12, i4, t5), t5))).then(() => {
      this._nodeAdded(), e12.cacheState = a8.Cached;
    }).catch((t6) => {
      if (!b(t6)) throw n2.getLogger(this).error("#loadNodeData()", this.layer, `Failed to load node '${e12.id}'`, t6), e12.failed = true, null != this._index && this._index.requestUpdate(), t6;
    });
  }
  _updateIdleState(e12) {
    e12 !== this._isIdle && (this._isIdle = e12, this._evaluateUpdating(), e12 && this._index && null != this._index && this._index.resetFailedNodes());
  }
  get test() {
  }
  notifyLODUpdate() {
    this._lodHandling.setLodGlobalDirty(), this._evaluateUpdating(), null != this._index && this._index.requestUpdate();
  }
  geometryFilterChanged(e12) {
    const t5 = this._index;
    null != t5 && t5.layerFilterChanged(e12), this._setCameraDirty();
  }
};
e3([y({
  readOnly: true
})], T4.prototype, "isMeshPyramid", null), e3([y({
  readOnly: true
})], T4.prototype, "isGraphics3D", null), e3([y({
  readOnly: true
})], T4.prototype, "useMaximumNumberOfFeatures", null), e3([y({
  readOnly: true
})], T4.prototype, "indexStreamController", null), e3([y({
  readOnly: true
})], T4.prototype, "dataStreamController", null), e3([y({
  readOnly: true
})], T4.prototype, "crsVertex", null), e3([y({
  readOnly: true
})], T4.prototype, "crsIndex", null), e3([y()], T4.prototype, "screenSizeFactor", void 0), e3([y()], T4.prototype, "featureTarget", void 0), e3([y()], T4.prototype, "fixedFeatureTarget", void 0), e3([y()], T4.prototype, "layerView", void 0), e3([y()], T4.prototype, "layer", null), e3([y()], T4.prototype, "updating", void 0), e3([y({
  readOnly: true
})], T4.prototype, "running", null), e3([y()], T4.prototype, "updatingProgress", void 0), e3([y({
  readOnly: true
})], T4.prototype, "leavesReached", void 0), e3([y({
  constructOnly: true
})], T4.prototype, "worker", void 0), e3([y({
  readOnly: true,
  dependsOn: []
})], T4.prototype, "rootNodeVisible", null), T4 = e3([a3("esri.layers.graphics.controllers.I3SOnDemandController")], T4);
var E2 = new l({
  deallocator: null
});
var k5;
function R3(e12, t5) {
  return null != e12 && e12.length === t5.length && e12.every((e13) => H4(t5, e13.name) >= 0);
}
function H4(e12, t5) {
  const i4 = t5.toLowerCase();
  for (let s12 = 0; s12 < e12.length; s12++) if (e12[s12].name.toLowerCase() === i4) return s12;
  return -1;
}
var z4 = {
  factorIM: 0.2,
  factor3dObject: 0.05,
  distancePenalty: 10
};
var B2 = u3();
var $3;
!function(e12) {
  e12[e12.pop = 0] = "pop", e12[e12.fadeout = 1] = "fadeout";
}($3 || ($3 = {}));
var K3 = T4;

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/I3SOverrides.js
var G5 = class extends S2 {
  constructor(e12) {
    super(e12), this._warnMaximumChangedObjectsExceeded = false, this._maximumNumberOfEditOVerrides = V5, this._original3DOFLDefinitionExpression = null, this._interactiveEditingSessions = new V(), this.geometryOverrides = new V(), this._clientGeometryCache = /* @__PURE__ */ new Map(), this._associatedLayerView = null, this._attributeChangedObjectIds = new s8(), this._geometryChangedObjectIds = new s8(), this._pendingFetchChangedObjectIds = null, this._pendingFetchAbortController = new AbortController(), this._featureIdLocks = /* @__PURE__ */ new Map();
  }
  initialize() {
    this._memCache = this.memoryController.newCache(`i3s-attribute-overrides-${this.layer.uid}`), this._pendingFetchChangedObjectIds = this._fetchChangedObjectIds(this._pendingFetchAbortController?.signal), this._pendingFetchChangedObjectIds.finally(() => {
      this._pendingFetchAbortController = null, this._pendingFetchChangedObjectIds = null;
    }), this.is3DOFL && null != this._associatedLayer && (a4() ? this._associatedLayer.load().then((e12) => {
      this.destroyed || (this._original3DOFLDefinitionExpression = e12.definitionExpression, this.addHandles(d(() => this._definitionExpression, (t5) => e12.definitionExpression = t5, P)), this._associatedLayerView = new n10({
        layer: this._associatedLayer,
        view: this.view
      }));
    }) : r3());
  }
  destroy() {
    this.is3DOFL && null != this._associatedLayer && (a4() ? null != this._associatedLayerView && (this._associatedLayer.definitionExpression = this._original3DOFLDefinitionExpression) : r3()), this._set("layer", null), this._memCache = u(this._memCache), this._pendingFetchAbortController = e(this._pendingFetchAbortController), this._pendingFetchChangedObjectIds = null, this._featureIdLocks.clear();
  }
  get is3DOFL() {
    return n7() && null != this._associatedLayer?.infoFor3D;
  }
  get sortedGeometryChangedObjectIds() {
    return this.is3DOFL ? [...this._geometryChangedObjectIds].sort((e12, t5) => e12 - t5) : [];
  }
  get _associatedLayer() {
    return null == this.layer ? null : this.layer.associatedLayer;
  }
  get hasGeometryChanges() {
    return this._geometryChangedObjectIds.size > 0;
  }
  get _definitionExpression() {
    const e12 = this.sortedGeometryChangedObjectIds;
    return 0 === e12.length ? "1 = 0" : `OBJECTID IN (${e12.join(",")})`;
  }
  get updating() {
    if (!this.is3DOFL) return false;
    if (this._pendingFetchChangedObjectIds) return true;
    if (a4()) {
      return !(null != this._associatedLayerView) || null != this._associatedLayerView && this._associatedLayerView.updating;
    }
    return false;
  }
  get isEmpty() {
    return null == this._pendingFetchChangedObjectIds && 0 === this._attributeChangedObjectIds.size && 0 === this._geometryChangedObjectIds.size;
  }
  featureHasGeometryChanges(e12) {
    return this._geometryChangedObjectIds.has(e12);
  }
  featureHasAttributeChanges(e12) {
    return this._attributeChangedObjectIds.has(e12);
  }
  createInteractiveEditSession(e12) {
    this._attributeChangedObjectIds.add(e12);
    const t5 = this._interactiveEditingSessions, i4 = new D4(e12, () => {
      t5.remove(i4);
    });
    return t5.unshift(i4), i4;
  }
  applyAttributeOverrides(_0, _1, _22) {
    return __async(this, arguments, function* (e12, t5, i4, r10 = []) {
      if (this._pendingFetchChangedObjectIds && (yield h(this._pendingFetchChangedObjectIds, i4)), null == t5) return;
      const {
        attributeData: s12,
        loadedAttributes: o6
      } = t5;
      if (null == o6 || null == s12 || 0 === this._attributeChangedObjectIds.size) return;
      const n11 = /* @__PURE__ */ new Set();
      for (const d7 of o6) n11.add(d7.index);
      for (const d7 of r10) n11.has(d7.index) || (o6.push(d7), s12[d7.name] = new Array(e12.length));
      const a13 = yield this._lockFeatureIds(e12);
      try {
        const t6 = {
          attributeData: s12,
          loadedAttributes: o6
        }, r11 = this._getOverridesFromCache(e12, t6, this._attributeChangedObjectIds), {
          objectIds: n12,
          fieldNames: a14
        } = r11;
        if (0 === n12.length || 0 === a14.length) return;
        const d7 = yield this._queryAttributeOverridesFromAssociatedLayer(n12, a14, i4);
        if (null == d7) return;
        this._processOverridesFromAssociatedLayer(e12, d7, a14, t6);
      } finally {
        a13.remove();
      }
    });
  }
  updateGeometry(e12, t5) {
    this._geometryChangedObjectIds.add(e12);
    const i4 = this._clientGeometryCache.get(e12);
    if (null != i4 && (this.geometryOverrides.remove(i4), this._clientGeometryCache.delete(e12)), null != t5) {
      const i5 = {
        oid: e12,
        mesh: t5
      };
      this.geometryOverrides.add(i5), this._clientGeometryCache.set(e12, i5);
    }
  }
  updateAttributeValue(e12, t5, i4) {
    this._attributeChangedObjectIds.add(e12), this._cacheAttributeValue(e12, t5, i4);
  }
  featureAdded(e12) {
    this.is3DOFL && r3() && this._geometryChangedObjectIds.add(e12), this._attributeChangedObjectIds.add(e12);
  }
  _cacheAttributeValue(e12, t5, i4) {
    this._memCache.put(this._getAttributeCacheKey(e12, t5), i4, this._memCacheAttributeValueSize(i4));
  }
  _getOverridesFromCache(e12, {
    loadedAttributes: t5,
    attributeData: i4
  }, r10) {
    const s12 = /* @__PURE__ */ new Set(), o6 = new Array();
    for (const a13 of t5) o6[a13.index] = i4[a13.name];
    const n11 = /* @__PURE__ */ new Set();
    for (let a13 = 0; a13 < e12.length; a13++) {
      const i5 = e12[a13];
      if (r10.has(i5)) for (const e13 of t5) {
        const t6 = this._attributeFromCache(i5, e13.index);
        void 0 === t6 ? (s12.add(i5), n11.add(e13.name)) : o6[e13.index][a13] = t6;
      }
    }
    return {
      objectIds: Array.from(s12),
      fieldNames: Array.from(n11)
    };
  }
  _attributeFromCache(e12, t5) {
    const i4 = this._fromInteractiveEditingSession(e12, t5);
    if (void 0 !== i4) return i4;
    const r10 = this._getAttributeCacheKey(e12, t5);
    return this._memCache.get(r10);
  }
  _fromInteractiveEditingSession(e12, t5) {
    if (null != this._interactiveEditingSessions) for (const i4 of this._interactiveEditingSessions) {
      if (i4.objectId !== e12) continue;
      const r10 = i4.getAttribute(t5);
      if (void 0 !== r10) return r10;
    }
  }
  _getAttributeCacheKey(e12, t5) {
    return `${e12}-${t5}`;
  }
  _queryAttributeOverridesFromAssociatedLayer(e12, t5, i4) {
    return __async(this, null, function* () {
      if (0 === e12.length) return null;
      this._logWarningIfMaximumObjectsExceeded();
      const {
        associatedLayer: r10
      } = this.layer;
      if (null == r10) return null;
      const s12 = r10.createQuery(), {
        objectIdField: o6
      } = r10, n11 = [o6, ...t5];
      s12.where = "1=1", s12.returnGeometry = false, s12.outFields = n11, s12.cacheHint = true;
      const a13 = yield this._executeBatchQuery(r10, e12, s12, i4), d7 = [];
      for (const c5 of a13) if (c5.ok) for (const e13 of c5.value.features) d7.push(e13);
      return d7;
    });
  }
  _queryGeometryOverridesFromAssociatedLayer(e12, t5) {
    return __async(this, null, function* () {
      if (0 === e12.length || !this.is3DOFL || !r3()) return null;
      const i4 = this.layer.associatedLayer, r10 = i4.infoFor3D, {
        spatialReference: s12
      } = i4, {
        state: {
          viewingMode: o6
        },
        spatialReference: n11
      } = this.view, a13 = o6 === l3.Global, d7 = s12.isGeographic;
      if (a13 && !d7) return n2.getLogger(this).warn("unsupported-pcs-edits-in-global-view", this.layer.title, k6(s12, n11, this.view.viewingMode, $4.Mode)), null;
      if (!a13 && d7) return n2.getLogger(this).warn("unsupported-gcs-edits-in-local-view", this.layer.title, k6(s12, n11, this.view.viewingMode, $4.Mode)), null;
      if (!(G(s12, n11) || a13 && n11.isWebMercator && s12.isWGS84)) return n2.getLogger(this).warn("unsupported-mismatched-spatial-reference-edits", this.layer.title, k6(s12, n11, this.view.viewingMode, $4.SpatialReference)), null;
      this._logWarningIfMaximumObjectsExceeded();
      const {
        objectIdField: c5,
        globalIdField: l7
      } = i4, u9 = [c5, ...null != l7 ? [l7] : []], m4 = i4.createQuery();
      m4.where = "1=1", m4.returnGeometry = true, m4.outFields = u9, m4.cacheHint = true, m4.returnZ = i4.hasZ, m4.returnM = i4.hasM;
      const g4 = yield this._executeBatchQuery(i4, e12, m4, t5), p5 = [];
      for (const h7 of g4) {
        if (!h7.ok) continue;
        const e13 = h7.value, {
          assetMaps: t6,
          features: i5,
          globalIdFieldName: o7
        } = e13;
        if (null == t6) continue;
        const n12 = d3(r10, t6);
        for (const a14 of i5) {
          const e14 = y3(a14, o7, s12, r10, n12), t7 = a14;
          null != e14 ? (t7.geometry = e14, p5.push(t7)) : t7.geometry = null;
        }
      }
      return p5;
    });
  }
  _logWarningIfMaximumObjectsExceeded() {
    if (!this._warnMaximumChangedObjectsExceeded) return;
    this._warnMaximumChangedObjectsExceeded = false;
    let e12 = `The number of edited objects that are not yet cached in the scene service exceeds the maximum limit. Attribute changes will only be available for the first ${l2(this._maximumNumberOfEditOVerrides)} objects. Please consider re-caching the scene service`;
    const t5 = this.layer.portalItem;
    e12 += t5?.loaded ? ` (${t5.portal.url}/home/item.html?id=${t5.id}#settings)` : ` (${this.layer.parsedUrl.path})`, n2.getLogger(this).warn("#queryOverrides()", this.layer.title, `${e12}.`);
  }
  _executeBatchQuery(e12, t5, i4, o6) {
    return __async(this, null, function* () {
      if (0 === t5.length) return [];
      const n11 = t2(e12);
      t5 = [...t5].sort((e13, t6) => e13 - t6);
      const a13 = p(t5, n11).map((t6) => {
        const r10 = i4.clone();
        return r10.objectIds = t6, b2(r6(e12, r10, {
          signal: o6
        }));
      });
      return Promise.all(a13);
    });
  }
  _processOverridesFromAssociatedLayer(e12, t5, i4, {
    loadedAttributes: r10,
    attributeData: s12
  }) {
    const o6 = this._associatedLayer;
    if (null == o6) return;
    const n11 = o6.objectIdField, a13 = i4.map((t6) => (t6 in s12 || (s12[t6] = new Array(e12.length)), s12[t6])), d7 = new Map(r10.map((e13) => [e13.name, e13.index])), c5 = i4.map((e13) => d7.get(e13)), h7 = new Map(Array.from(e12, (e13, t6) => [e13, t6]));
    for (const l7 of t5) {
      const e13 = l7.attributes[n11];
      for (let t6 = 0; t6 < i4.length; t6++) {
        const r11 = c5[t6], s13 = h7.get(e13), o7 = l7.attributes[i4[t6]];
        a13[t6][s13] = o7, this._cacheAttributeValue(e13, r11, o7);
      }
    }
  }
  _memCacheAttributeValueSize(e12) {
    return "string" == typeof e12 ? r(e12) : n();
  }
  _fetchChangedObjectIds(e12) {
    return __async(this, null, function* () {
      const i4 = this.layer;
      yield i4.load({
        signal: e12
      }), this._geometryChangedObjectIds.clear(), this._attributeChangedObjectIds.clear();
      const {
        associatedLayer: r10
      } = i4;
      if (null == r10 || !r10.capabilities?.operations?.supportsChangeTracking) return;
      const s12 = this._getFetchChangedObjectIdsServerGen();
      if (null == s12) return;
      const n11 = r10.layerId, a13 = this.is3DOFL, d7 = {
        f: "json",
        returnIdsOnly: true,
        layers: `[${n11}]`,
        returnUpdates: true,
        returnDeletes: a13,
        returnInserts: a13,
        layerServerGens: JSON.stringify([{
          id: n11,
          serverGen: s12
        }])
      };
      if (a13) {
        const e13 = r10.infoFor3D;
        d7.fieldsToCompare = JSON.stringify({
          fields: [...Object.values(e13.transformFieldRoles), e13.sourceHashField]
        });
      }
      const c5 = yield _2(U(`${r10.url}/extractChanges`, {
        method: "post",
        query: d7,
        timeout: M4,
        signal: e12
      }));
      if (!c5.ok && m(c5.error)) {
        const e13 = this.layer.title;
        n2.getLogger(this).warn("extractChanges:timeout", e13, `${e13} could not obtain edited features that are not cached in the scene service. Display of features may not be up to date with the latest edits. Consider re-caching the scene service.`);
      }
      if (c5.ok && 1 === c5.value.data?.edits?.length) {
        const t5 = c5.value.data.edits[0], i5 = t5?.objectIds, s13 = t5?.fieldUpdates, o6 = i5?.adds ?? [], n12 = i5?.updates ?? [], d8 = i5?.deletes ?? [], h7 = [...o6, ...n12, ...d8], l7 = a13 ? [...o6, ...s13 ?? n12, ...d8] : [], u9 = Math.min(this._maximumNumberOfEditOVerrides, h7.length);
        u9 < h7.length && (this._warnMaximumChangedObjectsExceeded = true);
        const m4 = h7.sort((e13, t6) => e13 - t6);
        for (let e13 = 0; e13 < u9; ++e13) {
          const t6 = m4[e13];
          this._attributeChangedObjectIds.add(t6);
        }
        for (const e13 of l7) this._geometryChangedObjectIds.add(e13);
        if (this.is3DOFL && r3() && this._geometryChangedObjectIds.size > 0) {
          const t6 = yield this._queryGeometryOverridesFromAssociatedLayer(Array.from(this._geometryChangedObjectIds), e12);
          if (null != t6) for (const e13 of t6) null != e13.geometry && this.updateGeometry(e13.attributes[r10.objectIdField], e13.geometry);
        }
      }
    });
  }
  _getFetchChangedObjectIdsServerGen() {
    const e12 = this.layer;
    if (null != e12.serviceUpdateTimeStamp?.lastUpdate) return e12.serviceUpdateTimeStamp.lastUpdate;
    const t5 = e12.associatedLayer;
    return null != t5?.serverGens?.minServerGen ? t5.serverGens.minServerGen : null;
  }
  _lockFeatureIds(e12) {
    return __async(this, null, function* () {
      const t5 = this._featureIdLocks;
      let i4 = true;
      for (; i4; ) {
        const r11 = new Array();
        for (const i5 of e12) {
          const e13 = t5.get(i5);
          e13 && r11.push(e13);
        }
        0 === r11.length ? i4 = false : yield Promise.all(r11);
      }
      const r10 = L(), s12 = r10.promise;
      for (const o6 of e12) t5.set(o6, s12);
      return e2(() => {
        for (const i5 of e12) t5.delete(i5);
        r10.resolve();
      });
    });
  }
  get test() {
  }
};
e3([y({
  constructOnly: true
})], G5.prototype, "view", void 0), e3([y({
  constructOnly: true
})], G5.prototype, "layer", void 0), e3([y({
  readOnly: true
})], G5.prototype, "is3DOFL", null), e3([y()], G5.prototype, "_interactiveEditingSessions", void 0), e3([y({
  readOnly: true
})], G5.prototype, "sortedGeometryChangedObjectIds", null), e3([y({
  readOnly: true
})], G5.prototype, "geometryOverrides", void 0), e3([y()], G5.prototype, "_clientGeometryCache", void 0), e3([y()], G5.prototype, "_associatedLayer", null), e3([y()], G5.prototype, "_associatedLayerView", void 0), e3([y({
  constructOnly: true
})], G5.prototype, "memoryController", void 0), e3([y()], G5.prototype, "_attributeChangedObjectIds", void 0), e3([y()], G5.prototype, "_geometryChangedObjectIds", void 0), e3([y()], G5.prototype, "hasGeometryChanges", null), e3([y()], G5.prototype, "_pendingFetchChangedObjectIds", void 0), e3([y()], G5.prototype, "_pendingFetchAbortController", void 0), e3([y()], G5.prototype, "_definitionExpression", null), e3([y()], G5.prototype, "updating", null), e3([y()], G5.prototype, "isEmpty", null), G5 = e3([a3("esri.views.3d.layers.i3s.I3SOverrides")], G5);
var D4 = class {
  constructor(e12, t5) {
    this.objectId = e12, this._remove = t5, this._updates = /* @__PURE__ */ new Map(), this._isActive = true;
  }
  getAttribute(e12) {
    return this._updates.get(e12);
  }
  setAttribute(e12, t5) {
    this.isActive && this._updates.set(e12, t5);
  }
  remove() {
    this.isActive && (this._isActive = false, this._remove());
  }
  get isActive() {
    return this._isActive;
  }
};
var M4 = 1e4;
var V5 = 5e4;
var $4;
function k6(e12, t5, i4, r10) {
  return `Displaying the edits of a SceneLayer with a${r10 === $4.Mode ? e12.isGeographic ? " geographic " : " projected " : " "}spatial reference (wkid:${e12.wkid}) in ${i4} viewing mode${r10 === $4.SpatialReference ? ` with spatial reference (wkid:${t5.wkid}) ` : " "}is not supported. No geometry edits will be displayed for this layer.
Please consider re-caching the scene service or changing the ${r10 === $4.Mode ? "viewing mode" : "view spatial reference"} to display edits.`;
}
!function(e12) {
  e12[e12.Mode = 0] = "Mode", e12[e12.SpatialReference = 1] = "SpatialReference";
}($4 || ($4 = {}));

export {
  e11 as e,
  s10 as s,
  a12 as a,
  b5 as b,
  C4 as C,
  M3 as M,
  R2 as R,
  D3 as D,
  K3 as K,
  G5 as G
};
//# sourceMappingURL=chunk-JCGHSOIP.js.map
