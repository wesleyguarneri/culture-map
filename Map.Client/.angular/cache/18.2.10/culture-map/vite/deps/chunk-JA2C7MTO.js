import {
  o as o11,
  r as r10,
  t as t9,
  u as u2
} from "./chunk-74INNEIP.js";
import {
  d as d2
} from "./chunk-7HBD4CJ3.js";
import {
  r as r7
} from "./chunk-K2LTET4M.js";
import {
  I
} from "./chunk-WG5JLPNN.js";
import {
  E as E3
} from "./chunk-RASN5P76.js";
import {
  p
} from "./chunk-5L3YXBNN.js";
import {
  A as A2,
  E as E2,
  _ as _4,
  c as c4,
  f as f4,
  s as s5
} from "./chunk-IFUKJDOU.js";
import {
  e as e10,
  f as f6,
  o as o10
} from "./chunk-LD5YIQXD.js";
import {
  t as t10
} from "./chunk-J7KF6IEI.js";
import {
  N
} from "./chunk-GOKBAMCG.js";
import {
  t as t7
} from "./chunk-HUX6Y26H.js";
import {
  t as t6
} from "./chunk-LN4EMOLP.js";
import {
  J
} from "./chunk-PDYGQYJC.js";
import {
  i as i5
} from "./chunk-PO7V7AQE.js";
import {
  R
} from "./chunk-JO42C6R3.js";
import {
  f as f5,
  v
} from "./chunk-A6XTYETO.js";
import {
  c as c2
} from "./chunk-GTZOXRB5.js";
import {
  d
} from "./chunk-PPMHRAOP.js";
import {
  r as r8,
  r2 as r9,
  t as t8
} from "./chunk-XGDLE7WK.js";
import {
  u
} from "./chunk-QMUS26QM.js";
import {
  r as r11
} from "./chunk-FHW2TG7X.js";
import {
  c2 as c3,
  h as h3,
  o as o6
} from "./chunk-YAGNWBGU.js";
import {
  O as O4
} from "./chunk-GCFUJXGH.js";
import {
  o as o7
} from "./chunk-VIIVMRRO.js";
import {
  o as o9
} from "./chunk-TGHJVD7I.js";
import {
  S as S2,
  _ as _3,
  h as h4,
  o as o8
} from "./chunk-LKHUGH5W.js";
import {
  l2 as l5,
  n as n6,
  n2 as n7,
  o2 as o4,
  o3 as o5,
  t as t5
} from "./chunk-L64P7DHA.js";
import {
  t as t4
} from "./chunk-EYYHTDAX.js";
import {
  r as r6
} from "./chunk-5XOZP4XS.js";
import {
  e as e9,
  n as n8,
  s as s4
} from "./chunk-ZVFENZUF.js";
import {
  f as f3,
  i as i4
} from "./chunk-JCWQ2LOQ.js";
import {
  t as t3
} from "./chunk-WN3YAMRZ.js";
import {
  H
} from "./chunk-NWICVENM.js";
import {
  l as l3
} from "./chunk-WU7FVYT7.js";
import {
  D,
  O as O3,
  f
} from "./chunk-YLE5AYZV.js";
import {
  n as n5,
  s as s3
} from "./chunk-R4P4UBKU.js";
import {
  e as e8,
  f as f2,
  l as l4,
  o as o3
} from "./chunk-AWJPQWYU.js";
import {
  E,
  L,
  O as O2,
  c,
  i as i3,
  x
} from "./chunk-JNWMZ6EJ.js";
import {
  a as a2
} from "./chunk-TT5ZTQDR.js";
import {
  r as r3
} from "./chunk-2SMFPIRI.js";
import {
  a as a3
} from "./chunk-PA7WZX2U.js";
import {
  n as n3,
  o as o2,
  r as r5
} from "./chunk-WJKYGQOY.js";
import {
  t as t2
} from "./chunk-RDQF44TE.js";
import {
  l as l2
} from "./chunk-KKD7A2GN.js";
import {
  e as e7
} from "./chunk-4MMTPKY4.js";
import {
  l
} from "./chunk-DY7FJHTG.js";
import {
  i as i2,
  j,
  n as n4
} from "./chunk-JYODC3YQ.js";
import {
  e as e5
} from "./chunk-BQZBOYBD.js";
import {
  e as e6,
  t
} from "./chunk-TYQXPPSP.js";
import {
  P as P2,
  h
} from "./chunk-J55F4AC2.js";
import {
  r as r4
} from "./chunk-IMVP5ADD.js";
import {
  h as h2
} from "./chunk-XTVPEVHA.js";
import {
  _ as _2
} from "./chunk-3ZXOUEQG.js";
import {
  A,
  O,
  P,
  S,
  e as e4,
  g,
  i,
  o,
  r as r2,
  s as s2,
  z
} from "./chunk-AXVPJBVW.js";
import {
  e as e3,
  n as n2,
  r
} from "./chunk-OXEPWRM7.js";
import {
  U
} from "./chunk-SYATLP3H.js";
import {
  _
} from "./chunk-XNUH25NY.js";
import {
  e as e2
} from "./chunk-4Z5SGKRM.js";
import {
  a
} from "./chunk-HJY2YILU.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-WYIDUUN2.js";
import {
  e2 as e,
  has
} from "./chunk-DXLOWWK7.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/views/3d/glTF/internal/TextureTransformUtils.js
function s6(s8) {
  if (null == s8) return null;
  const a4 = null != s8.offset ? s8.offset : i4, n9 = null != s8.rotation ? s8.rotation : 0, e11 = null != s8.scale ? s8.scale : f3, f7 = t(1, 0, 0, 0, 1, 0, a4[0], a4[1], 1), c6 = t(Math.cos(n9), -Math.sin(n9), 0, Math.sin(n9), Math.cos(n9), 0, 0, 0, 1), m = t(e11[0], 0, 0, 0, e11[1], 0, 0, 0, 1), u3 = e6();
  return i2(u3, c6, m), i2(u3, f7, u3), u3;
}

// ../../../node_modules/@arcgis/core/views/3d/layers/graphics/ProcessedObjectResource.js
var s7 = class {
  constructor() {
    this.geometries = new Array(), this.materials = new Array(), this.textures = new Array();
  }
};
var t11 = class {
  constructor(t13, e11, r12) {
    this.name = t13, this.lodThreshold = e11, this.pivotOffset = r12, this.stageResources = new s7(), this.numberOfVertices = 0;
  }
};

// ../../../node_modules/@arcgis/core/views/3d/webgl-engine/shaders/DefaultMaterialTechnique.js
var q = class extends f5 {
  constructor() {
    super(...arguments), this.isSchematic = false, this.usePBR = false, this.mrrFactors = e3(r10), this.hasVertexColors = false, this.hasSymbolColors = false, this.doubleSided = false, this.doubleSidedType = "normal", this.cullFace = e9.Back, this.isInstanced = false, this.hasInstancedColor = false, this.emissiveFactor = r(0, 0, 0), this.instancedDoublePrecision = false, this.normalType = a3.Attribute, this.receiveShadows = true, this.receiveAmbientOcclusion = true, this.castShadows = true, this.shadowMappingEnabled = false, this.ambient = r(0.2, 0.2, 0.2), this.diffuse = r(0.8, 0.8, 0.8), this.externalColor = r4(1, 1, 1, 1), this.colorMixMode = "multiply", this.opacity = 1, this.layerOpacity = 1, this.origin = n2(), this.hasSlicePlane = false, this.hasSliceHighlight = true, this.offsetTransparentBackfaces = false, this.vvSize = null, this.vvColor = null, this.vvOpacity = null, this.vvSymbolAnchor = null, this.vvSymbolRotationMatrix = null, this.modelTransformation = null, this.transparent = false, this.writeDepth = true, this.customDepthTest = n8.Less, this.textureAlphaMode = s4.Blend, this.textureAlphaCutoff = o9, this.textureAlphaPremultiplied = false, this.hasOccludees = false, this.renderOccluded = h3.Occlude, this.isDecoration = false;
  }
};
var z2 = class extends v {
  constructor() {
    super(...arguments), this.origin = n2(), this.slicePlaneLocalOrigin = this.origin;
  }
};
var E4 = class _E extends r8 {
  initializeConfiguration(e11, t13) {
    t13.spherical = e11.viewingMode === l2.Global, t13.doublePrecisionRequiresObfuscation = e11.rctx.driverTest.doublePrecisionRequiresObfuscation.result, t13.textureCoordinateType = t13.hasColorTexture || t13.hasMetallicRoughnessTexture || t13.hasEmissionTexture || t13.hasOcclusionTexture || t13.hasNormalTexture ? d.Default : d.None, t13.objectAndLayerIdColorInstanced = t13.instanced;
  }
  initializeProgram(e11) {
    return this._initializeProgram(e11, _E.shader);
  }
  _initializeProgram(e11, t13) {
    return new r9(e11.rctx, t13.get().build(this.configuration), O4);
  }
  _makePipeline(e11, t13) {
    const i6 = this.configuration, r12 = e11 === o7.NONE, s8 = e11 === o7.FrontFace;
    return S2({
      blending: i6.output === o2.Color && i6.transparent ? r12 ? A2 : c4(e11) : null,
      culling: R2(i6) ? h4(i6.cullFace) : null,
      depthTest: {
        func: f4(e11, I2(i6.customDepthTest))
      },
      depthWrite: (r12 || s8) && i6.writeDepth ? o8 : null,
      drawBuffers: i6.output === o2.Depth ? {
        buffers: [f.NONE]
      } : s5(e11),
      colorWrite: _3,
      stencilWrite: i6.hasOccludees ? e10 : null,
      stencilTest: i6.hasOccludees ? t13 ? o10 : f6 : null,
      polygonOffset: r12 || s8 ? null : _4(i6.enableOffset)
    });
  }
  initializePipeline() {
    return this._occludeePipelineState = this._makePipeline(this.configuration.transparencyPassType, true), this._makePipeline(this.configuration.transparencyPassType, false);
  }
  getPipeline(e11) {
    return e11 ? this._occludeePipelineState : super.getPipeline();
  }
};
function I2(e11) {
  return e11 === n8.Lequal ? O3.LEQUAL : O3.LESS;
}
function R2(e11) {
  return e11.cullFace !== e9.None || !e11.hasSlicePlane && !e11.transparent && !e11.doubleSidedMode;
}
E4.shader = new t8(J, () => import("./DefaultMaterial.glsl-XTLZPKIK.js"));

// ../../../node_modules/@arcgis/core/views/3d/webgl-engine/shaders/DefaultMaterialTechniqueConfiguration.js
var c5 = class extends t10 {
  constructor() {
    super(...arguments), this.output = o2.Color, this.alphaDiscardMode = s4.Opaque, this.doubleSidedMode = i5.None, this.pbrMode = c2.Disabled, this.cullFace = e9.None, this.transparencyPassType = o7.NONE, this.normalType = a3.Attribute, this.textureCoordinateType = d.None, this.customDepthTest = n8.Less, this.spherical = false, this.hasVertexColors = false, this.hasSymbolColors = false, this.hasVerticalOffset = false, this.hasSlicePlane = false, this.hasSliceHighlight = true, this.hasColorTexture = false, this.hasMetallicRoughnessTexture = false, this.hasEmissionTexture = false, this.hasOcclusionTexture = false, this.hasNormalTexture = false, this.hasScreenSizePerspective = false, this.hasVertexTangents = false, this.hasOccludees = false, this.multipassEnabled = false, this.hasModelTransformation = false, this.offsetBackfaces = false, this.vvSize = false, this.vvColor = false, this.receiveShadows = false, this.receiveAmbientOcclusion = false, this.textureAlphaPremultiplied = false, this.instanced = false, this.instancedColor = false, this.objectAndLayerIdColorInstanced = false, this.instancedDoublePrecision = false, this.doublePrecisionRequiresObfuscation = false, this.writeDepth = true, this.transparent = false, this.enableOffset = true, this.cullAboveGround = false, this.snowCover = false, this.hasColorTextureTransform = false, this.hasEmissionTextureTransform = false, this.hasNormalTextureTransform = false, this.hasOcclusionTextureTransform = false, this.hasMetallicRoughnessTextureTransform = false;
  }
};
e2([r11({
  count: o2.COUNT
})], c5.prototype, "output", void 0), e2([r11({
  count: s4.COUNT
})], c5.prototype, "alphaDiscardMode", void 0), e2([r11({
  count: i5.COUNT
})], c5.prototype, "doubleSidedMode", void 0), e2([r11({
  count: c2.COUNT
})], c5.prototype, "pbrMode", void 0), e2([r11({
  count: e9.COUNT
})], c5.prototype, "cullFace", void 0), e2([r11({
  count: o7.COUNT
})], c5.prototype, "transparencyPassType", void 0), e2([r11({
  count: a3.COUNT
})], c5.prototype, "normalType", void 0), e2([r11({
  count: d.COUNT
})], c5.prototype, "textureCoordinateType", void 0), e2([r11({
  count: n8.COUNT
})], c5.prototype, "customDepthTest", void 0), e2([r11()], c5.prototype, "spherical", void 0), e2([r11()], c5.prototype, "hasVertexColors", void 0), e2([r11()], c5.prototype, "hasSymbolColors", void 0), e2([r11()], c5.prototype, "hasVerticalOffset", void 0), e2([r11()], c5.prototype, "hasSlicePlane", void 0), e2([r11()], c5.prototype, "hasSliceHighlight", void 0), e2([r11()], c5.prototype, "hasColorTexture", void 0), e2([r11()], c5.prototype, "hasMetallicRoughnessTexture", void 0), e2([r11()], c5.prototype, "hasEmissionTexture", void 0), e2([r11()], c5.prototype, "hasOcclusionTexture", void 0), e2([r11()], c5.prototype, "hasNormalTexture", void 0), e2([r11()], c5.prototype, "hasScreenSizePerspective", void 0), e2([r11()], c5.prototype, "hasVertexTangents", void 0), e2([r11()], c5.prototype, "hasOccludees", void 0), e2([r11()], c5.prototype, "multipassEnabled", void 0), e2([r11()], c5.prototype, "hasModelTransformation", void 0), e2([r11()], c5.prototype, "offsetBackfaces", void 0), e2([r11()], c5.prototype, "vvSize", void 0), e2([r11()], c5.prototype, "vvColor", void 0), e2([r11()], c5.prototype, "receiveShadows", void 0), e2([r11()], c5.prototype, "receiveAmbientOcclusion", void 0), e2([r11()], c5.prototype, "textureAlphaPremultiplied", void 0), e2([r11()], c5.prototype, "instanced", void 0), e2([r11()], c5.prototype, "instancedColor", void 0), e2([r11()], c5.prototype, "objectAndLayerIdColorInstanced", void 0), e2([r11()], c5.prototype, "instancedDoublePrecision", void 0), e2([r11()], c5.prototype, "doublePrecisionRequiresObfuscation", void 0), e2([r11()], c5.prototype, "writeDepth", void 0), e2([r11()], c5.prototype, "transparent", void 0), e2([r11()], c5.prototype, "enableOffset", void 0), e2([r11()], c5.prototype, "cullAboveGround", void 0), e2([r11()], c5.prototype, "snowCover", void 0), e2([r11()], c5.prototype, "hasColorTextureTransform", void 0), e2([r11()], c5.prototype, "hasEmissionTextureTransform", void 0), e2([r11()], c5.prototype, "hasNormalTextureTransform", void 0), e2([r11()], c5.prototype, "hasOcclusionTextureTransform", void 0), e2([r11()], c5.prototype, "hasMetallicRoughnessTextureTransform", void 0), e2([r11({
  constValue: false
})], c5.prototype, "occlusionPass", void 0), e2([r11({
  constValue: true
})], c5.prototype, "hasVvInstancing", void 0), e2([r11({
  constValue: false
})], c5.prototype, "useCustomDTRExponentForWater", void 0), e2([r11({
  constValue: false
})], c5.prototype, "supportsTextureAtlas", void 0), e2([r11({
  constValue: true
})], c5.prototype, "useFillLights", void 0);

// ../../../node_modules/@arcgis/core/views/3d/webgl-engine/shaders/RealisticTreeTechnique.js
var t12 = class _t extends E4 {
  initializeConfiguration(i6, a4) {
    super.initializeConfiguration(i6, a4), a4.hasMetallicRoughnessTexture = false, a4.hasEmissionTexture = false, a4.hasOcclusionTexture = false, a4.hasNormalTexture = false, a4.hasModelTransformation = false, a4.normalType = a3.Attribute, a4.doubleSidedMode = i5.WindingOrder, a4.hasVertexTangents = false;
  }
  initializeProgram(e11) {
    return this._initializeProgram(e11, _t.shader);
  }
};
t12.shader = new t8(R, () => import("./RealisticTree.glsl-MSLAYEGZ.js"));

// ../../../node_modules/@arcgis/core/views/3d/webgl-engine/materials/DefaultMaterial.js
var j2 = class extends c3 {
  constructor(e11) {
    super(e11, D2), this.supportsEdges = true, this.produces = /* @__PURE__ */ new Map([[E3.OPAQUE_MATERIAL, (e12) => (n3(e12) || r5(e12)) && !this.parameters.transparent], [E3.TRANSPARENT_MATERIAL, (e12) => (n3(e12) || r5(e12)) && this.parameters.transparent && this.parameters.writeDepth], [E3.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL, (e12) => (n3(e12) || r5(e12)) && this.parameters.transparent && !this.parameters.writeDepth]]), this._configuration = new c5(), this._vertexBufferLayout = N2(this.parameters);
  }
  isVisibleForOutput(e11) {
    return e11 !== o2.Shadow && e11 !== o2.ShadowExcludeHighlight && e11 !== o2.ShadowHighlight || this.parameters.castShadows;
  }
  isVisible() {
    const e11 = this.parameters;
    if (!super.isVisible() || 0 === e11.layerOpacity) return false;
    const {
      hasInstancedColor: t13,
      hasVertexColors: r12,
      hasSymbolColors: s8,
      vvColor: a4
    } = e11, i6 = "replace" === e11.colorMixMode, o12 = e11.opacity > 0, n9 = e11.externalColor && e11.externalColor[3] > 0, h5 = t13 || a4 || s8;
    return r12 && h5 ? i6 || o12 : r12 ? i6 ? n9 : o12 : h5 ? i6 || o12 : i6 ? n9 : o12;
  }
  getConfiguration(e11, t13) {
    return this._configuration.output = e11, this._configuration.hasNormalTexture = !!this.parameters.normalTextureId, this._configuration.hasColorTexture = !!this.parameters.textureId, this._configuration.hasVertexTangents = this.parameters.hasVertexTangents, this._configuration.instanced = this.parameters.isInstanced, this._configuration.instancedDoublePrecision = this.parameters.instancedDoublePrecision, this._configuration.vvSize = !!this.parameters.vvSize, this._configuration.hasVerticalOffset = null != this.parameters.verticalOffset, this._configuration.hasScreenSizePerspective = null != this.parameters.screenSizePerspective, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.hasSliceHighlight = this.parameters.hasSliceHighlight, this._configuration.alphaDiscardMode = this.parameters.textureAlphaMode, this._configuration.normalType = this.parameters.normalType, this._configuration.transparent = this.parameters.transparent, this._configuration.writeDepth = this.parameters.writeDepth, null != this.parameters.customDepthTest && (this._configuration.customDepthTest = this.parameters.customDepthTest), this._configuration.hasOccludees = this.parameters.hasOccludees, this._configuration.cullFace = this.parameters.hasSlicePlane ? e9.None : this.parameters.cullFace, this._configuration.multipassEnabled = t13.multipassEnabled, this._configuration.cullAboveGround = t13.multipassTerrain.cullAboveGround, this._configuration.hasModelTransformation = null != this.parameters.modelTransformation, e11 === o2.Color && (this._configuration.hasVertexColors = this.parameters.hasVertexColors, this._configuration.hasSymbolColors = this.parameters.hasSymbolColors, this.parameters.treeRendering ? this._configuration.doubleSidedMode = i5.WindingOrder : this._configuration.doubleSidedMode = this.parameters.doubleSided && "normal" === this.parameters.doubleSidedType ? i5.View : this.parameters.doubleSided && "winding-order" === this.parameters.doubleSidedType ? i5.WindingOrder : i5.None, this._configuration.instancedColor = this.parameters.hasInstancedColor, this._configuration.receiveShadows = this.parameters.receiveShadows && this.parameters.shadowMappingEnabled, this._configuration.receiveAmbientOcclusion = this.parameters.receiveAmbientOcclusion && null != t13.ssao, this._configuration.vvColor = !!this.parameters.vvColor, this._configuration.textureAlphaPremultiplied = !!this.parameters.textureAlphaPremultiplied, this._configuration.pbrMode = this.parameters.usePBR ? this.parameters.isSchematic ? c2.Schematic : c2.Normal : c2.Disabled, this._configuration.hasMetallicRoughnessTexture = !!this.parameters.metallicRoughnessTextureId, this._configuration.hasEmissionTexture = !!this.parameters.emissiveTextureId, this._configuration.hasOcclusionTexture = !!this.parameters.occlusionTextureId, this._configuration.offsetBackfaces = !(!this.parameters.transparent || !this.parameters.offsetTransparentBackfaces), this._configuration.transparencyPassType = t13.transparencyPassType, this._configuration.enableOffset = t13.camera.relativeElevation < E2, this._configuration.snowCover = this.hasSnowCover(t13), this._configuration.hasColorTextureTransform = !!this.parameters.colorTextureTransformMatrix, this._configuration.hasNormalTextureTransform = !!this.parameters.normalTextureTransformMatrix, this._configuration.hasEmissionTextureTransform = !!this.parameters.emissiveTextureTransformMatrix, this._configuration.hasOcclusionTextureTransform = !!this.parameters.occlusionTextureTransformMatrix, this._configuration.hasMetallicRoughnessTextureTransform = !!this.parameters.metallicRoughnessTextureTransformMatrix), this._configuration;
  }
  hasSnowCover(e11) {
    return null != e11.weather && e11.weatherVisible && "snowy" === e11.weather.type && "enabled" === e11.weather.snowCover;
  }
  intersect(h5, l6, u3, m, p2, f7) {
    if (null != this.parameters.verticalOffset) {
      const h6 = u3.camera;
      o(W, l6[12], l6[13], l6[14]);
      let f8 = null;
      switch (u3.viewingMode) {
        case l2.Global:
          f8 = z(G, W);
          break;
        case l2.Local:
          f8 = r2(G, z3);
      }
      let d3 = 0;
      const g2 = e4(k, W, h6.eye), T2 = s2(g2), _5 = g(g2, g2, 1 / T2);
      let x2 = null;
      this.parameters.screenSizePerspective && (x2 = P(f8, _5)), d3 += o6(h6, T2, this.parameters.verticalOffset, x2 ?? 0, this.parameters.screenSizePerspective), g(f8, f8, d3), S(H2, f8, u3.transform.inverseRotation), m = e4(V, m, H2), p2 = e4(B, p2, H2);
    }
    p(h5, u3, m, p2, d2(u3.verticalOffset), f7);
  }
  createGLMaterial(e11) {
    return new E5(e11);
  }
  createBufferWriter() {
    return new r7(this._vertexBufferLayout);
  }
};
var E5 = class extends u {
  constructor(e11) {
    super(__spreadValues(__spreadValues({}, e11), e11.material.parameters));
  }
  _updateShadowState(e11) {
    e11.shadowMap.enabled !== this._material.parameters.shadowMappingEnabled && this._material.setParameters({
      shadowMappingEnabled: e11.shadowMap.enabled
    });
  }
  _updateOccludeeState(e11) {
    e11.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({
      hasOccludees: e11.hasOccludees
    });
  }
  beginSlot(t13) {
    this._output === o2.Color && (this._updateShadowState(t13), this._updateOccludeeState(t13));
    const r12 = this._material.parameters;
    this.updateTexture(r12.textureId);
    const s8 = t13.camera.viewInverseTransposeMatrix;
    return o(r12.origin, s8[3], s8[7], s8[11]), this._material.setParameters(this.textureBindParameters), this.ensureTechnique(r12.treeRendering ? t12 : E4, t13);
  }
};
var L2 = class extends q {
  constructor() {
    super(...arguments), this.initTextureTransparent = false, this.treeRendering = false, this.hasVertexTangents = false;
  }
};
var D2 = new L2();
function N2(e11) {
  const t13 = H().vec3f(e7.POSITION);
  e11.normalType === a3.Compressed ? t13.vec2i16(e7.NORMALCOMPRESSED, {
    glNormalized: true
  }) : t13.vec3f(e7.NORMAL), e11.hasVertexTangents && t13.vec4f(e7.TANGENT);
  return (e11.textureId || e11.normalTextureId || e11.metallicRoughnessTextureId || e11.emissiveTextureId || e11.occlusionTextureId) && t13.vec2f(e7.UV0), e11.hasVertexColors && t13.vec4u8(e7.COLOR), e11.hasSymbolColors && t13.vec4u8(e7.SYMBOLCOLOR), has("enable-feature:objectAndLayerId-rendering") && t13.vec4u8(e7.OBJECTANDLAYERIDCOLOR), t13;
}
var V = n2();
var B = n2();
var z3 = r(0, 0, 1);
var G = n2();
var H2 = n2();
var W = n2();
var k = n2();

// ../../../node_modules/@arcgis/core/views/3d/layers/graphics/wosrLoader.js
var v2 = () => n.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");
function A3(e11, t13) {
  return __async(this, null, function* () {
    const n9 = yield j3(e11, t13), s8 = yield E6(n9.textureDefinitions ?? {}, t13);
    let a4 = 0;
    for (const r12 in s8) if (s8.hasOwnProperty(r12)) {
      const e12 = s8[r12];
      a4 += e12?.image ? e12.image.width * e12.image.height * 4 : 0;
    }
    return {
      resource: n9,
      textures: s8,
      size: a4 + e(n9)
    };
  });
}
function j3(r12, n9) {
  return __async(this, null, function* () {
    const s8 = n9?.streamDataRequester;
    if (s8) return I3(r12, s8, n9);
    const a4 = yield _(U(r12, n9));
    if (true === a4.ok) return a4.value.data;
    a(a4.error), P3(a4.error);
  });
}
function I3(e11, r12, n9) {
  return __async(this, null, function* () {
    const s8 = yield _(r12.request(e11, "json", n9));
    if (true === s8.ok) return s8.value;
    a(s8.error), P3(s8.error.details.url);
  });
}
function P3(e11) {
  throw new s("", `Request for object resource failed: ${e11}`);
}
function M(e11) {
  const t13 = e11.params, r12 = t13.topology;
  let n9 = true;
  switch (t13.vertexAttributes || (v2().warn("Geometry must specify vertex attributes"), n9 = false), t13.topology) {
    case "PerAttributeArray":
      break;
    case "Indexed":
    case null:
    case void 0: {
      const e12 = t13.faces;
      if (e12) {
        if (t13.vertexAttributes) for (const r13 in t13.vertexAttributes) {
          const t14 = e12[r13];
          t14?.values ? (null != t14.valueType && "UInt32" !== t14.valueType && (v2().warn(`Unsupported indexed geometry indices type '${t14.valueType}', only UInt32 is currently supported`), n9 = false), null != t14.valuesPerElement && 1 !== t14.valuesPerElement && (v2().warn(`Unsupported indexed geometry values per element '${t14.valuesPerElement}', only 1 is currently supported`), n9 = false)) : (v2().warn(`Indexed geometry does not specify face indices for '${r13}' attribute`), n9 = false);
        }
      } else v2().warn("Indexed geometries must specify faces"), n9 = false;
      break;
    }
    default:
      v2().warn(`Unsupported topology '${r12}'`), n9 = false;
  }
  e11.params.material || (v2().warn("Geometry requires material"), n9 = false);
  const s8 = e11.params.vertexAttributes;
  for (const a4 in s8) {
    s8[a4].values || (v2().warn("Geometries with externally defined attributes are not yet supported"), n9 = false);
  }
  return n9;
}
function T(e11, t13) {
  const r12 = new Array(), n9 = new Array(), s8 = new Array(), o12 = new t6(), u3 = e11.resource, c6 = r3.parse(u3.version || "1.0", "wosr");
  q2.validate(c6);
  const p2 = u3.model.name, g2 = u3.model.geometries, h5 = u3.materialDefinitions ?? {}, v3 = e11.textures;
  let A4 = 0;
  const j4 = /* @__PURE__ */ new Map();
  for (let a4 = 0; a4 < g2.length; a4++) {
    const e12 = g2[a4];
    if (!M(e12)) continue;
    const i6 = k2(e12), u4 = e12.params.vertexAttributes, c7 = [], p3 = (t14) => {
      if ("PerAttributeArray" === e12.params.topology) return null;
      const r13 = e12.params.faces;
      for (const e13 in r13) if (e13 === t14) return r13[e13].values;
      return null;
    }, I4 = u4[e7.POSITION], P4 = I4.values.length / I4.valuesPerElement;
    for (const t14 in u4) {
      const e13 = u4[t14], r13 = e13.values, n10 = p3(t14) ?? l3(P4);
      c7.push([t14, new t2(r13, n10, e13.valuesPerElement, true)]);
    }
    const T2 = i6.texture, U3 = v3 && v3[T2];
    if (U3 && !j4.has(T2)) {
      const {
        image: e13,
        parameters: t14
      } = U3, r13 = new N(e13, t14);
      n9.push(r13), j4.set(T2, r13);
    }
    const E7 = j4.get(T2), q3 = E7 ? E7.id : void 0, R3 = i6.material;
    let B2 = o12.get(R3, T2);
    if (null == B2) {
      const e13 = h5[R3.substring(R3.lastIndexOf("/") + 1)].params;
      1 === e13.transparency && (e13.transparency = 0);
      const r13 = U3 && U3.alphaChannelUsage, n10 = e13.transparency > 0 || "transparency" === r13 || "maskAndTransparency" === r13, s9 = U3 ? O5(U3.alphaChannelUsage) : void 0, a5 = {
        ambient: e3(e13.diffuse),
        diffuse: e3(e13.diffuse),
        opacity: 1 - (e13.transparency || 0),
        transparent: n10,
        textureAlphaMode: s9,
        textureAlphaCutoff: 0.33,
        textureId: q3,
        initTextureTransparent: true,
        doubleSided: true,
        cullFace: e9.None,
        colorMixMode: e13.externalColorMixMode || "tint",
        textureAlphaPremultiplied: U3?.parameters.preMultiplyAlpha ?? false
      };
      t13?.materialParameters && Object.assign(a5, t13.materialParameters), B2 = new j2(a5), o12.set(R3, T2, B2);
    }
    s8.push(B2);
    const C = new I(B2, c7);
    A4 += c7.find((e13) => e13[0] === e7.POSITION)?.[1]?.indices.length ?? 0, r12.push(C);
  }
  return {
    engineResources: [{
      name: p2,
      stageResources: {
        textures: n9,
        materials: s8,
        geometries: r12
      },
      pivotOffset: u3.model.pivotOffset,
      numberOfVertices: A4,
      lodThreshold: null
    }],
    referenceBoundingBox: U2(r12)
  };
}
function U2(e11) {
  const t13 = P2();
  return e11.forEach((e12) => {
    const r12 = e12.boundingInfo;
    null != r12 && (h(t13, r12.bbMin), h(t13, r12.bbMax));
  }), t13;
}
function E6(e11, t13) {
  return __async(this, null, function* () {
    const r12 = new Array();
    for (const a4 in e11) {
      const n10 = e11[a4], s9 = n10.images[0].data;
      if (!s9) {
        v2().warn("Externally referenced texture data is not yet supported");
        continue;
      }
      const o12 = n10.encoding + ";base64," + s9, i6 = "/textureDefinitions/" + a4, l6 = "rgba" === n10.channels ? n10.alphaChannelUsage || "transparency" : "none", u3 = {
        noUnpackFlip: true,
        wrap: {
          s: D.REPEAT,
          t: D.REPEAT
        },
        preMultiplyAlpha: O5(l6) !== s4.Opaque
      }, c6 = t13?.disableTextures ? Promise.resolve(null) : t7(o12, t13);
      r12.push(c6.then((e12) => ({
        refId: i6,
        image: e12,
        parameters: u3,
        alphaChannelUsage: l6
      })));
    }
    const n9 = yield Promise.all(r12), s8 = {};
    for (const a4 of n9) s8[a4.refId] = a4;
    return s8;
  });
}
function O5(e11) {
  switch (e11) {
    case "mask":
      return s4.Mask;
    case "maskAndTransparency":
      return s4.MaskBlend;
    case "none":
      return s4.Opaque;
    default:
      return s4.Blend;
  }
}
function k2(e11) {
  const t13 = e11.params;
  return {
    id: 1,
    material: t13.material,
    texture: t13.texture,
    region: t13.texture
  };
}
var q2 = new r3(1, 2, "wosr");

// ../../../node_modules/@arcgis/core/views/3d/layers/graphics/objectResourceUtils.js
function te(t13, r12) {
  return __async(this, null, function* () {
    const o12 = re(a2(t13));
    if ("wosr" === o12.fileType) {
      const e11 = yield r12.cache ? r12.cache.loadWOSR(o12.url, r12) : A3(o12.url, r12), {
        engineResources: t14,
        referenceBoundingBox: s9
      } = T(e11, r12);
      return {
        lods: t14,
        referenceBoundingBox: s9,
        isEsriSymbolResource: false,
        isWosr: true
      };
    }
    const s8 = yield r12.cache ? r12.cache.loadGLTF(o12.url, r12, !!r12.usePBR) : l5(new n7(r12.streamDataRequester), o12.url, r12, r12.usePBR), i6 = s8.model.meta?.ESRI_proxyEllipsoid, n9 = s8.meta.isEsriSymbolResource && null != i6 && "EsriRealisticTreesStyle" === s8.meta.ESRI_webstyle;
    n9 && !s8.customMeta.esriTreeRendering && (s8.customMeta.esriTreeRendering = true, ae(s8, i6));
    const l6 = !!r12.usePBR, a4 = s8.meta.isEsriSymbolResource ? {
      usePBR: l6,
      isSchematic: false,
      treeRendering: n9,
      mrrFactors: [...o11]
    } : {
      usePBR: l6,
      isSchematic: false,
      treeRendering: false,
      mrrFactors: [...r10]
    }, u3 = __spreadProps(__spreadValues({}, r12.materialParameters), {
      treeRendering: n9
    }), {
      engineResources: c6,
      referenceBoundingBox: m
    } = oe(s8, a4, u3, r12.skipHighLods && null == o12.specifiedLodIndex ? {
      skipHighLods: true
    } : {
      skipHighLods: false,
      singleLodIndex: o12.specifiedLodIndex
    });
    return {
      lods: c6,
      referenceBoundingBox: m,
      isEsriSymbolResource: s8.meta.isEsriSymbolResource,
      isWosr: false
    };
  });
}
function re(e11) {
  const t13 = e11.match(/(.*\.(gltf|glb))(\?lod=([0-9]+))?$/);
  if (t13) return {
    fileType: "gltf",
    url: t13[1],
    specifiedLodIndex: null != t13[4] ? Number(t13[4]) : null
  };
  return e11.match(/(.*\.(json|json\.gz))$/) ? {
    fileType: "wosr",
    url: e11,
    specifiedLodIndex: null
  } : {
    fileType: "unknown",
    url: e11,
    specifiedLodIndex: null
  };
}
function oe(e11, t13, r12, o12) {
  const s8 = e11.model, i6 = new Array(), n9 = /* @__PURE__ */ new Map(), l6 = /* @__PURE__ */ new Map(), a4 = s8.lods.length, u3 = P2();
  return s8.lods.forEach((e12, c6) => {
    const m = true === o12.skipHighLods && (a4 > 1 && 0 === c6 || a4 > 3 && 1 === c6) || false === o12.skipHighLods && null != o12.singleLodIndex && c6 !== o12.singleLodIndex;
    if (m && 0 !== c6) return;
    const f7 = new t11(e12.name, e12.lodThreshold, [0, 0, 0]);
    e12.parts.forEach((e13) => {
      const o13 = m ? new j2({}) : se(s8, e13, f7, t13, r12, n9, l6), {
        geometry: i7,
        vertexCount: a5
      } = ie(e13, null != o13 ? o13 : new j2({})), d3 = i7.boundingInfo;
      null != d3 && 0 === c6 && (h(u3, d3.bbMin), h(u3, d3.bbMax)), null != o13 && (f7.stageResources.geometries.push(i7), f7.numberOfVertices += a5);
    }), m || i6.push(f7);
  }), {
    engineResources: i6,
    referenceBoundingBox: u3
  };
}
function se(e11, t13, r12, o12, s8, i6, n9) {
  const a4 = t13.material + (t13.attributes.normal ? "_normal" : "") + (t13.attributes.color ? "_color" : "") + (t13.attributes.texCoord0 ? "_texCoord0" : "") + (t13.attributes.tangent ? "_tangent" : ""), u3 = e11.materials.get(t13.material), c6 = null != t13.attributes.texCoord0, m = null != t13.attributes.normal;
  if (null == u3) return null;
  const f7 = le(u3.alphaMode);
  if (!i6.has(a4)) {
    if (c6) {
      const t14 = (t15, r14 = false) => {
        if (null != t15 && !n9.has(t15)) {
          const o13 = e11.textures.get(t15);
          if (null != o13) {
            const e12 = o13.data;
            n9.set(t15, new N(r6(e12) ? e12.data : e12, __spreadProps(__spreadValues({}, o13.parameters), {
              preMultiplyAlpha: !r6(e12) && r14,
              encoding: r6(e12) && null != e12.encoding ? e12.encoding : void 0
            })));
          }
        }
      };
      t14(u3.textureColor, f7 !== s4.Opaque), t14(u3.textureNormal), t14(u3.textureOcclusion), t14(u3.textureEmissive), t14(u3.textureMetallicRoughness);
    }
    const r13 = u3.color[0] ** (1 / o5), d4 = u3.color[1] ** (1 / o5), p2 = u3.color[2] ** (1 / o5), g2 = u3.emissiveFactor[0] ** (1 / o5), x2 = u3.emissiveFactor[1] ** (1 / o5), b = u3.emissiveFactor[2] ** (1 / o5), h5 = null != u3.textureColor && c6 ? n9.get(u3.textureColor) : null, T2 = u2({
      normalTexture: u3.textureNormal,
      metallicRoughnessTexture: u3.textureMetallicRoughness,
      metallicFactor: u3.metallicFactor,
      roughnessFactor: u3.roughnessFactor,
      emissiveTexture: u3.textureEmissive,
      emissiveFactor: u3.emissiveFactor,
      occlusionTexture: u3.textureOcclusion
    }), y = null != u3.normalTextureTransform?.scale ? u3.normalTextureTransform?.scale : l;
    i6.set(a4, new j2(__spreadValues(__spreadProps(__spreadValues({}, o12), {
      transparent: f7 === s4.Blend,
      customDepthTest: n8.Lequal,
      textureAlphaMode: f7,
      textureAlphaCutoff: u3.alphaCutoff,
      diffuse: [r13, d4, p2],
      ambient: [r13, d4, p2],
      opacity: u3.opacity,
      doubleSided: u3.doubleSided,
      doubleSidedType: "winding-order",
      cullFace: u3.doubleSided ? e9.None : e9.Back,
      hasVertexColors: !!t13.attributes.color,
      hasVertexTangents: !!t13.attributes.tangent,
      normalType: m ? a3.Attribute : a3.ScreenDerivative,
      castShadows: true,
      receiveShadows: u3.receiveShadows,
      receiveAmbientOcclusion: u3.receiveAmbientOcclustion,
      textureId: null != h5 ? h5.id : void 0,
      colorMixMode: u3.colorMixMode,
      normalTextureId: null != u3.textureNormal && c6 ? n9.get(u3.textureNormal).id : void 0,
      textureAlphaPremultiplied: null != h5 && !!h5.parameters.preMultiplyAlpha,
      occlusionTextureId: null != u3.textureOcclusion && c6 ? n9.get(u3.textureOcclusion).id : void 0,
      emissiveTextureId: null != u3.textureEmissive && c6 ? n9.get(u3.textureEmissive).id : void 0,
      metallicRoughnessTextureId: null != u3.textureMetallicRoughness && c6 ? n9.get(u3.textureMetallicRoughness).id : void 0,
      emissiveFactor: [g2, x2, b],
      mrrFactors: T2 ? [...t9] : [u3.metallicFactor, u3.roughnessFactor, o12.mrrFactors[2]],
      isSchematic: T2,
      colorTextureTransformMatrix: s6(u3.colorTextureTransform),
      normalTextureTransformMatrix: s6(u3.normalTextureTransform),
      scale: [y[0], y[1]],
      occlusionTextureTransformMatrix: s6(u3.occlusionTextureTransform),
      emissiveTextureTransformMatrix: s6(u3.emissiveTextureTransform),
      metallicRoughnessTextureTransformMatrix: s6(u3.metallicRoughnessTextureTransform)
    }), s8)));
  }
  const d3 = i6.get(a4);
  if (r12.stageResources.materials.push(d3), c6) {
    const e12 = (e13) => {
      null != e13 && r12.stageResources.textures.push(n9.get(e13));
    };
    e12(u3.textureColor), e12(u3.textureNormal), e12(u3.textureOcclusion), e12(u3.textureEmissive), e12(u3.textureMetallicRoughness);
  }
  return d3;
}
function ie(e11, s8) {
  const i6 = e11.attributes.position.count, n9 = o4(e11.indices || i6, e11.primitiveType), l6 = t3(3 * i6), {
    typedBuffer: a4,
    typedBufferStride: u3
  } = e11.attributes.position;
  e8(l6, a4, e11.transform, 3, u3);
  const c6 = [[e7.POSITION, new t2(l6, n9, 3, true)]];
  if (null != e11.attributes.normal) {
    const o12 = t3(3 * i6), {
      typedBuffer: s9,
      typedBufferStride: l7
    } = e11.attributes.normal;
    j(ne, e11.transform), f2(o12, s9, ne, 3, l7), _2(ne) && l4(o12, o12), c6.push([e7.NORMAL, new t2(o12, n9, 3, true)]);
  }
  if (null != e11.attributes.tangent) {
    const r12 = t3(4 * i6), {
      typedBuffer: s9,
      typedBufferStride: l7
    } = e11.attributes.tangent;
    n4(ne, e11.transform), n5(r12, s9, ne, 4, l7), _2(ne) && l4(r12, r12, 4), c6.push([e7.TANGENT, new t2(r12, n9, 4, true)]);
  }
  if (null != e11.attributes.texCoord0) {
    const t13 = t3(2 * i6), {
      typedBuffer: r12,
      typedBufferStride: o12
    } = e11.attributes.texCoord0;
    n6(t13, r12, 2, o12), c6.push([e7.UV0, new t2(t13, n9, 2, true)]);
  }
  const m = e11.attributes.color;
  if (null != m) {
    const t13 = new Uint8Array(4 * i6);
    4 === m.elementCount ? m instanceof c ? s3(t13, m, 255) : m instanceof x ? t5(t13, m) : m instanceof L && s3(t13, m, 1 / 256) : (t13.fill(255), m instanceof i3 ? o3(t13, m.typedBuffer, 255, 4, m.typedBufferStride) : e11.attributes.color instanceof O2 ? t4(t13, m.typedBuffer, 4, e11.attributes.color.typedBufferStride) : e11.attributes.color instanceof E && o3(t13, m.typedBuffer, 1 / 256, 4, m.typedBufferStride)), c6.push([e7.COLOR, new t2(t13, n9, 4, true)]);
  }
  return {
    geometry: new I(s8, c6),
    vertexCount: i6
  };
}
var ne = e6();
function le(e11) {
  switch (e11) {
    case "BLEND":
      return s4.Blend;
    case "MASK":
      return s4.Mask;
    case "OPAQUE":
    case null:
    case void 0:
      return s4.Opaque;
  }
}
function ae(e11, t13) {
  for (let r12 = 0; r12 < e11.model.lods.length; ++r12) {
    const o12 = e11.model.lods[r12];
    for (const s8 of o12.parts) {
      const o13 = s8.attributes.normal;
      if (null == o13) return;
      const l6 = s8.attributes.position, g2 = l6.count, x2 = n2(), b = n2(), h5 = n2(), y = new Uint8Array(4 * g2), v3 = new Float64Array(3 * g2), R3 = h2(e5(), s8.transform);
      let j4 = 0, B2 = 0;
      for (let i6 = 0; i6 < g2; i6++) {
        l6.getVec(i6, b), o13.getVec(i6, x2), O(b, b, s8.transform), e4(h5, b, t13.center), i(h5, h5, t13.radius);
        const n9 = h5[2], p2 = s2(h5), g3 = Math.min(0.45 + 0.55 * p2 * p2, 1);
        i(h5, h5, t13.radius), null !== R3 && O(h5, h5, R3), z(h5, h5), r12 + 1 !== e11.model.lods.length && e11.model.lods.length > 1 && A(h5, h5, x2, n9 > -1 ? 0.2 : Math.min(-4 * n9 - 3.8, 1)), v3[j4] = h5[0], v3[j4 + 1] = h5[1], v3[j4 + 2] = h5[2], j4 += 3, y[B2] = 255 * g3, y[B2 + 1] = 255 * g3, y[B2 + 2] = 255 * g3, y[B2 + 3] = 255, B2 += 4;
      }
      s8.attributes.normal = new i3(v3), s8.attributes.color = new x(y);
    }
  }
}

export {
  s6 as s,
  z2 as z,
  j2 as j,
  A3 as A,
  te,
  re,
  oe
};
//# sourceMappingURL=chunk-JA2C7MTO.js.map
