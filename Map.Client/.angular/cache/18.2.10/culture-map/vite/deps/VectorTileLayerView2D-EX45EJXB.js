import {
  e as e6,
  l as l2,
  r as r4,
  t
} from "./chunk-K4UHA6L6.js";
import {
  h as h2,
  t as t2
} from "./chunk-XBO6SJGQ.js";
import {
  d as d4,
  r as r3,
  s as s3
} from "./chunk-VDYOVDYI.js";
import "./chunk-CDFFTJSF.js";
import {
  f
} from "./chunk-4HCKDN6K.js";
import "./chunk-ONOVFOVG.js";
import {
  y as y2
} from "./chunk-5JJ6GBOU.js";
import {
  i as i2
} from "./chunk-EYUDXMUG.js";
import "./chunk-GQOLRPFL.js";
import "./chunk-OICO7AS6.js";
import "./chunk-WSWHLWMU.js";
import "./chunk-R3AQ3TGL.js";
import "./chunk-B6VSQC7C.js";
import "./chunk-BLE2CCDD.js";
import {
  E as E3
} from "./chunk-PAFFV5BJ.js";
import "./chunk-Q645EYZX.js";
import "./chunk-6QDMUFEM.js";
import "./chunk-T3454WZK.js";
import "./chunk-LZ6MXOBD.js";
import "./chunk-HSB7FBE7.js";
import "./chunk-6YA72G7G.js";
import "./chunk-D3AKDIJC.js";
import {
  e as e5,
  s as s2
} from "./chunk-JZXDPQXY.js";
import {
  c,
  e as e4
} from "./chunk-3PCYF7PE.js";
import {
  L,
  l
} from "./chunk-53QPRVJS.js";
import "./chunk-TXQH7JZF.js";
import {
  E as E2,
  I as I2
} from "./chunk-NJSYD5KZ.js";
import {
  a as a4,
  i
} from "./chunk-MPUFKSB2.js";
import {
  m
} from "./chunk-FICJP6TJ.js";
import {
  s
} from "./chunk-ON42KCSZ.js";
import "./chunk-HUHWKEOY.js";
import "./chunk-EMZQT2MP.js";
import "./chunk-PUH7YYDT.js";
import "./chunk-5JFTHL5W.js";
import "./chunk-KUYTX4V6.js";
import "./chunk-EXODD7PD.js";
import "./chunk-C7VF4AR2.js";
import "./chunk-4HODTCAO.js";
import "./chunk-EK3IKAMF.js";
import "./chunk-IJVN5N2Q.js";
import {
  e as e3
} from "./chunk-3NGDRCQI.js";
import "./chunk-TVUZAYCE.js";
import "./chunk-JCWQ2LOQ.js";
import "./chunk-P7OSFLIX.js";
import "./chunk-ZDC4PV4Y.js";
import "./chunk-O7ZVERIH.js";
import "./chunk-YSIUOTSV.js";
import {
  d as d3
} from "./chunk-NQEXQAS7.js";
import "./chunk-R4DKV4UN.js";
import "./chunk-SNHPS7NU.js";
import "./chunk-L3F4XA4B.js";
import "./chunk-DLRYNII2.js";
import "./chunk-6HBAAUBO.js";
import {
  I,
  O,
  R
} from "./chunk-YLE5AYZV.js";
import "./chunk-VS26W5Y5.js";
import "./chunk-PVO5NM6Q.js";
import {
  n as n2
} from "./chunk-E2WAKNLZ.js";
import {
  r as r2
} from "./chunk-DM4WHMQY.js";
import "./chunk-C7NRYPDG.js";
import "./chunk-4QBFFLOC.js";
import "./chunk-O437BSYE.js";
import "./chunk-YZNT6QWD.js";
import {
  h
} from "./chunk-YVOGHYE3.js";
import "./chunk-IBOZJLSO.js";
import "./chunk-5YIMTGEC.js";
import "./chunk-3UOXF3CT.js";
import {
  d as d2,
  p
} from "./chunk-QCBC3RJX.js";
import "./chunk-6XGV55XZ.js";
import "./chunk-HOH445RO.js";
import "./chunk-TCPN7AEH.js";
import "./chunk-DY7FJHTG.js";
import "./chunk-JYODC3YQ.js";
import {
  e as e2
} from "./chunk-PQ4T66BG.js";
import "./chunk-SWPHGZYB.js";
import {
  d
} from "./chunk-HD65DNIO.js";
import "./chunk-4KWLMXIA.js";
import "./chunk-BIUXKPKA.js";
import "./chunk-634JLXD4.js";
import "./chunk-Y3EDGYWG.js";
import "./chunk-UF6JOUSJ.js";
import "./chunk-T5JGQSO3.js";
import "./chunk-CIW3KHOW.js";
import "./chunk-J55F4AC2.js";
import "./chunk-IQLBZKUD.js";
import "./chunk-7MZZCQ64.js";
import "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import "./chunk-6A7CWJED.js";
import {
  z
} from "./chunk-LJEOBI2I.js";
import "./chunk-2OMCGIU4.js";
import "./chunk-D2NB6D6N.js";
import "./chunk-HT2T6PUB.js";
import "./chunk-6EUVKE22.js";
import "./chunk-A3NNJ7XA.js";
import "./chunk-XTVPEVHA.js";
import "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import "./chunk-DZALMCYL.js";
import "./chunk-K226GFDN.js";
import "./chunk-4ZZRP4MA.js";
import "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-7RMVJCDW.js";
import "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import {
  E,
  a as a3,
  u as u2
} from "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import "./chunk-NYQ5CYNR.js";
import {
  _
} from "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import "./chunk-AXVPJBVW.js";
import "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import {
  G
} from "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import "./chunk-6WHTZNUH.js";
import "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import "./chunk-XNUH25NY.js";
import "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e
} from "./chunk-4Z5SGKRM.js";
import "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3 as a2,
  r2 as r
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import {
  b
} from "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import {
  u
} from "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  a,
  n2 as n
} from "./chunk-WYIDUUN2.js";
import "./chunk-DXLOWWK7.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileManager.js
var r5 = 512;
var n3 = 1e-6;
var a5 = (e7, i3) => e7 + 1 / (1 << 2 * i3);
var h3 = class {
  constructor(i3, t3) {
    this._tiles = /* @__PURE__ */ new Map(), this._tileCache = new e2(40, (e7) => e7.dispose()), this._viewSize = [0, 0], this._visibleTiles = /* @__PURE__ */ new Map(), this.acquireTile = i3.acquireTile, this.releaseTile = i3.releaseTile, this.tileInfoView = i3.tileInfoView, this._container = t3;
  }
  destroy() {
    for (const [e7, i3] of this._tiles) i3.dispose();
    this._tiles = null, this._tileCache.clear(), this._tileCache = null;
  }
  update(e7) {
    this._updateCacheSize(e7);
    const i3 = this.tileInfoView, t3 = i3.getTileCoverage(e7.state, 0, true, "smallest");
    if (!t3) return true;
    const {
      spans: l3,
      lodInfo: r6
    } = t3, {
      level: n4
    } = r6, a6 = this._tiles, h6 = /* @__PURE__ */ new Set(), c5 = /* @__PURE__ */ new Set();
    for (const {
      row: s4,
      colFrom: _3,
      colTo: f2
    } of l3) for (let e8 = _3; e8 <= f2; e8++) {
      const i4 = e3.getId(n4, s4, r6.normalizeCol(e8), r6.getWorldForColumn(e8)), t4 = this._getOrAcquireTile(i4);
      h6.add(i4), t4.processed() ? this._addToContainer(t4) : c5.add(new e3(i4));
    }
    for (const [s4, o] of a6) o.isCoverage = h6.has(s4);
    for (const s4 of c5) this._findPlaceholdersForMissingTiles(s4, h6);
    let d7 = false;
    for (const [s4, o] of a6) o.neededForCoverage = h6.has(s4), o.neededForCoverage || o.isHoldingForFade && i3.intersects(t3, o.key) && h6.add(s4), o.isFading && (d7 = true);
    for (const [s4, o] of this._tiles) h6.has(s4) || this._releaseTile(s4);
    return s.pool.release(t3), !d7;
  }
  clear() {
    this._tiles.clear(), this._tileCache.clear(), this._visibleTiles.clear();
  }
  clearCache() {
    this._tileCache.clear();
  }
  getIntersectingTiles(e7, s4, o, r6, n4) {
    const a6 = [0, 0], h6 = [0, 0];
    r6.toMap(a6, e7 - o, s4 + o), r6.toMap(h6, e7 + o, s4 - o);
    const c5 = Math.min(a6[0], h6[0]), d7 = Math.min(a6[1], h6[1]), _3 = Math.max(a6[0], h6[0]), f2 = Math.max(a6[1], h6[1]), T = a3(c5, d7, _3, f2), p3 = u2(), u4 = [];
    for (const [i3, t3] of this._visibleTiles) this.tileInfoView.getTileBounds(p3, t3.key), E(T, p3) && u4.push(t3);
    if (null != n4 && n4.length > 0) {
      const e8 = new Set(u4.map((e9) => e9.id)), i3 = n4.filter((i4) => !e8.has(i4.tileKey.id)).map((e9) => this._visibleTiles.get(e9.tileKey.id)).filter((e9) => void 0 !== e9);
      u4.push(...i3);
    }
    return u4;
  }
  _findPlaceholdersForMissingTiles(e7, i3) {
    const t3 = [];
    for (const [s4, o] of this._tiles) this._addPlaceholderChild(t3, o, e7, i3);
    const l3 = t3.reduce(a5, 0);
    Math.abs(1 - l3) < n3 || this._addPlaceholderParent(e7.id, i3);
  }
  _addPlaceholderChild(e7, i3, t3, l3) {
    i3.key.level <= t3.level || !i3.hasData() || d5(t3, i3.key) && (this._addToContainer(i3), l3.add(i3.id), e7.push(i3.key.level - t3.level));
  }
  _addPlaceholderParent(e7, i3) {
    const t3 = this._tiles;
    let l3 = e7;
    for (; ; ) {
      if (l3 = c2(l3), !l3 || i3.has(l3)) return;
      const e8 = t3.get(l3);
      if (e8?.hasData()) return this._addToContainer(e8), void i3.add(e8.id);
    }
  }
  _getOrAcquireTile(e7) {
    let i3 = this._tiles.get(e7);
    return i3 || (i3 = this._tileCache.pop(e7), i3 || (i3 = this.acquireTile(new e3(e7))), this._tiles.set(e7, i3), i3);
  }
  _releaseTile(e7) {
    const i3 = this._tiles.get(e7);
    this.releaseTile(i3), this._removeFromContainer(i3), this._tiles.delete(e7), i3.hasData() ? this._tileCache.put(e7, i3, 1) : i3.dispose();
  }
  _addToContainer(e7) {
    let i3;
    const t3 = [], l3 = this._container;
    if (l3.contains(e7)) return;
    const s4 = this._visibleTiles;
    for (const [o, r6] of s4) this._canConnectDirectly(e7, r6) && t3.push(r6), null == i3 && this._canConnectDirectly(r6, e7) && (i3 = r6);
    if (null != i3) {
      for (const l4 of t3) i3.childrenTiles.delete(l4), e7.childrenTiles.add(l4), l4.parentTile = e7;
      i3.childrenTiles.add(e7), e7.parentTile = i3;
    } else for (const o of t3) e7.childrenTiles.add(o), o.parentTile = e7;
    s4.set(e7.id, e7), l3.addChild(e7);
  }
  _removeFromContainer(e7) {
    if (this._visibleTiles.delete(e7.id), this._container.removeChild(e7), null != e7.parentTile) {
      e7.parentTile.childrenTiles.delete(e7);
      for (const i3 of e7.childrenTiles) null != e7.parentTile && e7.parentTile.childrenTiles.add(i3);
    }
    for (const i3 of e7.childrenTiles) i3.parentTile = e7.parentTile;
    e7.parentTile = null, e7.childrenTiles.clear();
  }
  _canConnectDirectly(e7, i3) {
    const t3 = e7.key;
    let {
      level: l3,
      row: s4,
      col: o,
      world: r6
    } = i3.key;
    const n4 = this._visibleTiles;
    for (; l3 > 0; ) {
      if (l3--, s4 >>= 1, o >>= 1, t3.level === l3 && t3.row === s4 && t3.col === o && t3.world === r6) return true;
      if (n4.has(`${l3}/${s4}/${o}/${r6}`)) return false;
    }
    return false;
  }
  _updateCacheSize(e7) {
    const i3 = e7.state.size;
    if (i3[0] === this._viewSize[0] && i3[1] === this._viewSize[1]) return;
    const t3 = Math.ceil(i3[0] / r5) + 1, l3 = Math.ceil(i3[1] / r5) + 1;
    this._viewSize[0] = i3[0], this._viewSize[1] = i3[1], this._tileCache.maxSize = 5 * t3 * l3;
  }
};
function c2(e7) {
  const [i3, t3, l3, s4] = e7.split("/"), o = parseInt(i3, 10);
  return 0 === o ? null : `${o - 1}/${parseInt(t3, 10) >> 1}/${parseInt(l3, 10) >> 1}/${parseInt(s4, 10)}`;
}
function d5(e7, i3) {
  const t3 = i3.level - e7.level;
  return e7.row === i3.row >> t3 && e7.col === i3.col >> t3 && e7.world === i3.world;
}

// ../../../node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolFader.js
var c3 = 0.5;
var h4 = 1e-6;
var _2 = class {
  constructor(e7, i3) {
    this.styleRepository = e7, this._tileToHandle = /* @__PURE__ */ new Map(), this._viewState = {
      scale: 0,
      rotation: 0,
      center: [0, 0],
      size: [0, 0]
    }, this._declutterViewState = {
      scale: 0,
      rotation: 0,
      center: [0, 0],
      size: [0, 0]
    }, this._offsetFromScreenCenter = [0, 0], this._completed = false, this._fading = r2(false), this._symbolRepository = new r4(4096, i3, () => new s3()), this._symbolDeclutterer = new e6(i3, this._symbolRepository, (t3, e8, i4) => this._createCollisionJob(t3, e8, i4), (t3, e8) => {
      t3.allSymbolsFadingOut = true, t3.lastOpacityUpdate = e8, r3(t3, e8, true), t3.decluttered = true, t3.requestRender();
    }, (t3, e8) => this.styleRepository.getStyleLayerByUID(t3.styleLayerUID).z - this.styleRepository.getStyleLayerByUID(e8.styleLayerUID).z, (t3) => {
      const e8 = this.styleRepository.getStyleLayerByUID(t3);
      if (this._zoom + h4 < e8.minzoom || this._zoom - h4 >= e8.maxzoom) return false;
      const i4 = e8.getLayoutProperty("visibility");
      return !i4 || i4.getValue() !== i.NONE;
    });
  }
  get symbolRepository() {
    return this._symbolRepository;
  }
  _createCollisionJob(t3, e7, i3) {
    return this.updateDecluttererViewState(), new l2(t3, e7, i3, this.styleRepository, this._zoom, this._viewState.rotation);
  }
  get fading() {
    return this._fading.value;
  }
  get decluttererOffset() {
    return this._offsetFromScreenCenter;
  }
  addTile(t3) {
    t3.decluttered = false, this._tileToHandle.set(t3, t3.on("symbols-changed", () => {
      this._symbolRepository.add(t3), this.restartDeclutter();
    })), this._symbolRepository.add(t3), this.restartDeclutter();
  }
  removeTile(t3) {
    const e7 = this._tileToHandle.get(t3);
    e7 && (this._symbolRepository.removeTile(t3), this.restartDeclutter(), e7.remove(), this._tileToHandle.delete(t3));
  }
  update(t3, e7) {
    this._zoom = t3, this._viewState = {
      scale: e7.scale,
      rotation: e7.rotation,
      center: [e7.center[0], e7.center[1]],
      size: [e7.size[0], e7.size[1]]
    };
    const i3 = [0, 0];
    e7.toScreen(i3, e7.center);
    const s4 = [0, 0];
    return e7.toScreen(s4, this._declutterViewState.center), this._offsetFromScreenCenter[0] = i3[0] - s4[0], this._offsetFromScreenCenter[1] = i3[1] - s4[1], this._continueDeclutter(), this._completed;
  }
  restartDeclutter() {
    this._completed = false, this._symbolDeclutterer.restart(), this._notifyUnstable();
  }
  clear() {
    this._completed = false, this._symbolRepository = null, this._symbolDeclutterer.restart(), this._tileToHandle.forEach((t3) => t3.remove()), this._tileToHandle.clear();
  }
  get stale() {
    return this._zoom !== this._declutterZoom || this._viewState.size[0] !== this._declutterViewState.size[0] || this._viewState.size[1] !== this._declutterViewState.size[1] || this._viewState.scale !== this._declutterViewState.scale || this._viewState.rotation !== this._declutterViewState.rotation;
  }
  deleteStyleLayers(t3) {
    this._symbolRepository.deleteStyleLayers(t3);
  }
  _continueDeclutter() {
    this._completed && !this.stale || (this._symbolDeclutterer.running || (this.updateDecluttererViewState(), this._symbolDeclutterer.restart()), this._symbolDeclutterer.setScreenSize(this._viewState.size[0], this._viewState.size[1]), this._completed = this._symbolDeclutterer.continue(c), this._completed && this._scheduleNotifyStable());
  }
  _scheduleNotifyStable() {
    null != this._stableNotificationHandle && clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = setTimeout(() => {
      this._stableNotificationHandle = null, this._fading.value = false;
    }, (1 + c3) * e4);
  }
  _notifyUnstable() {
    null != this._stableNotificationHandle && (clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = null), this._fading.value = true;
  }
  updateDecluttererViewState() {
    this._declutterZoom = this._zoom, this._declutterViewState.center[0] = this._viewState.center[0], this._declutterViewState.center[1] = this._viewState.center[1], this._declutterViewState.rotation = this._viewState.rotation, this._declutterViewState.scale = this._viewState.scale, this._declutterViewState.size[0] = this._viewState.size[0], this._declutterViewState.size[1] = this._viewState.size[1], this._offsetFromScreenCenter[0] = 0, this._offsetFromScreenCenter[1] = 0;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileContainer.js
var y3 = 1e-6;
function p2(e7, t3) {
  if (e7) {
    const s4 = e7.getLayoutProperty("visibility");
    if (!s4 || s4.getValue() !== i.NONE && (void 0 === e7.minzoom || e7.minzoom < t3 + y3) && (void 0 === e7.maxzoom || e7.maxzoom >= t3 - y3)) return true;
  }
  return false;
}
var m2 = class extends i2 {
  constructor(e7) {
    super(e7), this._backgroundTiles = [], this._computeDisplayInfoView(e7);
  }
  destroy() {
    this.removeAllChildren(), this._spriteMosaic?.dispose(), this._spriteMosaic = null, this._glyphMosaic?.dispose(), this._glyphMosaic = null, null != this._symbolFader && (this._symbolFader.clear(), this._symbolFader = null), this._styleRepository = null, this._backgroundTiles = [];
  }
  get fading() {
    return this._symbolFader?.fading ?? false;
  }
  get symbolFader() {
    return this._symbolFader;
  }
  get symbolRepository() {
    return this._symbolFader?.symbolRepository;
  }
  setStyleResources(e7, t3, r6, i3) {
    this._spriteMosaic = e7, this._glyphMosaic = t3, this._styleRepository = r6, this._tileInfoView = i3, this._computeDisplayInfoView(i3), null == this._symbolFader && (this._symbolFader = new _2(this._styleRepository, this.children)), this._symbolFader.styleRepository = r6;
  }
  setSpriteMosaic(e7) {
    this._spriteMosaic?.dispose(), this._spriteMosaic = e7;
  }
  deleteStyleLayers(e7) {
    null != this._symbolFader && this._symbolFader.deleteStyleLayers(e7);
  }
  createRenderParams(e7) {
    return __spreadProps(__spreadValues({}, super.createRenderParams(e7)), {
      renderPass: null,
      styleLayer: null,
      styleLayerUID: -1,
      glyphMosaic: this._glyphMosaic,
      spriteMosaic: this._spriteMosaic,
      hasClipping: !!this._clippingInfos
    });
  }
  doRender(e7) {
    !this.visible || e7.drawPhase !== E3.MAP && e7.drawPhase !== E3.DEBUG || void 0 === this._spriteMosaic || super.doRender(e7);
  }
  addChild(e7) {
    return super.addChild(e7), null != this._symbolFader ? this._symbolFader.addTile(e7) : e7.decluttered = true, this.requestRender(), e7;
  }
  removeChild(e7) {
    return null != this._symbolFader && this._symbolFader.removeTile(e7), this.requestRender(), super.removeChild(e7);
  }
  renderChildren(e7) {
    const {
      drawPhase: t3
    } = e7;
    t3 !== E3.DEBUG ? this._doRender(e7) : super.renderChildren(e7);
  }
  removeAllChildren() {
    for (let e7 = 0; e7 < this.children.length; e7++) {
      const t3 = this.children[e7];
      null != this._symbolFader && this._symbolFader.removeTile(t3), t3.dispose();
    }
    super.removeAllChildren();
  }
  getStencilTarget() {
    return this.children.filter((e7) => e7.neededForCoverage && e7.hasData());
  }
  restartDeclutter() {
    null != this._symbolFader && this._symbolFader.restartDeclutter();
  }
  _doRender(e7) {
    const {
      context: t3,
      state: s4
    } = e7, r6 = this._styleRepository;
    if (!r6) return;
    const i3 = r6.layers, o = this._displayInfo.scaleToZoom(s4.scale);
    r6.backgroundBucketIds.length > 0 && (e7.renderPass = "background", this._renderBackgroundLayers(e7, r6.backgroundBucketIds, o)), super.renderChildren(e7), e7.drawPhase === E3.MAP && this._fade(o, s4);
    const n4 = this.children.filter((e8) => e8.visible && e8.hasData());
    if (!n4 || 0 === n4.length) return t3.bindVAO(), t3.setStencilTestEnabled(true), void t3.setBlendingEnabled(true);
    for (const l3 of n4) l3.triangleCount = 0;
    t3.setStencilWriteMask(0), t3.setColorMask(true, true, true, true), t3.setStencilOp(I.KEEP, I.KEEP, I.REPLACE), t3.setStencilTestEnabled(true), t3.setBlendingEnabled(false), t3.setDepthTestEnabled(true), t3.setDepthWriteEnabled(true), t3.setDepthFunction(O.LEQUAL), t3.setClearDepth(1), t3.clear(t3.gl.DEPTH_BUFFER_BIT), e7.renderPass = "opaque";
    for (let l3 = i3.length - 1; l3 >= 0; l3--) this._renderStyleLayer(i3[l3], e7, n4);
    t3.setDepthWriteEnabled(false), t3.setBlendingEnabled(true), t3.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e7.renderPass = "translucent";
    for (let l3 = 0; l3 < i3.length; l3++) this._renderStyleLayer(i3[l3], e7, n4);
    t3.bindVAO(), t3.setStencilTestEnabled(true), t3.setBlendingEnabled(true);
    for (const l3 of n4) l3.debugInfo.display.triangleCount = l3.triangleCount;
  }
  _fade(e7, t3) {
    null != this._symbolFader && (this._symbolFader.update(e7, t3) || this.requestRender());
  }
  _renderStyleLayer(e7, t3, s4) {
    const {
      displayLevel: l3,
      painter: o,
      renderPass: n4
    } = t3;
    if (void 0 === e7) return;
    const a6 = e7.getLayoutProperty("visibility");
    if (a6 && a6.getValue() === i.NONE) return;
    let d7;
    switch (e7.type) {
      case a4.BACKGROUND:
        return;
      case a4.FILL:
        if ("opaque" !== n4 && "translucent" !== t3.renderPass) return;
        d7 = "vtlFill";
        break;
      case a4.LINE:
        if ("translucent" !== n4) return;
        d7 = "vtlLine";
        break;
      case a4.CIRCLE:
        if ("translucent" !== n4) return;
        d7 = "vtlCircle";
        break;
      case a4.SYMBOL:
        if ("translucent" !== n4) return;
        d7 = "vtlSymbol";
    }
    if (s4 = e7.type === a4.SYMBOL ? s4.filter((e8) => e8.decluttered) : s4.filter((e8) => e8.neededForCoverage), "vtlSymbol" !== d7 && (0 === s4.length || void 0 !== e7.minzoom && e7.minzoom >= l3 + y3 || void 0 !== e7.maxzoom && e7.maxzoom < l3 - y3)) return;
    const h6 = e7.uid;
    t3.styleLayerUID = h6, t3.styleLayer = e7;
    for (const r6 of s4) if (r6.layerData.has(h6)) {
      o.renderObjects(t3, s4, d7);
      break;
    }
  }
  _renderBackgroundLayers(t3, s4, r6) {
    const {
      context: l3,
      painter: n4,
      state: u4
    } = t3, y5 = this._styleRepository;
    let m4 = false;
    for (const e7 of s4) {
      if (y5.getLayerById(e7).type === a4.BACKGROUND && p2(y5.getLayerById(e7), r6)) {
        m4 = true;
        break;
      }
    }
    if (!m4) return;
    const f2 = this._tileInfoView, g = f2.getTileCoverage(t3.state, 0, true, "smallest"), {
      spans: _3,
      lodInfo: b2
    } = g, {
      level: E4
    } = b2, C = u2(), F = [];
    if (this._renderPasses) {
      const e7 = this._renderPasses[0];
      null != this._clippingInfos && (e7.brushes[0].prepareState(t3), e7.brushes[0].drawMany(t3, this._clippingInfos));
    }
    const L2 = this._backgroundTiles;
    let R2, v = 0;
    for (const {
      row: i3,
      colFrom: a6,
      colTo: h6
    } of _3) for (let t4 = a6; t4 <= h6; t4++) {
      if (v < L2.length) R2 = L2[v], R2.key.set(E4, i3, b2.normalizeCol(t4), b2.getWorldForColumn(t4)), f2.getTileBounds(C, R2.key, false), R2.x = C[0], R2.y = C[3], R2.resolution = f2.getTileResolution(E4);
      else {
        const s5 = new e3(E4, i3, b2.normalizeCol(t4), b2.getWorldForColumn(t4)), r7 = f2.getTileBounds(u2(), s5), l4 = f2.getTileResolution(E4);
        R2 = new t(s5, l4, r7[0], r7[3], 512, 512, 4096, 4096), L2.push(R2);
      }
      R2.setTransform(u4), F.push(R2), v++;
    }
    l3.setStencilWriteMask(0), l3.setColorMask(true, true, true, true), l3.setStencilOp(I.KEEP, I.KEEP, I.REPLACE), l3.setStencilFunction(O.EQUAL, 0, 255), l3.setStencilTestEnabled(true);
    for (const e7 of s4) {
      const s5 = y5.getLayerById(e7);
      s5.type === a4.BACKGROUND && p2(s5, r6) && (t3.styleLayerUID = s5.uid, t3.styleLayer = s5, n4.renderObjects(t3, F, "vtlBackground"));
    }
    s.pool.release(g);
  }
  _computeDisplayInfoView(e7) {
    let s4 = e7.tileInfo.lods[0].scale;
    const r6 = Math.max(25, e7.tileInfo.lods.length), i3 = [];
    for (let t3 = 0; t3 <= r6; t3++) i3.push(s4), s4 /= 2;
    this._displayInfo = z.create({
      scales: i3,
      size: 512,
      spatialReference: e7.spatialReference,
      numLODs: r6
    });
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileFeatureIndex.js
var y4 = 8;
var c4 = 512;
var u3 = 4096;
var h5 = (e7, t3) => {
  const s4 = e7.vtlSymbol.sourceTile, r6 = t3.vtlSymbol.sourceTile;
  return s4.level !== r6.level ? s4.level - r6.level : s4.row !== r6.row ? s4.row - r6.row : s4.col !== r6.col ? s4.col - r6.col : e7.styleLayerUID - t3.styleLayerUID;
};
var d6 = class _d {
  constructor(e7, t3, s4, r6, i3) {
    this.tileKey = e7, this._index = null, this._styleRepository = null, this._tileHandler = null, this._tileKeyToPBF = /* @__PURE__ */ new Map(), this._tileLayerData = t3, this._styleRepository = s4, this._tileHandler = r6, this._parentLayer = i3;
  }
  static create(e7, t3, s4, r6, i3) {
    return new _d(e7, t3, s4, r6, i3);
  }
  clear() {
    this._index?.clear(), this._tileKeyToPBF.clear();
  }
  queryAttributes(e7, t3, s4, i3, l3) {
    return __async(this, null, function* () {
      if (0 === this._tileLayerData.size || !this._styleRepository || !this._tileHandler) return [];
      null === this._index && (this._index = new h(100, m3), yield this._indexLayers());
      const o = [];
      return this._queryIndex(o, e7, t3, s4, this.tileKey.level, i3), l3 && l3?.length > 0 && (yield this._getSymbolsAttributes(o, l3)), o;
    });
  }
  _indexLayers() {
    return __async(this, null, function* () {
      const e7 = this.tileKey, t3 = this._styleRepository.layers, s4 = yield this._getTilePayload(e7);
      for (const [r6, l3] of this._tileLayerData) {
        const o = t3[r6], n4 = s4.find((e8) => e8.sourceName === o.source);
        if (!n4) continue;
        const {
          protobuff: a6,
          key: y5
        } = n4;
        if (l3.type !== E2.SYMBOL) {
          const t4 = 1 << e7.level - y5.level, s5 = e7.row - y5.row * t4, r7 = e7.col - y5.col * t4;
          this._indexLayer(o, a6, e7.level, t4, s5, r7);
        }
      }
    });
  }
  _indexLayer(e7, t3, r6, i3, y5, h6) {
    const d7 = e7.sourceLayer, m4 = e7.getFeatureFilter(), f2 = r6, _3 = r6 + 1, p3 = d3(f2), g = new n2(new Uint8Array(t3), new DataView(t3));
    for (; g.next(); ) switch (g.tag()) {
      case 3: {
        const t4 = g.getMessage(), s4 = new e5(t4);
        if (t4.release(), s4.name !== d7) continue;
        const o = s4.getData(), w2 = s4.extent / i3, x = w2 * h6 - p3, b2 = w2 * y5 - p3, I4 = x + w2 + 2 * p3, L2 = b2 + w2 + 2 * p3, v = w2 / c4, D2 = u3 / w2, T = w2 * h6, S2 = w2 * y5;
        for (; o.nextTag(2); ) {
          const t5 = o.getMessage(), i4 = new s2(t5, s4);
          if (t5.release(), m4 && !m4.filter(i4, r6)) continue;
          const n4 = i4.values || {}, y6 = n4._minzoom, c5 = n4._maxzoom;
          if (y6 && y6 >= 10 * _3 || c5 && c5 <= 10 * f2) continue;
          const u4 = e7.getFeatureInflatedBounds(i4, f2, s4.extent, v);
          null == u4 || u4[0] > I4 || u4[1] > L2 || u4[2] < x || u4[3] < b2 || (u4[0] = (u4[0] - T) * D2, u4[1] = (u4[1] - S2) * D2, u4[2] = (u4[2] - T) * D2, u4[3] = (u4[3] - S2) * D2, this._index.insert(new L(e7, i4, u4, D2, T, S2)));
        }
        break;
      }
      default:
        g.skip();
    }
  }
  _getSymbolsAttributes(e7, t3) {
    return __async(this, null, function* () {
      if (!t3 || 0 === t3.length) return e7;
      const s4 = [];
      t3.sort(h5);
      let r6 = t3[0].styleLayerUID, i3 = 0;
      for (let a6 = 0; a6 < t3.length; a6++) r6 !== t3[a6].styleLayerUID && (s4.push({
        from: i3,
        to: a6,
        styleLayerUID: r6,
        sourceTileKey: t3[a6].vtlSymbol.sourceTile
      }), i3 = a6, r6 = t3[a6].styleLayerUID);
      s4.push({
        from: i3,
        to: t3.length,
        styleLayerUID: r6,
        sourceTileKey: t3[t3.length - 1].vtlSymbol.sourceTile
      });
      const l3 = this._styleRepository.layers;
      let o, n4 = null;
      for (const a6 of s4) {
        const s5 = yield this._getTilePayload(a6.sourceTileKey);
        o = l3[a6.styleLayerUID], n4 = !!o && s5.find((e8) => e8.sourceName === o.source), n4 && this._addSymbolsAttributes(e7, t3.slice(a6.from, a6.to).map((e8) => e8.vtlSymbol), r6, n4);
      }
      return e7;
    });
  }
  _addSymbolsAttributes(t3, s4, r6, i3) {
    const l3 = this._styleRepository.layers, o = i3.key, n4 = this.tileKey, a6 = 1 << n4.level - o.level, y5 = n4.row - o.row * a6, c5 = n4.col - o.col * a6;
    this._getSymbolAttributes(i3.protobuff, s4, r6, a6, y5, c5).forEach((s5) => {
      const {
        attributes: i4,
        tilePoint: o2
      } = s5;
      t3.push({
        layerId: l3[r6].id,
        layerIndex: r6,
        graphic: new d({
          attributes: i4,
          origin: {
            type: "vector-tile",
            layerId: l3[r6].id,
            layerIndex: r6,
            layer: this._parentLayer
          }
        }),
        tilePoint: o2
      });
    });
  }
  _getSymbolAttributes(e7, t3, r6, i3, o, a6) {
    const y5 = [], c5 = this._styleRepository.layers;
    let h6 = 0;
    t3.sort((e8, t4) => e8.featureIndex - t4.featureIndex);
    const d7 = new n2(new Uint8Array(e7), new DataView(e7));
    for (; d7.next(); ) switch (d7.tag()) {
      case 3: {
        const e8 = d7.getMessage(), s4 = new e5(e8);
        if (e8.release(), s4.name !== c5[r6].sourceLayer) continue;
        const m4 = s4.getData(), f2 = s4.extent / i3, _3 = u3 / f2, p3 = f2 * a6, g = f2 * o;
        let w2 = 0;
        for (; m4.nextTag(2); ) {
          const e9 = m4.getMessage();
          if (w2++ === t3[h6].featureIndex) {
            const t4 = new s2(e9, s4), r7 = t4.values, i4 = t4.getGeometry(), o2 = null != i4 ? [_3 * (i4[0][0].x - p3), _3 * (i4[0][0].y - g)] : null;
            y5.push({
              attributes: r7,
              tilePoint: o2
            }), h6++;
          }
          if (e9.release(), h6 === t3.length) return y5;
        }
        break;
      }
      default:
        d7.skip();
    }
    return y5;
  }
  _queryIndex(t3, s4, r6, i3, l3, o) {
    const n4 = y4 * i3 * (window.devicePixelRatio || 1);
    return this._index?.search({
      minX: s4 - n4,
      minY: r6 - n4,
      maxX: s4 + n4,
      maxY: r6 + n4
    }, (n5) => {
      const {
        layer: a6,
        feature: y5
      } = n5;
      a6.isIntersectingFeature(s4, r6, i3, y5, l3, o, n5) && t3.push({
        layerId: a6.id,
        layerIndex: a6.uid,
        tilePoint: null,
        graphic: new d({
          attributes: y5.values,
          origin: {
            type: "vector-tile",
            layerId: n5.layer.id,
            layerIndex: n5.layer.uid,
            layer: this._parentLayer
          }
        })
      });
    }), t3;
  }
  _getTilePayload(e7) {
    return __async(this, null, function* () {
      return r(this._tileKeyToPBF, e7.id, () => this._tileHandler.fetchTilePBFs(e7)).then((e8) => e8);
    });
  }
};
var m3 = (e7) => ({
  minX: e7.bounds[0],
  minY: e7.bounds[1],
  maxX: e7.bounds[2],
  maxY: e7.bounds[3]
});

// ../../../node_modules/@arcgis/core/views/2d/layers/VectorTileLayerView2D.js
var w = 2;
var I3 = 8;
var D = 512;
var P = class extends f(y2) {
  constructor() {
    super(...arguments), this._styleChanges = [], this._fetchQueue = null, this._parseQueue = null, this._tileHandlerPromise = null, this._isTileHandlerReady = false;
  }
  get fading() {
    return this._vectorTileContainer?.fading ?? false;
  }
  hitTest(e7, t3) {
    return __async(this, null, function* () {
      const i3 = this._tileHandlerPromise, s4 = this._vectorTileContainer?.symbolFader;
      if (!i3 || !this._isTileHandlerReady || !s4) return;
      yield i3;
      let r6 = null;
      const a6 = this._vectorTileContainer?.symbolRepository;
      a6 && (r6 = a6.querySymbols(t3, w, s4.decluttererOffset, {}));
      const l3 = this.view.state, n4 = this._tileManager.getIntersectingTiles(t3.x, t3.y, w, l3, r6);
      if ((!n4 || 0 === n4.length) && 0 === r6?.length) return null;
      e7 = e7.clone().normalize();
      const o = [], h6 = [];
      for (const y5 of n4) o.push(this._queryTile(h6, e7, w, this.view.state.rotation, y5, r6?.filter((e8) => e8.tileKey.id === y5.id)));
      return yield Promise.all(o), h6;
    });
  }
  update(e7) {
    if (this._tileHandlerPromise && this._isTileHandlerReady) return e7.pixelRatio !== this._tileHandler.devicePixelRatio ? (this._start(), void (this._tileHandler.devicePixelRatio = e7.pixelRatio)) : void (this._styleChanges.length > 0 ? this._tileHandlerPromise = this._applyStyleChanges() : (this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.state = e7.state, this._parseQueue.state = e7.state, this._tileManager.update(e7) || this.requestUpdate(), this._parseQueue.resume(), this._fetchQueue.resume()));
  }
  attach() {
    const {
      style: e7
    } = this.layer.currentStyleInfo;
    this._styleRepository = new l(e7), this._tileInfoView = new t2(this.layer.tileInfo, this.layer.fullExtent), this._vectorTileContainer = new m2(this._tileInfoView), this._tileHandler = new h2(this.layer, this._styleRepository, window.devicePixelRatio || 1, this.layer.tileInfo.lods.length - 1), this.container.addChild(this._vectorTileContainer), this._start(), this.addAttachHandles([this.layer.on("paint-change", (e8) => {
      if (e8.isDataDriven) this._styleChanges.push({
        type: I2.PAINTER_CHANGED,
        data: e8
      }), this.requestUpdate();
      else {
        const t3 = this._styleRepository, i3 = t3.getLayerById(e8.layer);
        if (!i3) return;
        const s4 = i3.type === a4.SYMBOL;
        t3.setPaintProperties(e8.layer, e8.paint), s4 && this._vectorTileContainer?.restartDeclutter(), this._vectorTileContainer?.requestRender();
      }
    }), this.layer.on("layout-change", (e8) => {
      const t3 = this._styleRepository, i3 = t3.getLayerById(e8.layer);
      if (!i3) return;
      const s4 = d2(i3.layout, e8.layout);
      if (null != s4) {
        if (p(s4, "visibility") && 1 === S(s4)) return t3.setLayoutProperties(e8.layer, e8.layout), i3.type === a4.SYMBOL && this._vectorTileContainer?.restartDeclutter(), void this._vectorTileContainer?.requestRender();
        this._styleChanges.push({
          type: I2.LAYOUT_CHANGED,
          data: e8
        }), this.requestUpdate();
      }
    }), this.layer.on("style-layer-visibility-change", (e8) => {
      const t3 = this._styleRepository, i3 = t3.getLayerById(e8.layer);
      i3 && (t3.setStyleLayerVisibility(e8.layer, e8.visibility), i3.type === a4.SYMBOL && this._vectorTileContainer?.restartDeclutter(), this._vectorTileContainer?.requestRender());
    }), this.layer.on("style-layer-change", (e8) => {
      this._styleChanges.push({
        type: I2.LAYER_CHANGED,
        data: e8
      }), this.requestUpdate();
    }), this.layer.on("delete-style-layer", (e8) => {
      this._styleChanges.push({
        type: I2.LAYER_REMOVED,
        data: e8
      }), this.requestUpdate();
    }), this.layer.on("load-style", () => this._loadStyle()), this.layer.on("spriteSource-change", (e8) => {
      this._styleChanges.push({
        type: I2.SPRITES_CHANGED,
        data: e8
      });
      const t3 = this._styleRepository.layers;
      for (const i3 of t3) switch (i3.type) {
        case a4.SYMBOL:
          i3.getLayoutProperty("icon-image") && this._styleChanges.push({
            type: I2.LAYOUT_CHANGED,
            data: {
              layer: i3.id,
              layout: i3.layout
            }
          });
          break;
        case a4.LINE:
          i3.getPaintProperty("line-pattern") && this._styleChanges.push({
            type: I2.PAINTER_CHANGED,
            data: {
              layer: i3.id,
              paint: i3.paint,
              isDataDriven: i3.isPainterDataDriven()
            }
          });
          break;
        case a4.FILL:
          i3.getLayoutProperty("fill-pattern") && this._styleChanges.push({
            type: I2.PAINTER_CHANGED,
            data: {
              layer: i3.id,
              paint: i3.paint,
              isDataDriven: i3.isPainterDataDriven()
            }
          });
      }
      this.requestUpdate();
    })]);
  }
  detach() {
    this._stop(), this.container.removeAllChildren(), this._vectorTileContainer = u(this._vectorTileContainer), this._tileHandler = u(this._tileHandler);
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  supportsSpatialReference(e7) {
    return G(this.layer.tileInfo?.spatialReference, e7);
  }
  canResume() {
    let e7 = super.canResume();
    const {
      currentStyleInfo: t3
    } = this.layer;
    if (e7 && t3?.layerDefinition) {
      const i3 = this.view.scale, {
        minScale: s4,
        maxScale: r6
      } = t3.layerDefinition;
      t3?.layerDefinition && (s4 && s4 < i3 && (e7 = false), r6 && r6 > i3 && (e7 = false));
    }
    return e7;
  }
  isUpdating() {
    return this.fading;
  }
  acquireTile(e7) {
    const t3 = this._createVectorTile(e7);
    return this._updatingHandles.addPromise(this._fetchQueue.push(t3.key).then((e8) => this._parseQueue.push({
      key: t3.key,
      data: e8
    })).then((e8) => {
      t3.once("attach", () => this.requestUpdate()), t3.setData(e8), this.requestUpdate();
    }).catch((e8) => {
      b(e8) || n.getLogger(this).error(e8);
    })), t3;
  }
  releaseTile(e7) {
    const t3 = e7.key.id;
    this._fetchQueue.abort(t3), this._parseQueue.abort(t3), this.requestUpdate();
  }
  _start() {
    if (this._stop(), this._tileManager = new h3({
      acquireTile: (e8) => this.acquireTile(e8),
      releaseTile: (e8) => this.releaseTile(e8),
      tileInfoView: this._tileInfoView
    }, this._vectorTileContainer), !this.layer.currentStyleInfo) return;
    const e7 = new AbortController(), t3 = this._tileHandler.start({
      signal: e7.signal
    }).then(() => {
      this._fetchQueue = new m({
        tileInfoView: this._tileInfoView,
        process: (e8, t4) => this._getTileData(e8, t4),
        concurrency: 15
      }), this._parseQueue = new m({
        tileInfoView: this._tileInfoView,
        process: (e8, t4) => this._parseTileData(e8, t4),
        concurrency: 8
      }), this.requestUpdate(), this._isTileHandlerReady = true;
    });
    this._tileHandler.spriteMosaic.then((e8) => {
      this._vectorTileContainer.setStyleResources(e8, this._tileHandler.glyphMosaic, this._styleRepository, this._tileInfoView), this.requestUpdate();
    }), this._tileHandlerAbortController = e7, this._tileHandlerPromise = t3;
  }
  _stop() {
    if (!this._tileHandlerAbortController || !this._vectorTileContainer) return;
    const e7 = this._tileHandlerAbortController;
    e7 && e7.abort(), this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._fetchQueue = u(this._fetchQueue), this._parseQueue = u(this._parseQueue), this._tileManager = u(this._tileManager), this._vectorTileContainer.removeAllChildren();
  }
  _getTileData(e7, t3) {
    return __async(this, null, function* () {
      return this._tileHandler.fetchTileData(e7, t3);
    });
  }
  _parseTileData(e7, t3) {
    return __async(this, null, function* () {
      return this._tileHandler.parseTileData(e7, t3);
    });
  }
  _applyStyleChanges() {
    return __async(this, null, function* () {
      this._isTileHandlerReady = false, this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.clear(), this._parseQueue.clear(), this._tileManager.clearCache();
      const e7 = this._styleChanges;
      try {
        yield this._tileHandler.updateStyle(e7);
      } catch (l3) {
        n.getLogger(this).error("error applying vector-tiles style update", l3.message), this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true;
      }
      const t3 = this._styleRepository, s4 = /* @__PURE__ */ new Set();
      e7.forEach((e8) => {
        if (e8.type !== I2.LAYER_REMOVED) return;
        const i3 = e8.data, r7 = t3.getLayerById(i3.layer);
        r7 && s4.add(r7.uid);
      });
      const r6 = /* @__PURE__ */ new Set();
      e7.forEach((e8) => {
        let i3;
        switch (e8.type) {
          case I2.PAINTER_CHANGED:
            t3.setPaintProperties(e8.data.layer, e8.data.paint), i3 = e8.data.layer;
            break;
          case I2.LAYOUT_CHANGED:
            t3.setLayoutProperties(e8.data.layer, e8.data.layout), i3 = e8.data.layer;
            break;
          case I2.LAYER_REMOVED:
            return void t3.deleteStyleLayer(e8.data.layer);
          case I2.LAYER_CHANGED:
            t3.setStyleLayer(e8.data.layer, e8.data.index), i3 = e8.data.layer.id;
            break;
          case I2.SPRITES_CHANGED:
            this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(e8.data.spriteSource));
        }
        if (i3) {
          const e9 = t3.getLayerById(i3);
          e9 && r6.add(e9.uid);
        }
      });
      const a6 = this._vectorTileContainer.children;
      if (s4.size > 0) {
        const e8 = Array.from(s4);
        this._vectorTileContainer.deleteStyleLayers(e8);
        for (const t4 of a6) t4.deleteLayerData(e8);
      }
      if (this._fetchQueue.resume(), this._parseQueue.resume(), r6.size > 0) {
        const e8 = Array.from(r6), t4 = [];
        for (const i3 of a6) {
          const s5 = this._updatingHandles.addPromise(this._fetchQueue.push(i3.key).then((t5) => this._parseQueue.push({
            key: i3.key,
            data: t5,
            styleLayerUIDs: e8
          })).then((e9) => i3.setData(e9)));
          t4.push(s5);
        }
        yield Promise.all(t4);
      }
      this._styleChanges = [], this._isTileHandlerReady = true, this.requestUpdate();
    });
  }
  _loadStyle() {
    return __async(this, null, function* () {
      const {
        style: e7
      } = this.layer.currentStyleInfo, i3 = a(e7);
      this._isTileHandlerReady = false, this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.clear(), this._parseQueue.clear(), this._styleRepository = new l(i3), this._vectorTileContainer.destroy(), this._tileManager.clear(), this._tileHandlerAbortController.abort(), this._tileHandlerAbortController = new AbortController();
      const {
        signal: s4
      } = this._tileHandlerAbortController;
      try {
        this._tileHandlerPromise = this._tileHandler.setStyle(this._styleRepository, i3, this.layer.tileInfo.lods.length - 1), yield this._tileHandlerPromise;
      } catch (n4) {
        if (!b(n4)) throw n4;
      }
      if (s4.aborted) return this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true, void this.requestUpdate();
      const a6 = yield this._tileHandler.spriteMosaic, l3 = this._vectorTileContainer;
      this._tileInfoView = new t2(this.layer.tileInfo, this.layer.fullExtent), l3.setStyleResources(a6, this._tileHandler.glyphMosaic, this._styleRepository, this._tileInfoView), this._tileManager = new h3({
        acquireTile: (e8) => this.acquireTile(e8),
        releaseTile: (e8) => this.releaseTile(e8),
        tileInfoView: this._tileInfoView
      }, this._vectorTileContainer), this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true, this.requestUpdate();
    });
  }
  _createVectorTile(e7) {
    const t3 = this._tileInfoView.getTileBounds(u2(), e7), i3 = this._tileInfoView.getTileResolution(e7.level);
    return new d4(e7, i3, t3[0], t3[3], 512, 512, this._styleRepository);
  }
  _queryTile(e7, t3, i3, s4, r6, a6) {
    return __async(this, null, function* () {
      if (0 === r6.layerData.size) return;
      const l3 = this._ensureTileIndex(r6), n4 = this._tileInfoView.getTileBounds(u2(), r6.key, true), o = I3 * D * ((t3.x - n4[0]) / (n4[2] - n4[0])), h6 = I3 * D * (1 - (t3.y - n4[1]) / (n4[3] - n4[1])), c5 = yield l3.queryAttributes(o, h6, i3, s4, a6);
      for (const y5 of c5) y5.graphic.geometry = this._tileToMapPoint(y5.tilePoint, r6.transforms.tileUnitsToPixels), e7.push({
        type: "graphic",
        layer: this.layer,
        graphic: y5.graphic,
        mapPoint: t3.clone()
      });
      e7.sort((e8, t4) => t4.graphic.origin.layerIndex - e8.graphic.origin.layerIndex);
    });
  }
  _tileToMapPoint(e7, t3) {
    if (!e7) return null;
    const i3 = e7[0] * t3[0] + e7[1] * t3[3] + t3[6], s4 = e7[0] * t3[1] + e7[1] * t3[4] + t3[7], r6 = this.view.state, a6 = [0, 0];
    return r6.toMap(a6, [i3, s4]), new _({
      x: a6[0],
      y: a6[1],
      spatialReference: r6.spatialReference
    });
  }
  _ensureTileIndex(e7) {
    let t3 = e7.featureIndex;
    return t3 || (t3 = d6.create(e7.key, e7.layerData, this._styleRepository, this._tileHandler, this.layer), e7.featureIndex = t3), t3;
  }
};
function S(e7) {
  if (null == e7) return 0;
  switch (e7.type) {
    case "partial":
      return Object.keys(e7.diff).length;
    case "complete":
      return Math.max(Object.keys(e7.oldValue).length, Object.keys(e7.newValue).length);
    case "collection":
      return Object.keys(e7.added).length + Object.keys(e7.changed).length + Object.keys(e7.removed).length;
  }
}
e([y()], P.prototype, "_isTileHandlerReady", void 0), P = e([a2("esri.views.2d.layers.VectorTileLayerView2D")], P);
var A = P;
export {
  A as default
};
//# sourceMappingURL=VectorTileLayerView2D-EX45EJXB.js.map
