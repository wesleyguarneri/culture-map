{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/FoamRendering.glsl.js", "../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ScreenSpaceReflections.glsl.js", "../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/Water.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { glsl as t } from \"../../shaderModules/interfaces.js\";\nfunction o(o) {\n  o.fragment.code.add(t`float normals2FoamIntensity(vec3 n, float waveStrength){\nfloat normalizationFactor =  max(0.015, waveStrength);\nreturn max((n.x + n.y)*0.3303545/normalizationFactor + 0.3303545, 0.0);\n}`);\n}\nfunction n(o) {\n  o.fragment.code.add(t`vec3 foamIntensity2FoamColor(float foamIntensityExternal, float foamPixelIntensity, vec3 skyZenitColor, float dayMod){\nreturn foamIntensityExternal * (0.075 * skyZenitColor * pow(foamPixelIntensity, 4.) +  50.* pow(foamPixelIntensity, 23.0)) * dayMod;\n}`);\n}\nexport { n as FoamColor, o as FoamIntensity };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { ReadDepth as e } from \"../output/ReadDepth.glsl.js\";\nimport { Float2PassUniform as o } from \"../../shaderModules/Float2PassUniform.js\";\nimport { FloatPassUniform as t } from \"../../shaderModules/FloatPassUniform.js\";\nimport { glsl as r } from \"../../shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as a } from \"../../shaderModules/Matrix4PassUniform.js\";\nimport { Texture2DPassUniform as i } from \"../../shaderModules/Texture2DPassUniform.js\";\nfunction d(d, n) {\n  const c = d.fragment;\n  c.include(e), c.uniforms.add(new o(\"nearFar\", (e, o) => o.camera.nearFar)), c.uniforms.add(new i(\"depthMap\", (e, o) => o.depth?.attachment)), c.uniforms.add(new a(\"proj\", (e, o) => o.camera.projectionMatrix)), c.uniforms.add(new t(\"invResolutionHeight\", (e, o) => 1 / o.camera.height)), c.uniforms.add(new a(\"reprojectionMatrix\", (e, o) => o.ssr.reprojectionMatrix)), c.code.add(r`\n  vec2 reprojectionCoordinate(vec3 projectionCoordinate)\n  {\n    vec4 zw = proj * vec4(0.0, 0.0, -projectionCoordinate.z, 1.0);\n    vec4 reprojectedCoord = reprojectionMatrix * vec4(zw.w * (projectionCoordinate.xy * 2.0 - 1.0), zw.z, zw.w);\n    reprojectedCoord.xy /= reprojectedCoord.w;\n    return reprojectedCoord.xy * 0.5 + 0.5;\n  }\n\n  const int maxSteps = ${n.highStepCount ? \"150\" : \"75\"};\n\n  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)\n  {\n    vec4 projectedCoord =  projectionMat * vec4(x, 1.0);\n    projectedCoord.xy /= projectedCoord.w;\n    projectedCoord.xy = projectedCoord.xy*0.5 + 0.5;\n    return projectedCoord;\n  }\n\n  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)\n  {\n    vec3 viewPos = startPosition;\n    vec3 viewPosEnd = startPosition;\n\n    // Project the start position to the screen\n    vec4 projectedCoordStart = applyProjectionMat(proj, viewPos);\n    vec3  Q0 = viewPos / projectedCoordStart.w; // homogeneous camera space\n    float k0 = 1.0/ projectedCoordStart.w;\n\n    // advance the position in the direction of the reflection\n    viewPos += dir;\n\n    vec4 projectedCoordVanishingPoint = applyProjectionMat(proj, dir);\n\n    // Project the advanced position to the screen\n    vec4 projectedCoordEnd = applyProjectionMat(proj, viewPos);\n    vec3  Q1 = viewPos / projectedCoordEnd.w; // homogeneous camera space\n    float k1 = 1.0/ projectedCoordEnd.w;\n\n    // calculate the reflection direction in the screen space\n    vec2 projectedCoordDir = (projectedCoordEnd.xy - projectedCoordStart.xy);\n    vec2 projectedCoordDistVanishingPoint = (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);\n\n    float yMod = min(abs(projectedCoordDistVanishingPoint.y), 1.0);\n\n    float projectedCoordDirLength = length(projectedCoordDir);\n    float maxSt = float(maxSteps);\n\n    // normalize the projection direction depending on maximum steps\n    // this determines how blocky the reflection looks\n    vec2 dP = yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);\n\n    // Normalize the homogeneous camera space coordinates\n    vec3  dQ = yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);\n    float dk = yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);\n\n    // initialize the variables for ray marching\n    vec2 P = projectedCoordStart.xy;\n    vec3 Q = Q0;\n    float k = k0;\n    float rayStartZ = -startPosition.z; // estimated ray start depth value\n    float rayEndZ = -startPosition.z;   // estimated ray end depth value\n    float prevEstimateZ = -startPosition.z;\n    float rayDiffZ = 0.0;\n    float dDepth;\n    float depth;\n    float rayDiffZOld = 0.0;\n\n    // early outs\n    if (dot(normal, dir) < 0.0 || dot(-viewDir, normal) < 0.0)\n      return vec3(P, 0.0);\n\n    for(int i = 0; i < maxSteps-1; i++)\n    {\n      depth = -linearDepthFromTexture(depthMap, P); // get linear depth from the depth buffer\n\n      // estimate depth of the marching ray\n      rayStartZ = prevEstimateZ;\n      dDepth = -rayStartZ - depth;\n      rayEndZ = (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));\n      rayDiffZ = rayEndZ- rayStartZ;\n      prevEstimateZ = rayEndZ;\n\n      if(-rayEndZ > nearFar[1] || -rayEndZ < nearFar[0] || P.y < 0.0  || P.y > 1.0 )\n      {\n        return vec3(P, 0.);\n      }\n\n      // If we detect a hit - return the intersection point, two conditions:\n      //  - dDepth > 0.0 - sampled point depth is in front of estimated depth\n      //  - if difference between dDepth and rayDiffZOld is not too large\n      //  - if difference between dDepth and 0.025/abs(k) is not too large\n      //  - if the sampled depth is not behind far plane or in front of near plane\n\n      if((dDepth) < 0.025/abs(k) + abs(rayDiffZ) && dDepth > 0.0 && depth > nearFar[0] && depth < nearFar[1] && abs(P.y - projectedCoordStart.y) > invResolutionHeight)\n      {\n        return vec3(P, depth);\n      }\n\n      // continue with ray marching\n      P = clamp(P + dP, vec2(0.0), vec2(0.999));\n      Q.z += dQ.z;\n      k += dk;\n      rayDiffZOld = rayDiffZ;\n    }\n    return vec3(P, 0.0);\n  }\n  `);\n}\nexport { d as ScreenSpaceReflections };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { FoamColor as e } from \"./FoamRendering.glsl.js\";\nimport { Gamma as o } from \"./Gamma.glsl.js\";\nimport { PhysicallyBasedRenderingWater as r } from \"./PhysicallyBasedRendering.glsl.js\";\nimport { distanceFadeStart as t, distanceFadeEnd as i } from \"./ScreenSpaceConstants.js\";\nimport { ScreenSpaceReflections as a } from \"./ScreenSpaceReflections.glsl.js\";\nimport { CloudsParallaxShading as l } from \"../util/CloudsParallaxShading.glsl.js\";\nimport { FloatPassUniform as n } from \"../../shaderModules/FloatPassUniform.js\";\nimport { glsl as d } from \"../../shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as c } from \"../../shaderModules/Matrix4PassUniform.js\";\nimport { Texture2DPassUniform as s } from \"../../shaderModules/Texture2DPassUniform.js\";\nfunction f(f, m) {\n  f.include(r, m), f.include(o), f.include(e), m.hasCloudsReflections && f.include(l, m), m.hasScreenSpaceReflections && f.include(a, m);\n  const v = f.fragment;\n  v.constants.add(\"fresnelSky\", \"vec3\", [.02, 1, 15]).add(\"fresnelMaterial\", \"vec2\", [.02, .1]).add(\"roughness\", \"float\", .015).add(\"foamIntensityExternal\", \"float\", 1.7).add(\"ssrIntensity\", \"float\", .65).add(\"ssrHeightFadeStart\", \"float\", t).add(\"ssrHeightFadeEnd\", \"float\", i).add(\"waterDiffusion\", \"float\", .92).add(\"waterSeaColorMod\", \"float\", .8).add(\"correctionViewingPowerFactor\", \"float\", .4).add(\"skyZenitColor\", \"vec3\", [.52, .68, .9]).add(\"skyColor\", \"vec3\", [.67, .79, .9]).add(\"cloudFresnelModifier\", \"vec2\", [1.2, .01]), v.code.add(d`PBRShadingWater shadingInfo;\nvec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {\nfloat exponent = pow((1.0 - cosTheta), fresnelSky[2]);\nreturn mix(zenit, horizon, exponent);\n}`), v.uniforms.add(new n(\"lightingSpecularStrength\", (e, o) => o.lighting.mainLight.specularStrength), new n(\"lightingEnvironmentStrength\", (e, o) => o.lighting.mainLight.environmentStrength)), v.code.add(d`vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow, float foamIntensity, vec3 viewPosition, vec3 position) {\nfloat reflectionHit = 0.0;\nfloat reflectionHitDiffused = 0.0;\nvec3 seaWaterColor = linearizeGamma(color);\nvec3 h = normalize(l + v);\nshadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);\nshadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);\nshadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);\nshadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);\nshadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);\nshadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);\nfloat upDotV = max(dot(localUp,v), 0.0);\nvec3 skyHorizon = linearizeGamma(skyColor);\nvec3 skyZenit = linearizeGamma(skyZenitColor);\nvec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );\nfloat upDotL = max(dot(localUp,l),0.0);\nfloat daytimeMod = 0.1 + upDotL * 0.9;\nskyColor *= daytimeMod;\nfloat shadowModifier = clamp(shadow, 0.8, 1.0);\nvec3 fresnelModifier = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]);\nvec3 reflSky = lightingEnvironmentStrength * fresnelModifier * skyColor * shadowModifier;\nvec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;\nvec3 specular = vec3(0.0);\nif(upDotV > 0.0 && upDotL > 0.0) {\nvec3 specularSun = brdfSpecularWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);\nvec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;\nspecular = lightingSpecularStrength * shadingInfo.NdotL * incidentLight * specularSun;\n}\nvec3 foam = vec3(0.0);\nif(upDotV > 0.0) {\nfoam = foamIntensity2FoamColor(foamIntensityExternal, foamIntensity, skyZenitColor, daytimeMod);\n}\nfloat correctionViewingFactor = pow(max(dot(v, localUp), 0.0), correctionViewingPowerFactor);\nvec3 normalCorrectedClouds = mix(localUp, n, correctionViewingFactor);\nvec3 reflectedWorld = normalize(reflect(-v, normalCorrectedClouds));`), m.hasCloudsReflections && v.code.add(d`vec4 cloudsColor = renderClouds(reflectedWorld, position);\ncloudsColor.a = 1.0 - cloudsColor.a;\ncloudsColor = pow(cloudsColor, vec4(GAMMA));\ncloudsColor *= clamp(fresnelModifier.y * cloudFresnelModifier[0] - cloudFresnelModifier[1], 0.0, 1.0) * clamp((1.0 - totalFadeInOut), 0.0, 1.0);`), m.hasScreenSpaceReflections ? (v.uniforms.add(new c(\"view\", (e, o) => o.camera.viewMatrix), new s(\"lastFrameColorTexture\", (e, o) => o.ssr.lastFrameColor?.getTexture()), new n(\"fadeFactorSSR\", (e, o) => o.ssr.fadeFactor)), v.code.add(d`vec3 viewDir = normalize(viewPosition);\nvec4 viewNormalVectorCoordinate = view *vec4(n, 0.0);\nvec3 viewNormal = normalize(viewNormalVectorCoordinate.xyz);\nvec4 viewUp = view * vec4(localUp, 0.0);\nvec3 viewNormalCorrectedSSR = mix(viewUp.xyz, viewNormal, correctionViewingFactor);\nvec3 reflected = normalize(reflect(viewDir, viewNormalCorrectedSSR));\nvec3 hitCoordinate = screenSpaceIntersection(reflected, viewPosition, viewDir, viewUp.xyz);\nvec3 reflectedColor = vec3(0.0);\nif (hitCoordinate.z > 0.0)\n{\nvec2 reprojectedCoordinate = reprojectionCoordinate(hitCoordinate);\nvec2 dCoords = smoothstep(0.3, 0.6, abs(vec2(0.5, 0.5) - hitCoordinate.xy));\nfloat heightMod = smoothstep(ssrHeightFadeEnd, ssrHeightFadeStart, -viewPosition.z);\nreflectionHit = clamp(1.0 - (1.3 * dCoords.y), 0.0, 1.0) * heightMod * fadeFactorSSR;\nreflectionHitDiffused = waterDiffusion * reflectionHit;\nreflectedColor = linearizeGamma(texture(lastFrameColorTexture, reprojectedCoordinate).xyz) *\nreflectionHitDiffused * fresnelModifier.y * ssrIntensity;\n}\nfloat seaColorMod =  mix(waterSeaColorMod, waterSeaColorMod * 0.5, reflectionHitDiffused);\nvec3 waterRenderedColor = tonemapACES((1.0 - reflectionHitDiffused) * reflSky + reflectedColor +\nreflSea * seaColorMod + specular + foam);`)) : v.code.add(d`vec3 waterRenderedColor = tonemapACES(reflSky + reflSea * waterSeaColorMod + specular + foam);`), m.hasCloudsReflections ? m.hasScreenSpaceReflections ? v.code.add(d`return waterRenderedColor * (1.0 - (1.0 - reflectionHit) * cloudsColor.a) + (1.0 - reflectionHit) * cloudsColor.xyz;\n}`) : v.code.add(d`return waterRenderedColor * (1.0 - cloudsColor.a) + cloudsColor.xyz;\n}`) : v.code.add(d`return waterRenderedColor;\n}`);\n}\nexport { f as Water };"],
  "mappings": "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",
  "names": ["o", "d", "n", "c", "e", "o", "f", "e", "v", "o"]
}
