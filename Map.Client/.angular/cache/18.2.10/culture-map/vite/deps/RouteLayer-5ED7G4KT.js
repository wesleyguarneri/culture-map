import {
  a as a2
} from "./chunk-OBYSRKB3.js";
import {
  O as O2,
  c,
  d as d4,
  f as f6,
  u as u2
} from "./chunk-TWSPJWO4.js";
import "./chunk-K2S5NWH3.js";
import {
  C,
  S as S4,
  T,
  c as c2,
  c2 as c3,
  j as j3,
  y as y4
} from "./chunk-HKVW65MQ.js";
import {
  n as n3,
  o as o5,
  w as w2
} from "./chunk-YPQWCITS.js";
import {
  P
} from "./chunk-4AU62DQA.js";
import {
  R
} from "./chunk-Z3GMSC63.js";
import "./chunk-F35MWZH7.js";
import "./chunk-ED7UGR2X.js";
import {
  f as f5
} from "./chunk-YA5CTHMT.js";
import {
  o as o4
} from "./chunk-YFOAET4H.js";
import "./chunk-5U4TBXYS.js";
import "./chunk-6WG22V46.js";
import "./chunk-OOGIXDXG.js";
import "./chunk-HCFDI7IX.js";
import "./chunk-AQJS6F3O.js";
import "./chunk-WUB6LJVL.js";
import "./chunk-QXSES7JX.js";
import {
  d as d3
} from "./chunk-UFVMJL32.js";
import "./chunk-2SMFPIRI.js";
import "./chunk-ZR5BOILP.js";
import "./chunk-QCBC3RJX.js";
import "./chunk-63QCTVYB.js";
import "./chunk-U74WRHVJ.js";
import "./chunk-TCPN7AEH.js";
import "./chunk-PFMGJTQM.js";
import "./chunk-Q7SRMLJZ.js";
import "./chunk-PQ4T66BG.js";
import "./chunk-SWPHGZYB.js";
import "./chunk-DWASPXVI.js";
import "./chunk-TNWXOQKO.js";
import "./chunk-MAO5BVLA.js";
import "./chunk-T2S5VXNP.js";
import "./chunk-4U5GUJRA.js";
import "./chunk-7KRERHHR.js";
import "./chunk-T4AP6CTC.js";
import {
  d as d2
} from "./chunk-HD65DNIO.js";
import {
  k as k2
} from "./chunk-4KWLMXIA.js";
import "./chunk-BIUXKPKA.js";
import "./chunk-N6TJI25E.js";
import {
  D,
  L,
  k2 as k
} from "./chunk-634JLXD4.js";
import "./chunk-Y3EDGYWG.js";
import "./chunk-UF6JOUSJ.js";
import "./chunk-T5JGQSO3.js";
import "./chunk-CIW3KHOW.js";
import "./chunk-J55F4AC2.js";
import {
  S as S3
} from "./chunk-IQLBZKUD.js";
import {
  y as y3
} from "./chunk-7MZZCQ64.js";
import "./chunk-JOJZ6YC5.js";
import "./chunk-L4TOCXR5.js";
import "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import {
  i
} from "./chunk-XLPKC3OB.js";
import "./chunk-HEWCRCJC.js";
import {
  j as j2
} from "./chunk-SJX5DIA7.js";
import "./chunk-6A7CWJED.js";
import {
  f as f3
} from "./chunk-LFKEQKEA.js";
import {
  K,
  N
} from "./chunk-DUTZNK67.js";
import "./chunk-IN6BQCWS.js";
import {
  y as y2
} from "./chunk-CRNUMTSV.js";
import "./chunk-JM7HAEY6.js";
import {
  l
} from "./chunk-OUKUASAF.js";
import "./chunk-V5RMUGJJ.js";
import "./chunk-D2NB6D6N.js";
import {
  t
} from "./chunk-UWJIHV6Q.js";
import {
  b as b2
} from "./chunk-ZUSCOMQM.js";
import "./chunk-DSEUCBVP.js";
import "./chunk-UPDWQH75.js";
import {
  S as S2
} from "./chunk-RXWBJSJ5.js";
import {
  f as f4
} from "./chunk-M2NS3MSU.js";
import "./chunk-HMNBB7ED.js";
import "./chunk-3RRMLFFN.js";
import "./chunk-DR5TVNEL.js";
import "./chunk-HT2T6PUB.js";
import "./chunk-K64AAM77.js";
import "./chunk-6EUVKE22.js";
import "./chunk-A3NNJ7XA.js";
import "./chunk-OKJHJ3CY.js";
import "./chunk-XTVPEVHA.js";
import "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import {
  d
} from "./chunk-DZALMCYL.js";
import "./chunk-K226GFDN.js";
import {
  o as o3
} from "./chunk-4ZZRP4MA.js";
import "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-EODIWR2E.js";
import "./chunk-LLDOZWVV.js";
import {
  S
} from "./chunk-FYAEQPUY.js";
import {
  C as C2
} from "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-7RMVJCDW.js";
import {
  m2 as m,
  u
} from "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import {
  w
} from "./chunk-NYQ5CYNR.js";
import {
  _
} from "./chunk-O7UDKFOW.js";
import {
  f as f2
} from "./chunk-TKPMIAIW.js";
import {
  o as o2
} from "./chunk-NQOJNTB3.js";
import {
  r
} from "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import "./chunk-AXVPJBVW.js";
import "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import {
  g2 as g,
  j
} from "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import {
  n as n2
} from "./chunk-V5C6HSAM.js";
import {
  I,
  U
} from "./chunk-SYATLP3H.js";
import {
  f
} from "./chunk-V6AMQYXE.js";
import {
  v
} from "./chunk-6WHTZNUH.js";
import {
  V
} from "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import "./chunk-XNUH25NY.js";
import "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e as e2
} from "./chunk-4Z5SGKRM.js";
import "./chunk-ANKOCGE2.js";
import {
  o,
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3 as a
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import {
  b
} from "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  e,
  n2 as n,
  s,
  s2
} from "./chunk-WYIDUUN2.js";
import {
  O
} from "./chunk-DXLOWWK7.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/layers/support/RouteStopSymbols.js
var p = class extends f {
  constructor(o6) {
    super(o6), this.break = new y3({
      color: [255, 255, 255],
      size: 12,
      outline: {
        color: [0, 122, 194],
        width: 3
      }
    }), this.first = new y3({
      color: [0, 255, 0],
      size: 20,
      outline: {
        color: [255, 255, 255],
        width: 4
      }
    }), this.unlocated = new y3({
      color: [255, 0, 0],
      size: 12,
      outline: {
        color: [255, 255, 255],
        width: 3
      }
    }), this.last = new y3({
      color: [255, 0, 0],
      size: 20,
      outline: {
        color: [255, 255, 255],
        width: 4
      }
    }), this.middle = new y3({
      color: [51, 51, 51],
      size: 12,
      outline: {
        color: [0, 122, 194],
        width: 3
      }
    }), this.waypoint = new y3({
      color: [255, 255, 255],
      size: 12,
      outline: {
        color: [0, 122, 194],
        width: 3
      }
    });
  }
};
e2([y({
  types: D
})], p.prototype, "break", void 0), e2([y({
  types: D
})], p.prototype, "first", void 0), e2([y({
  types: D
})], p.prototype, "unlocated", void 0), e2([y({
  types: D
})], p.prototype, "last", void 0), e2([y({
  types: D
})], p.prototype, "middle", void 0), e2([y({
  types: D
})], p.prototype, "waypoint", void 0), p = e2([a("esri.layers.support.RouteStopSymbols")], p);
var l2 = p;

// ../../../node_modules/@arcgis/core/layers/support/RouteSymbols.js
var y5 = class extends f {
  constructor(o6) {
    super(o6), this.directionLines = new d({
      color: [0, 122, 194],
      width: 6
    }), this.directionPoints = new y3({
      color: [255, 255, 255],
      size: 6,
      outline: {
        color: [0, 122, 194],
        width: 2
      }
    }), this.pointBarriers = new y3({
      style: "x",
      size: 10,
      outline: {
        color: [255, 0, 0],
        width: 3
      }
    }), this.polygonBarriers = new S3({
      color: [255, 170, 0, 0.6],
      outline: {
        width: 7.5,
        color: [255, 0, 0, 0.6]
      }
    }), this.polylineBarriers = new d({
      width: 7.5,
      color: [255, 85, 0, 0.7]
    }), this.routeInfo = new d({
      width: 8,
      color: [20, 89, 127]
    }), this.stops = new l2();
  }
};
e2([y({
  types: L
})], y5.prototype, "directionLines", void 0), e2([y({
  types: D
})], y5.prototype, "directionPoints", void 0), e2([y({
  types: D
})], y5.prototype, "pointBarriers", void 0), e2([y({
  types: k
})], y5.prototype, "polygonBarriers", void 0), e2([y({
  types: L
})], y5.prototype, "polylineBarriers", void 0), e2([y({
  types: L
})], y5.prototype, "routeInfo", void 0), e2([y({
  type: l2
})], y5.prototype, "stops", void 0), y5 = e2([a("esri.layers.support.RouteSymbols")], y5);
var d5 = y5;

// ../../../node_modules/@arcgis/core/rest/support/NAMessage.js
var p2 = new n2({
  0: "informative",
  1: "process-definition",
  2: "process-start",
  3: "process-stop",
  50: "warning",
  100: "error",
  101: "empty",
  200: "abort"
});
var c4 = class extends a2 {
  constructor(r2) {
    super(r2), this.type = null;
  }
};
e2([y({
  type: String,
  json: {
    read: p2.read,
    write: p2.write
  }
})], c4.prototype, "type", void 0), c4 = e2([a("esri.rest.support.NAMessage")], c4);
var i2 = c4;

// ../../../node_modules/@arcgis/core/rest/support/DirectionsString.js
var c5 = class extends f {
  constructor(r2) {
    super(r2);
  }
};
e2([y({
  json: {
    read: {
      source: "string"
    }
  }
})], c5.prototype, "text", void 0), e2([o3(P, {
  name: "stringType"
})], c5.prototype, "type", void 0), c5 = e2([a("esri.rest.support.DirectionsString")], c5);
var i3 = c5;

// ../../../node_modules/@arcgis/core/rest/support/DirectionsEvent.js
var a3 = class extends f {
  constructor(r2) {
    super(r2), this.arriveTime = null, this.arriveTimeOffset = null, this.geometry = null, this.strings = null;
  }
  readArriveTimeOffset(r2, e3) {
    return n3(e3.ETA, e3.arriveTimeUTC);
  }
  readGeometry(r2, e3) {
    return _.fromJSON(e3.point);
  }
};
e2([y({
  type: Date,
  json: {
    read: {
      source: "arriveTimeUTC"
    }
  }
})], a3.prototype, "arriveTime", void 0), e2([y()], a3.prototype, "arriveTimeOffset", void 0), e2([o2("arriveTimeOffset", ["arriveTimeUTC", "ETA"])], a3.prototype, "readArriveTimeOffset", null), e2([y({
  type: _
})], a3.prototype, "geometry", void 0), e2([o2("geometry", ["point"])], a3.prototype, "readGeometry", null), e2([y({
  type: [i3]
})], a3.prototype, "strings", void 0), a3 = e2([a("esri.rest.support.DirectionsEvent")], a3);
var c6 = a3;

// ../../../node_modules/@arcgis/core/rest/support/DirectionsFeature.js
function c7(r2) {
  if (null == r2 || "" === r2) return null;
  let e3 = 0, t2 = 0, s3 = 0, o6 = 0;
  const p3 = [];
  let n5, i4, c10, a5, m6, l4, u6, f7, d6 = 0, y7 = 0, h = 0;
  if (m6 = r2.match(/((\+|-)[^+\-|]+|\|)/g), m6 || (m6 = []), 0 === parseInt(m6[d6], 32)) {
    d6 = 2;
    const r3 = parseInt(m6[d6], 32);
    d6++, l4 = parseInt(m6[d6], 32), d6++, 1 & r3 && (y7 = m6.indexOf("|") + 1, u6 = parseInt(m6[y7], 32), y7++), 2 & r3 && (h = m6.indexOf("|", y7) + 1, f7 = parseInt(m6[h], 32), h++);
  } else l4 = parseInt(m6[d6], 32), d6++;
  for (; d6 < m6.length && "|" !== m6[d6]; ) {
    n5 = parseInt(m6[d6], 32) + e3, d6++, e3 = n5, i4 = parseInt(m6[d6], 32) + t2, d6++, t2 = i4;
    const r3 = [n5 / l4, i4 / l4];
    y7 && (a5 = parseInt(m6[y7], 32) + s3, y7++, s3 = a5, r3.push(a5 / u6)), h && (c10 = parseInt(m6[h], 32) + o6, h++, o6 = c10, r3.push(c10 / f7)), p3.push(r3);
  }
  return {
    paths: [p3],
    hasZ: y7 > 0,
    hasM: h > 0
  };
}
var a4 = class extends d2 {
  constructor(r2) {
    super(r2), this.events = null, this.strings = null;
  }
  readGeometry(r2, e3) {
    const t2 = c7(e3.compressedGeometry);
    return null != t2 ? m.fromJSON(t2) : null;
  }
};
e2([y({
  type: [c6]
})], a4.prototype, "events", void 0), e2([o2("geometry", ["compressedGeometry"])], a4.prototype, "readGeometry", null), e2([y({
  type: [i3]
})], a4.prototype, "strings", void 0), a4 = e2([a("esri.rest.support.DirectionsFeature")], a4);
var m2 = a4;

// ../../../node_modules/@arcgis/core/rest/support/DirectionsFeatureSet.js
function m3(e3, t2) {
  if (0 === e3.length) return new m({
    spatialReference: t2
  });
  const r2 = [];
  for (const n5 of e3) for (const e4 of n5.paths) r2.push(...e4);
  const o6 = [];
  r2.forEach((e4, t3) => {
    0 !== t3 && e4[0] === r2[t3 - 1][0] && e4[1] === r2[t3 - 1][1] || o6.push(e4);
  });
  const {
    hasM: s3,
    hasZ: a5
  } = e3[0];
  return new m({
    hasM: s3,
    hasZ: a5,
    paths: [o6],
    spatialReference: t2
  });
}
var u3 = class extends d3 {
  constructor(e3) {
    super(e3), this.extent = null, this.features = [], this.geometryType = "polyline", this.routeId = null, this.routeName = null, this.totalDriveTime = null, this.totalLength = null, this.totalTime = null;
  }
  readFeatures(e3, t2) {
    if (!e3) return [];
    const r2 = t2.summary.envelope.spatialReference ?? t2.spatialReference, o6 = r2 && f2.fromJSON(r2);
    return e3.map((e4) => {
      const t3 = m2.fromJSON(e4);
      if (null != t3.geometry && (t3.geometry.spatialReference = o6), null != t3.events) for (const r3 of t3.events) null != r3.geometry && (r3.geometry.spatialReference = o6);
      return t3;
    });
  }
  get mergedGeometry() {
    if (!this.features) return null;
    return m3(this.features.map(({
      geometry: e3
    }) => e3), this.extent.spatialReference);
  }
  get strings() {
    return this.features.flatMap(({
      strings: e3
    }) => e3).filter(O);
  }
};
e2([y({
  type: w,
  json: {
    read: {
      source: "summary.envelope"
    }
  }
})], u3.prototype, "extent", void 0), e2([y({
  nonNullable: true
})], u3.prototype, "features", void 0), e2([o2("features")], u3.prototype, "readFeatures", null), e2([y()], u3.prototype, "geometryType", void 0), e2([y({
  readOnly: true
})], u3.prototype, "mergedGeometry", null), e2([y()], u3.prototype, "routeId", void 0), e2([y()], u3.prototype, "routeName", void 0), e2([y({
  value: null,
  readOnly: true
})], u3.prototype, "strings", null), e2([y({
  json: {
    read: {
      source: "summary.totalDriveTime"
    }
  }
})], u3.prototype, "totalDriveTime", void 0), e2([y({
  json: {
    read: {
      source: "summary.totalLength"
    }
  }
})], u3.prototype, "totalLength", void 0), e2([y({
  json: {
    read: {
      source: "summary.totalTime"
    }
  }
})], u3.prototype, "totalTime", void 0), u3 = e2([a("esri.rest.support.DirectionsFeatureSet")], u3);
var c8 = u3;

// ../../../node_modules/@arcgis/core/rest/support/RouteResult.js
var n4 = class extends f {
  constructor(t2) {
    super(t2), this.directionLines = null, this.directionPoints = null, this.directions = null, this.route = null, this.routeName = null, this.stops = null, this.traversedEdges = null, this.traversedJunctions = null, this.traversedTurns = null;
  }
};
e2([y({
  type: d3,
  json: {
    write: true
  }
})], n4.prototype, "directionLines", void 0), e2([y({
  type: d3,
  json: {
    write: true
  }
})], n4.prototype, "directionPoints", void 0), e2([y({
  type: c8,
  json: {
    write: true
  }
})], n4.prototype, "directions", void 0), e2([y({
  type: d2,
  json: {
    write: true
  }
})], n4.prototype, "route", void 0), e2([y({
  type: String,
  json: {
    write: true
  }
})], n4.prototype, "routeName", void 0), e2([y({
  type: [d2],
  json: {
    write: true
  }
})], n4.prototype, "stops", void 0), e2([y({
  type: d3,
  json: {
    write: true
  }
})], n4.prototype, "traversedEdges", void 0), e2([y({
  type: d3,
  json: {
    write: true
  }
})], n4.prototype, "traversedJunctions", void 0), e2([y({
  type: d3,
  json: {
    write: true
  }
})], n4.prototype, "traversedTurns", void 0), n4 = e2([a("esri.rest.support.RouteResult")], n4);
var u4 = n4;

// ../../../node_modules/@arcgis/core/rest/support/RouteSolveResult.js
function u5(r2) {
  return r2 ? d3.fromJSON(r2).features.filter(O) : [];
}
var m4 = class extends f {
  constructor(r2) {
    super(r2), this.messages = null, this.pointBarriers = null, this.polylineBarriers = null, this.polygonBarriers = null, this.routeResults = null;
  }
  readPointBarriers(r2, o6) {
    return u5(o6.barriers);
  }
  readPolylineBarriers(r2) {
    return u5(r2);
  }
  readPolygonBarriers(r2) {
    return u5(r2);
  }
};
e2([y({
  type: [i2]
})], m4.prototype, "messages", void 0), e2([y({
  type: [d2]
})], m4.prototype, "pointBarriers", void 0), e2([o2("pointBarriers", ["barriers"])], m4.prototype, "readPointBarriers", null), e2([y({
  type: [d2]
})], m4.prototype, "polylineBarriers", void 0), e2([o2("polylineBarriers")], m4.prototype, "readPolylineBarriers", null), e2([y({
  type: [d2]
})], m4.prototype, "polygonBarriers", void 0), e2([o2("polygonBarriers")], m4.prototype, "readPolygonBarriers", null), e2([y({
  type: [u4]
})], m4.prototype, "routeResults", void 0), m4 = e2([a("esri.rest.support.RouteSolveResult")], m4);
var y6 = m4;

// ../../../node_modules/@arcgis/core/rest/route.js
function c9(e3) {
  return e3 instanceof d3;
}
function l3(f7, p3, l4) {
  return __async(this, null, function* () {
    const y7 = [], d6 = [], g2 = {}, h = {}, R2 = f5(f7), {
      path: v2
    } = R2;
    c9(p3.stops) && u2(p3.stops.features, d6, "stops.features", g2), c9(p3.pointBarriers) && u2(p3.pointBarriers.features, d6, "pointBarriers.features", g2), c9(p3.polylineBarriers) && u2(p3.polylineBarriers.features, d6, "polylineBarriers.features", g2), c9(p3.polygonBarriers) && u2(p3.polygonBarriers.features, d6, "polygonBarriers.features", g2);
    const B = yield R(d6);
    for (const e3 in g2) {
      const r2 = g2[e3];
      y7.push(e3), h[e3] = B.slice(r2[0], r2[1]);
    }
    if (c(h, y7)) {
      let e3 = null;
      try {
        e3 = yield d4(v2, p3.apiKey, l4);
      } catch {
      }
      e3 && !e3.hasZ && f6(h, y7);
    }
    for (const e3 in h) h[e3].forEach((t2, s3) => {
      o(p3, e3)[s3].geometry = t2;
    });
    const E = __spreadProps(__spreadValues({}, l4), {
      query: __spreadProps(__spreadValues(__spreadValues({}, R2.query), o5(p3)), {
        f: "json"
      })
    }), T2 = v2.endsWith("/solve") ? v2 : `${v2}/solve`, {
      data: b3
    } = yield U(T2, E);
    return m5(b3);
  });
}
function m5(e3) {
  const {
    barriers: r2,
    directionLines: t2,
    directionPoints: s3,
    directions: o6,
    messages: a5,
    polygonBarriers: i4,
    polylineBarriers: n5,
    routes: u6,
    stops: f7,
    traversedEdges: c10,
    traversedJunctions: l4,
    traversedTurns: m6
  } = e3, y7 = (e4) => {
    const r3 = g2.find((r4) => r4.routeName === e4);
    if (null != r3) return r3;
    const t3 = {
      routeId: g2.length + 1,
      routeName: e4
    };
    return g2.push(t3), t3;
  }, d6 = (e4) => {
    const r3 = g2.find((r4) => r4.routeId === e4);
    if (null != r3) return r3;
    const t3 = {
      routeId: e4,
      routeName: null
    };
    return g2.push(t3), t3;
  }, g2 = [];
  u6?.features.forEach((e4, r3) => {
    e4.geometry.spatialReference = u6.spatialReference ?? void 0;
    const t3 = e4.attributes.Name, s4 = r3 + 1;
    g2.push({
      routeId: s4,
      routeName: t3,
      route: e4
    });
  }), o6?.forEach((e4) => {
    const {
      routeName: r3
    } = e4;
    y7(r3).directions = e4;
  });
  const h = (f7?.features.every((e4) => null == e4.attributes.RouteName) ?? false) && g2.length > 0 ? g2[0].routeName : null;
  return f7?.features.forEach((e4) => {
    e4.geometry && (e4.geometry.spatialReference ??= f7.spatialReference ?? void 0);
    const r3 = h ?? e4.attributes.RouteName, t3 = y7(r3);
    t3.stops ??= [], t3.stops.push(e4);
  }), t2?.features.forEach((e4) => {
    const r3 = e4.attributes.RouteID, s4 = d6(r3), {
      geometryType: o7,
      spatialReference: a6
    } = t2;
    s4.directionLines ??= {
      features: [],
      geometryType: o7,
      spatialReference: a6
    }, s4.directionLines.features.push(e4);
  }), s3?.features.forEach((e4) => {
    const r3 = e4.attributes.RouteID, t3 = d6(r3), {
      geometryType: o7,
      spatialReference: a6
    } = s3;
    t3.directionPoints ??= {
      features: [],
      geometryType: o7,
      spatialReference: a6
    }, t3.directionPoints.features.push(e4);
  }), c10?.features.forEach((e4) => {
    const r3 = e4.attributes.RouteID, t3 = d6(r3), {
      geometryType: s4,
      spatialReference: o7
    } = c10;
    t3.traversedEdges ??= {
      features: [],
      geometryType: s4,
      spatialReference: o7
    }, t3.traversedEdges.features.push(e4);
  }), l4?.features.forEach((e4) => {
    const r3 = e4.attributes.RouteID, t3 = d6(r3), {
      geometryType: s4,
      spatialReference: o7
    } = l4;
    t3.traversedJunctions ??= {
      features: [],
      geometryType: s4,
      spatialReference: o7
    }, t3.traversedJunctions.features.push(e4);
  }), m6?.features.forEach((e4) => {
    const r3 = e4.attributes.RouteID, t3 = d6(r3);
    t3.traversedTurns ??= {
      features: []
    }, t3.traversedTurns.features.push(e4);
  }), y6.fromJSON({
    routeResults: g2,
    barriers: r2,
    polygonBarriers: i4,
    polylineBarriers: n5,
    messages: a5
  });
}

// ../../../node_modules/@arcgis/core/layers/RouteLayer.js
function z(e3) {
  return e3.length ? e3 : null;
}
function H(e3) {
  switch (e3) {
    case "esriGeometryPoint":
      return {
        type: "esriSMS",
        style: "esriSMSCircle",
        size: 12,
        color: [0, 0, 0, 0],
        outline: H("esriGeometryPolyline")
      };
    case "esriGeometryPolyline":
      return {
        type: "esriSLS",
        style: "esriSLSSolid",
        width: 1,
        color: [0, 0, 0, 0]
      };
    case "esriGeometryPolygon":
      return {
        type: "esriSFS",
        style: "esriSFSNull",
        outline: H("esriGeometryPolyline")
      };
  }
}
function K2(e3) {
  return "layers" in e3;
}
function Q(e3) {
  return "esri.rest.support.FeatureSet" === e3.declaredClass;
}
function Y(e3) {
  return "esri.rest.support.NetworkFeatureSet" === e3.declaredClass;
}
function Z(e3, t2, r2) {
  const o6 = t2.networkDataset?.networkAttributes, i4 = o6?.filter(({
    usageType: e4
  }) => "cost" === e4) ?? [], s3 = r2.travelMode ?? t2.defaultTravelMode;
  if (null == s3) return void ue().warn("route-layer:missing-travel-mode", "The routing service must have a default travel mode or one must be specified in the route parameter.");
  const {
    timeAttributeName: n5,
    distanceAttributeName: a5
  } = s3, u6 = i4.find(({
    name: e4
  }) => e4 === n5), p3 = i4.find(({
    name: e4
  }) => e4 === a5), c10 = r2.travelMode?.impedanceAttributeName ?? r2.impedanceAttribute ?? t2.impedance, m6 = u6?.units, y7 = p3?.units;
  if (!m6 || !y7) throw new s2("routelayer:unknown-impedance-units", "the units of either the distance or time impedance are unknown");
  const f7 = r2.directionsLanguage ?? t2.directionsLanguage, d6 = r2.accumulateAttributes ?? t2.accumulateAttributeNames ?? [], h = new Set(i4.filter(({
    name: e4
  }) => e4 === n5 || e4 === a5 || e4 === c10 || null != e4 && d6.includes(e4)).map(({
    name: e4
  }) => e4)), w3 = (e4) => {
    for (const t3 in e4) h.has(t3) || delete e4[t3];
  };
  for (const l4 of e3.pointBarriers) null != l4.costs && (l4.addedCost = l4.costs[c10] ?? 0, w3(l4.costs));
  for (const l4 of e3.polygonBarriers) null != l4.costs && (l4.scaleFactor = l4.costs[c10] ?? 1, w3(l4.costs));
  for (const l4 of e3.polylineBarriers) null != l4.costs && (l4.scaleFactor = l4.costs[c10] ?? 1, w3(l4.costs));
  const {
    routeInfo: S5
  } = e3, {
    findBestSequence: g2,
    preserveFirstStop: b3,
    preserveLastStop: v2,
    startTimeIsUTC: B,
    timeWindowsAreUTC: P2
  } = r2;
  S5.analysisSettings = new c3({
    accumulateAttributes: d6,
    directionsLanguage: f7,
    findBestSequence: g2,
    preserveFirstStop: b3,
    preserveLastStop: v2,
    startTimeIsUTC: B,
    timeWindowsAreUTC: P2,
    travelMode: s3
  }), S5.totalDuration = X(S5.totalCosts?.[n5] ?? 0, m6), S5.totalDistance = ee(S5.totalCosts?.[a5] ?? 0, y7), S5.totalLateDuration = X(S5.totalViolations?.[n5] ?? 0, m6), S5.totalWaitDuration = X(S5.totalWait?.[n5] ?? 0, m6), null != S5.totalCosts && w3(S5.totalCosts), null != S5.totalViolations && w3(S5.totalViolations), null != S5.totalWait && w3(S5.totalWait);
  for (const l4 of e3.stops) null != l4.serviceCosts && (l4.serviceDuration = X(l4.serviceCosts[n5] ?? 0, m6), l4.serviceDistance = ee(l4.serviceCosts[a5] ?? 0, y7), w3(l4.serviceCosts)), null != l4.cumulativeCosts && (l4.cumulativeDuration = X(l4.cumulativeCosts[n5] ?? 0, m6), l4.cumulativeDistance = ee(l4.cumulativeCosts[a5] ?? 0, y7), w3(l4.cumulativeCosts)), null != l4.violations && (l4.lateDuration = X(l4.violations[n5] ?? 0, m6), w3(l4.violations)), null != l4.wait && (l4.waitDuration = X(l4.wait[n5] ?? 0, m6), w3(l4.wait));
}
function $(e3) {
  return __async(this, null, function* () {
    const t2 = f2.WGS84;
    return yield N(e3.spatialReference, t2), K(e3, t2);
  });
}
function X(e3, t2) {
  switch (t2) {
    case "seconds":
      return e3 / 60;
    case "hours":
      return 60 * e3;
    case "days":
      return 60 * e3 * 24;
    default:
      return e3;
  }
}
function ee(e3, t2) {
  return "decimal-degrees" === t2 || "points" === t2 || "unknown" === t2 ? e3 : j(e3, t2, "meters");
}
function te(e3) {
  const {
    attributes: t2,
    geometry: r2,
    popupTemplate: o6,
    symbol: i4
  } = e3.toGraphic().toJSON();
  return {
    attributes: t2,
    geometry: r2,
    popupInfo: o6,
    symbol: i4
  };
}
var re = V.ofType(c2);
var oe = V.ofType(y4);
var ie = V.ofType(C);
var se = V.ofType(T);
var ne = V.ofType(j3);
var le = V.ofType(w2);
var ae = "esri.layers.RouteLayer";
var ue = () => n.getLogger(ae);
var pe = class extends l(t(b2(j2(S2(f4))))) {
  constructor(e3) {
    super(e3), this._cachedServiceDescription = null, this._featureCollection = null, this._type = "Feature Collection", this.defaultSymbols = new d5(), this.directionLines = null, this.directionPoints = null, this.featureCollectionType = "route", this.legendEnabled = false, this.maxScale = 0, this.minScale = 0, this.pointBarriers = new ie(), this.polygonBarriers = new se(), this.polylineBarriers = new ne(), this.routeInfo = null, this.spatialReference = f2.WGS84, this.stops = new le(), this.type = "route";
    const t2 = () => {
      this._setStopSymbol(this.stops);
    };
    this.addHandles(v(() => this.stops, "change", t2, {
      sync: true,
      onListenerAdd: t2
    }));
  }
  writeFeatureCollectionWebmap(e3, t2, r2, o6) {
    const i4 = [this._writePolygonBarriers(), this._writePolylineBarriers(), this._writePointBarriers(), this._writeRouteInfo(), this._writeDirectionLines(), this._writeDirectionPoints(), this._writeStops()].filter((e4) => !!e4), s3 = i4.map((e4, t3) => t3), n5 = "web-map" === o6.origin ? "featureCollection.layers" : "layers";
    e(n5, i4, t2), t2.opacity = this.opacity, t2.visibility = this.visible, t2.visibleLayers = s3;
  }
  readDirectionLines(e3, t2) {
    return this._getNetworkFeatures(t2, "DirectionLines", (e4) => c2.fromGraphic(e4));
  }
  readDirectionPoints(e3, t2) {
    return this._getNetworkFeatures(t2, "DirectionPoints", (e4) => y4.fromGraphic(e4));
  }
  get fullExtent() {
    const e3 = new w({
      xmin: -180,
      ymin: -90,
      xmax: 180,
      ymax: 90,
      spatialReference: f2.WGS84
    });
    if (null != this.routeInfo?.geometry) return this.routeInfo.geometry.extent ?? e3;
    if (null == this.stops) return e3;
    const t2 = this.stops.filter((e4) => null != e4.geometry);
    if (t2.length < 2) return e3;
    const {
      spatialReference: r2
    } = t2.at(0).geometry;
    if (null == r2) return e3;
    const o6 = t2.toArray().map((e4) => {
      const t3 = e4.geometry;
      return [t3.x, t3.y];
    });
    return new u({
      points: o6,
      spatialReference: r2
    }).extent;
  }
  readMaxScale(e3, t2) {
    const r2 = K2(t2) ? t2.layers : t2.featureCollection?.layers, o6 = r2?.find((e4) => null != e4.layerDefinition.maxScale);
    return o6?.layerDefinition.maxScale ?? 0;
  }
  readMinScale(e3, t2) {
    const r2 = K2(t2) ? t2.layers : t2.featureCollection?.layers, o6 = r2?.find((e4) => null != e4.layerDefinition.minScale);
    return o6?.layerDefinition.minScale ?? 0;
  }
  readPointBarriers(e3, t2) {
    return this._getNetworkFeatures(t2, "Barriers", (e4) => C.fromGraphic(e4));
  }
  readPolygonBarriers(e3, t2) {
    return this._getNetworkFeatures(t2, "PolygonBarriers", (e4) => T.fromGraphic(e4));
  }
  readPolylineBarriers(e3, t2) {
    return this._getNetworkFeatures(t2, "PolylineBarriers", (e4) => j3.fromGraphic(e4));
  }
  readRouteInfo(e3, t2) {
    return this._getNetworkFeatures(t2, "RouteInfo", (e4) => S4.fromGraphic(e4)).at(0) ?? null;
  }
  readSpatialReference(e3, t2) {
    const r2 = K2(t2) ? t2.layers : t2.featureCollection?.layers;
    if (!r2?.length) return f2.WGS84;
    const {
      layerDefinition: o6,
      featureSet: i4
    } = r2[0], s3 = i4.features[0], n5 = s3?.geometry?.spatialReference ?? i4.spatialReference ?? o6.spatialReference ?? o6.extent.spatialReference ?? g;
    return f2.fromJSON(n5);
  }
  readStops(e3, t2) {
    return this._getNetworkFeatures(t2, "Stops", (e4) => w2.fromGraphic(e4), (e4) => this._setStopSymbol(e4));
  }
  get title() {
    return this.routeInfo?.name ?? "Route";
  }
  set title(e3) {
    this._overrideIfSome("title", e3);
  }
  get url() {
    return s.routeServiceUrl;
  }
  set url(e3) {
    null != e3 ? this._set("url", y2(e3, ue())) : this._set("url", s.routeServiceUrl);
  }
  load(e3) {
    return this.addResolvingPromise(this.loadFromPortal({
      supportedTypes: ["Feature Collection"]
    }, e3)), Promise.resolve(this);
  }
  removeAll() {
    this.removeResult(), this.pointBarriers.removeAll(), this.polygonBarriers.removeAll(), this.polylineBarriers.removeAll(), this.stops.removeAll();
  }
  removeResult() {
    null != this.directionLines && (this.directionLines.removeAll(), this._set("directionLines", null)), null != this.directionPoints && (this.directionPoints.removeAll(), this._set("directionPoints", null)), null != this.routeInfo && this._set("routeInfo", null);
  }
  save() {
    return __async(this, null, function* () {
      yield this.load();
      const {
        fullExtent: e3,
        portalItem: t2
      } = this;
      if (!t2) throw new s2("routelayer:portal-item-not-set", "save() requires to the layer to have a portal item");
      if (!t2.id) throw new s2("routelayer:portal-item-not-saved", "Please use saveAs() first to save the routelayer");
      if ("Feature Collection" !== t2.type) throw new s2("routelayer:portal-item-wrong-type", 'Portal item needs to have type "Feature Collection"');
      if (null == this.routeInfo) throw new s2("routelayer:route-unsolved", "save() requires a solved route");
      const {
        portal: r2
      } = t2;
      yield r2.signIn(), r2.user || (yield t2.reload());
      const {
        itemUrl: o6,
        itemControl: i4
      } = t2;
      if ("admin" !== i4 && "update" !== i4) throw new s2("routelayer:insufficient-permissions", "To save this layer, you need to be the owner or an administrator of your organization");
      const s3 = {
        messages: [],
        origin: "portal-item",
        portal: r2,
        url: o6 ? I(o6) : void 0,
        writtenProperties: []
      }, n5 = this.write(void 0, s3);
      return t2.extent = yield $(e3), t2.title = this.title, yield t2.update({
        data: n5
      }), t2;
    });
  }
  saveAs(_0) {
    return __async(this, arguments, function* (e3, t2 = {}) {
      if (yield this.load(), null == this.routeInfo) throw new s2("routelayer:route-unsolved", "saveAs() requires a solved route");
      const r2 = S.from(e3).clone();
      r2.extent ??= yield $(this.fullExtent), r2.id = null, r2.portal ??= C2.getDefault(), r2.title ??= this.title, r2.type = "Feature Collection", r2.typeKeywords = ["Data", "Feature Collection", f3.MULTI_LAYER, "Route Layer"];
      const {
        portal: o6
      } = r2, i4 = {
        messages: [],
        origin: "portal-item",
        portal: o6,
        url: null,
        writtenProperties: []
      };
      yield o6.signIn();
      const s3 = t2?.folder, n5 = this.write(void 0, i4);
      return yield o6.user?.addItem({
        item: r2,
        folder: s3,
        data: n5
      }), this.portalItem = r2, i(i4), i4.portalItem = r2, r2;
    });
  }
  solve(e3, t2) {
    return __async(this, null, function* () {
      const r2 = e3?.stops ?? this.stops, o6 = e3?.pointBarriers ?? z(this.pointBarriers), i4 = e3?.polylineBarriers ?? z(this.polylineBarriers), s3 = e3?.polygonBarriers ?? z(this.polygonBarriers);
      if (null == r2) throw new s2("routelayer:undefined-stops", "the route layer must have stops defined in the route parameters.");
      if ((Q(r2) || Y(r2)) && r2.features.length < 2 || V.isCollection(r2) && r2.length < 2) throw new s2("routelayer:insufficent-stops", "the route layer must have two or more stops to solve a route.");
      if (V.isCollection(r2)) for (const n5 of r2) n5.routeName = null;
      const a5 = e3?.apiKey, u6 = this.url, c10 = yield this._getServiceDescription(u6, a5, t2), m6 = e3?.travelMode ?? c10.defaultTravelMode, y7 = e3?.accumulateAttributes ?? [];
      null != m6 && (y7.push(m6.distanceAttributeName), m6.timeAttributeName && y7.push(m6.timeAttributeName));
      const f7 = {
        accumulateAttributes: y7,
        directionsOutputType: "featuresets",
        ignoreInvalidLocations: true,
        pointBarriers: o6,
        polylineBarriers: i4,
        polygonBarriers: s3,
        preserveFirstStop: true,
        preserveLastStop: true,
        returnBarriers: !!o6,
        returnDirections: true,
        returnPolygonBarriers: !!s3,
        returnPolylineBarriers: !!i4,
        returnRoutes: true,
        returnStops: true,
        stops: r2
      }, d6 = O2.from(e3 ?? {});
      let h;
      d6.set(f7);
      try {
        h = yield l3(u6, d6, t2);
      } catch (S5) {
        throw b(S5) ? S5 : new s2("routelayer:failed-route-request", "the routing request failed", {
          error: S5
        });
      }
      const w3 = this._toRouteLayerSolution(h);
      return this._isOverridden("title") || (this.title = w3.routeInfo.name ?? "Route"), Z(w3, c10, d6), w3;
    });
  }
  update(e3) {
    const {
      stops: t2,
      directionLines: r2,
      directionPoints: o6,
      pointBarriers: i4,
      polylineBarriers: s3,
      polygonBarriers: n5,
      routeInfo: l4
    } = e3;
    this.set({
      stops: t2,
      pointBarriers: i4,
      polylineBarriers: s3,
      polygonBarriers: n5
    }), this._set("directionLines", r2), this._set("directionPoints", o6), this._set("routeInfo", l4), null != l4.geometry && (this.spatialReference = l4.geometry.spatialReference);
  }
  _getNetworkFeatures(e3, t2, s3, l4) {
    const a5 = K2(e3) ? e3.layers : e3.featureCollection?.layers, u6 = a5?.find((e4) => e4.layerDefinition.name === t2);
    if (null == u6) return new V();
    const {
      layerDefinition: p3,
      popupInfo: c10,
      featureSet: m6
    } = u6, y7 = p3.drawingInfo.renderer, {
      features: f7
    } = m6, d6 = m6.spatialReference ?? p3.spatialReference ?? p3.extent.spatialReference ?? g, h = y7 && o4(y7), w3 = f2.fromJSON(d6), S5 = f7.map((e4) => {
      const i4 = d2.fromJSON(e4);
      null != i4.geometry && null != e4.geometry && null == e4.geometry.spatialReference && (i4.geometry.spatialReference = w3);
      const n5 = s3(i4);
      return n5.symbol ??= h?.getSymbol(i4) ?? this._getNetworkSymbol(t2), n5.popupTemplate ??= c10 && k2.fromJSON(c10), n5;
    });
    return l4 && S5.some(({
      symbol: e4
    }) => !e4) && l4(S5), new V(S5);
  }
  _getNetworkSymbol(e3) {
    switch (e3) {
      case "Barriers":
        return this.defaultSymbols.pointBarriers;
      case "DirectionPoints":
        return this.defaultSymbols.directionPoints;
      case "DirectionLines":
        return this.defaultSymbols.directionLines;
      case "PolylineBarriers":
        return this.defaultSymbols.polylineBarriers;
      case "PolygonBarriers":
        return this.defaultSymbols.polygonBarriers;
      case "RouteInfo":
        return this.defaultSymbols.routeInfo;
      case "Stops":
        return null;
    }
  }
  _getServiceDescription(e3, t2, r2) {
    return __async(this, null, function* () {
      if (null != this._cachedServiceDescription && this._cachedServiceDescription.url === e3) return this._cachedServiceDescription.serviceDescription;
      const o6 = yield d4(e3, t2, r2);
      return this._cachedServiceDescription = {
        serviceDescription: o6,
        url: e3
      }, o6;
    });
  }
  _setStopSymbol(e3) {
    if (!e3 || 0 === e3.length) return;
    if (null == this.defaultSymbols.stops) return;
    if (e3.every(({
      symbol: e4
    }) => null != e4)) return;
    const {
      first: t2,
      last: r2,
      middle: o6,
      unlocated: i4,
      waypoint: s3,
      break: n5
    } = this.defaultSymbols.stops;
    if (null == this.routeInfo || 1 === e3.length) return void e3.forEach((i5, s4) => {
      switch (s4) {
        case 0:
          i5.symbol = t2;
          break;
        case e3.length - 1:
          i5.symbol = r2;
          break;
        default:
          i5.symbol = o6;
      }
    });
    const l4 = e3.map(({
      sequence: e4
    }) => e4).filter((e4) => null != e4), a5 = Math.min(...l4), u6 = Math.max(...l4);
    for (const p3 of e3) p3.sequence !== a5 ? p3.sequence !== u6 ? "ok" === p3.status || "not-located-on-closest" === p3.status ? "waypoint" !== p3.locationType ? "break" !== p3.locationType ? p3.symbol = o6 : p3.symbol = n5 : p3.symbol = s3 : p3.symbol = i4 : p3.symbol = r2 : p3.symbol = t2;
  }
  _toRouteLayerSolution(e3) {
    const t2 = e3.routeResults[0].stops?.map((e4) => w2.fromJSON(e4.toJSON()));
    this._setStopSymbol(t2);
    const r2 = new le(t2), o6 = new se(e3.polygonBarriers?.map((e4) => {
      const t3 = T.fromJSON(e4.toJSON());
      return t3.symbol = this.defaultSymbols.polygonBarriers, t3;
    })), i4 = new ne(e3.polylineBarriers?.map((e4) => {
      const t3 = j3.fromJSON(e4.toJSON());
      return t3.symbol = this.defaultSymbols.polylineBarriers, t3;
    })), s3 = new ie(e3.pointBarriers?.map((e4) => {
      const t3 = C.fromJSON(e4.toJSON());
      return t3.symbol = this.defaultSymbols.pointBarriers, t3;
    })), n5 = e3.routeResults[0].route?.toJSON(), l4 = S4.fromJSON(n5);
    l4.symbol = this.defaultSymbols.routeInfo;
    const a5 = new oe(e3.routeResults[0].directionPoints?.features.map((e4) => {
      const t3 = y4.fromJSON(e4.toJSON());
      return t3.symbol = this.defaultSymbols.directionPoints, t3;
    }));
    return {
      directionLines: new re(e3.routeResults[0].directionLines?.features.map((e4) => {
        const t3 = c2.fromJSON(e4.toJSON());
        return t3.symbol = this.defaultSymbols.directionLines, t3;
      })),
      directionPoints: a5,
      pointBarriers: s3,
      polygonBarriers: o6,
      polylineBarriers: i4,
      routeInfo: l4,
      stops: r2
    };
  }
  _writeDirectionLines() {
    return this._writeNetworkFeatures(this.directionLines, this.defaultSymbols.directionLines, "esriGeometryPolyline", c2.fields, "DirectionLines", "Direction Lines");
  }
  _writeDirectionPoints() {
    return this._writeNetworkFeatures(this.directionPoints, this.defaultSymbols.directionPoints, "esriGeometryPoint", y4.fields, "DirectionPoints", "Direction Points");
  }
  _writeNetworkFeatures(e3, t2, r2, o6, i4, s3) {
    if (!e3?.length) return null;
    const n5 = this.spatialReference.toJSON(), {
      fullExtent: l4,
      maxScale: a5,
      minScale: u6
    } = this;
    return {
      featureSet: {
        features: e3.toArray().map((e4) => te(e4)),
        geometryType: r2,
        spatialReference: n5
      },
      layerDefinition: {
        capabilities: "Query,Update,Editing",
        drawingInfo: {
          renderer: {
            type: "simple",
            symbol: null != t2 ? t2.toJSON() : H(r2)
          }
        },
        extent: l4.toJSON(),
        fields: o6,
        geometryType: r2,
        hasM: false,
        hasZ: false,
        maxScale: a5,
        minScale: u6,
        name: i4,
        objectIdField: "ObjectID",
        spatialReference: n5,
        title: s3,
        type: "Feature Layer",
        typeIdField: ""
      }
    };
  }
  _writePointBarriers() {
    return this._writeNetworkFeatures(this.pointBarriers, this.defaultSymbols.pointBarriers, "esriGeometryPoint", C.fields, "Barriers", "Point Barriers");
  }
  _writePolygonBarriers() {
    return this._writeNetworkFeatures(this.polygonBarriers, this.defaultSymbols.polygonBarriers, "esriGeometryPolygon", T.fields, "PolygonBarriers", "Polygon Barriers");
  }
  _writePolylineBarriers() {
    return this._writeNetworkFeatures(this.polylineBarriers, this.defaultSymbols.polylineBarriers, "esriGeometryPolyline", j3.fields, "PolylineBarriers", "Line Barriers");
  }
  _writeRouteInfo() {
    return this._writeNetworkFeatures(null != this.routeInfo ? new V([this.routeInfo]) : null, this.defaultSymbols.routeInfo, "esriGeometryPolyline", S4.fields, "RouteInfo", "Route Details");
  }
  _writeStops() {
    const e3 = this._writeNetworkFeatures(this.stops, null, "esriGeometryPoint", w2.fields, "Stops", "Stops");
    if (null == e3) return null;
    const {
      stops: t2
    } = this.defaultSymbols, r2 = t2?.first?.toJSON(), o6 = t2?.middle?.toJSON(), i4 = t2?.last?.toJSON();
    return e3.layerDefinition.drawingInfo.renderer = {
      type: "uniqueValue",
      field1: "Sequence",
      defaultSymbol: o6,
      uniqueValueInfos: [{
        value: "1",
        symbol: r2,
        label: "First Stop"
      }, {
        value: `${this.stops.length}`,
        symbol: i4,
        label: "Last Stop"
      }]
    }, e3;
  }
};
e2([y({
  readOnly: true,
  json: {
    read: false,
    origins: {
      "portal-item": {
        write: {
          allowNull: true,
          ignoreOrigin: true
        }
      },
      "web-map": {
        write: {
          overridePolicy() {
            return {
              allowNull: true,
              ignoreOrigin: null == this.portalItem
            };
          }
        }
      }
    }
  }
})], pe.prototype, "_featureCollection", void 0), e2([r(["web-map", "portal-item"], "_featureCollection")], pe.prototype, "writeFeatureCollectionWebmap", null), e2([y({
  readOnly: true,
  json: {
    read: false,
    origins: {
      "web-map": {
        write: {
          target: "type",
          overridePolicy() {
            return {
              ignoreOrigin: null != this.portalItem
            };
          }
        }
      }
    }
  }
})], pe.prototype, "_type", void 0), e2([y({
  nonNullable: true,
  type: d5
})], pe.prototype, "defaultSymbols", void 0), e2([y({
  readOnly: true
})], pe.prototype, "directionLines", void 0), e2([o2(["web-map", "portal-item"], "directionLines", ["layers", "featureCollection.layers"])], pe.prototype, "readDirectionLines", null), e2([y({
  readOnly: true
})], pe.prototype, "directionPoints", void 0), e2([o2(["web-map", "portal-item"], "directionPoints", ["layers", "featureCollection.layers"])], pe.prototype, "readDirectionPoints", null), e2([y({
  readOnly: true,
  json: {
    read: false,
    origins: {
      "web-map": {
        write: {
          ignoreOrigin: true
        }
      }
    }
  }
})], pe.prototype, "featureCollectionType", void 0), e2([y({
  readOnly: true
})], pe.prototype, "fullExtent", null), e2([y({
  json: {
    origins: {
      "web-map": {
        name: "featureCollection.showLegend"
      }
    },
    write: true
  }
})], pe.prototype, "legendEnabled", void 0), e2([y({
  type: ["show", "hide"]
})], pe.prototype, "listMode", void 0), e2([y({
  type: Number,
  nonNullable: true,
  json: {
    write: false
  }
})], pe.prototype, "maxScale", void 0), e2([o2(["web-map", "portal-item"], "maxScale", ["layers", "featureCollection.layers"])], pe.prototype, "readMaxScale", null), e2([y({
  type: Number,
  nonNullable: true,
  json: {
    write: false
  }
})], pe.prototype, "minScale", void 0), e2([o2(["web-map", "portal-item"], "minScale", ["layers", "featureCollection.layers"])], pe.prototype, "readMinScale", null), e2([y({
  type: ["ArcGISFeatureLayer"],
  value: "ArcGISFeatureLayer"
})], pe.prototype, "operationalLayerType", void 0), e2([y({
  nonNullable: true,
  type: V.ofType(C)
})], pe.prototype, "pointBarriers", void 0), e2([o2(["web-map", "portal-item"], "pointBarriers", ["layers", "featureCollection.layers"])], pe.prototype, "readPointBarriers", null), e2([y({
  nonNullable: true,
  type: V.ofType(T)
})], pe.prototype, "polygonBarriers", void 0), e2([o2(["web-map", "portal-item"], "polygonBarriers", ["layers", "featureCollection.layers"])], pe.prototype, "readPolygonBarriers", null), e2([y({
  nonNullable: true,
  type: V.ofType(j3)
})], pe.prototype, "polylineBarriers", void 0), e2([o2(["web-map", "portal-item"], "polylineBarriers", ["layers", "featureCollection.layers"])], pe.prototype, "readPolylineBarriers", null), e2([y({
  readOnly: true
})], pe.prototype, "routeInfo", void 0), e2([o2(["web-map", "portal-item"], "routeInfo", ["layers", "featureCollection.layers"])], pe.prototype, "readRouteInfo", null), e2([y({
  type: f2
})], pe.prototype, "spatialReference", void 0), e2([o2(["web-map", "portal-item"], "spatialReference", ["layers", "featureCollection.layers"])], pe.prototype, "readSpatialReference", null), e2([y({
  nonNullable: true,
  type: V.ofType(w2)
})], pe.prototype, "stops", void 0), e2([o2(["web-map", "portal-item"], "stops", ["layers", "featureCollection.layers"])], pe.prototype, "readStops", null), e2([y()], pe.prototype, "title", null), e2([y({
  readOnly: true,
  json: {
    read: false
  }
})], pe.prototype, "type", void 0), e2([y()], pe.prototype, "url", null), pe = e2([a(ae)], pe);
var ce = pe;
export {
  ce as default
};
//# sourceMappingURL=RouteLayer-5ED7G4KT.js.map
