{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/symbols/support/cimSymbolUtils.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport e from \"../../Color.js\";\nimport { toCIMSymbolJSON as t, isCIMMarker as o, isCIMStroke as r, isCIMFill as n, isCIMMarkerStrokePlacement as s, normalizeAlpha as a } from \"../cim/utils.js\";\nfunction i(e) {\n  const s = t(e);\n  if (\"CIMTextSymbol\" === s?.type) return s.height ?? 0;\n  let a = 0;\n  if (s?.symbolLayers) for (const t of s.symbolLayers) o(t) && null != t.size && t.size > a ? a = t.size : r(t) && null != t.width && t.width > a ? a = t.width : n(t);\n  return a;\n}\nfunction c(e, o, r) {\n  if (!e) return;\n  const n = t(e),\n    s = i(e);\n  if (0 === s) return void f(n, o);\n  l(n, o / s, !1, r);\n}\nfunction f(e, t) {\n  if (e) if (\"CIMTextSymbol\" !== e.type) {\n    if (e.symbolLayers) for (const o of e.symbolLayers) switch (o.type) {\n      case \"CIMPictureMarker\":\n      case \"CIMVectorMarker\":\n        o.size = t;\n        break;\n      case \"CIMPictureStroke\":\n      case \"CIMSolidStroke\":\n        o.width = t;\n    }\n  } else e.height = t;\n}\nfunction l(e, t, o, r) {\n  if (e) if (\"CIMTextSymbol\" !== e.type) {\n    if (o && e.effects) for (const o of e.effects) y(o, t);\n    if (e.symbolLayers) for (const o of e.symbolLayers) switch (o.type) {\n      case \"CIMPictureMarker\":\n      case \"CIMVectorMarker\":\n        m(o, t, r);\n        break;\n      case \"CIMPictureStroke\":\n      case \"CIMSolidStroke\":\n        !r?.preserveOutlineWidth && o.width && (o.width *= t);\n        break;\n      case \"CIMPictureFill\":\n        o.height && (o.height *= t), o.offsetX && (o.offsetX *= t), o.offsetY && (o.offsetY *= t);\n        break;\n      case \"CIMHatchFill\":\n        l(o.lineSymbol, t, !0, {\n          ...r,\n          preserveOutlineWidth: !1\n        }), o.offsetX && (o.offsetX *= t), o.offsetY && (o.offsetY *= t), o.separation && (o.separation *= t);\n    }\n  } else null != e.height && (e.height *= t);\n}\nfunction m(e, t, o) {\n  if (e && (e.markerPlacement && M(e.markerPlacement, t), e.offsetX && (e.offsetX *= t), e.offsetY && (e.offsetY *= t), e.anchorPoint && \"Absolute\" === e.anchorPointUnits && (e.anchorPoint = {\n    x: e.anchorPoint.x * t,\n    y: e.anchorPoint.y * t\n  }), e.size = null != e.size ? e.size * t : 0, \"CIMVectorMarker\" === e.type && e.markerGraphics)) for (const r of e.markerGraphics) e.scaleSymbolsProportionally || l(r.symbol, t, !0, o);\n}\nfunction M(e, t) {\n  switch (s(e) && e.offset && (e.offset *= t), e.type) {\n    case \"CIMMarkerPlacementAlongLineRandomSize\":\n    case \"CIMMarkerPlacementAlongLineSameSize\":\n      if (e.customEndingOffset && (e.customEndingOffset *= t), e.offsetAlongLine && (e.offsetAlongLine *= t), e.placementTemplate && e.placementTemplate.length) {\n        const o = e.placementTemplate.map(e => e * t);\n        e.placementTemplate = o;\n      }\n      break;\n    case \"CIMMarkerPlacementAlongLineVariableSize\":\n      if (e.maxRandomOffset && (e.maxRandomOffset *= t), e.placementTemplate && e.placementTemplate.length) {\n        const o = e.placementTemplate.map(e => e * t);\n        e.placementTemplate = o;\n      }\n      break;\n    case \"CIMMarkerPlacementOnLine\":\n      e.startPointOffset && (e.startPointOffset *= t);\n      break;\n    case \"CIMMarkerPlacementAtExtremities\":\n      e.offsetAlongLine && (e.offsetAlongLine *= t);\n      break;\n    case \"CIMMarkerPlacementAtMeasuredUnits\":\n    case \"CIMMarkerPlacementOnVertices\":\n      break;\n    case \"CIMMarkerPlacementAtRatioPositions\":\n      e.beginPosition && (e.beginPosition *= t), e.endPosition && (e.endPosition *= t);\n      break;\n    case \"CIMMarkerPlacementPolygonCenter\":\n      e.offsetX && (e.offsetX *= t), e.offsetY && (e.offsetY *= t);\n      break;\n    case \"CIMMarkerPlacementInsidePolygon\":\n      e.offsetX && (e.offsetX *= t), e.offsetY && (e.offsetY *= t), e.stepX && (e.stepX *= t), e.stepY && (e.stepY *= t);\n  }\n}\nfunction y(e, t) {\n  switch (e.type) {\n    case \"CIMGeometricEffectArrow\":\n    case \"CIMGeometricEffectDonut\":\n      e.width && (e.width *= t);\n      break;\n    case \"CIMGeometricEffectBuffer\":\n      e.size && (e.size *= t);\n      break;\n    case \"CIMGeometricEffectCut\":\n      e.beginCut && (e.beginCut *= t), e.endCut && (e.endCut *= t), e.middleCut && (e.middleCut *= t);\n      break;\n    case \"CIMGeometricEffectDashes\":\n      if (e.customEndingOffset && (e.customEndingOffset *= t), e.offsetAlongLine && (e.offsetAlongLine *= t), e.dashTemplate && e.dashTemplate.length) {\n        const o = e.dashTemplate.map(e => e * t);\n        e.dashTemplate = o;\n      }\n      break;\n    case \"CIMGeometricEffectExtension\":\n    case \"CIMGeometricEffectJog\":\n    case \"CIMGeometricEffectRadial\":\n      e.length && (e.length *= t);\n      break;\n    case \"CIMGeometricEffectMove\":\n      e.offsetX && (e.offsetX *= t), e.offsetY && (e.offsetY *= t);\n      break;\n    case \"CIMGeometricEffectOffset\":\n    case \"CIMGeometricEffectOffsetTangent\":\n      e.offset && (e.offset *= t);\n      break;\n    case \"CIMGeometricEffectRegularPolygon\":\n      e.radius && (e.radius *= t);\n      break;\n    case \"CIMGeometricEffectTaperedPolygon\":\n      e.fromWidth && (e.fromWidth *= t), e.length && (e.length *= t), e.toWidth && (e.toWidth *= t);\n      break;\n    case \"CIMGeometricEffectWave\":\n      e.amplitude && (e.amplitude *= t), e.period && (e.period *= t);\n  }\n}\nfunction C(o) {\n  const r = [];\n  return u(t(o), r), r.length ? new e(a(r[0])) : null;\n}\nfunction u(e, t) {\n  if (!e) return;\n  let n;\n  n = \"CIMTextSymbol\" === e.type ? e.symbol : e;\n  const a = \"CIMPolygonSymbol\" === e.type;\n  if (n?.symbolLayers) for (const i of n.symbolLayers) if (!(i.colorLocked || a && (r(i) || o(i) && i.markerPlacement && s(i.markerPlacement)))) switch (i.type) {\n    case \"CIMPictureMarker\":\n    case \"CIMPictureStroke\":\n    case \"CIMPictureFill\":\n      i.tintColor && b(t, i.tintColor);\n      break;\n    case \"CIMVectorMarker\":\n      i.markerGraphics?.forEach(e => {\n        u(e.symbol, t);\n      });\n      break;\n    case \"CIMSolidStroke\":\n    case \"CIMSolidFill\":\n      b(t, i.color);\n      break;\n    case \"CIMHatchFill\":\n      u(i.lineSymbol, t);\n  }\n}\nfunction b(e, t) {\n  for (const o of e) if (o.join(\".\") === t.join(\".\")) return;\n  e.push(t);\n}\nfunction I(o, r, n) {\n  r instanceof e || (r = new e(r));\n  const s = t(o);\n  s && k(s, r, n);\n}\nfunction k(e, t, a) {\n  if (!e) return;\n  let i;\n  i = \"CIMTextSymbol\" === e.type ? e.symbol : e;\n  const c = \"CIMPolygonSymbol\" === i?.type;\n  if (i?.symbolLayers) for (const f of i.symbolLayers) {\n    if (f.colorLocked) continue;\n    if (c) if (a) {\n      const {\n        layersToColor: e\n      } = a;\n      if ((r(f) || o(f) && f.markerPlacement && s(f.markerPlacement)) && \"fill\" === e || n(f) && \"outline\" === e) continue;\n    } else if (r(f) || o(f) && f.markerPlacement && s(f.markerPlacement)) continue;\n    const e = t.toArray();\n    switch (f.type) {\n      case \"CIMPictureMarker\":\n      case \"CIMPictureStroke\":\n      case \"CIMPictureFill\":\n        f.tintColor = e;\n        break;\n      case \"CIMVectorMarker\":\n        f.markerGraphics?.forEach(e => {\n          k(e.symbol, t, a);\n        });\n        break;\n      case \"CIMSolidStroke\":\n      case \"CIMSolidFill\":\n        f.color = e;\n        break;\n      case \"CIMHatchFill\":\n        k(f.lineSymbol, t, a);\n    }\n  }\n}\nfunction p(e, o = !1) {\n  const r = t(e);\n  if (\"CIMTextSymbol\" === r?.type || \"CIMPointSymbol\" === r?.type) {\n    const e = r.angle;\n    return null != e && o ? 360 - e : e ?? 0;\n  }\n  return 0;\n}\nfunction h(e, r, n = !1) {\n  const s = t(e);\n  if (n && (r = 360 - r), \"CIMTextSymbol\" !== s?.type) {\n    if (\"CIMPointSymbol\" === s?.type && s.symbolLayers) {\n      const e = r - (s.angle || 0);\n      for (const t of s.symbolLayers) if (o(t)) {\n        let o = t.rotation || 0;\n        t.rotateClockwise ? o -= e : o += e, t.rotation = o;\n      }\n      s.angle = r;\n    }\n  } else s.angle = r;\n}\nfunction P(e) {\n  const o = t(e);\n  if (!o) return null;\n  switch (o.type) {\n    case \"CIMPointSymbol\":\n      return \"CIMPointSymbol\";\n    case \"CIMLineSymbol\":\n      return \"CIMLineSymbol\";\n    case \"CIMPolygonSymbol\":\n      return \"CIMPolygonSymbol\";\n    case \"CIMTextSymbol\":\n      return \"CIMTextSymbol\";\n    case \"CIMMeshSymbol\":\n      return \"CIMMeshSymbol\";\n    default:\n      return null;\n  }\n}\nexport { I as applyCIMSymbolColor, h as applyCIMSymbolRotation, C as getCIMSymbolColor, p as getCIMSymbolRotation, i as getCIMSymbolSize, P as getCIMSymbolType, m as scaleCIMMarker, l as scaleCIMSymbol, c as scaleCIMSymbolTo };"],
  "mappings": "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",
  "names": ["o", "y", "m", "M", "e", "C", "u", "b", "f"]
}
