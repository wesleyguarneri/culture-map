import {
  $,
  B as B2,
  L as L2,
  N as N2,
  U as U2,
  a as a5,
  c as c2,
  c2 as c3,
  c3 as c4,
  d as d6,
  f as f6,
  h,
  i as i4,
  j as j5,
  l as l5,
  n as n6,
  p as p5,
  t as t4
} from "./chunk-6562L2GA.js";
import {
  d as d7,
  g as g3,
  m as m2,
  p as p4
} from "./chunk-SBTROJY3.js";
import {
  s as s7,
  s2 as s8
} from "./chunk-TXBBE7ID.js";
import {
  s as s9
} from "./chunk-BB54E5CP.js";
import {
  A as A2,
  B2 as B,
  G,
  L2 as L,
  P,
  d as d4,
  j as j4,
  m,
  n2 as n4,
  n4 as n5
} from "./chunk-2AV27Q4X.js";
import {
  g as g2,
  l3,
  s2 as s6
} from "./chunk-3HU4B6P4.js";
import {
  s as s5
} from "./chunk-5AUX2A3J.js";
import {
  R
} from "./chunk-Z3GMSC63.js";
import {
  f as f5,
  i as i3,
  s as s4
} from "./chunk-YA5CTHMT.js";
import {
  t as t3
} from "./chunk-C3UDKWXD.js";
import {
  l as l2
} from "./chunk-DSMB46HB.js";
import {
  l as l4
} from "./chunk-Z4YAQ5JI.js";
import {
  p as p3
} from "./chunk-S5EXT7FA.js";
import {
  e as e2
} from "./chunk-73Y7XDLH.js";
import {
  b as b2
} from "./chunk-WUB6LJVL.js";
import {
  d as d5
} from "./chunk-UFVMJL32.js";
import {
  b as b3,
  s as s3
} from "./chunk-TRSGUVSM.js";
import {
  y as y3
} from "./chunk-PFMGJTQM.js";
import {
  Z
} from "./chunk-Q7SRMLJZ.js";
import {
  d as d3
} from "./chunk-HD65DNIO.js";
import {
  k as k2
} from "./chunk-4KWLMXIA.js";
import {
  i as i2
} from "./chunk-CIW3KHOW.js";
import {
  A
} from "./chunk-ZZEAVAVX.js";
import {
  j as j3
} from "./chunk-SJX5DIA7.js";
import {
  t as t2
} from "./chunk-YI35FRTC.js";
import {
  f as f4
} from "./chunk-DOK4SACJ.js";
import {
  l
} from "./chunk-OUKUASAF.js";
import {
  t
} from "./chunk-UWJIHV6Q.js";
import {
  b
} from "./chunk-ZUSCOMQM.js";
import {
  p as p2,
  s as s2,
  w as w2,
  y as y4
} from "./chunk-DSEUCBVP.js";
import {
  S
} from "./chunk-RXWBJSJ5.js";
import {
  f as f3
} from "./chunk-M2NS3MSU.js";
import {
  c
} from "./chunk-DR5TVNEL.js";
import {
  n as n3
} from "./chunk-GAW5JHG4.js";
import {
  p,
  y as y2
} from "./chunk-S3IO7V4Q.js";
import {
  o as o2
} from "./chunk-4ZZRP4MA.js";
import {
  j as j2,
  u
} from "./chunk-T6GCUITX.js";
import {
  w
} from "./chunk-NYQ5CYNR.js";
import {
  _
} from "./chunk-O7UDKFOW.js";
import {
  f as f2
} from "./chunk-TKPMIAIW.js";
import {
  o
} from "./chunk-NQOJNTB3.js";
import {
  r
} from "./chunk-MFOQYQFG.js";
import {
  d2,
  fe,
  me,
  oe
} from "./chunk-JJS7PR2U.js";
import {
  n as n2
} from "./chunk-V5C6HSAM.js";
import {
  I,
  U
} from "./chunk-SYATLP3H.js";
import {
  f
} from "./chunk-V6AMQYXE.js";
import {
  d
} from "./chunk-6WHTZNUH.js";
import {
  e
} from "./chunk-4Z5SGKRM.js";
import {
  i
} from "./chunk-ANKOCGE2.js";
import {
  j,
  y
} from "./chunk-7CJXZOFG.js";
import {
  N,
  a as a3,
  a3 as a4,
  g2 as g
} from "./chunk-DDYVXG4F.js";
import {
  a as a2,
  k
} from "./chunk-HJY2YILU.js";
import {
  a,
  n2 as n,
  s2 as s
} from "./chunk-WYIDUUN2.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/layers/support/rasterFunctions/rasterFunctionSchema.js
var e3 = {
  StretchFunction: {
    arguments: {
      ComputeGamma: {
        isDataset: false,
        isPublic: false,
        name: "ComputeGamma",
        type: "RasterFunctionVariable",
        value: false
      },
      DRA: {
        isDataset: false,
        isPublic: false,
        name: "DRA",
        type: "RasterFunctionVariable",
        value: false
      },
      EstimateStatsHistogram: {
        isDataset: false,
        isPublic: false,
        name: "EstimateStatsHistogram",
        type: "RasterFunctionVariable",
        value: false
      },
      Gamma: {
        displayName: "Gamma",
        isDataset: false,
        isPublic: false,
        name: "Gamma",
        type: "RasterFunctionVariable"
      },
      Histograms: {
        isDataset: false,
        isPublic: false,
        name: "Histograms",
        type: "RasterFunctionVariable"
      },
      Max: {
        isDataset: false,
        isPublic: false,
        name: "Max",
        type: "RasterFunctionVariable",
        value: 255
      },
      MaxPercent: {
        isDataset: false,
        isPublic: false,
        name: "MaxPercent",
        type: "RasterFunctionVariable",
        value: 0.5
      },
      Min: {
        isDataset: false,
        isPublic: false,
        name: "Min",
        type: "RasterFunctionVariable",
        value: 0
      },
      MinPercent: {
        isDataset: false,
        isPublic: false,
        name: "MinPercent",
        type: "RasterFunctionVariable",
        value: 0.25
      },
      NumberOfStandardDeviations: {
        isDataset: false,
        isPublic: false,
        name: "NumberOfStandardDeviation",
        type: "RasterFunctionVariable",
        value: 2
      },
      Raster: {
        isDataset: true,
        isPublic: false,
        name: "Raster",
        type: "RasterFunctionVariable"
      },
      SigmoidStrengthLevel: {
        isDataset: false,
        isPublic: false,
        name: "SigmoidStrengthLevel",
        type: "RasterFunctionVariable",
        value: 2
      },
      Statistics: {
        isDataset: false,
        isPublic: false,
        name: "Statistics",
        type: "RasterFunctionVariable"
      },
      StretchType: {
        isDataset: false,
        isPublic: false,
        name: "StretchType",
        type: "RasterFunctionVariable",
        value: 0
      },
      type: "StretchFunctionArguments",
      UseGamma: {
        isDataset: false,
        isPublic: false,
        name: "UseGamma",
        type: "RasterFunctionVariable",
        value: false
      }
    },
    description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.",
    function: {
      description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.",
      name: "Stretch",
      pixelType: "UNKNOWN",
      type: "StretchFunction"
    },
    functionType: 0,
    name: "Stretch",
    thumbnail: ""
  },
  RemapFunction: {
    name: "Remap",
    description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table.",
    function: {
      type: "RemapFunction",
      pixelType: "UNKNOWN",
      name: "Remap",
      description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table."
    },
    arguments: {
      Raster: {
        name: "Raster",
        isPublic: false,
        isDataset: true,
        type: "RasterFunctionVariable"
      },
      UseTable: {
        name: "UseTable",
        isPublic: false,
        isDataset: false,
        value: false,
        type: "RasterFunctionVariable"
      },
      InputRanges: {
        name: "InputRanges",
        isPublic: false,
        isDataset: false,
        type: "RasterFunctionVariable",
        displayName: "Input Ranges"
      },
      OutputValues: {
        name: "OutputValues",
        isPublic: false,
        isDataset: false,
        type: "RasterFunctionVariable",
        displayName: "Output Values"
      },
      NoDataRanges: {
        name: "NoDataRanges",
        isPublic: false,
        isDataset: false,
        type: "RasterFunctionVariable",
        displayName: "NoData Ranges"
      },
      Table: {
        name: "Table",
        isPublic: false,
        isDataset: false,
        type: "RasterFunctionVariable"
      },
      InputField: {
        name: "InputField",
        isPublic: false,
        isDataset: false,
        type: "RasterFunctionVariable"
      },
      OutputField: {
        name: "OutputField",
        isPublic: false,
        isDataset: false,
        type: "RasterFunctionVariable"
      },
      InputMaxField: {
        name: "InputMaxField",
        isPublic: false,
        isDataset: false,
        type: "RasterFunctionVariable"
      },
      RemapTableType: {
        name: "RemapTableType",
        isPublic: false,
        isDataset: false,
        value: 1,
        type: "RasterFunctionVariable"
      },
      AllowUnmatched: {
        name: "AllowUnmatched",
        isPublic: false,
        isDataset: false,
        value: true,
        type: "RasterFunctionVariable"
      },
      type: "RemapFunctionArguments"
    },
    functionType: 0,
    thumbnail: ""
  },
  ColormapFunction: {
    name: "Colormap",
    description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.",
    function: {
      type: "ColormapFunction",
      pixelType: "UNKNOWN",
      name: "Colormap",
      description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp."
    },
    arguments: {
      Raster: {
        name: "Raster",
        isPublic: false,
        isDataset: true,
        type: "RasterFunctionVariable"
      },
      ColorSchemeType: {
        name: "ColorSchemeType",
        isPublic: false,
        isDataset: false,
        value: 1,
        type: "RasterFunctionVariable"
      },
      Colormap: {
        name: "Colormap",
        isPublic: false,
        isDataset: false,
        type: "RasterFunctionVariable"
      },
      ColormapName: {
        name: "ColormapName",
        isPublic: false,
        isDataset: false,
        value: "Gray",
        type: "RasterFunctionVariable"
      },
      ColorRamp: {
        name: "ColorRamp",
        isPublic: false,
        isDataset: false,
        type: "RasterFunctionVariable"
      },
      type: "ColormapFunctionArguments"
    },
    functionType: 0,
    thumbnail: ""
  },
  ShadedReliefFunction: {
    name: "Shaded Relief",
    description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.",
    function: {
      type: "ShadedReliefFunction",
      pixelType: "UNKNOWN",
      name: "Shaded Relief",
      description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image."
    },
    arguments: {
      Raster: {
        name: "Raster",
        isPublic: false,
        isDataset: true,
        type: "RasterFunctionVariable"
      },
      ColorSchemeType: {
        name: "ColorSchemeType",
        isPublic: false,
        isDataset: false,
        value: 1,
        type: "RasterFunctionVariable"
      },
      ColorRamp: {
        name: "ColorRamp",
        isPublic: false,
        isDataset: false,
        type: "RasterFunctionVariable"
      },
      HillshadeType: {
        name: "HillshadeType",
        isPublic: false,
        isDataset: false,
        value: 0,
        type: "RasterFunctionVariable"
      },
      Colormap: {
        name: "Colormap",
        isPublic: false,
        isDataset: false,
        type: "RasterFunctionVariable"
      },
      Azimuth: {
        name: "Azimuth",
        isPublic: false,
        isDataset: false,
        value: 315,
        type: "RasterFunctionVariable"
      },
      Altitude: {
        name: "Altitude",
        isPublic: false,
        isDataset: false,
        value: 45,
        type: "RasterFunctionVariable"
      },
      SlopeType: {
        name: "SlopeType",
        isPublic: false,
        isDataset: false,
        value: 1,
        type: "RasterFunctionVariable"
      },
      ZFactor: {
        name: "ZFactor",
        isPublic: false,
        isDataset: false,
        value: 1,
        type: "RasterFunctionVariable"
      },
      PSPower: {
        name: "PSPower",
        isPublic: false,
        isDataset: false,
        value: 0.664,
        type: "RasterFunctionVariable"
      },
      PSZFactor: {
        name: "PSZFactor",
        isPublic: false,
        isDataset: false,
        value: 0.024,
        type: "RasterFunctionVariable"
      },
      RemoveEdgeEffect: {
        name: "RemoveEdgeEffect",
        isPublic: false,
        isDataset: false,
        value: false,
        type: "RasterFunctionVariable"
      },
      type: "ShadedReliefFunctionArguments"
    },
    functionType: 0,
    thumbnail: ""
  },
  HillshadeFunction: {
    name: "Hillshade",
    description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image",
    function: {
      type: "HillshadeFunction",
      pixelType: "UNKNOWN",
      name: "Hillshade",
      description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image"
    },
    arguments: {
      DEM: {
        name: "DEM",
        isPublic: false,
        isDataset: true,
        type: "RasterFunctionVariable"
      },
      HillshadeType: {
        name: "HillshadeType",
        isPublic: false,
        isDataset: false,
        value: 0,
        type: "RasterFunctionVariable"
      },
      Azimuth: {
        name: "Azimuth",
        isPublic: false,
        isDataset: false,
        value: 315,
        type: "RasterFunctionVariable"
      },
      Altitude: {
        name: "Altitude",
        isPublic: false,
        isDataset: false,
        value: 45,
        type: "RasterFunctionVariable"
      },
      SlopeType: {
        name: "SlopeType",
        isPublic: false,
        isDataset: false,
        value: 1,
        type: "RasterFunctionVariable"
      },
      ZFactor: {
        name: "ZFactor",
        isPublic: false,
        isDataset: false,
        value: 1,
        type: "RasterFunctionVariable"
      },
      PSPower: {
        name: "PSPower",
        isPublic: false,
        isDataset: false,
        value: 0.664,
        type: "RasterFunctionVariable"
      },
      PSZFactor: {
        name: "PSZFactor",
        isPublic: false,
        isDataset: false,
        value: 0.024,
        type: "RasterFunctionVariable"
      },
      RemoveEdgeEffect: {
        name: "RemoveEdgeEffect",
        isPublic: false,
        isDataset: false,
        value: false,
        type: "RasterFunctionVariable"
      },
      type: "HillshadeFunctionArguments"
    },
    functionType: 0,
    thumbnail: ""
  },
  ResampleFunction: {
    name: "Resample",
    description: "Changes the cell size of a raster.",
    function: {
      type: "ResampleFunction",
      pixelType: "UNKNOWN",
      name: "Resample",
      description: "Changes the cell size of a raster."
    },
    arguments: {
      Raster: {
        name: "Raster",
        isPublic: false,
        isDataset: true,
        type: "RasterFunctionVariable"
      },
      ResamplingType: {
        name: "ResamplingType",
        isPublic: false,
        isDataset: false,
        value: 0,
        type: "RasterFunctionVariable"
      },
      InputCellSize: {
        name: "InputCellsize",
        isPublic: false,
        isDataset: false,
        value: {
          x: 0,
          y: 0
        },
        type: "RasterFunctionVariable"
      },
      OutputCellSize: {
        name: "OutputCellsize",
        isPublic: false,
        isDataset: false,
        value: {
          x: 0,
          y: 0
        },
        type: "RasterFunctionVariable"
      },
      type: "ResampleFunctionArguments"
    },
    functionType: 0,
    thumbnail: ""
  }
};

// ../../../node_modules/@arcgis/core/layers/support/imageryRendererUtils.js
var c5 = /* @__PURE__ */ new Set(["u1", "u2", "u4", "u8", "s8", "u16", "s16"]);
var m3 = {
  simple_scalar: "Simple Scalar",
  wind_barb: "Wind Barb",
  single_arrow: "Single Arrow",
  beaufort_kn: "Beaufort Wind (Knots)",
  beaufort_m: "Beaufort Wind (MetersPerSecond)",
  ocean_current_m: "Ocean Current (MetersPerSecond)",
  ocean_current_kn: "Ocean Current (Knots)"
};
var f7 = /* @__PURE__ */ new Set(["raster-stretch", "unique-value", "class-breaks", "raster-shaded-relief", "vector-field", "raster-colormap"]);
function p6(e5) {
  return f7.has(e5.type);
}
function g4(n14, t6) {
  if (!n14 || !t6) return a(n14 || t6);
  const r2 = a(n14);
  if (r2.functionDefinition && t6.rasterFunctionDefinition) {
    const e5 = t6.rasterFunctionDefinition;
    (e5.thumbnail || e5.thumbnailEx) && (e5.thumbnail = e5.thumbnailEx = void 0), d8(r2.functionDefinition.arguments, t6), r2.rasterFunctionDefinition = r2.functionDefinition.toJSON();
  } else if ("none" !== t6.functionName?.toLowerCase()) {
    b4(r2.functionArguments).Raster = t6;
  }
  return r2;
}
function d8(e5, n14) {
  for (const t6 in e5) "raster" === t6.toLowerCase() && ("RasterFunctionVariable" === e5[t6].type ? (e5[t6] = n14.rasterFunctionDefinition, e5[t6].type = "RasterFunctionTemplate") : "RasterFunctionTemplate" === e5[t6].type && d8(e5[t6].arguments, n14));
}
function h2(n14) {
  const t6 = a(e3[n14.functionName + "Function"]), o3 = n14.functionArguments;
  for (const e5 in o3) "raster" === e5.toLowerCase() ? (t6.arguments[e5] = h2(o3[e5]), t6.arguments[e5].type = "RasterFunctionTemplate") : "colormap" === e5.toLowerCase() ? (t6.arguments[e5].value = D(o3[e5]), t6.arguments.ColorSchemeType.value = 0) : t6.arguments[e5].value = o3[e5];
  return t6;
}
function y5(e5, n14) {
  switch (n14 = n14 || {}, e5.type) {
    case "raster-stretch":
      return w3(e5, n14);
    case "class-breaks":
      return S2(e5, n14);
    case "unique-value":
      return F(e5, n14);
    case "raster-colormap":
      return N3(e5, n14);
    case "vector-field":
      return T(e5, n14);
    case "raster-shaded-relief":
      return v(e5, n14);
    case "flow":
      throw new Error("Unsupported rendering rule.");
  }
}
function b4(e5) {
  const n14 = e5?.Raster ?? e5?.raster;
  return n14 && "esri.layers.support.RasterFunction" === n14.declaredClass ? b4(n14.functionArguments) : e5;
}
var R2 = {
  none: 0,
  standardDeviation: 3,
  histogramEqualization: 4,
  minMax: 5,
  percentClip: 6,
  sigmoid: 9
};
function T(e5, t6) {
  const r2 = new N2();
  r2.functionName = "VectorFieldRenderer";
  const {
    dataType: o3,
    bandNames: a14
  } = t6, i11 = "vector-uv" === o3;
  let s11, u6;
  if (a14 && 2 === a14.length) {
    const e6 = a14.map((e7) => e7.toLowerCase());
    s11 = e6.indexOf("magnitude"), u6 = e6.indexOf("direction");
  }
  -1 !== s11 && null !== s11 || (s11 = 0, u6 = 1);
  const c22 = "arithmetic" === e5.rotationType ? 1 : 2, f8 = "flow-from" === e5.flowRepresentation ? 0 : 1, p21 = e5.visualVariables ? e5.visualVariables.find((e6) => "Magnitude" === e6.field) : new b2(), g6 = {
    magnitudeBandID: s11,
    directionBandID: u6,
    isUVComponents: i11,
    referenceSystem: c22,
    massFlowAngleRepresentation: f8,
    symbolTileSize: 50,
    symbolTileSizeUnits: 100,
    calculationMethod: "Vector Average",
    symbologyName: m3[e5.style.toLowerCase().replace("-", "_")],
    minimumMagnitude: p21.minDataValue,
    maximumMagnitude: p21.maxDataValue,
    minimumSymbolSize: p21.minSize,
    maximumSymbolSize: p21.maxSize
  };
  r2.functionArguments = g6;
  const d12 = h2(r2);
  return t6.convertToRFT ? N2.fromJSON({
    rasterFunctionDefinition: d12
  }) : r2;
}
function v(e5, t6) {
  const r2 = t6.convertToRFT;
  if ("elevation" !== t6.dataType && ("generic" !== t6.dataType || 1 !== t6.bandCount || "s16" !== t6.pixelType && "s32" !== t6.pixelType && "f32" !== t6.pixelType && "f64" !== t6.pixelType)) return new N2();
  const i11 = new N2();
  i11.functionName = "Hillshade";
  const s11 = "traditional" === e5.hillshadeType ? 0 : 1, u6 = "none" === e5.scalingType ? 1 : 3, l13 = {
    HillshadeType: s11,
    SlopeType: u6,
    ZFactor: e5.zFactor
  };
  return 0 === s11 && (l13.Azimuth = e5.azimuth, l13.Altitude = e5.altitude), 3 === u6 && (l13.PSPower = e5.pixelSizePower, l13.PSZFactor = e5.pixelSizeFactor), i11.functionArguments = l13, i11.variableName = "Raster", e5.colorRamp && (i11.functionName = "ShadedRelief", r2 ? l13.ColorRamp = G(e5.colorRamp) : l13.Colormap = B(e5.colorRamp)), r2 ? new N2({
    rasterFunctionDefinition: h2(i11)
  }) : i11;
}
function w3(e5, t6) {
  const r2 = t6.convertToRFT, s11 = new N2();
  s11.functionName = "Stretch";
  const l13 = R2[n5.toJSON(e5.stretchType)], c22 = "u8", m12 = {
    StretchType: l13,
    Statistics: V(e5.statistics ?? []),
    DRA: e5.dynamicRangeAdjustment,
    UseGamma: e5.useGamma,
    Gamma: e5.gamma,
    ComputeGamma: e5.computeGamma
  };
  if (null != e5.outputMin && (m12.Min = e5.outputMin), null != e5.outputMax && (m12.Max = e5.outputMax), l13 === R2.standardDeviation ? (m12.NumberOfStandardDeviations = e5.numberOfStandardDeviations, s11.outputPixelType = c22) : l13 === R2.percentClip ? (m12.MinPercent = e5.minPercent, m12.MaxPercent = e5.maxPercent, s11.outputPixelType = c22) : l13 === R2.minMax ? s11.outputPixelType = c22 : l13 === R2.sigmoid && (m12.SigmoidStrengthLevel = e5.sigmoidStrengthLevel), s11.functionArguments = m12, s11.variableName = "Raster", e5.colorRamp) {
    const u6 = e5.colorRamp, l14 = new N2();
    if (r2) l14.functionArguments = {
      ColorRamp: G(u6)
    };
    else {
      const n14 = d4(u6, true);
      if (n14) l14.functionArguments = {
        colorRampName: n14
      };
      else if (!t6.convertColorRampToColormap || "algorithmic" !== u6.type && "multipart" !== u6.type) {
        const n15 = e5.colorRamp.toJSON();
        "algorithmic" === n15.type ? n15.algorithm = n15.algorithm || "esriCIELabAlgorithm" : "multipart" === n15.type && n15.colorRamps?.length && n15.colorRamps.forEach((e6) => e6.algorithm = e6.algorithm || "esriCIELabAlgorithm"), l14.functionArguments = {
          colorRamp: n15
        };
      } else l14.functionArguments = {
        Colormap: B(u6)
      };
    }
    return l14.variableName = "Raster", l14.functionName = "Colormap", l14.functionArguments.Raster = s11, r2 ? new N2({
      rasterFunctionDefinition: h2(l14)
    }) : l14;
  }
  return r2 ? new N2({
    rasterFunctionDefinition: h2(s11)
  }) : s11;
}
function S2(e5, t6) {
  const r2 = [], o3 = [], a14 = [], i11 = [], s11 = 1e-4, {
    pixelType: u6,
    rasterAttributeTable: l13
  } = t6, c22 = null == l13 ? null : l13.features, m12 = C(l13);
  if (m12 && c22 && Array.isArray(c22) && e5.classBreakInfos) {
    e5.classBreakInfos.forEach((n14, t7) => {
      const r4 = n14.symbol?.color;
      let o5;
      r4?.a && null != n14.minValue && null != n14.maxValue && c22.forEach((a15) => {
        null != n14.minValue && null != n14.maxValue && (o5 = a15.attributes[e5.field], (o5 >= n14.minValue && o5 < n14.maxValue || t7 === e5.classBreakInfos.length - 1 && o5 >= n14.minValue) && i11.push([a15.attributes[m12], r4.r, r4.g, r4.b]));
      });
    });
    const r3 = u6 ? x(i11, u6) : i11, o4 = new N2();
    return o4.functionName = "Colormap", o4.functionArguments = {}, o4.functionArguments.Colormap = r3, o4.variableName = "Raster", t6.convertToRFT ? new N2({
      rasterFunctionDefinition: h2(o4)
    }) : o4;
  }
  e5.classBreakInfos.forEach((e6, n14) => {
    if (null == e6.minValue || null == e6.maxValue) return;
    const t7 = e6.symbol && e6.symbol.color;
    t7?.a ? (0 === n14 ? r2.push(e6.minValue, e6.maxValue + s11) : r2.push(e6.minValue + s11, e6.maxValue + s11), o3.push(n14), i11.push([n14, t7.r, t7.g, t7.b])) : a14.push(e6.minValue, e6.maxValue);
  });
  const f8 = u6 ? x(i11, u6) : i11, p21 = new N2();
  p21.functionName = "Remap", p21.functionArguments = {
    InputRanges: r2,
    OutputValues: o3,
    NoDataRanges: a14
  }, p21.variableName = "Raster";
  const g6 = new N2();
  return g6.functionName = "Colormap", g6.functionArguments = {
    Colormap: f8,
    Raster: p21
  }, t6.convertToRFT ? new N2({
    rasterFunctionDefinition: h2(g6)
  }) : g6;
}
function x(e5, n14) {
  const r2 = c5.has(n14) ? s5(n14) : null;
  return r2 && e5.push([Math.floor(r2[0] - 1), 0, 0, 0], [Math.ceil(r2[1] + 1), 0, 0, 0]), e5;
}
function C(e5) {
  if (null == e5) return;
  const {
    fields: n14
  } = e5, t6 = n14?.find((e6) => e6?.name && "value" === e6.name.toLowerCase());
  return t6?.name;
}
function F(e5, t6) {
  const r2 = [], {
    pixelType: o3,
    rasterAttributeTable: a14
  } = t6, i11 = null == a14 ? null : a14.features, s11 = C(a14), u6 = e5.defaultSymbol?.color?.toRgb(), l13 = e5.uniqueValueInfos;
  if (l13) if (i11) {
    if (s11) {
      const n14 = /* @__PURE__ */ new Map();
      l13.forEach((e6) => {
        const t8 = e6.value, r3 = A3(e6);
        null != t8 && r3?.a && n14.set(String(t8), r3.toRgb());
      });
      const t7 = e5.field;
      t7 && i11.forEach(({
        attributes: e6
      }) => {
        const o4 = String(e6[t7]), a15 = e6[s11], i12 = n14.get(o4);
        i12 ? r2.push([a15, ...i12]) : u6 && r2.push([a15, ...u6]);
      });
    }
  } else for (let n14 = 0; n14 < l13.length; n14++) {
    const e6 = l13[n14], t7 = A3(e6), o4 = +e6.value;
    if (t7?.a) {
      if (isNaN(o4)) return null;
      r2.push([o4, t7.r, t7.g, t7.b]);
    }
  }
  const c22 = o3 ? x(r2, o3) : r2, m12 = new N2();
  return m12.functionName = "Colormap", m12.functionArguments = {}, m12.functionArguments.Colormap = c22, m12.variableName = "Raster", t6.convertToRFT ? new N2({
    rasterFunctionDefinition: h2(m12)
  }) : m12;
}
function A3(e5) {
  return "polygon-3d" === e5.symbol?.type ? e5.symbol.symbolLayers?.find((e6) => "fill" === e6.type)?.material?.color : e5.symbol?.color;
}
function N3(e5, t6) {
  const r2 = e5.extractColormap();
  if (!r2 || 0 === r2.length) return null;
  const {
    pixelType: o3
  } = t6, a14 = o3 ? x(r2, o3) : r2, i11 = new N2();
  return i11.functionName = "Colormap", i11.functionArguments = {}, i11.functionArguments.Colormap = a14, t6.convertToRFT ? new N2({
    rasterFunctionDefinition: h2(i11)
  }) : i11;
}
function V(e5) {
  const n14 = [];
  return e5?.forEach((e6) => {
    const t6 = e6;
    if (Array.isArray(t6)) n14.push(t6);
    else {
      if (null == t6.min || null == t6.max) return;
      const e7 = [t6.min, t6.max, t6.avg || 0, t6.stddev || 0];
      n14.push(e7);
    }
  }), n14;
}
function D(e5) {
  const n14 = [], t6 = [];
  return e5.forEach((e6) => {
    n14.push(e6[0]), t6.push(A2([...e6.slice(1), 255]));
  }), {
    type: "RasterColormap",
    values: n14,
    colors: t6
  };
}

// ../../../node_modules/@arcgis/core/layers/support/ExportImageServiceParameters.js
var y6 = class extends f {
  constructor() {
    super(...arguments), this.layer = null, this.compression = void 0, this.pixelType = void 0, this.lercVersion = 2;
  }
  get adjustAspectRatio() {
    return this.layer.adjustAspectRatio;
  }
  writeAdjustAspectRatio(e5, t6, r2) {
    this.layer.version < 10.3 || (t6[r2] = e5);
  }
  get bandIds() {
    return this.layer.bandIds;
  }
  get compressionQuality() {
    return this.layer.compressionQuality;
  }
  writeCompressionQuality(e5, t6, r2) {
    this.format && this.format.toLowerCase().includes("jpg") && null != e5 && (t6[r2] = e5);
  }
  get compressionTolerance() {
    return this.layer.compressionTolerance;
  }
  writeCompressionTolerance(e5, t6, r2) {
    "lerc" === this.format && null != e5 && (t6[r2] = e5);
  }
  get format() {
    return "vector-field" === this.layer.renderer?.type ? "lerc" : this.layer.format;
  }
  get interpolation() {
    return this.layer.interpolation;
  }
  get noData() {
    return this.layer.noData;
  }
  get noDataInterpretation() {
    return this.layer.noDataInterpretation;
  }
  writeLercVersion(e5, t6, r2) {
    "lerc" === this.format && this.layer.version >= 10.5 && (t6[r2] = e5);
  }
  get version() {
    const e5 = this.layer;
    return e5.commitProperty("bandIds"), e5.commitProperty("format"), e5.commitProperty("compressionQuality"), e5.commitProperty("compressionTolerance"), e5.commitProperty("interpolation"), e5.commitProperty("noData"), e5.commitProperty("noDataInterpretation"), e5.commitProperty("mosaicRule"), e5.commitProperty("rasterFunction"), e5.commitProperty("adjustAspectRatio"), e5.commitProperty("pixelFilter"), e5.commitProperty("definitionExpression"), e5.commitProperty("multidimensionalSubset"), (this._get("version") || 0) + 1;
  }
  set version(e5) {
    this._set("version", e5);
  }
  get mosaicRule() {
    const e5 = this.layer;
    let t6 = e5.mosaicRule;
    const r2 = e5.definitionExpression;
    return t6 ? r2 && r2 !== t6.where && (t6 = t6.clone(), t6.where = r2) : r2 && (t6 = new j5({
      where: r2
    })), t6;
  }
  get rasterFunction() {
    const e5 = this.layer;
    let {
      rasterFunction: t6
    } = e5;
    const r2 = e5.pixelFilter, o3 = !e5.format || e5.format.includes("jpg") || e5.format.includes("png");
    t6 = this._addResampleRasterFunction(t6);
    const i11 = e5.multidimensionalSubset?.areaOfInterest;
    return i11 && (t6 = d9(t6, i11)), o3 && !r2 && "vector-field" !== e5.renderer?.type && (t6 = this.combineRendererWithRenderingRule(t6)), t6;
  }
  combineRendererWithRenderingRule(e5) {
    const t6 = this.layer, {
      rasterInfo: r2,
      renderer: o3
    } = t6;
    if (e5 = e5 || t6.rasterFunction, !o3 || !p6(o3)) return e5;
    return g4(y5(o3, {
      rasterAttributeTable: r2.attributeTable,
      pixelType: r2.pixelType,
      dataType: r2.dataType,
      bandNames: r2.bandInfos.map(({
        name: e6
      }) => e6),
      convertColorRampToColormap: t6.version < 10.6,
      convertToRFT: !!e5?.rasterFunctionDefinition,
      bandCount: r2.bandCount
    }), e5);
  }
  _addResampleRasterFunction(e5) {
    if (!("vector-field" === this.layer.renderer?.type) || "Resample" === e5?.functionName) return e5;
    const t6 = "esriImageServiceDataTypeVector-UV" === this.layer.serviceDataType ? 7 : 10, r2 = this.layer.serviceRasterInfo.pixelSize;
    let o3 = new N2({
      functionName: "Resample",
      functionArguments: {
        ResamplingType: t6,
        InputCellSize: r2
      }
    });
    return o3 = e5?.rasterFunctionDefinition ? new N2({
      rasterFunctionDefinition: h2(o3)
    }) : o3, g4(o3, e5);
  }
};
function d9(e5, t6) {
  const r2 = new N2({
    functionName: "Clip",
    functionArguments: {
      ClippingGeometry: t6.toJSON(),
      ClippingType: 1
    }
  });
  return g4(r2, e5);
}
e([y()], y6.prototype, "layer", void 0), e([y({
  json: {
    write: true
  }
})], y6.prototype, "adjustAspectRatio", null), e([r("adjustAspectRatio")], y6.prototype, "writeAdjustAspectRatio", null), e([y({
  json: {
    write: true
  }
})], y6.prototype, "bandIds", null), e([y({
  json: {
    write: true
  }
})], y6.prototype, "compression", void 0), e([y({
  json: {
    write: true
  }
})], y6.prototype, "compressionQuality", null), e([r("compressionQuality")], y6.prototype, "writeCompressionQuality", null), e([y({
  json: {
    write: true
  }
})], y6.prototype, "compressionTolerance", null), e([r("compressionTolerance")], y6.prototype, "writeCompressionTolerance", null), e([y({
  json: {
    write: true
  }
})], y6.prototype, "format", null), e([y({
  type: String,
  json: {
    read: {
      reader: a5.read
    },
    write: {
      writer: a5.write
    }
  }
})], y6.prototype, "interpolation", null), e([y({
  json: {
    write: true
  }
})], y6.prototype, "noData", null), e([y({
  type: String,
  json: {
    read: {
      reader: i4.read
    },
    write: {
      writer: i4.write
    }
  }
})], y6.prototype, "noDataInterpretation", null), e([y({
  json: {
    write: true
  }
})], y6.prototype, "pixelType", void 0), e([y({
  json: {
    write: true
  }
})], y6.prototype, "lercVersion", void 0), e([r("lercVersion")], y6.prototype, "writeLercVersion", null), e([y({
  type: Number
})], y6.prototype, "version", null), e([y({
  json: {
    write: true
  }
})], y6.prototype, "mosaicRule", null), e([y({
  json: {
    write: true,
    name: "renderingRule"
  }
})], y6.prototype, "rasterFunction", null), y6 = e([a4("esri.layers.support.ExportImageServiceParameters")], y6);

// ../../../node_modules/@arcgis/core/rest/support/FindImagesParameters.js
var i5 = class extends i2(f) {
  constructor() {
    super(...arguments), this.fromGeometry = null, this.toGeometry = null, this.objectIds = null, this.where = null, this.maxCount = null;
  }
};
e([y({
  type: _,
  json: {
    read: true
  }
})], i5.prototype, "fromGeometry", void 0), e([y({
  type: _,
  json: {
    read: true,
    write: true
  }
})], i5.prototype, "toGeometry", void 0), e([y({
  json: {
    write: true
  }
})], i5.prototype, "objectIds", void 0), e([y({
  type: String,
  json: {
    write: true
  }
})], i5.prototype, "where", void 0), e([y({
  type: Number,
  json: {
    write: true
  }
})], i5.prototype, "maxCount", void 0), i5 = e([a4("esri.rest.support.FindImagesParameters")], i5);
var m4 = i5;

// ../../../node_modules/@arcgis/core/rest/support/CameraInfoMixin.js
var s10 = (s11) => {
  let e5 = class extends s11 {
    constructor() {
      super(...arguments), this.make = null, this.model = null, this.focalLength = null, this.pixelSize = null, this.rows = null, this.cols = null;
    }
  };
  return e([y({
    json: {
      write: true
    }
  })], e5.prototype, "make", void 0), e([y({
    json: {
      write: true
    }
  })], e5.prototype, "model", void 0), e([y({
    json: {
      write: true
    }
  })], e5.prototype, "focalLength", void 0), e([y({
    json: {
      write: true
    }
  })], e5.prototype, "pixelSize", void 0), e([y({
    json: {
      write: true
    }
  })], e5.prototype, "rows", void 0), e([y({
    json: {
      write: true
    }
  })], e5.prototype, "cols", void 0), e5 = e([a4("esri.rest.support.CameraInfoMixin")], e5), e5;
};

// ../../../node_modules/@arcgis/core/rest/support/ImageInspectionInfo.js
var n7 = class extends s10(f) {
  constructor() {
    super(...arguments), this.id = null, this.referenceUri = null, this.acquisitionDate = null, this.cameraID = null, this.center = null, this.perspectiveCenter = null, this.orientation = null;
  }
  writeAcquisitionDate(t6, o3) {
    o3.acquisitionDate = t6?.getTime();
  }
};
e([y({
  json: {
    write: true
  }
})], n7.prototype, "id", void 0), e([y({
  json: {
    name: "uri",
    write: true
  }
})], n7.prototype, "referenceUri", void 0), e([y({
  type: Date,
  json: {
    write: true
  }
})], n7.prototype, "acquisitionDate", void 0), e([r("acquisitionDate")], n7.prototype, "writeAcquisitionDate", null), e([y({
  json: {
    write: true
  }
})], n7.prototype, "cameraID", void 0), e([y({
  type: _,
  json: {
    write: true
  }
})], n7.prototype, "center", void 0), e([y({
  type: _,
  json: {
    write: true
  }
})], n7.prototype, "perspectiveCenter", void 0), e([y({
  json: {
    write: true
  }
})], n7.prototype, "orientation", void 0), n7 = e([a4("esri.rest.support.ImageInspectionInfo")], n7);
var c6 = n7;

// ../../../node_modules/@arcgis/core/rest/support/FindImagesResult.js
var p7 = class extends f {
  constructor() {
    super(...arguments), this.images = null;
  }
};
e([y({
  type: [c6],
  json: {
    write: true
  }
})], p7.prototype, "images", void 0), p7 = e([a4("esri.rest.support.FindImagesResult")], p7);
var c7 = p7;

// ../../../node_modules/@arcgis/core/rest/support/ImageAngleParameters.js
var n8;
var m5 = n8 = class extends f {
  constructor(e5) {
    super(e5), this.angleNames = null, this.point = null, this.spatialReference = null, this.rasterId = null;
  }
  clone() {
    return new n8(a({
      angleNames: this.angleNames,
      point: this.point,
      spatialReference: this.spatialReference,
      rasterId: this.rasterId
    }));
  }
};
e([y({
  type: [String],
  json: {
    name: "angleName",
    write: true
  }
})], m5.prototype, "angleNames", void 0), e([y({
  type: _,
  json: {
    write: true
  }
})], m5.prototype, "point", void 0), e([y({
  type: f2,
  json: {
    write: true
  }
})], m5.prototype, "spatialReference", void 0), e([y({
  type: N,
  json: {
    write: true
  }
})], m5.prototype, "rasterId", void 0), m5 = n8 = e([a4("esri.rest.support.ImageAngleParameters")], m5);
var l6 = m5;

// ../../../node_modules/@arcgis/core/rest/support/ImageAngleResult.js
var p8 = class extends f {
  constructor(r2) {
    super(r2), this.north = null, this.up = null, this.spatialReference = null;
  }
};
e([y({
  type: Number,
  json: {
    write: true
  }
})], p8.prototype, "north", void 0), e([y({
  type: Number,
  json: {
    write: true
  }
})], p8.prototype, "up", void 0), e([y({
  type: f2,
  json: {
    write: true
  }
})], p8.prototype, "spatialReference", void 0), p8 = e([a4("esri.rest.support.ImageAngleResult")], p8);
var i6 = p8;

// ../../../node_modules/@arcgis/core/rest/support/BaseImageMeasureParameters.js
var a6 = new n2({
  esriMensurationPoint: "point",
  esriMensurationCentroid: "centroid",
  esriMensurationDistanceAndAngle: "distance-and-angle",
  esriMensurationAreaAndPerimeter: "area-and-perimeter",
  esriMensurationHeightFromBaseAndTop: "base-and-top",
  esriMensurationHeightFromBaseAndTopShadow: "base-and-top-shadow",
  esriMensurationHeightFromTopAndTopShadow: "top-and-top-shadow",
  esriMensurationPoint3D: "point-3D",
  esriMensurationCentroid3D: "centroid-3D",
  esriMensurationDistanceAndAngle3D: "distance-and-angle-3D",
  esriMensurationAreaAndPerimeter3D: "area-and-perimeter-3D"
});
var p9 = class extends f {
  constructor() {
    super(...arguments), this.type = null, this.measureOperation = null, this.mosaicRule = null, this.pixelSize = null, this.raster = void 0;
  }
};
e([y()], p9.prototype, "type", void 0), e([y({
  type: a6.apiValues,
  json: {
    read: a6.read,
    write: a6.write
  }
})], p9.prototype, "measureOperation", void 0), e([y({
  type: j5,
  json: {
    write: true
  }
})], p9.prototype, "mosaicRule", void 0), e([y({
  type: _,
  json: {
    write: true
  }
})], p9.prototype, "pixelSize", void 0), e([y({
  json: {
    write: true
  }
})], p9.prototype, "raster", void 0), p9 = e([a4("esri.rest.support.BaseImageMeasureParameters")], p9);

// ../../../node_modules/@arcgis/core/rest/support/ImageAreaParameters.js
var c8;
var u2 = c8 = class extends p9 {
  constructor() {
    super(...arguments), this.type = "area-perimeter", this.geometry = null, this.is3D = false, this.linearUnit = "meters", this.areaUnit = "square-meters";
  }
  writeGeometry(e5, r2, t6) {
    null != e5 && (r2.geometryType = p(e5), r2[t6] = e5.toJSON());
  }
  get measureOperation() {
    return this.is3D ? "area-and-perimeter-3D" : "area-and-perimeter";
  }
  clone() {
    return new c8(a({
      geometry: this.geometry,
      is3D: this.is3D,
      linearUnit: this.linearUnit,
      areaUnit: this.areaUnit,
      mosaicRule: this.mosaicRule,
      pixelSize: this.pixelSize,
      raster: this.raster
    }));
  }
};
e([y({
  types: n3,
  json: {
    name: "fromGeometry",
    read: true,
    write: true
  }
})], u2.prototype, "geometry", void 0), e([r("geometry")], u2.prototype, "writeGeometry", null), e([y({
  type: a6.apiValues,
  json: {
    write: a6.write
  }
})], u2.prototype, "measureOperation", null), e([y({
  json: {
    read: true
  }
})], u2.prototype, "is3D", void 0), e([y({
  type: String,
  json: {
    read: me.read,
    write: me.write
  }
})], u2.prototype, "linearUnit", void 0), e([y({
  type: String,
  json: {
    read: oe.read,
    write: oe.write
  }
})], u2.prototype, "areaUnit", void 0), u2 = c8 = e([a4("esri.rest.support.ImageAreaParameters")], u2);
var y7 = u2;

// ../../../node_modules/@arcgis/core/rest/support/BaseImageMeasureResult.js
var i7 = class extends f {
  constructor() {
    super(...arguments), this.value = null, this.displayValue = null, this.uncertainty = null;
  }
};
e([y({
  type: Number,
  json: {
    read: true,
    write: true
  }
})], i7.prototype, "value", void 0), e([y({
  type: String,
  json: {
    read: true,
    write: true
  }
})], i7.prototype, "displayValue", void 0), e([y({
  type: Number,
  json: {
    read: true,
    write: true
  }
})], i7.prototype, "uncertainty", void 0), i7 = e([a4("esri.rest.support.BaseImageMeasureResult.BaseImageMeasureResultValue")], i7);
var p10 = class extends i7 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
e([y({
  type: String,
  json: {
    read: me.read,
    write: me.write
  }
})], p10.prototype, "unit", void 0), p10 = e([a4("esri.rest.support.BaseImageMeasureResult.ImageMeasureResultLengthValue")], p10);
var n9 = class extends i7 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
e([y({
  type: String,
  json: {
    read: oe.read,
    write: oe.write
  }
})], n9.prototype, "unit", void 0), n9 = e([a4("esri.rest.support.BaseImageMeasureResult.ImageMeasureResultAreaValue")], n9);
var l7 = class extends i7 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
e([y({
  type: String,
  json: {
    read: fe.read,
    write: fe.write
  }
})], l7.prototype, "unit", void 0), l7 = e([a4("esri.rest.support.BaseImageMeasureResult.ImageMeasureResultAngleValue")], l7);
var c9 = class extends f {
  constructor() {
    super(...arguments), this.name = null, this.sensorName = null;
  }
};
e([y({
  type: String,
  json: {
    read: true,
    write: true
  }
})], c9.prototype, "name", void 0), e([y({
  type: String,
  json: {
    read: true,
    write: true
  }
})], c9.prototype, "sensorName", void 0), c9 = e([a4("esri.rest.support.BaseImageMeasureResult")], c9);

// ../../../node_modules/@arcgis/core/rest/support/ImageAreaResult.js
var a7 = class extends c9 {
  constructor() {
    super(...arguments), this.area = null, this.perimeter = null;
  }
};
e([y({
  type: n9,
  json: {
    read: true,
    write: true
  }
})], a7.prototype, "area", void 0), e([y({
  type: p10,
  json: {
    read: true,
    write: true
  }
})], a7.prototype, "perimeter", void 0), a7 = e([a4("esri.rest.support.ImageAreaResult")], a7);
var c10 = a7;

// ../../../node_modules/@arcgis/core/rest/support/ImageBoundaryParameters.js
var a8 = class extends i2(f) {
  constructor() {
    super(...arguments), this.outSpatialReference = null;
  }
};
e([y({
  type: f2,
  json: {
    name: "outSR",
    write: true
  }
})], a8.prototype, "outSpatialReference", void 0), a8 = e([a4("esri.rest.support.ImageBoundaryParameters")], a8);
var c11 = a8;

// ../../../node_modules/@arcgis/core/rest/support/ImageBoundaryResult.js
var a9 = class extends f {
  constructor() {
    super(...arguments), this.area = null, this.geometry = null;
  }
  readGeometry(r2, o3) {
    return null == r2 ? null : r2.rings ? j2.fromJSON(r2) : w.fromJSON(r2);
  }
};
e([y({
  type: Number,
  json: {
    write: true
  }
})], a9.prototype, "area", void 0), e([y({
  json: {
    name: "shape",
    write: true
  }
})], a9.prototype, "geometry", void 0), e([o("geometry")], a9.prototype, "readGeometry", null), a9 = e([a4("esri.rest.support.ImageBoundaryResult")], a9);
var c12 = a9;

// ../../../node_modules/@arcgis/core/rest/support/ImageDistanceParameters.js
var y8;
var c13 = y8 = class extends p9 {
  constructor() {
    super(...arguments), this.type = "distance-angle", this.fromGeometry = null, this.toGeometry = null, this.is3D = false, this.linearUnit = "meters", this.angularUnit = "degrees";
  }
  writeFromGeometry(e5, r2, t6) {
    null != e5 && (r2.geometryType = p(e5), r2[t6] = e5.toJSON());
  }
  get measureOperation() {
    return this.is3D ? "distance-and-angle-3D" : "distance-and-angle";
  }
  clone() {
    return new y8(a({
      fromGeometry: this.fromGeometry,
      toGeometry: this.toGeometry,
      is3D: this.is3D,
      linearUnit: this.linearUnit,
      angularUnit: this.angularUnit,
      mosaicRule: this.mosaicRule,
      pixelSize: this.pixelSize,
      raster: this.raster
    }));
  }
};
e([y({
  type: _,
  json: {
    read: true,
    write: true
  }
})], c13.prototype, "fromGeometry", void 0), e([r("fromGeometry")], c13.prototype, "writeFromGeometry", null), e([y({
  type: _,
  json: {
    read: true,
    write: true
  }
})], c13.prototype, "toGeometry", void 0), e([y({
  type: a6.apiValues,
  json: {
    write: a6.write
  }
})], c13.prototype, "measureOperation", null), e([y({
  json: {
    read: true
  }
})], c13.prototype, "is3D", void 0), e([y({
  type: String,
  json: {
    read: me.read,
    write: me.write
  }
})], c13.prototype, "linearUnit", void 0), e([y({
  type: String,
  json: {
    read: fe.read,
    write: fe.write
  }
})], c13.prototype, "angularUnit", void 0), c13 = y8 = e([a4("esri.rest.support.ImageDistanceParameters")], c13);
var u3 = c13;

// ../../../node_modules/@arcgis/core/rest/support/ImageDistanceResult.js
var a10 = class extends c9 {
  constructor() {
    super(...arguments), this.distance = null, this.azimuthAngle = null, this.elevationAngle = null;
  }
};
e([y({
  type: p10,
  json: {
    read: true,
    write: true
  }
})], a10.prototype, "distance", void 0), e([y({
  type: l7,
  json: {
    read: true,
    write: true
  }
})], a10.prototype, "azimuthAngle", void 0), e([y({
  type: l7,
  json: {
    read: true,
    write: true
  }
})], a10.prototype, "elevationAngle", void 0), a10 = e([a4("esri.rest.support.ImageDistanceResult")], a10);
var i8 = a10;

// ../../../node_modules/@arcgis/core/rest/support/ImageGPSInfoParameters.js
var j6 = class extends i2(f) {
  constructor() {
    super(...arguments), this.geometry = null, this.objectIds = null, this.spatialRelationship = "intersects", this.timeExtent = null, this.where = null;
  }
  writeGeometry(o3, t6, r2) {
    null != o3 && (t6.geometryType = p(o3), t6[r2] = JSON.stringify(o3.toJSON()));
  }
};
e([y({
  types: n3,
  json: {
    read: y2,
    write: true
  }
})], j6.prototype, "geometry", void 0), e([r("geometry")], j6.prototype, "writeGeometry", null), e([y({
  json: {
    write: true
  }
})], j6.prototype, "objectIds", void 0), e([o2(s3, {
  ignoreUnknown: false,
  name: "spatialRel"
})], j6.prototype, "spatialRelationship", void 0), e([y({
  type: c,
  json: {
    name: "time",
    write: true
  }
})], j6.prototype, "timeExtent", void 0), e([y({
  type: String,
  json: {
    write: true
  }
})], j6.prototype, "where", void 0), j6 = e([a4("esri.rest.support.ImageGPSInfoParameters")], j6);
var y9 = j6;

// ../../../node_modules/@arcgis/core/rest/support/CameraInfo.js
var p11 = class extends s10(f) {
  constructor() {
    super(...arguments), this.id = null;
  }
};
e([y({
  json: {
    write: true
  }
})], p11.prototype, "id", void 0), p11 = e([a4("esri.rest.support.CameraInfo")], p11);
var c14 = p11;

// ../../../node_modules/@arcgis/core/rest/support/ImageGPSInfo.js
var p12 = class extends f {
  constructor() {
    super(...arguments), this.id = null, this.name = null, this.acquisitionDate = null, this.cameraID = null, this.center = null, this.gps = null, this.orientation = null;
  }
  writeAcquisitionDate(o3, t6) {
    t6.acquisitionDate = o3?.getTime();
  }
};
e([y({
  json: {
    write: true
  }
})], p12.prototype, "id", void 0), e([y({
  json: {
    write: true
  }
})], p12.prototype, "name", void 0), e([y({
  type: Date,
  json: {
    write: true
  }
})], p12.prototype, "acquisitionDate", void 0), e([r("acquisitionDate")], p12.prototype, "writeAcquisitionDate", null), e([y({
  json: {
    write: true
  }
})], p12.prototype, "cameraID", void 0), e([y({
  type: _,
  json: {
    write: true
  }
})], p12.prototype, "center", void 0), e([y({
  json: {
    write: true
  }
})], p12.prototype, "gps", void 0), e([y({
  json: {
    write: true
  }
})], p12.prototype, "orientation", void 0), p12 = e([a4("esri.rest.support.ImageGPSInfo")], p12);
var n10 = p12;

// ../../../node_modules/@arcgis/core/rest/support/ImageGPSInfoResult.js
var m6 = class extends f {
  constructor() {
    super(...arguments), this.images = null, this.cameras = null;
  }
};
e([y({
  type: [n10],
  json: {
    write: true
  }
})], m6.prototype, "images", void 0), e([y({
  type: [c14],
  json: {
    write: true
  }
})], m6.prototype, "cameras", void 0), m6 = e([a4("esri.rest.support.ImageGPSInfoResult")], m6);
var a11 = m6;

// ../../../node_modules/@arcgis/core/rest/support/ImageHeightParameters.js
var y10;
var l8 = y10 = class extends p9 {
  constructor() {
    super(...arguments), this.type = "height", this.fromGeometry = null, this.toGeometry = null, this.operationType = "base-and-top", this.linearUnit = "meters";
  }
  writeFromGeometry(e5, r2, t6) {
    null != e5 && (r2.geometryType = p(e5), r2[t6] = e5.toJSON());
  }
  get measureOperation() {
    return this.operationType;
  }
  clone() {
    return new y10(a({
      fromGeometry: this.fromGeometry,
      toGeometry: this.toGeometry,
      operationType: this.operationType,
      linearUnit: this.linearUnit,
      mosaicRule: this.mosaicRule,
      pixelSize: this.pixelSize,
      raster: this.raster
    }));
  }
};
e([y({
  type: _,
  json: {
    read: true
  }
})], l8.prototype, "fromGeometry", void 0), e([r("fromGeometry")], l8.prototype, "writeFromGeometry", null), e([y({
  type: _,
  json: {
    read: true,
    write: true
  }
})], l8.prototype, "toGeometry", void 0), e([y({
  type: a6.apiValues,
  json: {
    write: a6.write
  }
})], l8.prototype, "measureOperation", null), e([y({
  json: {
    read: true
  }
})], l8.prototype, "operationType", void 0), e([y({
  type: String,
  json: {
    read: me.read,
    write: me.write
  }
})], l8.prototype, "linearUnit", void 0), l8 = y10 = e([a4("esri.rest.support.ImageHeightParameters")], l8);
var c15 = l8;

// ../../../node_modules/@arcgis/core/rest/support/ImageHeightResult.js
var p13 = class extends c9 {
  constructor() {
    super(...arguments), this.height = null;
  }
};
e([y({
  type: p10,
  json: {
    read: true,
    write: true
  }
})], p13.prototype, "height", void 0), p13 = e([a4("esri.rest.support.ImageHeightResult")], p13);
var c16 = p13;

// ../../../node_modules/@arcgis/core/rest/support/ImageIdentifyParameters.js
var y11;
var g5 = y11 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterFunctions = null, this.pixelSize = null, this.returnGeometry = true, this.returnCatalogItems = true, this.returnPixelValues = true, this.maxItemCount = null, this.timeExtent = null, this.raster = void 0, this.viewId = void 0, this.processAsMultidimensional = false;
  }
  writeGeometry(t6, e5, r2) {
    null != t6 && (e5.geometryType = p(t6), e5[r2] = JSON.stringify(t6.toJSON()));
  }
  set mosaicRule(t6) {
    let e5 = t6;
    e5?.mosaicMethod && (e5 = j5.fromJSON(__spreadProps(__spreadValues({}, e5.toJSON()), {
      mosaicMethod: e5.mosaicMethod,
      mosaicOperation: e5.mosaicOperation
    }))), this._set("mosaicRule", e5);
  }
  writeMosaicRule(t6, e5, r2) {
    null != t6 && (e5[r2] = JSON.stringify(t6.toJSON()));
  }
  get renderingRule() {
    return i(n.getLogger(this), "renderingRule", {
      replacement: "rasterFunction",
      version: "4.27",
      warnOnce: true
    }), this._get("rasterFunction");
  }
  set renderingRule(t6) {
    i(n.getLogger(this), "renderingRule", {
      replacement: "rasterFunction",
      version: "4.27",
      warnOnce: true
    }), this._set("rasterFunction", t6);
  }
  get renderingRules() {
    return i(n.getLogger(this), "renderingRules", {
      replacement: "rasterFunctions",
      version: "4.27",
      warnOnce: true
    }), this._get("rasterFunctions");
  }
  set renderingRules(t6) {
    i(n.getLogger(this), "renderingRules", {
      replacement: "rasterFunctions",
      version: "4.27",
      warnOnce: true
    }), this._set("rasterFunctions", t6);
  }
  set rasterFunction(t6) {
    let e5 = t6;
    e5?.rasterFunction && (e5 = N2.fromJSON(__spreadProps(__spreadValues({}, e5.toJSON()), {
      rasterFunction: e5.rasterFunction,
      rasterFunctionArguments: e5.rasterFunctionArguments
    }))), this._set("rasterFunction", e5);
  }
  writeRasterFunction(t6, e5, r2) {
    null != t6 && (e5[r2] = JSON.stringify(t6.toJSON())), t6.rasterFunctionDefinition && (e5[r2] = JSON.stringify(t6.rasterFunctionDefinition));
  }
  writeRasterFunctions(t6, e5, r2) {
    null != t6 && (e5[r2] = JSON.stringify(t6.map((t7) => t7.rasterFunctionDefinition || t7.toJSON())));
  }
  writePixelSize(t6, e5, r2) {
    null != t6 && (e5[r2] = JSON.stringify(t6));
  }
  writeTimeExtent(t6, e5, r2) {
    if (null != t6) {
      const o3 = null != t6.start ? t6.start.getTime() : null, i11 = null != t6.end ? t6.end.getTime() : null;
      e5[r2] = null != o3 ? null != i11 ? `${o3},${i11}` : `${o3}` : null;
    }
  }
  clone() {
    return new y11(a({
      geometry: this.geometry,
      mosaicRule: this.mosaicRule,
      rasterFunction: this.rasterFunction,
      rasterFunctions: this.rasterFunctions,
      pixelSize: this.pixelSize,
      returnGeometry: this.returnGeometry,
      returnCatalogItems: this.returnCatalogItems,
      returnPixelValues: this.returnPixelValues,
      maxItemCount: this.maxItemCount,
      processAsMultidimensional: this.processAsMultidimensional,
      raster: this.raster,
      viewId: this.viewId,
      timeExtent: this.timeExtent
    }));
  }
};
e([y({
  json: {
    write: true
  }
})], g5.prototype, "geometry", void 0), e([r("geometry")], g5.prototype, "writeGeometry", null), e([y({
  type: j5,
  json: {
    write: true
  }
})], g5.prototype, "mosaicRule", null), e([r("mosaicRule")], g5.prototype, "writeMosaicRule", null), e([y({
  type: N2
})], g5.prototype, "renderingRule", null), e([y({
  type: [N2]
})], g5.prototype, "renderingRules", null), e([y({
  type: N2,
  json: {
    write: true,
    name: "renderingRule"
  }
})], g5.prototype, "rasterFunction", null), e([r("rasterFunction")], g5.prototype, "writeRasterFunction", null), e([y({
  type: [N2],
  json: {
    write: true,
    name: "renderingRules"
  }
})], g5.prototype, "rasterFunctions", void 0), e([r("rasterFunctions")], g5.prototype, "writeRasterFunctions", null), e([y({
  type: _,
  json: {
    write: true
  }
})], g5.prototype, "pixelSize", void 0), e([r("pixelSize")], g5.prototype, "writePixelSize", null), e([y({
  type: Boolean,
  json: {
    write: true
  }
})], g5.prototype, "returnGeometry", void 0), e([y({
  type: Boolean,
  json: {
    write: true
  }
})], g5.prototype, "returnCatalogItems", void 0), e([y({
  type: Boolean,
  json: {
    write: true
  }
})], g5.prototype, "returnPixelValues", void 0), e([y({
  type: Number,
  json: {
    write: true
  }
})], g5.prototype, "maxItemCount", void 0), e([y({
  type: c,
  json: {
    write: {
      target: "time"
    }
  }
})], g5.prototype, "timeExtent", void 0), e([r("timeExtent")], g5.prototype, "writeTimeExtent", null), e([y({
  json: {
    write: true
  }
})], g5.prototype, "raster", void 0), e([y({
  json: {
    write: true
  }
})], g5.prototype, "viewId", void 0), e([y({
  type: Boolean,
  json: {
    write: true
  }
})], g5.prototype, "processAsMultidimensional", void 0), g5 = y11 = e([a4("esri.rest.support.ImageIdentifyParameters")], g5);
var d10 = g5;

// ../../../node_modules/@arcgis/core/rest/support/ImageIdentifyResult.js
var p14 = class extends f {
  constructor() {
    super(...arguments), this.catalogItemVisibilities = null, this.catalogItems = null, this.location = null, this.name = null, this.objectId = null, this.processedValues = null, this.properties = null, this.value = null;
  }
};
e([y({
  json: {
    write: true
  }
})], p14.prototype, "catalogItemVisibilities", void 0), e([y({
  type: d5,
  json: {
    write: true
  }
})], p14.prototype, "catalogItems", void 0), e([y({
  type: _,
  json: {
    write: true
  }
})], p14.prototype, "location", void 0), e([y({
  json: {
    write: true
  }
})], p14.prototype, "name", void 0), e([y({
  json: {
    write: true
  }
})], p14.prototype, "objectId", void 0), e([y({
  json: {
    write: true
  }
})], p14.prototype, "processedValues", void 0), e([y({
  json: {
    write: true
  }
})], p14.prototype, "properties", void 0), e([y({
  json: {
    write: true
  }
})], p14.prototype, "value", void 0), p14 = e([a4("esri.rest.support.ImageIdentifyResult")], p14);
var l9 = p14;

// ../../../node_modules/@arcgis/core/rest/support/ImagePixelLocationParameters.js
var m7;
var c17 = m7 = class extends f {
  constructor() {
    super(...arguments), this.geometries = null, this.rasterId = null;
  }
  writeGeometry(r2, e5, o3) {
    e5.geometries = {
      geometryType: "esriGeometryPoint",
      geometries: r2.map((r3) => r3.toJSON())
    };
  }
  clone() {
    return new m7({
      geometries: this.geometries?.map((r2) => r2.clone()) ?? [],
      rasterId: this.rasterId
    });
  }
};
e([y({
  type: [_],
  json: {
    write: true
  }
})], c17.prototype, "geometries", void 0), e([r("geometries")], c17.prototype, "writeGeometry", null), e([y({
  type: N,
  json: {
    write: true
  }
})], c17.prototype, "rasterId", void 0), c17 = m7 = e([a4("esri.rest.support.ImagePixelLocationParameters")], c17);
var a12 = c17;

// ../../../node_modules/@arcgis/core/rest/support/ImagePixelLocationResult.js
var t5 = class extends f {
  constructor() {
    super(...arguments), this.geometries = null;
  }
};
e([y({
  json: {
    write: true
  }
})], t5.prototype, "geometries", void 0), t5 = e([a4("esri.rest.support.ImagePixelLocationResult")], t5);
var p15 = t5;

// ../../../node_modules/@arcgis/core/rest/support/ImagePointParameters.js
var c18;
var u4 = c18 = class extends p9 {
  constructor() {
    super(...arguments), this.type = "point", this.geometry = null, this.is3D = false;
  }
  writeGeometry(e5, r2, o3) {
    null != e5 && (r2.geometryType = p(e5), r2[o3] = e5.toJSON());
  }
  get measureOperation() {
    const {
      is3D: e5,
      geometry: r2
    } = this;
    return "point" === r2.type ? e5 ? "point-3D" : "point" : e5 ? "centroid-3D" : "centroid";
  }
  clone() {
    return new c18(a({
      geometry: this.geometry,
      is3D: this.is3D,
      mosaicRule: this.mosaicRule,
      pixelSize: this.pixelSize,
      raster: this.raster
    }));
  }
};
e([y({
  types: n3,
  json: {
    name: "fromGeometry",
    read: y2
  }
})], u4.prototype, "geometry", void 0), e([r("geometry")], u4.prototype, "writeGeometry", null), e([y({
  type: a6.apiValues,
  json: {
    read: a6.read,
    write: a6.write
  }
})], u4.prototype, "measureOperation", null), e([y({
  json: {
    read: true
  }
})], u4.prototype, "is3D", void 0), u4 = c18 = e([a4("esri.rest.support.ImagePointParameters")], u4);
var y12 = u4;

// ../../../node_modules/@arcgis/core/rest/support/ImagePointResult.js
var p16 = class extends c9 {
  constructor() {
    super(...arguments), this.point = null;
  }
};
e([y({
  type: _,
  json: {
    name: "point.value",
    read: true,
    write: true
  }
})], p16.prototype, "point", void 0), p16 = e([a4("esri.rest.support.ImagePointResult")], p16);
var m8 = p16;

// ../../../node_modules/@arcgis/core/rest/support/ImageSampleParameters.js
var d11;
var j7 = d11 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.interpolation = "nearest", this.mosaicRule = null, this.outFields = null, this.pixelSize = null, this.returnFirstValueOnly = true, this.sampleDistance = null, this.sampleCount = null, this.sliceId = null, this.timeExtent = null;
  }
  writeGeometry(t6, e5, o3) {
    null != t6 && (e5.geometryType = p(t6), e5[o3] = t6.toJSON());
  }
  set locations(t6) {
    if (t6?.length) {
      const e5 = new u({
        spatialReference: t6[0].spatialReference,
        points: t6.map(({
          x: t7,
          y: e6
        }) => [t7, e6])
      });
      this._set("locations", t6), this.geometry = e5;
    }
  }
  clone() {
    return new d11(a({
      geometry: this.geometry,
      locations: this.locations,
      interpolation: this.interpolation,
      mosaicRule: this.mosaicRule,
      outFields: this.outFields,
      raster: this.raster,
      returnFirstValueOnly: this.returnFirstValueOnly,
      sampleDistance: this.sampleDistance,
      sampleCount: this.sampleCount,
      sliceId: this.sliceId,
      pixelSize: this.pixelSize,
      timeExtent: this.timeExtent
    }));
  }
};
e([y({
  types: n3,
  json: {
    read: y2
  }
})], j7.prototype, "geometry", void 0), e([r("geometry")], j7.prototype, "writeGeometry", null), e([y()], j7.prototype, "locations", null), e([y({
  type: String,
  json: {
    type: a5.jsonValues,
    read: a5.read,
    write: a5.write
  }
})], j7.prototype, "interpolation", void 0), e([y({
  type: j5,
  json: {
    write: true
  }
})], j7.prototype, "mosaicRule", void 0), e([y({
  type: [String],
  json: {
    write: true
  }
})], j7.prototype, "outFields", void 0), e([y({
  type: _,
  json: {
    write: true
  }
})], j7.prototype, "pixelSize", void 0), e([y({
  type: String,
  json: {
    write: true
  }
})], j7.prototype, "raster", void 0), e([y({
  type: Boolean,
  json: {
    write: true
  }
})], j7.prototype, "returnFirstValueOnly", void 0), e([y({
  type: Number,
  json: {
    write: true
  }
})], j7.prototype, "sampleDistance", void 0), e([y({
  type: Number,
  json: {
    write: true
  }
})], j7.prototype, "sampleCount", void 0), e([y({
  type: Number,
  json: {
    write: true
  }
})], j7.prototype, "sliceId", void 0), e([y({
  type: c,
  json: {
    read: {
      source: "time"
    },
    write: {
      target: "time"
    }
  }
})], j7.prototype, "timeExtent", void 0), j7 = d11 = e([a4("esri.rest.support.ImageSampleParameters")], j7);
var h3 = j7;

// ../../../node_modules/@arcgis/core/rest/support/ImageSample.js
var i9 = class extends f {
  constructor() {
    super(...arguments), this.attributes = null, this.location = null, this.locationId = null, this.rasterId = null, this.resolution = null, this.pixelValue = null;
  }
};
e([y({
  json: {
    write: true
  }
})], i9.prototype, "attributes", void 0), e([y({
  type: _,
  json: {
    write: true
  }
})], i9.prototype, "location", void 0), e([y({
  json: {
    write: true
  }
})], i9.prototype, "locationId", void 0), e([y({
  json: {
    write: true
  }
})], i9.prototype, "rasterId", void 0), e([y({
  json: {
    write: true
  }
})], i9.prototype, "resolution", void 0), e([y({
  json: {
    write: true
  }
})], i9.prototype, "pixelValue", void 0), i9 = e([a4("esri.rest.support.ImageSample")], i9);
var p17 = i9;

// ../../../node_modules/@arcgis/core/rest/support/ImageSampleResult.js
var p18 = class extends f {
  constructor() {
    super(...arguments), this.samples = null;
  }
};
e([y({
  type: [p17],
  json: {
    write: true
  }
})], p18.prototype, "samples", void 0), p18 = e([a4("esri.rest.support.ImageSampleResult")], p18);
var m9 = p18;

// ../../../node_modules/@arcgis/core/rest/support/ImageToMapMultirayParameters.js
var l10 = class extends i2(f) {
  constructor() {
    super(...arguments), this.geometries = [], this.rasterIds = null, this.outSpatialReference = null;
  }
  writeGeometries(e5, r2, o3) {
    r2.geometries = e5?.length ? {
      geometryType: p(e5[0]),
      geometries: e5.map((e6) => __spreadProps(__spreadValues({}, e6.toJSON()), {
        spatialReference: void 0
      }))
    } : null;
  }
};
e([y({
  types: [n3]
})], l10.prototype, "geometries", void 0), e([r("geometries")], l10.prototype, "writeGeometries", null), e([y({
  type: [N],
  json: {
    write: true
  }
})], l10.prototype, "rasterIds", void 0), e([y({
  type: f2,
  json: {
    name: "outSR",
    write: true
  }
})], l10.prototype, "outSpatialReference", void 0), l10 = e([a4("esri.rest.support.ImageToMapMultirayParameters")], l10);
var u5 = l10;

// ../../../node_modules/@arcgis/core/rest/support/ImageToMapParameters.js
var n11 = class extends i2(f) {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterId = null, this.outSpatialReference = null, this.depthOffset = 0, this.adjust = false;
  }
  writeGeometry(o3, e5, r2) {
    null != o3 && (e5.geometryType = p(o3), e5[r2] = __spreadProps(__spreadValues({}, o3.toJSON()), {
      spatialReference: void 0
    }));
  }
};
e([y({
  types: n3,
  json: {
    read: y2,
    write: true
  }
})], n11.prototype, "geometry", void 0), e([r("geometry")], n11.prototype, "writeGeometry", null), e([y({
  json: {
    write: true
  }
})], n11.prototype, "rasterId", void 0), e([y({
  type: f2,
  json: {
    name: "outSR",
    write: true
  }
})], n11.prototype, "outSpatialReference", void 0), e([y({
  json: {
    name: "options.DOff",
    write: true
  }
})], n11.prototype, "depthOffset", void 0), e([y({
  json: {
    name: "options.Adjust",
    write: true
  }
})], n11.prototype, "adjust", void 0), n11 = e([a4("esri.rest.support.ImageToMapParameters")], n11);
var l11 = n11;

// ../../../node_modules/@arcgis/core/rest/support/ImageUrlParameters.js
var p19 = class extends i2(f) {
  constructor() {
    super(...arguments), this.referenceUri = null, this.rasterId = null;
  }
};
e([y({
  type: String,
  json: {
    name: "uri",
    write: true
  }
})], p19.prototype, "referenceUri", void 0), e([y({
  type: Number,
  json: {
    write: true
  }
})], p19.prototype, "rasterId", void 0), p19 = e([a4("esri.rest.support.ImageUrlParameters")], p19);
var c19 = p19;

// ../../../node_modules/@arcgis/core/rest/support/ImageUrlResult.js
var e4 = class extends f {
  constructor() {
    super(...arguments), this.url = null;
  }
};
e([y({
  json: {
    name: "imageURL",
    write: true
  }
})], e4.prototype, "url", void 0), e4 = e([a4("esri.rest.support.ImageUrlResult")], e4);
var p20 = e4;

// ../../../node_modules/@arcgis/core/rest/support/MapToImageParameters.js
var a13 = class extends i2(f) {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterId = null, this.visibleOnly = false;
  }
  writeGeometry(r2, o3, e5) {
    null != r2 && (o3.geometryType = p(r2), o3[e5] = JSON.stringify(r2));
  }
};
e([y({
  types: n3,
  json: {
    read: y2,
    write: true
  }
})], a13.prototype, "geometry", void 0), e([r("geometry")], a13.prototype, "writeGeometry", null), e([y({
  json: {
    write: true
  }
})], a13.prototype, "rasterId", void 0), e([y({
  json: {
    name: "options.VisibleOnly",
    write: true
  }
})], a13.prototype, "visibleOnly", void 0), a13 = e([a4("esri.rest.support.MapToImageParameters")], a13);
var l12 = a13;

// ../../../node_modules/@arcgis/core/rest/support/MeasureAreaFromImageResult.js
var m10 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.length = null, this.area = null, this.center = null;
  }
  readCenter(e5, r2) {
    return e5.spatialReference || (e5 = __spreadProps(__spreadValues({}, e5), {
      spatialReference: r2.Shape.spatialReference
    })), _.fromJSON(e5);
  }
};
e([y({
  types: n3,
  json: {
    name: "Shape",
    read: y2,
    write: true
  }
})], m10.prototype, "geometry", void 0), e([y({
  json: {
    name: "Length",
    write: true
  }
})], m10.prototype, "length", void 0), e([y({
  json: {
    name: "Area",
    write: true
  }
})], m10.prototype, "area", void 0), e([y({
  json: {
    name: "Center",
    write: true
  }
})], m10.prototype, "center", void 0), e([o("center")], m10.prototype, "readCenter", null), m10 = e([a4("esri.rest.support.MeasureAreaFromImageResult")], m10);
var i10 = m10;

// ../../../node_modules/@arcgis/core/rest/support/MeasureFromImageParameters.js
var c20;
var n12 = c20 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterId = void 0;
  }
  writeGeometry(r2, o3, e5) {
    null != r2 && (o3.geometryType = p(r2), o3[e5] = __spreadProps(__spreadValues({}, r2.toJSON()), {
      spatialReference: void 0
    }));
  }
  clone() {
    const r2 = a({
      geometry: this.geometry,
      rasterId: this.rasterId
    });
    return new c20(r2);
  }
};
e([y({
  types: n3,
  json: {
    name: "fromGeometry",
    read: y2,
    write: true
  }
})], n12.prototype, "geometry", void 0), e([r("geometry")], n12.prototype, "writeGeometry", null), e([y({
  json: {
    write: true
  }
})], n12.prototype, "rasterId", void 0), n12 = c20 = e([a4("esri.rest.support.MeasureFromImageParameters")], n12);
var y13 = n12;

// ../../../node_modules/@arcgis/core/rest/support/MeasureLengthFromImageResult.js
var m11 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.length = null;
  }
};
e([y({
  types: n3,
  json: {
    name: "Shape",
    read: y2,
    write: true
  }
})], m11.prototype, "geometry", void 0), e([y({
  json: {
    name: "Length",
    write: true
  }
})], m11.prototype, "length", void 0), m11 = e([a4("esri.rest.support.MeasureLengthFromImageResult")], m11);
var c21 = m11;

// ../../../node_modules/@arcgis/core/rest/imageService.js
function H(t6) {
  const e5 = t6?.time;
  if (e5 && (null != e5.start || null != e5.end)) {
    const r2 = [];
    null != e5.start && r2.push(e5.start), null == e5.end || r2.includes(e5.end) || r2.push(e5.end), t6.time = r2.join(",");
  }
}
function B3(t6, o3, m12) {
  return __async(this, null, function* () {
    o3 = g(h, o3);
    const i11 = f5(t6), p21 = o3.geometry ? [o3.geometry] : [], u6 = yield R(p21), c22 = o3.toJSON();
    H(c22);
    const f8 = u6?.[0];
    null != f8 && (c22.geometry = rt(f8));
    const l13 = s4(__spreadValues(__spreadProps(__spreadValues({}, i11.query), {
      f: "json"
    }), c22));
    return i3(l13, m12);
  });
}
function D2(r2, o3, m12) {
  return __async(this, null, function* () {
    const i11 = (o3 = g(l6, o3)).toJSON();
    null != i11.angleName && (i11.angleName = i11.angleName.join(",")), o3?.point?.spatialReference?.imageCoordinateSystem && (i11.point.spatialReference = ot(o3.point.spatialReference)), o3?.spatialReference?.imageCoordinateSystem && (i11.spatialReference = at(o3.spatialReference));
    const c22 = f5(r2), f8 = s4(__spreadValues(__spreadProps(__spreadValues({}, c22.query), {
      f: "json"
    }), i11)), l13 = i3(f8, m12), {
      data: g6
    } = yield U(`${c22.path}/computeAngles`, l13);
    return g6.spatialReference = g6.spatialReference ? null != g6.spatialReference.geodataXform ? new f2({
      wkid: 0,
      imageCoordinateSystem: g6.spatialReference
    }) : f2.fromJSON(g6.spatialReference) : null, "NaN" === g6.north && (g6.north = null), "NaN" === g6.up && (g6.up = null), new i6(g6);
  });
}
function k3(r2, o3, m12) {
  return __async(this, null, function* () {
    const i11 = (o3 = g(a12, o3)).toJSON(), {
      geometries: p21
    } = o3;
    if (p21) for (let t6 = 0; t6 < p21.length; t6++) p21[t6].spatialReference?.imageCoordinateSystem && (i11.geometries.geometries[t6].spatialReference = ot(p21[t6].spatialReference));
    const u6 = f5(r2), c22 = s4(__spreadValues(__spreadProps(__spreadValues({}, u6.query), {
      f: "json"
    }), i11)), f8 = i3(c22, m12), {
      data: l13
    } = yield U(`${u6.path}/computePixelLocation`, f8);
    return p15.fromJSON(l13);
  });
}
function z(e5, r2, o3) {
  return __async(this, null, function* () {
    const s11 = yield B3(e5, r2, o3), n14 = f5(e5), {
      data: m12
    } = yield U(`${n14.path}/computeStatisticsHistograms`, s11), {
      statistics: i11
    } = m12;
    return i11?.length && i11.forEach((t6) => {
      t6.avg = t6.mean, t6.stddev = t6.standardDeviation;
    }), {
      statistics: i11,
      histograms: m12.histograms
    };
  });
}
function E(e5, r2, o3) {
  return __async(this, null, function* () {
    const s11 = yield B3(e5, r2, o3), n14 = f5(e5), {
      data: m12
    } = yield U(`${n14.path}/computeHistograms`, s11);
    return {
      histograms: m12.histograms
    };
  });
}
function V2(o3, m12, i11) {
  return __async(this, null, function* () {
    const p21 = (m12 = g(h3, m12)).toJSON();
    H(p21), p21.outFields?.length && (p21.outFields = p21.outFields.join(","));
    const u6 = yield R(m12.geometry), c22 = u6?.[0];
    null != c22 && (p21.geometry = rt(c22));
    const f8 = f5(o3), l13 = s4(__spreadValues(__spreadProps(__spreadValues({}, f8.query), {
      f: "json"
    }), p21)), g6 = i3(l13, i11), {
      data: y14
    } = yield U(`${f8.path}/getSamples`, g6), j8 = y14?.samples?.map((t6) => {
      const e5 = "NaN" === t6.value || "" === t6.value ? null : t6.value.split(" ").map((t7) => Number(t7));
      return __spreadProps(__spreadValues({}, t6), {
        pixelValue: e5
      });
    });
    return m9.fromJSON({
      samples: j8
    });
  });
}
function X(o3, m12, i11) {
  return __async(this, null, function* () {
    m12 = g(d10, m12);
    const p21 = f5(o3), u6 = m12.geometry ? [m12.geometry] : [];
    return R(u6).then((e5) => {
      const r2 = m12.toJSON(), o4 = e5?.[0];
      null != o4 && (r2.geometry = JSON.stringify(rt(o4)));
      const a14 = s4(__spreadValues(__spreadProps(__spreadValues({}, p21.query), {
        f: "json"
      }), r2)), u7 = i3(a14, i11);
      return U(p21.path + "/identify", u7);
    }).then((t6) => l9.fromJSON(t6.data));
  });
}
function K(t6, r2, o3) {
  return __async(this, null, function* () {
    r2 = g(c15, r2);
    const a14 = yield Z2(t6, r2, [r2.fromGeometry, r2.toGeometry], o3);
    return c16.fromJSON(a14);
  });
}
function Q(t6, r2, o3) {
  return __async(this, null, function* () {
    r2 = g(y7, r2);
    const a14 = yield Z2(t6, r2, [r2.geometry], o3);
    return c10.fromJSON(a14);
  });
}
function W(t6, r2, o3) {
  return __async(this, null, function* () {
    r2 = g(y12, r2);
    const a14 = yield Z2(t6, r2, [r2.geometry], o3);
    return m8.fromJSON(a14);
  });
}
function Y(t6, r2, o3) {
  return __async(this, null, function* () {
    r2 = g(u3, r2);
    const a14 = yield Z2(t6, r2, [r2.fromGeometry, r2.toGeometry], o3);
    return i8.fromJSON(a14);
  });
}
function Z2(e5, o3, m12, i11) {
  return __async(this, null, function* () {
    const p21 = f5(e5), u6 = yield R(m12), c22 = o3.toJSON();
    null != u6[0] && (c22.fromGeometry = JSON.stringify(rt(u6[0]))), null != u6[1] && (c22.toGeometry = JSON.stringify(rt(u6[1])));
    const f8 = s4(__spreadValues(__spreadProps(__spreadValues({}, p21.query), {
      f: "json"
    }), c22)), l13 = i3(f8, i11), {
      data: g6
    } = yield U(p21.path + "/measure", l13);
    return g6;
  });
}
function _2(t6, e5, r2) {
  return __async(this, null, function* () {
    const o3 = yield et(t6, e5, r2);
    return c21.fromJSON(o3);
  });
}
function tt(t6, e5, r2) {
  return __async(this, null, function* () {
    const o3 = yield et(t6, e5, r2);
    return i10.fromJSON(o3);
  });
}
function et(r2, o3, m12) {
  return __async(this, null, function* () {
    o3 = g(y13, o3);
    const i11 = f5(r2), p21 = o3.toJSON(), u6 = s4(__spreadValues(__spreadProps(__spreadValues({}, i11.query), {
      f: "json"
    }), p21)), c22 = i3(u6, m12), {
      data: f8
    } = yield U(i11.path + "/measureFromImage", c22);
    return f8;
  });
}
function rt(t6) {
  const e5 = t6.toJSON();
  return t6.spatialReference?.imageCoordinateSystem && (e5.spatialReference = ot(t6.spatialReference)), e5;
}
function ot(t6) {
  const {
    imageCoordinateSystem: e5
  } = t6;
  if (e5) {
    const {
      id: t7,
      referenceServiceName: r2
    } = e5;
    return null != t7 ? r2 ? {
      icsid: t7,
      icsns: r2
    } : {
      icsid: t7
    } : {
      ics: e5
    };
  }
  return t6.toJSON();
}
function at(t6, e5) {
  if (!t6.imageCoordinateSystem) return d2(t6);
  const r2 = ot(t6), {
    icsid: a14,
    icsns: s11
  } = r2;
  return null == a14 || null != s11 && !e5?.toLowerCase().includes("/" + s11.toLowerCase() + "/") ? JSON.stringify(r2) : `0:${a14}`;
}
function st(r2, o3, m12) {
  return __async(this, null, function* () {
    o3 = g(c11, o3);
    const i11 = f5(r2), p21 = o3.toJSON();
    o3.outSpatialReference && (p21.outSR = at(o3.outSpatialReference));
    const u6 = s4(__spreadValues(__spreadProps(__spreadValues({}, i11.query), {
      f: "json"
    }), p21)), c22 = i3(u6, m12), {
      data: f8
    } = yield U(i11.path + "/queryBoundary", c22);
    return c12.fromJSON(f8);
  });
}
function nt(o3, m12, i11) {
  return __async(this, null, function* () {
    const p21 = (m12 = g(y9, m12)).toJSON();
    H(p21), p21.objectIds?.length && (p21.objectIds = p21.objectIds.join(",")), p21.geometry || p21.objectIds || p21.time || p21.where || (p21.where = "1=1");
    const u6 = yield R(m12.geometry), c22 = u6?.[0];
    null != c22 && (p21.geometry = rt(c22));
    const f8 = c22?.spatialReference ?? m12.geometry?.spatialReference;
    f8 && (p21.inSR = at(f8));
    const l13 = f5(o3), g6 = s4(__spreadValues(__spreadProps(__spreadValues({}, l13.query), {
      f: "json"
    }), p21)), y14 = i3(g6, i11), {
      data: j8
    } = yield U(`${l13.path}/queryGPSInfo`, y14);
    return a11.fromJSON(j8);
  });
}
function mt(r2, o3, m12) {
  return __async(this, null, function* () {
    const i11 = (o3 = g(l11, o3)).toJSON();
    o3.geometry.spatialReference.imageCoordinateSystem && (i11.geometry = rt(o3.geometry)), o3.depthOffset && o3.adjust || delete i11.options;
    const p21 = f5(r2), u6 = s4(__spreadValues(__spreadProps(__spreadValues({}, p21.query), {
      f: "json"
    }), i11)), c22 = i3(u6, m12), {
      data: f8
    } = yield U(`${p21.path}/imageToMap`, c22);
    return y2(f8);
  });
}
function it(r2, o3, m12) {
  return __async(this, null, function* () {
    const i11 = (o3 = g(u5, o3)).toJSON();
    o3.rasterIds?.length && (i11.rasterIds = o3.rasterIds.join(","));
    const p21 = f5(r2), u6 = s4(__spreadValues(__spreadProps(__spreadValues({}, p21.query), {
      f: "json"
    }), i11)), c22 = i3(u6, m12), {
      data: f8
    } = yield U(`${p21.path}/imageToMapMultiray`, c22);
    return y2(f8);
  });
}
function pt(o3, m12, i11) {
  return __async(this, null, function* () {
    const p21 = (m12 = g(l12, m12)).toJSON(), u6 = yield R(m12.geometry), c22 = u6?.[0];
    null != c22 && (p21.geometry = rt(c22)), m12.visibleOnly || delete p21.options;
    const f8 = c22?.spatialReference ?? m12.geometry?.spatialReference;
    f8 && (p21.inSR = at(f8));
    const l13 = f5(o3), g6 = s4(__spreadValues(__spreadProps(__spreadValues({}, l13.query), {
      f: "json"
    }), p21)), y14 = i3(g6, i11), {
      data: j8
    } = yield U(`${l13.path}/mapToImage`, y14);
    return y2(j8);
  });
}
function ut(r2, o3, m12) {
  return __async(this, null, function* () {
    const i11 = (o3 = g(c19, o3)).toJSON(), p21 = f5(r2), u6 = s4(__spreadValues(__spreadProps(__spreadValues({}, p21.query), {
      f: "json"
    }), i11)), c22 = i3(u6, m12), {
      data: f8
    } = yield U(`${p21.path}/getImageUrl`, c22);
    return p20.fromJSON(f8);
  });
}
function ct(o3, p21, u6) {
  return __async(this, null, function* () {
    const c22 = (p21 = g(m4, p21)).toJSON(), f8 = yield R([p21.fromGeometry, p21.toGeometry]);
    null != f8[0] && (c22.fromGeometry = rt(f8[0]), f8[0].spatialReference && (c22.inSR = at(f8[0].spatialReference))), null != f8[1] && (c22.toGeometry = rt(f8[1])), p21.objectIds?.length && (c22.objectIds = c22.objectIds.join(","));
    const l13 = f5(o3), g6 = s4(__spreadValues(__spreadProps(__spreadValues({}, l13.query), {
      f: "json"
    }), c22)), y14 = i3(g6, u6), {
      data: j8
    } = yield U(`${l13.path}/find`, y14);
    return c7.fromJSON(j8);
  });
}

// ../../../node_modules/@arcgis/core/rest/imageService/getCatalogItemRasterInfo.js
function n13(n14, m12, p21) {
  return __async(this, null, function* () {
    const f8 = f5(n14), u6 = s4(__spreadProps(__spreadValues({}, f8?.query), {
      f: "json"
    })), h4 = i3(u6, p21), d12 = `${f8?.path}/${m12}/info`, c22 = U(`${d12}`, h4), g6 = U(`${d12}/keyProperties`, h4), x3 = yield Promise.allSettled([c22, g6]), y14 = "fulfilled" === x3[0].status ? x3[0].value.data : null, v2 = "fulfilled" === x3[1].status ? x3[1].value.data : null;
    let P2 = null;
    y14.statistics?.length && (P2 = y14.statistics.map((e5) => ({
      min: e5[0],
      max: e5[1],
      avg: e5[2],
      stddev: e5[3]
    })));
    const S3 = w.fromJSON(y14.extent), j8 = Math.ceil(S3.width / y14.pixelSizeX - 0.1), w4 = Math.ceil(S3.height / y14.pixelSizeY - 0.1), b5 = S3.spatialReference, k4 = new _({
      x: y14.pixelSizeX,
      y: y14.pixelSizeY,
      spatialReference: b5
    }), z2 = y14.histograms?.length ? y14.histograms : null, L3 = new n4({
      origin: y14.origin,
      blockWidth: y14.blockWidth,
      blockHeight: y14.blockHeight,
      firstPyramidLevel: y14.firstPyramidLevel,
      maximumPyramidLevel: y14.maxPyramidLevel
    });
    return new m({
      width: j8,
      height: w4,
      bandCount: y14.bandCount,
      extent: S3,
      spatialReference: b5,
      pixelSize: k4,
      pixelType: y14.pixelType.toLowerCase(),
      statistics: P2,
      histograms: z2,
      keyProperties: v2,
      storageInfo: L3
    });
  });
}

// ../../../node_modules/@arcgis/core/layers/mixins/ArcGISImageService.js
var Oe = /* @__PURE__ */ new Set(["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff"]);
var je = j(a3, {
  min: 0,
  max: 255
});
function Pe(e5) {
  if (!e5) return null;
  const t6 = JSON.stringify(e5).match(/"rasterFunction":"(.*?")/gi), i11 = t6?.map((e6) => e6.slice(18, -1));
  return i11 ? i11.join("/") : null;
}
var Ce = (d12) => {
  let g6 = class extends d12 {
    constructor() {
      super(...arguments), this._functionRasterInfos = {}, this._rasterJobHandler = {
        instance: null,
        refCount: 0,
        connectionPromise: null
      }, this._cachedRendererJson = null, this._serviceSupportsMosaicRule = null, this._rasterAttributeTableFieldPrefix = "Raster.", this.adjustAspectRatio = null, this.bandIds = void 0, this.capabilities = null, this.compressionQuality = void 0, this.compressionTolerance = 0.01, this.copyright = null, this.defaultMosaicRule = null, this.definitionExpression = null, this.exportImageServiceParameters = null, this.rasterInfo = null, this.fields = null, this.fullExtent = null, this.hasMultidimensions = false, this.imageMaxHeight = 4100, this.imageMaxWidth = 4100, this.interpolation = void 0, this.minScale = 0, this.maxScale = 0, this.multidimensionalInfo = null, this.multidimensionalSubset = null, this.noData = null, this.noDataInterpretation = void 0, this.objectIdField = null, this.geometryType = "polygon", this.typeIdField = null, this.types = [], this.pixelFilter = null, this.raster = void 0, this.sourceType = null, this.viewId = void 0, this.symbolizer = null, this.rasterFunctionInfos = null, this.serviceDataType = null, this.spatialReference = null, this.pixelType = null, this.serviceRasterInfo = null, this.sourceJSON = null, this.url = null, this.version = void 0;
    }
    initialize() {
      this._set("exportImageServiceParameters", new y6({
        layer: this
      }));
    }
    readServiceSupportsMosaicRule(e5, t6) {
      return this._isMosaicRuleSupported(t6);
    }
    get _rasterFunctionNamesIndex() {
      const e5 = /* @__PURE__ */ new Map();
      return !this.rasterFunctionInfos || null != this.rasterFunctionInfos && this.rasterFunctionInfos.length < 1 || null != this.rasterFunctionInfos && this.rasterFunctionInfos.forEach((t6) => {
        e5.set(t6.name.toLowerCase().replaceAll(/ /gi, "_"), t6.name);
      }), e5;
    }
    readBandIds(e5, t6) {
      if (Array.isArray(e5) && e5.length > 0 && e5.every((e6) => "number" == typeof e6)) return e5;
    }
    readCapabilities(e5, t6) {
      return this._readCapabilities(t6);
    }
    writeCompressionQuality(e5, t6, i11) {
      null != e5 && "lerc" !== this.format && (t6[i11] = e5);
    }
    writeCompressionTolerance(e5, t6, i11) {
      "lerc" === this.format && null != e5 && (t6[i11] = e5);
    }
    readDefaultMosaicRule(e5, t6) {
      return this._serviceSupportsMosaicRule ? j5.fromJSON(t6) : null;
    }
    get fieldsIndex() {
      return this.fields ? new Z(this.fields) : null;
    }
    set format(e5) {
      e5 && Oe.has(e5.toLowerCase()) && this._set("format", e5.toLowerCase());
    }
    readFormat(e5, t6) {
      return "esriImageServiceDataTypeVector-UV" === t6.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === t6.serviceDataType || null != this.pixelFilter ? "lerc" : "jpgpng";
    }
    readMinScale(e5, t6) {
      return null != t6.minLOD && null != t6.maxLOD ? e5 : 0;
    }
    readMaxScale(e5, t6) {
      return null != t6.minLOD && null != t6.maxLOD ? e5 : 0;
    }
    set mosaicRule(e5) {
      let t6 = e5;
      t6?.mosaicMethod && (t6 = j5.fromJSON(__spreadProps(__spreadValues({}, t6.toJSON()), {
        mosaicMethod: t6.mosaicMethod,
        mosaicOperation: t6.mosaicOperation
      }))), this._set("mosaicRule", t6);
    }
    readMosaicRule(e5, t6) {
      const i11 = e5 || t6.mosaicRule;
      return i11 ? j5.fromJSON(i11) : this._isMosaicRuleSupported(t6) ? j5.fromJSON(t6) : null;
    }
    writeMosaicRule(e5, t6, i11) {
      let r2 = this.mosaicRule;
      const s11 = this.definitionExpression;
      r2 ? s11 && s11 !== r2.where && (r2 = r2.clone(), r2.where = s11) : s11 && (r2 = new j5({
        where: s11
      })), this._isValidCustomizedMosaicRule(r2) && (t6[i11] = r2.toJSON());
    }
    writeNoData(e5, t6, i11) {
      null != e5 && "number" == typeof e5 && (t6[i11] = je(e5));
    }
    readObjectIdField(e5, t6) {
      if (!e5) {
        const i11 = t6.fields.find((e6) => "esriFieldTypeOID" === e6.type || "oid" === e6.type);
        e5 = i11?.name;
      }
      return e5;
    }
    get parsedUrl() {
      return I(this.url);
    }
    readSourceType(e5, t6) {
      return this._isMosaicDataset(t6) ? "mosaic-dataset" : "raster-dataset";
    }
    set renderer(e5) {
      this.loaded && (e5 = this._configRenderer(e5)), this._set("renderer", e5);
    }
    readRenderer(e5, t6, i11) {
      const r2 = t6?.layerDefinition?.drawingInfo?.renderer, n14 = c2(r2, i11);
      return null == n14 ? null : ("vector-field" === n14.type && t6.symbolTileSize && !r2.symbolTileSize && (n14.symbolTileSize = t6.symbolTileSize), p6(n14) || n.getLogger(this).warn("ArcGISImageService", "Imagery layer doesn't support given renderer type."), n14);
    }
    writeRenderer(e5, t6, i11) {
      t6.layerDefinition = t6.layerDefinition || {}, t6.layerDefinition.drawingInfo = t6.layerDefinition.drawingInfo || {}, t6.layerDefinition.drawingInfo.renderer = e5.toJSON(), "vector-field" === e5.type && (t6.symbolTileSize = e5.symbolTileSize);
    }
    get rasterFields() {
      const e5 = this._rasterAttributeTableFieldPrefix, t6 = new y3({
        name: "Raster.ItemPixelValue",
        alias: "Item Pixel Value",
        domain: null,
        editable: false,
        length: 50,
        type: "string"
      }), i11 = new y3({
        name: "Raster.ServicePixelValue",
        alias: "Service Pixel Value",
        domain: null,
        editable: false,
        length: 50,
        type: "string"
      }), r2 = new y3({
        name: "Raster.ServicePixelValue.Raw",
        alias: "Raw Service Pixel Value",
        domain: null,
        editable: false,
        length: 50,
        type: "string"
      });
      let s11 = this.fields ? a(this.fields) : [];
      s11.push(i11), this.capabilities?.operations.supportsQuery && this.fields && this.fields.length > 0 && s11.push(t6), this.version >= 10.4 && null != this.rasterFunctionInfos && this.rasterFunctionInfos.some((e6) => "none" === e6.name.toLowerCase()) && s11.push(r2), null != this.rasterFunctionInfos && this.rasterFunctionInfos.filter((e6) => "none" !== e6.name.toLowerCase()).forEach((e6) => {
        s11.push(new y3({
          name: "Raster.ServicePixelValue." + e6.name,
          alias: e6.name,
          domain: null,
          editable: false,
          length: 50,
          type: "string"
        }));
      }), this._isVectorDataSet() && (s11.push(new y3({
        name: "Raster.Magnitude",
        alias: "Magnitude",
        domain: null,
        editable: false,
        type: "double"
      })), s11.push(new y3({
        name: "Raster.Direction",
        alias: "Direction",
        domain: null,
        editable: false,
        type: "double"
      })));
      const {
        attributeTable: n14
      } = this.rasterInfo ?? {};
      if (null != n14) {
        const t7 = n14.fields.filter((e6) => "esriFieldTypeOID" !== e6.type && "value" !== e6.name.toLowerCase()).map((t8) => {
          const i12 = a(t8);
          return i12.name = e5 + t8.name, i12;
        });
        s11 = s11.concat(t7);
      }
      return s11;
    }
    get renderingRule() {
      return i(n.getLogger(this), "renderingRule", {
        replacement: "rasterFunction",
        version: "4.27",
        warnOnce: true
      }), this.rasterFunction;
    }
    set renderingRule(e5) {
      i(n.getLogger(this), "renderingRule", {
        replacement: "rasterFunction",
        version: "4.27",
        warnOnce: true
      }), this._set("rasterFunction", e5);
    }
    set rasterFunction(e5) {
      let t6 = e5;
      t6?.rasterFunction && (t6 = N2.fromJSON(__spreadProps(__spreadValues({}, t6.toJSON()), {
        rasterFunction: t6.rasterFunction,
        rasterFunctionArguments: t6.rasterFunctionArguments
      }))), this._set("rasterFunction", t6);
    }
    readRasterFunction(e5, t6) {
      const i11 = t6.rasterFunctionInfos;
      return t6.renderingRule || i11?.length && "None" !== i11[0].name ? this._isRFTJson(t6.renderingRule) ? N2.fromJSON({
        rasterFunctionDefinition: t6.renderingRule
      }) : N2.fromJSON(t6.renderingRule || {
        rasterFunctionInfos: t6.rasterFunctionInfos
      }) : null;
    }
    readSpatialReference(e5, t6) {
      const i11 = e5 || t6.extent.spatialReference;
      return i11 ? f2.fromJSON(i11) : null;
    }
    readPixelType(e5) {
      return n6.fromJSON(e5) || e5;
    }
    writePixelType(e5, t6, i11) {
      null != this.serviceRasterInfo && this.pixelType === this.serviceRasterInfo.pixelType || (t6[i11] = n6.toJSON(e5));
    }
    readVersion(e5, t6) {
      let i11 = t6.currentVersion;
      return i11 || (i11 = t6.hasOwnProperty("fields") || t6.hasOwnProperty("timeInfo") ? 10 : 9.3), i11;
    }
    applyFilter(e5) {
      let t6 = e5;
      return this.pixelFilter && (t6 = this._clonePixelData(e5), this.pixelFilter(t6)), t6;
    }
    applyRenderer(e5, t6) {
      return __async(this, null, function* () {
        let i11 = e5;
        const {
          renderer: r2,
          symbolizer: s11,
          pixelFilter: n14,
          bandIds: a14
        } = this;
        if (!this._isPicture() && r2 && s11 && !n14) {
          const n15 = JSON.stringify(this._cachedRendererJson) !== JSON.stringify(r2.toJSON()), o3 = this._rasterJobHandler.instance;
          if (o3) {
            n15 && (s11.bind(), yield o3.updateSymbolizer(s11, t6), this._cachedRendererJson = r2.toJSON());
            const l13 = yield o3.symbolize(__spreadValues({
              bandIds: a14
            }, e5), t6);
            i11 = {
              extent: e5.extent,
              pixelBlock: l13
            };
          } else i11 = {
            extent: e5.extent,
            pixelBlock: s11.symbolize(__spreadValues({
              bandIds: a14
            }, e5))
          };
        }
        return i11;
      });
    }
    destroy() {
      this._shutdownJobHandler();
    }
    increaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount++;
    }
    decreaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount--, this._rasterJobHandler.refCount <= 0 && this._shutdownJobHandler();
    }
    computeAngles(e5, t6) {
      return __async(this, null, function* () {
        if (!(yield this._fetchCapabilities(t6?.signal)).operations.supportsComputeAngles) throw new s("imagery-layer:compute-angles", "this operation is not supported on the input image service");
        return D2(this.url, e5, this._getRequestOptions(t6));
      });
    }
    computePixelSpaceLocations(e5, t6) {
      return __async(this, null, function* () {
        if (!(yield this._fetchCapabilities(t6?.signal)).operations.supportsComputePixelLocation) throw new s("imagery-layer:compute-pixel-space-locations", "this operation is not supported on the input image service");
        return k3(this.url, e5, this._getRequestOptions(t6));
      });
    }
    computeHistograms(e5, t6) {
      return __async(this, null, function* () {
        if (!(yield this._fetchCapabilities(t6?.signal)).operations.supportsComputeHistograms) throw new s("imagery-layer:compute-histograms", "this operation is not supported on the input image service");
        return e5 = a(e5), this._applyMosaicAndRenderingRules(e5), E(this.url, e5, this._getRequestOptions(t6));
      });
    }
    computeStatisticsHistograms(e5, t6) {
      return __async(this, null, function* () {
        if (!(yield this._fetchCapabilities(t6?.signal)).operations.supportsComputeStatisticsHistograms) throw new s("imagery-layer:compute-statistics-histograms", "this operation is not supported on the input image service");
        return e5 = a(e5), this._applyMosaicAndRenderingRules(e5), z(this.url, e5, this._getRequestOptions(t6));
      });
    }
    measureHeight(e5, t6) {
      return __async(this, null, function* () {
        const i11 = yield this._fetchCapabilities(t6?.signal);
        if (!("base-and-top" === e5.operationType ? i11.mensuration.supportsHeightFromBaseAndTop : "base-and-top-shadow" === e5.operationType ? i11.mensuration.supportsHeightFromBaseAndTopShadow : i11.mensuration.supportsHeightFromTopAndTopShadow)) throw new s("imagery-layer:measure-height", "this operation is not supported on the input image service");
        return e5 = a(e5), this._applyMosaicAndRenderingRules(e5), K(this.url, e5, this._getRequestOptions(t6));
      });
    }
    measureAreaAndPerimeter(e5, t6) {
      return __async(this, null, function* () {
        const i11 = yield this._fetchCapabilities(t6?.signal);
        if (!(i11.mensuration.supportsAreaAndPerimeter && (!e5.is3D || i11.mensuration.supports3D))) throw new s("imagery-layer:measure-area-and-perimeter", "this operation is not supported on the input image service");
        return e5 = a(e5), this._applyMosaicAndRenderingRules(e5), Q(this.url, e5, this._getRequestOptions(t6));
      });
    }
    measureDistanceAndAngle(e5, t6) {
      return __async(this, null, function* () {
        const i11 = yield this._fetchCapabilities(t6?.signal);
        if (!(i11.mensuration.supportsDistanceAndAngle && (!e5.is3D || i11.mensuration.supports3D))) throw new s("imagery-layer:measure-distance-and-angle", "this operation is not supported on the input image service");
        return e5 = a(e5), this._applyMosaicAndRenderingRules(e5), Y(this.url, e5, this._getRequestOptions(t6));
      });
    }
    measurePointOrCentroid(e5, t6) {
      return __async(this, null, function* () {
        const i11 = yield this._fetchCapabilities(t6?.signal);
        if (!(i11.mensuration.supportsPointOrCentroid && (!e5.is3D || i11.mensuration.supports3D))) throw new s("imagery-layer:measure-point-or-centroid", "this operation is not supported on the input image service");
        return e5 = a(e5), this._applyMosaicAndRenderingRules(e5), W(this.url, e5, this._getRequestOptions(t6));
      });
    }
    measureLengthFromImage(e5, t6) {
      return __async(this, null, function* () {
        if (!(yield this._fetchCapabilities(t6?.signal)).operations.supportsMeasureFromImage) throw new s("imagery-layer:measure-length-from-image", "this operation is not supported on the input image service");
        if ("polyline" !== e5.geometry.type) throw new s("imagery-layer:measure-length-from-image", "this input geometry must be a polyline");
        return _2(this.url, e5, this._getRequestOptions(t6));
      });
    }
    measureAreaFromImage(e5, t6) {
      return __async(this, null, function* () {
        if (!(yield this._fetchCapabilities(t6?.signal)).operations.supportsMeasureFromImage) throw new s("imagery-layer:measure-area-from-image", "this operation is not supported on the input image service");
        if ("polygon" !== e5.geometry.type) throw new s("imagery-layer:measure-area-from-image", "this input geometry must be a polygon");
        return tt(this.url, e5, this._getRequestOptions(t6));
      });
    }
    getField(e5) {
      const {
        fieldsIndex: t6
      } = this;
      return null != t6 ? t6.get(e5) : void 0;
    }
    getFieldDomain(e5, t6) {
      const i11 = this.getField(e5);
      return i11 ? i11.domain : null;
    }
    fetchImage(_0, _1, _22) {
      return __async(this, arguments, function* (e5, t6, i11, r2 = {}) {
        if (null == e5 || null == t6 || null == i11) throw new s("imagery-layer:fetch-image", "Insufficient parameters for requesting an image. A valid extent, width and height values are required.");
        if (this.renderer || this.symbolizer) {
          const e6 = yield this._generateRasterInfo(this.rasterFunction, {
            signal: r2.signal
          });
          e6 && (this.rasterInfo = e6);
        }
        const s11 = this.getExportImageServiceParameters(e5, t6, i11, r2.timeExtent);
        if (null == s11) {
          if (r2.requestAsImageElement && this._canRequestImageElement(this.format)) {
            const e6 = document.createElement("canvas");
            if (e6.width = t6, e6.height = i11, r2.returnImageBitmap) {
              return {
                imageBitmap: yield t2(e6, `${Ce2(this.parsedUrl)}/exportImage`, r2.signal)
              };
            }
            return {
              imageOrCanvasElement: e6
            };
          }
          const {
            bandIds: s12,
            rasterInfo: n15
          } = this, a15 = (s12?.length || n15.bandCount) ?? 0, o3 = t6 * i11, l14 = n15.pixelType, u6 = [];
          for (let e6 = 0; e6 < a15; e6++) u6.push(g2.createEmptyBand(l14, o3));
          return {
            pixelData: {
              pixelBlock: new g2({
                width: t6,
                height: i11,
                pixels: u6,
                mask: new Uint8Array(o3),
                pixelType: l14
              }),
              extent: e5
            }
          };
        }
        const n14 = !!r2.requestAsImageElement && !this.pixelFilter, a14 = n14 && !!r2.returnImageBitmap, l13 = {
          imageServiceParameters: s11,
          imageProps: {
            extent: e5,
            width: t6,
            height: i11,
            format: this.format
          },
          requestAsImageElement: n14,
          returnImageBitmap: a14,
          signal: r2.signal
        };
        return this._requestArrayBuffer(l13);
      });
    }
    fetchKeyProperties(e5) {
      return U(Ce2(this.parsedUrl) + "/keyProperties", {
        query: this._getQueryParams({
          renderingRule: this.version >= 10.3 ? e5?.rasterFunction : null
        })
      }).then((e6) => e6.data);
    }
    fetchRasterAttributeTable(e5) {
      return this.version < 10.1 ? Promise.reject(new s("#fetchRasterAttributeTable()", "Failed to get rasterAttributeTable")) : U(Ce2(this.parsedUrl) + "/rasterAttributeTable", {
        query: this._getQueryParams({
          renderingRule: this.version >= 10.3 ? e5?.rasterFunction : null
        })
      }).then((e6) => d5.fromJSON(e6.data));
    }
    getCatalogItemRasterInfo(e5, t6) {
      const i11 = __spreadProps(__spreadValues({}, t6), {
        query: this._getQueryParams()
      });
      return n13(Ce2(this.parsedUrl), e5, i11);
    }
    getCatalogItemICSInfo(e5, t6) {
      return __async(this, null, function* () {
        const {
          data: i11
        } = yield U(Ce2(this.parsedUrl) + "/" + e5 + "/info/ics", __spreadValues({
          query: this._getQueryParams()
        }, t6)), r2 = i11?.ics;
        if (!r2) return;
        let s11 = null;
        try {
          s11 = (yield U(Ce2(this.parsedUrl) + "/" + e5 + "/info", __spreadValues({
            query: this._getQueryParams()
          }, t6))).data.extent;
        } catch {
        }
        if (!s11?.spatialReference) return {
          ics: r2,
          icsToPixelTransform: null,
          icsExtent: null,
          northDirection: null
        };
        const a14 = this.version >= 10.7 ? U(Ce2(this.parsedUrl) + "/" + e5 + "/info/icstopixel", __spreadValues({
          query: this._getQueryParams()
        }, t6)).then((e6) => e6.data).catch(() => ({})) : {}, o3 = s11.spatialReference, l13 = {
          geometries: JSON.stringify({
            geometryType: "esriGeometryEnvelope",
            geometries: [s11]
          }),
          inSR: d2(o3),
          outSR: "0:" + e5
        }, u6 = U(Ce2(this.parsedUrl) + "/project", __spreadValues({
          query: this._getQueryParams(l13)
        }, t6)).then((e6) => e6.data).catch(() => ({})), p21 = 5, m12 = (s11.xmin + s11.xmax) / 2, c22 = (s11.ymax - s11.ymin) / (p21 + 1), d13 = s11.ymin + c22, h4 = [];
        for (let n14 = 0; n14 < p21; n14++) h4.push({
          x: m12,
          y: d13 + c22 * n14
        });
        const y14 = {
          geometries: JSON.stringify({
            geometryType: "esriGeometryPoint",
            geometries: h4
          }),
          inSR: d2(o3),
          outSR: "0:" + e5
        }, g7 = U(Ce2(this.parsedUrl) + "/project", __spreadValues({
          query: this._getQueryParams(y14)
        }, t6)).then((e6) => e6.data).catch(() => ({})), f8 = yield Promise.all([a14, u6, g7]);
        let R3 = f8[0].ipxf;
        if (null == R3) {
          const e6 = r2.geodataXform?.xf_0;
          "topup" === e6?.name?.toLowerCase() && 6 === e6?.coefficients?.length && (R3 = {
            affine: {
              name: "ics [sensor: Frame] to pixel (column, row) transformation",
              coefficients: e6.coefficients,
              cellsizeRatio: 0,
              type: "GeometricXform"
            }
          });
        }
        const b5 = w.fromJSON(f8[1]?.geometries?.[0]);
        b5 && (b5.spatialReference = new f2({
          wkid: 0,
          imageCoordinateSystem: r2
        }));
        const v2 = f8[2].geometries ? f8[2].geometries.filter((e6) => null != e6?.x && null != e6.y && "NaN" !== e6.x && "NaN" !== e6.y) : [], I2 = v2.length;
        if (I2 < 3) return {
          ics: r2,
          icsToPixelTransform: R3,
          icsExtent: b5,
          northDirection: null
        };
        let S3 = 0, x3 = 0, _3 = 0, F2 = 0;
        for (let n14 = 0; n14 < I2; n14++) S3 += v2[n14].x, x3 += v2[n14].y, _3 += v2[n14].x * v2[n14].x, F2 += v2[n14].x * v2[n14].y;
        const D3 = (I2 * F2 - S3 * x3) / (I2 * _3 - S3 * S3);
        let T3 = 0;
        const O = v2[p21 - 1].x > v2[0].x, j8 = v2[p21 - 1].y > v2[0].y;
        return D3 === 1 / 0 ? T3 = j8 ? 90 : 270 : 0 === D3 ? T3 = O ? 0 : 180 : D3 > 0 ? T3 = O ? 180 * Math.atan(D3) / Math.PI : 180 * Math.atan(D3) / Math.PI + 180 : D3 < 0 && (T3 = j8 ? 180 + 180 * Math.atan(D3) / Math.PI : 360 + 180 * Math.atan(D3) / Math.PI), {
          ics: r2,
          icsToPixelTransform: R3,
          icsExtent: b5,
          northDirection: T3
        };
      });
    }
    generateRasterInfo(e5, t6) {
      return __async(this, null, function* () {
        if (e5 = g(N2, e5), this.serviceRasterInfo && (!e5 || "none" === e5.functionName?.toLowerCase() || this._isVectorFieldResampleFunction(e5))) return this.serviceRasterInfo;
        const i11 = Pe(e5);
        if (!i11) throw new s("imagery-layer:generate-raster-info", "the rendering rule is not supported");
        if (this._functionRasterInfos[i11]) return this._functionRasterInfos[i11];
        const r2 = __spreadProps(__spreadValues({}, t6), {
          query: this._getQueryParams()
        }), s11 = p5(Ce2(this.parsedUrl), e5, r2);
        this._functionRasterInfos[i11] = s11;
        try {
          return yield s11;
        } catch (n14) {
          throw this._functionRasterInfos[i11] = null, n14;
        }
      });
    }
    getExportImageServiceParameters(e5, t6, i11, r2) {
      e5 = e5.clone().shiftCentralMeridian();
      const s11 = at(e5.spatialReference, Ce2(this.parsedUrl));
      this.pixelType !== this.serviceRasterInfo.pixelType && (this.exportImageServiceParameters.pixelType = this.pixelType);
      const n14 = this.exportImageServiceParameters.toJSON(), {
        bandIds: a14,
        noData: o3
      } = n14;
      let {
        renderingRule: l13
      } = n14;
      const u6 = this.rasterFunction?.rasterFunctionDefinition, p21 = !this.renderer || "raster-stretch" === this.renderer.type;
      if (a14?.length && this._hasRasterFunction(this.rasterFunction) && !u6 && p21) {
        const e6 = {
          rasterFunction: "ExtractBand",
          rasterFunctionArguments: {
            BandIds: a14
          }
        };
        if ("Stretch" === l13.rasterFunction) e6.rasterFunctionArguments.Raster = l13.rasterFunctionArguments.Raster, l13.rasterFunctionArguments.Raster = e6;
        else if ("Colormap" === l13.rasterFunction) {
          const t7 = l13.rasterFunctionArguments.Raster;
          "Stretch" === t7?.rasterFunction ? (e6.rasterFunctionArguments.Raster = t7.rasterFunctionArguments.Raster, t7.rasterFunctionArguments.Raster = e6) : (e6.rasterFunctionArguments.Raster = t7, l13.rasterFunctionArguments.Raster = e6);
        } else e6.rasterFunctionArguments.Raster = l13, l13 = e6;
        n14.bandIds = void 0;
      } else n14.bandIds = a14?.join(",");
      Array.isArray(o3) && o3.length > 0 && (n14.noData = o3.join(","));
      const m12 = this._processMultidimensionalIntersection(null, r2, this.exportImageServiceParameters.mosaicRule);
      if (m12.isOutSide) return null;
      n14.mosaicRule = null != m12.mosaicRule ? JSON.stringify(m12.mosaicRule) : null, r2 = m12.timeExtent, n14.renderingRule = this._getRenderingRuleString(N2.fromJSON(l13));
      const c22 = {};
      if (null != r2) {
        const {
          start: e6,
          end: t7
        } = r2.toJSON();
        e6 && t7 && e6 === t7 ? c22.time = "" + e6 : null == e6 && null == t7 || (c22.time = `${e6 ?? "null"},${t7 ?? "null"}`);
      }
      return __spreadValues(__spreadValues({
        bbox: e5.xmin + "," + e5.ymin + "," + e5.xmax + "," + e5.ymax,
        bboxSR: s11,
        imageSR: s11,
        size: t6 + "," + i11
      }, n14), c22);
    }
    getSamples(e5, t6) {
      return __async(this, null, function* () {
        const i11 = yield this._fetchCapabilities(t6?.signal);
        if (!i11?.operations.supportsGetSamples) throw new s("imagery-layer:get-samples", "getSamples operation is not supported on the input image service");
        e5 = a(e5);
        const {
          raster: r2
        } = this;
        return r2 && null == e5.raster && (e5.raster = r2), V2(this.url, e5, this._getRequestOptions(t6));
      });
    }
    identify(e5, t6) {
      return __async(this, null, function* () {
        if (!(yield this._fetchCapabilities(t6?.signal)).operations.supportsIdentify) throw new s("imagery-layer:identify", "identify operation is not supported on the input image service");
        e5 = a(e5), this.version < 10.91 && "extent" === e5.geometry?.type && (e5.geometry = j2.fromExtent(e5.geometry));
        const i11 = this._processMultidimensionalIntersection(e5.geometry, e5.timeExtent, e5.mosaicRule || this.mosaicRule);
        if (i11.isOutSide) throw new s("imagery-layer:identify", "the request cannot be fulfilled when falling outside of the multidimensional subset");
        e5.timeExtent = i11.timeExtent, e5.mosaicRule = i11.mosaicRule;
        const {
          raster: r2,
          rasterFunction: s11
        } = this;
        return s11 && null == e5.rasterFunction && (e5.rasterFunction = s11), r2 && null == e5.raster && (e5.raster = r2), X(this.url, e5, this._getRequestOptions(t6));
      });
    }
    imageToMap(e5, t6) {
      return __async(this, null, function* () {
        if (!(yield this._fetchCapabilities(t6?.signal)).operations.supportsImageToMap) throw new s("imagery-layer:image-to-map", "imageToMap operation is not supported on the input image service");
        return mt(Ce2(this.parsedUrl), e5, this._getRequestOptions(t6));
      });
    }
    imageToMapMultiray(e5, t6) {
      return __async(this, null, function* () {
        if (!(yield this._fetchCapabilities(t6?.signal)).operations.supportsImageToMapMultiray) throw new s("imagery-layer:image-to-map-multiray", "imageToMapMultiray operation is not supported on the input image service");
        return it(Ce2(this.parsedUrl), e5, this._getRequestOptions(t6));
      });
    }
    mapToImage(e5, t6) {
      return __async(this, null, function* () {
        if (!(yield this._fetchCapabilities(t6?.signal)).operations.supportsMapToImage) throw new s("imagery-layer:map-to-image", "mapToImage operation is not supported on the input image service");
        return pt(Ce2(this.parsedUrl), e5, this._getRequestOptions(t6));
      });
    }
    findImages(e5, t6) {
      return __async(this, null, function* () {
        if (!(yield this._fetchCapabilities(t6?.signal)).operations.supportsFindImages) throw new s("imagery-layer:find-images", "findImages operation is not supported on the input image service");
        return ct(Ce2(this.parsedUrl), e5, this._getRequestOptions(t6));
      });
    }
    getImageUrl(e5, t6) {
      return __async(this, null, function* () {
        if (!(yield this._fetchCapabilities(t6?.signal)).operations.supportsGetImageUrl) throw new s("imagery-layer:get-image-url", "getImageUrl operation is not supported on the input image service");
        return ut(Ce2(this.parsedUrl), e5, this._getRequestOptions(t6));
      });
    }
    createQuery() {
      return new b3({
        outFields: ["*"],
        returnGeometry: true,
        where: this.definitionExpression || "1=1"
      });
    }
    queryBoundary(e5, t6) {
      return __async(this, null, function* () {
        if (!(yield this._fetchCapabilities(t6?.signal)).operations.supportsQueryBoundary) throw new s("imagery-layer:query-boundary", "queryBoundary operation is not supported on the input image service");
        return e5 = e5 ?? {
          outSpatialReference: this.spatialReference
        }, st(Ce2(this.parsedUrl), e5, this._getRequestOptions(t6));
      });
    }
    queryRasters(e5, t6) {
      return __async(this, null, function* () {
        return {
          query: e5,
          requestOptions: t6
        } = yield this._prepareForQuery(e5, t6), s9(this.url, e5, t6);
      });
    }
    queryObjectIds(e5, t6) {
      return __async(this, null, function* () {
        return {
          query: e5,
          requestOptions: t6
        } = yield this._prepareForQuery(e5, t6), s8(this.url, e5, t6);
      });
    }
    queryGPSInfo(e5, t6) {
      return __async(this, null, function* () {
        if (!(yield this._fetchCapabilities(t6?.signal)).operations.supportsQueryGPSInfo) throw new s("imagery-layer:query-gps-info", "queryGPSInfo operation is not supported on the input image service");
        return e5 = e5 ?? {
          where: "1=1"
        }, nt(Ce2(this.parsedUrl), e5, this._getRequestOptions(t6));
      });
    }
    queryRasterCount(e5, t6) {
      return __async(this, null, function* () {
        return {
          query: e5,
          requestOptions: t6
        } = yield this._prepareForQuery(e5, t6), s7(this.url, e5, t6);
      });
    }
    queryVisibleRasters(e5, t6) {
      return __async(this, null, function* () {
        if (!e5) throw new s("imagery-layer: query-visible-rasters", "missing query parameter");
        yield this.load();
        const {
          pixelSize: i11,
          returnDomainValues: r2,
          returnTopmostRaster: s11,
          showNoDataRecords: n14
        } = t6 || {
          pixelSize: null,
          returnDomainValues: false,
          returnTopmostRaster: false,
          showNoDataRecords: false
        };
        let a14 = false, l13 = null, u6 = null;
        const p21 = "raster.servicepixelvalue", m12 = this._rasterFunctionNamesIndex;
        if (null != e5.outFields && (a14 = e5.outFields.some((e6) => !e6.toLowerCase().includes(p21)), this.version >= 10.4)) {
          const t7 = e5.outFields.filter((e6) => e6.toLowerCase().includes(p21) && e6.length > p21.length).map((e6) => {
            const t8 = e6.slice(p21.length + 1);
            return [this._updateRenderingRulesFunctionName(t8, m12), t8];
          });
          l13 = t7.map((e6) => new N2({
            functionName: e6[0]
          })), u6 = t7.map((e6) => e6[1]);
          const {
            rasterFunction: i12
          } = this;
          0 === l13.length ? i12?.functionName ? (l13.push(i12), u6.push(i12.functionName)) : l13 = null : i12?.functionName && !l13.some((e6) => e6.functionName === i12.functionName) && (l13.push(i12), u6.push(i12.functionName));
        }
        const c22 = null == e5.outSpatialReference || e5.outSpatialReference.equals(this.spatialReference), {
          multidimensionalSubset: d13
        } = this;
        let h4 = e5.timeExtent || this.timeExtent;
        if (d13) {
          const {
            isOutside: t7,
            intersection: i12
          } = m2(d13, {
            geometry: e5.geometry,
            timeExtent: e5.timeExtent,
            multidimensionalDefinition: this.exportImageServiceParameters.mosaicRule?.multidimensionalDefinition
          });
          if (t7) throw new s("imagery-layer:query-visible-rasters", "the request cannot be fulfilled when falling outside of the multidimensional subset");
          null != i12?.timeExtent && (h4 = i12.timeExtent);
        }
        const y14 = this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule, h4);
        let g7 = e5.geometry;
        this.version < 10.91 && "extent" === g7?.type && (g7 = j2.fromExtent(g7));
        const f8 = this._getQueryParams({
          geometry: g7,
          timeExtent: h4,
          mosaicRule: y14,
          rasterFunction: this.version < 10.4 ? this.rasterFunction : null,
          rasterFunctions: l13,
          pixelSize: i11,
          returnCatalogItems: a14,
          returnGeometry: c22,
          raster: this.raster,
          maxItemCount: s11 ? 1 : null
        });
        delete f8.f;
        const R3 = new d10(f8);
        try {
          yield this._generateRasterInfo(this.rasterFunction);
          const i12 = yield X(this.url, R3, {
            signal: t6?.signal,
            query: __spreadValues({}, this.customParameters)
          }), s12 = e5.outFields, o3 = null != i12.value && i12.value.toLowerCase().includes("nodata");
          if (!(a14 && !c22 && i12?.catalogItems?.features.length && (n14 || !o3))) return this._processVisibleRastersResponse(i12, {
            returnDomainValues: r2,
            templateRRFunctionNames: u6,
            showNoDataRecords: n14,
            templateFields: s12
          });
          const l14 = this.objectIdField || "ObjectId", p22 = i12.catalogItems?.features ?? [], m13 = p22.map((e6) => e6.attributes?.[l14]), d14 = new b3({
            objectIds: m13,
            returnGeometry: true,
            outSpatialReference: e5.outSpatialReference,
            outFields: [l14]
          }), h5 = yield this.queryRasters(d14);
          return h5?.features?.length && h5.features.forEach((t7) => {
            p22.forEach((i13) => {
              i13.attributes[l14] === t7.attributes[l14] && (i13.geometry = new j2(t7.geometry), null != e5.outSpatialReference && (i13.geometry.spatialReference = e5.outSpatialReference));
            });
          }), this._processVisibleRastersResponse(i12, {
            returnDomainValues: r2,
            templateRRFunctionNames: u6,
            showNoDataRecords: n14,
            templateFields: s12
          });
        } catch {
          throw new s("imagery-layer:query-visible-rasters", "encountered error when querying visible rasters");
        }
      });
    }
    fetchVariableStatisticsHistograms(e5, t6) {
      return __async(this, null, function* () {
        const i11 = U(Ce2(this.parsedUrl) + "/statistics", {
          query: this._getQueryParams({
            variable: e5
          }),
          signal: t6
        }).then((e6) => e6.data?.statistics), r2 = U(Ce2(this.parsedUrl) + "/histograms", {
          query: this._getQueryParams({
            variable: e5
          }),
          signal: t6
        }).then((e6) => e6.data?.histograms), s11 = yield Promise.all([i11, r2]);
        return s11[0] && s11[0].forEach((e6) => {
          e6.avg = e6.mean, e6.stddev = e6.standardDeviation;
        }), {
          statistics: s11[0] || null,
          histograms: s11[1] || null
        };
      });
    }
    createFlowMesh(e5, t6) {
      return __async(this, null, function* () {
        const i11 = this._rasterJobHandler.instance;
        return i11 ? i11.createFlowMesh(e5, t6) : s6(e5.meshType, e5.simulationSettings, e5.flowData, null != t6.signal ? t6.signal : new AbortController().signal);
      });
    }
    getMultidimensionalSubsetVariables(e5) {
      const t6 = e5 ?? this.serviceRasterInfo.multidimensionalInfo;
      return g3(this.multidimensionalSubset, t6);
    }
    _fetchService(e5) {
      return __async(this, null, function* () {
        yield this._fetchServiceInfo(e5), this.rasterInfo || (this.rasterInfo = this.serviceRasterInfo);
        const t6 = this.sourceJSON, i11 = null != this.serviceRasterInfo ? Promise.resolve(this.serviceRasterInfo) : f6(Ce2(this.parsedUrl), t6, {
          signal: e5,
          query: this._getQueryParams()
        }).then((e6) => (this._set("serviceRasterInfo", e6), this._set("multidimensionalInfo", e6.multidimensionalInfo), c4(e6, t6), e6)), r2 = this._hasRasterFunction(this.rasterFunction) ? this._generateRasterInfo(this.rasterFunction, {
          signal: e5
        }) : null, s11 = this._getRasterFunctionInfos();
        return Promise.all([i11, r2, s11]).then((e6) => {
          e6[1] ? this._set("rasterInfo", e6[1]) : this._set("rasterInfo", e6[0]), e6[2] && this._set("rasterFunctionInfos", e6[2]), this.renderer && !this._isSupportedRenderer(this.renderer) && (this._set("renderer", null), n.getLogger(this).warn("ArcGISImageService", "Switching to the default renderer. Renderer applied is not valid for this Imagery Layer")), this._set("renderer", this._configRenderer(this.renderer)), this.addHandles([d(() => this.rasterFunction, (e7) => {
            (this.renderer || this.symbolizer || this.popupEnabled && this.popupTemplate) && this._generateRasterInfo(e7).then((e8) => {
              e8 && (this.rasterInfo = e8);
            });
          })]);
          const {
            serviceRasterInfo: t7
          } = this;
          null != t7.multidimensionalInfo && this._updateMultidimensionalDefinition(t7);
        });
      });
    }
    _combineMosaicRuleWithTimeExtent(e5, t6) {
      const i11 = this.timeInfo, {
        multidimensionalInfo: r2
      } = this.serviceRasterInfo;
      if (null == e5 || null == r2 || null == t6 || null == i11?.startField) return e5;
      const {
        startField: s11
      } = i11, n14 = r2.variables.some((e6) => e6.dimensions.some((e7) => e7.name === s11)) ? s11 : "StdTime";
      if (e5 = e5.clone(), "mosaic-dataset" === this.sourceType) return e5.multidimensionalDefinition = e5.multidimensionalDefinition?.filter((e6) => e6.dimensionName !== n14), this._cleanupMultidimensionalDefinition(e5);
      e5.multidimensionalDefinition = e5.multidimensionalDefinition || [];
      const a14 = e5.multidimensionalDefinition.filter((e6) => e6.dimensionName === n14), o3 = null != t6.start ? t6.start.getTime() : null, l13 = null != t6.end ? t6.end.getTime() : null, u6 = null == o3 || null == l13 || o3 === l13, p21 = u6 ? [o3 || l13] : [[o3, l13]], m12 = this.version >= 10.8;
      if (a14.length) a14.forEach((e6) => {
        e6.dimensionName === n14 && (m12 ? (e6.dimensionName = null, e6.isSlice = false, e6.values = []) : (e6.isSlice = u6, e6.values = p21));
      });
      else if (!m12) {
        const t7 = e5.multidimensionalDefinition.filter((e6) => null != e6.variableName && null == e6.dimensionName);
        t7.length ? t7.forEach((e6) => {
          e6.dimensionName = n14, e6.isSlice = u6, e6.values = p21;
        }) : e5.multidimensionalDefinition.push(new p4({
          variableName: "",
          dimensionName: n14,
          isSlice: u6,
          values: p21
        }));
      }
      return this._cleanupMultidimensionalDefinition(e5);
    }
    _cleanupMultidimensionalDefinition(e5) {
      return null == e5 ? null : (e5.multidimensionalDefinition && (e5.multidimensionalDefinition = e5.multidimensionalDefinition.filter((e6) => !(!e6.variableName && !e6.dimensionName)), 0 === e5.multidimensionalDefinition.length && (e5.multidimensionalDefinition = null)), "mosaic-dataset" !== this.sourceType && null == e5.multidimensionalDefinition ? null : e5);
    }
    _prepareForQuery(e5, t6) {
      return __async(this, null, function* () {
        if (!(yield this._fetchCapabilities(t6?.signal)).operations.supportsQuery) throw new s("imagery-layer:query-rasters", "query operation is not supported on the input image service");
        return e5 = null != e5 ? g(b3, e5) : this.createQuery(), t6 = this._getRequestOptions(t6), this.raster && (t6.query = __spreadProps(__spreadValues({}, t6.query), {
          raster: this.raster
        })), {
          query: e5,
          requestOptions: t6
        };
      });
    }
    _initJobHandler() {
      return __async(this, null, function* () {
        if (null != this._rasterJobHandler.connectionPromise) return this._rasterJobHandler.connectionPromise;
        const e5 = new t4();
        this._rasterJobHandler.connectionPromise = e5.initialize().then(() => {
          this._rasterJobHandler.instance = e5;
        }, () => {
        }), yield this._rasterJobHandler.connectionPromise;
      });
    }
    _shutdownJobHandler() {
      this._rasterJobHandler.instance && this._rasterJobHandler.instance.destroy(), this._rasterJobHandler.instance = null, this._rasterJobHandler.connectionPromise = null, this._rasterJobHandler.refCount = 0, this._cachedRendererJson = null;
    }
    _isSupportedRenderer(e5) {
      const {
        rasterInfo: t6,
        rasterFunction: i11
      } = this;
      return "unique-value" === e5.type && this._hasRasterFunction(i11) && 1 === t6?.bandCount && ["u8", "s8"].includes(t6.pixelType) || null != t6 && null != e5 && B2(t6).includes(e5.type);
    }
    _fetchCapabilities(e5) {
      return __async(this, null, function* () {
        return this.capabilities || (yield this._fetchServiceInfo(e5)), this.capabilities;
      });
    }
    _fetchServiceInfo(e5) {
      return __async(this, null, function* () {
        let t6 = this.sourceJSON;
        if (!t6) {
          const {
            data: i11,
            ssl: r2
          } = yield U(Ce2(this.parsedUrl), {
            query: this._getQueryParams(),
            signal: e5
          });
          t6 = i11, this.sourceJSON = t6, r2 && (this.url = this.url.replace(/^http:/i, "https:"));
        }
        if (t6.capabilities?.toLowerCase().split(",").map((e6) => e6.trim()).indexOf("tilesonly") > -1) throw new s("imagery-layer:fetch-service-info", "use ImageryTileLayer to open tiles-only image services");
        this.read(t6, {
          origin: "service",
          url: this.parsedUrl
        });
      });
    }
    _isMosaicDataset(e5) {
      return e5.serviceSourceType ? "esriImageServiceSourceTypeMosaicDataset" === e5.serviceSourceType : e5.fields?.length > 0;
    }
    _isMosaicRuleSupported(e5) {
      if (!e5) return false;
      const t6 = this._isMosaicDataset(e5), i11 = e5.currentVersion >= 10.71 && e5.hasMultidimensions && !(e5.fields?.length > 1);
      return t6 || i11;
    }
    _isVectorFieldResampleFunction(e5) {
      if (null == e5) return false;
      const {
        functionName: t6,
        functionArguments: i11
      } = e5, r2 = "resample" === t6?.toLowerCase(), s11 = i11?.ResampleType || i11?.resampleType;
      return r2 && (7 === s11 || 10 === s11);
    }
    _isPicture() {
      return !this.format || this.format.includes("jpg") || this.format.includes("png");
    }
    _configRenderer(e5) {
      const t6 = this._isPicture(), {
        rasterInfo: i11
      } = this;
      if (!t6 && !this.pixelFilter || this._isVectorDataSet()) {
        if (!this.bandIds && i11.bandCount >= 3) {
          const e6 = U2(i11);
          !e6 || 3 === i11.bandCount && 0 === e6[0] && 1 === e6[1] && 2 === e6[2] || (this.bandIds = e6);
        }
        e5 || (e5 = L2(i11, {
          bandIds: this.bandIds,
          variableName: this.rasterFunction ? null : this.mosaicRule?.multidimensionalDefinition?.[0].variableName
        }));
        const t7 = $(e5.toJSON());
        this.symbolizer ? (this.symbolizer.rendererJSON = t7, this.symbolizer.rasterInfo = i11) : this.symbolizer = new L({
          rendererJSON: t7,
          rasterInfo: i11
        }), this.symbolizer.bind().success || (this.symbolizer = null);
      }
      return e5;
    }
    _clonePixelData(e5) {
      return null == e5 ? e5 : {
        extent: e5.extent && e5.extent.clone(),
        pixelBlock: null != e5.pixelBlock ? e5.pixelBlock.clone() : null
      };
    }
    _getQueryParams(e5) {
      null != e5?.renderingRule && "string" != typeof e5.renderingRule && (e5.renderingRule = this._getRenderingRuleString(e5.renderingRule));
      const {
        raster: t6,
        viewId: i11
      } = this;
      return __spreadValues(__spreadValues({
        raster: t6,
        viewId: i11,
        f: "json"
      }, e5), this.customParameters);
    }
    _getRequestOptions(e5) {
      return __spreadProps(__spreadValues({}, e5), {
        query: __spreadValues(__spreadValues({}, e5?.query), this.customParameters)
      });
    }
    _decodePixelBlock(e5, t6, i11) {
      return this._rasterJobHandler.instance ? this._rasterJobHandler.instance.decode({
        data: e5,
        options: t6
      }) : j4(e5, t6, i11);
    }
    _getRasterFunctionInfos(e5) {
      return __async(this, null, function* () {
        const t6 = this.sourceJSON.rasterFunctionInfos;
        if (this.loaded) return t6;
        if (t6 && this.version >= 10.3) {
          if (1 === t6.length && "none" === t6[0].name.toLowerCase()) return t6;
          const i11 = yield U(Ce2(this.parsedUrl) + "/rasterFunctionInfos", {
            query: this._getQueryParams(),
            signal: e5
          });
          return i11.data?.rasterFunctionInfos;
        }
        return null;
      });
    }
    _canRequestImageElement(e5) {
      return !this.pixelFilter && (!e5 || e5.includes("png"));
    }
    _requestArrayBuffer(e5) {
      return __async(this, null, function* () {
        const {
          imageProps: t6,
          requestAsImageElement: i11,
          returnImageBitmap: r2,
          signal: s11
        } = e5;
        if (i11 && this._canRequestImageElement(t6.format)) {
          const i12 = `${Ce2(this.parsedUrl)}/exportImage`, {
            data: a15
          } = yield U(i12, {
            responseType: r2 ? "blob" : "image",
            query: this._getQueryParams(__spreadValues(__spreadValues({
              f: "image"
            }, this.refreshParameters), e5.imageServiceParameters)),
            signal: s11
          });
          if (a15 instanceof Blob) {
            return {
              imageBitmap: yield t2(a15, i12, s11),
              params: t6
            };
          }
          return {
            imageOrCanvasElement: a15,
            params: t6
          };
        }
        const a14 = this._initJobHandler(), l13 = U(Ce2(this.parsedUrl) + "/exportImage", {
          responseType: "array-buffer",
          query: this._getQueryParams(__spreadValues({
            f: "image"
          }, e5.imageServiceParameters)),
          signal: s11
        }), u6 = (yield Promise.all([l13, a14]))[0].data, p21 = t6.format || "jpgpng";
        let m12 = p21;
        if ("bsq" !== m12 && "bip" !== m12 && (m12 = P(u6)), !m12) throw new s("imagery-layer:fetch-image", "unsupported format signature " + String.fromCharCode.apply(null, new Uint8Array(u6)));
        const c22 = {
          signal: s11
        }, d13 = "gif" === p21 || "bmp" === p21 || p21.includes("png") && ("png" === m12 || "jpg" === m12) ? j4(u6, __spreadValues({
          useCanvas: true
        }, t6), c22) : this._decodePixelBlock(u6, {
          width: t6.width,
          height: t6.height,
          planes: null,
          pixelType: null,
          noDataValue: null,
          format: p21
        }, c22);
        return {
          pixelData: {
            pixelBlock: yield d13,
            extent: t6.extent
          },
          params: t6
        };
      });
    }
    _generateRasterInfo(e5, t6) {
      return this.generateRasterInfo(e5, t6).catch(() => null);
    }
    _isValidCustomizedMosaicRule(e5) {
      return e5 && JSON.stringify(e5.toJSON()) !== JSON.stringify(this.defaultMosaicRule?.toJSON());
    }
    _updateMultidimensionalDefinition(e5) {
      if (this._isValidCustomizedMosaicRule(this.mosaicRule)) return;
      let t6 = d7(e5, {
        multidimensionalSubset: this.multidimensionalSubset
      });
      if (null != t6 && t6.length > 0) {
        this.mosaicRule = this.mosaicRule || new j5();
        const e6 = this.mosaicRule.multidimensionalDefinition;
        !this.sourceJSON.defaultVariableName && this.rasterFunction && "none" !== this.rasterFunction.functionName?.toLowerCase() && t6.forEach((e7) => e7.variableName = ""), t6 = t6.filter(({
          variableName: e7,
          dimensionName: t7
        }) => e7 && "*" !== e7 || t7), !e6?.length && t6.length && (this.mosaicRule.multidimensionalDefinition = t6);
      }
    }
    _processVisibleRastersResponse(e5, i11) {
      i11 = i11 || {};
      const r2 = e5.value, {
        templateRRFunctionNames: s11,
        showNoDataRecords: n14,
        returnDomainValues: a14,
        templateFields: o3
      } = i11, l13 = e5.processedValues;
      let u6 = e5.catalogItems?.features, p21 = e5.properties?.Values?.map((e6) => e6.replaceAll(/ /gi, ", ")) || [];
      const m12 = this.objectIdField || "ObjectId", c22 = "string" == typeof r2 && r2.toLowerCase().includes("nodata"), d13 = [];
      if (r2 && !u6 && !c22) {
        const e6 = {};
        e6[m12] = 0;
        p21 = [r2], u6 = [new d3({
          geometry: this.fullExtent,
          attributes: e6
        })];
      }
      if (!u6) return [];
      let h4, y14, g7;
      this._updateResponseFieldNames(u6, o3), c22 && !n14 && (u6 = []);
      for (let t6 = 0; t6 < u6.length; t6++) {
        if (h4 = u6[t6], null != r2) {
          if (y14 = p21[t6], g7 = this.rasterFunction && l13 && l13.length > 0 && s11 && s11.length > 0 && s11.includes(this.rasterFunction.functionName) ? l13[s11.indexOf(this.rasterFunction.functionName)] : r2, "nodata" === y14.toLowerCase() && !n14) continue;
          const e6 = "Raster.ItemPixelValue", i12 = "Raster.ServicePixelValue";
          h4.attributes[e6] = y14, h4.attributes[i12] = g7, this._updateFeatureWithMagDirValues(h4, y14);
          const a15 = this.fields && this.fields.length > 0;
          let o4 = this.rasterFunction && null != this.serviceRasterInfo.attributeTable ? a15 ? y14 : r2 : g7;
          this.rasterFunction || (o4 = a15 ? y14 : r2), this._updateFeatureWithRasterAttributeTableValues(h4, o4);
        }
        if (h4.sourceLayer = h4.layer = this, a14 && this._updateFeatureWithDomainValues(h4), s11 && l13 && s11.length === l13.length) for (let e6 = 0; e6 < s11.length; e6++) {
          const t7 = "Raster.ServicePixelValue." + s11[e6];
          h4.attributes[t7] = l13[e6];
        }
        d13.push(u6[t6]);
      }
      return d13;
    }
    _processMultidimensionalIntersection(e5, t6, i11) {
      const {
        multidimensionalSubset: r2
      } = this;
      if (!r2) return {
        isOutSide: false,
        timeExtent: t6,
        mosaicRule: i11 = this._combineMosaicRuleWithTimeExtent(i11, t6)
      };
      if (r2) {
        const {
          isOutside: i12,
          intersection: s11
        } = m2(r2, {
          geometry: e5,
          timeExtent: t6
        });
        if (i12) return {
          isOutSide: true,
          timeExtent: null,
          mosaicRule: null
        };
        null != s11?.timeExtent && (t6 = s11.timeExtent);
      }
      if (i11 = this._combineMosaicRuleWithTimeExtent(i11, t6), i11?.multidimensionalDefinition) {
        const {
          isOutside: e6
        } = m2(r2, {
          multidimensionalDefinition: i11.multidimensionalDefinition
        });
        if (e6) return {
          isOutSide: true,
          timeExtent: null,
          mosaicRule: null
        };
      }
      return {
        isOutSide: false,
        timeExtent: t6,
        mosaicRule: i11
      };
    }
    _updateFeatureWithRasterAttributeTableValues(e5, t6) {
      const i11 = this.rasterInfo.attributeTable || this.serviceRasterInfo.attributeTable;
      if (null == i11) return;
      const {
        features: r2,
        fields: s11
      } = i11, n14 = s11.map((e6) => e6.name).find((e6) => "value" === e6.toLowerCase());
      if (!n14) return;
      const a14 = r2.filter((e6) => e6.attributes[n14] === (null != t6 ? parseInt(t6, 10) : null));
      a14 && a14[0] && s11.forEach((t7) => {
        const i12 = this._rasterAttributeTableFieldPrefix + t7.name;
        e5.attributes[i12] = a14[0].attributes[t7.name];
      });
    }
    _updateFeatureWithMagDirValues(e5, t6) {
      if (!this._isVectorDataSet()) return;
      const i11 = t6.split(/,\s*/).map((e6) => parseFloat(e6)), r2 = i11.map((e6) => [e6]), s11 = i11.map((e6) => ({
        minValue: e6,
        maxValue: e6,
        noDataValue: null
      })), n14 = new g2({
        height: 1,
        width: 1,
        pixelType: "f32",
        pixels: r2,
        statistics: s11
      });
      null != this.pixelFilter && this.pixelFilter({
        pixelBlock: n14,
        extent: new w(0, 0, 0, 0, this.spatialReference)
      });
      const a14 = "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType ? [n14.pixels[0][0], n14.pixels[1][0]] : l3([n14.pixels[0][0], n14.pixels[1][0]]);
      e5.attributes["Raster.Magnitude"] = a14[0], e5.attributes["Raster.Direction"] = a14[1];
    }
    _updateFeatureWithDomainValues(e5) {
      const t6 = this.fields && this.fields.filter((e6) => e6.domain && "coded-value" === e6.domain.type);
      null != t6 && t6.forEach((t7) => {
        const i11 = e5.attributes[t7.name];
        if (null != i11) {
          const r2 = t7.domain.codedValues.find((e6) => e6.code === i11);
          r2 && (e5.attributes[t7.name] = r2.name);
        }
      });
    }
    _updateResponseFieldNames(e5, t6) {
      if (!t6 || t6.length < 1) return;
      const i11 = this.fieldsIndex;
      null != i11 && e5.forEach((e6) => {
        if (e6?.attributes) for (const r2 of t6) {
          const t7 = i11.get(r2)?.name;
          t7 && t7 !== r2 && (e6.attributes[r2] = e6.attributes[t7], delete e6.attributes[t7]);
        }
      });
    }
    _getRenderingRuleString(e5) {
      if (e5) {
        let t6 = e5.toJSON();
        return t6 = t6.rasterFunctionDefinition ?? t6, (t6.thumbnail || t6.thumbnailEx) && (t6.thumbnail = t6.thumbnailEx = null), JSON.stringify(t6);
      }
      return null;
    }
    _hasRasterFunction(e5) {
      return null != e5?.functionName && "none" !== e5.functionName.toLowerCase();
    }
    _updateRenderingRulesFunctionName(e5, t6) {
      if (!e5 || e5.length < 1) return;
      if ("Raw" === e5) return e5.replace("Raw", "None");
      const i11 = e5.toLowerCase().replaceAll(/ /gi, "_");
      return t6.has(i11) ? t6.get(i11) : e5;
    }
    _isRFTJson(e5) {
      return e5?.name && e5.arguments && e5.function && e5.hasOwnProperty("functionType");
    }
    _isVectorDataSet() {
      return "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType;
    }
    _applyMosaicAndRenderingRules(e5) {
      const {
        raster: t6,
        mosaicRule: i11,
        rasterFunction: r2
      } = this;
      r2 && "rasterFunction" in e5 && null == e5.rasterFunction && (e5.rasterFunction = r2), i11 && null == e5.mosaicRule && (e5.mosaicRule = i11), t6 && null == e5.raster && (e5.raster = t6);
    }
    _readCapabilities(e5) {
      const t6 = e5.capabilities ? e5.capabilities.toLowerCase().split(",").map((e6) => e6.trim()) : ["image", "catalog"], {
        currentVersion: i11,
        advancedQueryCapabilities: r2,
        maxRecordCount: s11
      } = e5, n14 = t6.includes("image"), a14 = "esriImageServiceDataTypeElevation" === e5.serviceDataType, o3 = !(!e5.spatialReference && !e5.extent?.spatialReference), l13 = t6.includes("edit"), u6 = t6.includes("mensuration") && o3, p21 = null == e5.mensurationCapabilities ? [] : e5.mensurationCapabilities.toLowerCase().split(",").map((e6) => e6.trim()), m12 = u6 && p21.includes("basic"), c22 = this._isMosaicDataset(e5) && t6.includes("catalog"), d13 = t6.includes("download");
      return {
        data: {
          supportsAttachment: false
        },
        operations: {
          supportsComputeHistograms: n14,
          supportsExportImage: n14,
          supportsIdentify: n14,
          supportsImageToMap: i11 >= 11.2 && c22,
          supportsImageToMapMultiray: i11 >= 11.2 && c22,
          supportsMapToImage: i11 >= 11.2 && c22,
          supportsFindImages: i11 >= 11.2 && c22,
          supportsGetImageUrl: i11 >= 11.3 && d13,
          supportsMeasure: u6,
          supportsMeasureFromImage: i11 >= 11.2,
          supportsDownload: d13,
          supportsQuery: c22 && e5.fields && e5.fields.length > 0,
          supportsGetSamples: i11 >= 10.2 && n14,
          supportsProject: i11 >= 10.3 && n14,
          supportsComputeStatisticsHistograms: i11 >= 10.4 && n14,
          supportsQueryBoundary: i11 >= 10.6 && n14,
          supportsCalculateVolume: i11 >= 10.7 && a14,
          supportsComputePixelLocation: i11 >= 10.7 && c22,
          supportsComputeAngles: i11 >= 10.91,
          supportsQueryGPSInfo: i11 >= 11.2 && c22,
          supportsAdd: l13,
          supportsDelete: l13,
          supportsEditing: l13,
          supportsUpdate: l13,
          supportsCalculate: false,
          supportsTruncate: false,
          supportsValidateSql: false,
          supportsChangeTracking: false,
          supportsQueryAttachments: false,
          supportsResizeAttachments: false,
          supportsSync: false,
          supportsExceedsLimitStatistics: false,
          supportsQueryAnalytics: false,
          supportsQueryTopFeatures: false,
          supportsAsyncConvert3D: false
        },
        query: {
          maxRecordCount: s11,
          maxRecordCountFactor: void 0,
          supportsStatistics: !!r2?.supportsStatistics,
          supportsOrderBy: !!r2?.supportsOrderBy,
          supportsDistinct: !!r2?.supportsDistinct,
          supportsPagination: !!r2?.supportsPagination,
          supportsStandardizedQueriesOnly: !!r2?.useStandardizedQueries,
          supportsPercentileStatistics: !!r2?.supportsPercentileStatistics,
          supportsCentroid: !!r2?.supportsReturningGeometryCentroid,
          supportsDistance: !!r2?.supportsQueryWithDistance,
          supportsExtent: !!r2?.supportsReturningQueryExtent,
          supportsGeometryProperties: !!r2?.supportsReturningGeometryProperties,
          supportsHavingClause: !!r2?.supportsHavingClause,
          supportsQuantization: false,
          supportsQuantizationEditMode: false,
          supportsQueryGeometry: false,
          supportsResultType: false,
          supportsMaxRecordCountFactor: false,
          supportsSqlExpression: false,
          supportsTopFeaturesQuery: false,
          supportsQueryByAnonymous: false,
          supportsQueryByOthers: false,
          supportsHistoricMoment: false,
          supportsFormatPBF: false,
          supportsDisjointSpatialRelationship: false,
          supportsCacheHint: false,
          supportsSpatialAggregationStatistics: false,
          supportedSpatialAggregationStatistics: {
            envelope: false,
            centroid: false,
            convexHull: false
          },
          supportsDefaultSpatialReference: !!r2?.supportsDefaultSR,
          supportsFullTextSearch: false,
          supportsCompactGeometry: false,
          standardMaxRecordCount: void 0,
          tileMaxRecordCount: void 0
        },
        mensuration: {
          supportsDistanceAndAngle: m12,
          supportsAreaAndPerimeter: m12,
          supportsPointOrCentroid: m12,
          supportsHeightFromBaseAndTop: u6 && p21.includes("base-top height"),
          supportsHeightFromBaseAndTopShadow: u6 && p21.includes("base-top shadow height"),
          supportsHeightFromTopAndTopShadow: u6 && p21.includes("top-top shadow height"),
          supports3D: u6 && p21.includes("3d")
        }
      };
    }
  };
  function Ce2(e5) {
    return e5?.path ?? "";
  }
  return e([y({
    clonable: false
  })], g6.prototype, "_functionRasterInfos", void 0), e([y({
    clonable: false
  })], g6.prototype, "_rasterJobHandler", void 0), e([y({
    clonable: false
  })], g6.prototype, "_cachedRendererJson", void 0), e([y({
    readOnly: true
  })], g6.prototype, "_serviceSupportsMosaicRule", void 0), e([o("_serviceSupportsMosaicRule", ["currentVersion", "fields"])], g6.prototype, "readServiceSupportsMosaicRule", null), e([y({
    readOnly: true
  })], g6.prototype, "_rasterAttributeTableFieldPrefix", void 0), e([y({
    readOnly: true
  })], g6.prototype, "_rasterFunctionNamesIndex", null), e([y()], g6.prototype, "adjustAspectRatio", void 0), e([y({
    type: [N],
    json: {
      write: true
    }
  })], g6.prototype, "bandIds", void 0), e([o("bandIds")], g6.prototype, "readBandIds", null), e([y({
    readOnly: true,
    json: {
      read: false
    }
  })], g6.prototype, "capabilities", void 0), e([o("service", "capabilities", ["capabilities", "currentVersion", "serviceDataType"])], g6.prototype, "readCapabilities", null), e([y({
    type: Number
  })], g6.prototype, "compressionQuality", void 0), e([r("compressionQuality")], g6.prototype, "writeCompressionQuality", null), e([y({
    type: Number
  })], g6.prototype, "compressionTolerance", void 0), e([r("compressionTolerance")], g6.prototype, "writeCompressionTolerance", null), e([y({
    json: {
      read: {
        source: "copyrightText"
      }
    }
  })], g6.prototype, "copyright", void 0), e([y({
    readOnly: true,
    dependsOn: ["_serviceSupportsMosaicRule"]
  })], g6.prototype, "defaultMosaicRule", void 0), e([o("defaultMosaicRule", ["defaultMosaicMethod"])], g6.prototype, "readDefaultMosaicRule", null), e([y({
    type: String,
    json: {
      name: "layerDefinition.definitionExpression",
      write: {
        enabled: true,
        allowNull: true
      }
    }
  })], g6.prototype, "definitionExpression", void 0), e([y({
    readOnly: true,
    constructOnly: true
  })], g6.prototype, "exportImageServiceParameters", void 0), e([y()], g6.prototype, "rasterInfo", void 0), e([y({
    readOnly: true,
    type: [y3]
  })], g6.prototype, "fields", void 0), e([y({
    readOnly: true
  })], g6.prototype, "fieldsIndex", null), e([y({
    type: ["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff", "bip", "bsq"],
    json: {
      write: true
    }
  })], g6.prototype, "format", null), e([o("service", "format", ["serviceDataType"])], g6.prototype, "readFormat", null), e([y({
    type: w
  })], g6.prototype, "fullExtent", void 0), e([y({
    readOnly: true
  })], g6.prototype, "hasMultidimensions", void 0), e([y({
    json: {
      read: {
        source: "maxImageHeight"
      }
    }
  })], g6.prototype, "imageMaxHeight", void 0), e([y({
    json: {
      read: {
        source: "maxImageWidth"
      }
    }
  })], g6.prototype, "imageMaxWidth", void 0), e([y({
    type: String,
    json: {
      type: a5.jsonValues,
      read: a5.read,
      write: a5.write
    }
  })], g6.prototype, "interpolation", void 0), e([y()], g6.prototype, "minScale", void 0), e([o("service", "minScale")], g6.prototype, "readMinScale", null), e([y()], g6.prototype, "maxScale", void 0), e([o("service", "maxScale")], g6.prototype, "readMaxScale", null), e([y({
    type: j5
  })], g6.prototype, "mosaicRule", null), e([o("mosaicRule", ["mosaicRule", "defaultMosaicMethod"])], g6.prototype, "readMosaicRule", null), e([r("mosaicRule")], g6.prototype, "writeMosaicRule", null), e([y()], g6.prototype, "multidimensionalInfo", void 0), e([y({
    type: c3,
    json: {
      write: true
    }
  })], g6.prototype, "multidimensionalSubset", void 0), e([y({
    json: {
      type: N
    }
  })], g6.prototype, "noData", void 0), e([r("noData")], g6.prototype, "writeNoData", null), e([y({
    type: String,
    json: {
      type: i4.jsonValues,
      read: i4.read,
      write: i4.write
    }
  })], g6.prototype, "noDataInterpretation", void 0), e([y({
    type: String,
    readOnly: true,
    json: {
      read: {
        source: ["fields"]
      }
    }
  })], g6.prototype, "objectIdField", void 0), e([o("objectIdField")], g6.prototype, "readObjectIdField", null), e([y({
    readOnly: true
  })], g6.prototype, "geometryType", void 0), e([y({})], g6.prototype, "typeIdField", void 0), e([y({})], g6.prototype, "types", void 0), e([y({
    readOnly: true
  })], g6.prototype, "parsedUrl", null), e([y({
    type: Function
  })], g6.prototype, "pixelFilter", void 0), e([y()], g6.prototype, "raster", void 0), e([y({
    readOnly: true
  })], g6.prototype, "sourceType", void 0), e([o("sourceType", ["serviceSourceType", "fields"])], g6.prototype, "readSourceType", null), e([y()], g6.prototype, "viewId", void 0), e([y({
    types: l5,
    json: {
      name: "layerDefinition.drawingInfo.renderer",
      origins: {
        "web-scene": {
          types: d6,
          name: "layerDefinition.drawingInfo.renderer",
          write: {
            overridePolicy: (e5) => ({
              enabled: e5 && "vector-field" !== e5.type && "flow" !== e5.type
            })
          }
        }
      }
    }
  })], g6.prototype, "renderer", null), e([o("renderer")], g6.prototype, "readRenderer", null), e([r("renderer")], g6.prototype, "writeRenderer", null), e([y({
    clonable: false
  })], g6.prototype, "symbolizer", void 0), e([y(w2)], g6.prototype, "opacity", void 0), e([y({
    readOnly: true
  })], g6.prototype, "rasterFields", null), e([y({
    constructOnly: true
  })], g6.prototype, "rasterFunctionInfos", void 0), e([y({
    type: N2
  })], g6.prototype, "renderingRule", null), e([y({
    type: N2,
    json: {
      name: "renderingRule"
    }
  })], g6.prototype, "rasterFunction", null), e([o("rasterFunction", ["renderingRule", "rasterFunctionInfos"])], g6.prototype, "readRasterFunction", null), e([y({
    readOnly: true
  })], g6.prototype, "serviceDataType", void 0), e([y({
    readOnly: true,
    type: f2
  })], g6.prototype, "spatialReference", void 0), e([o("spatialReference", ["spatialReference", "extent"])], g6.prototype, "readSpatialReference", null), e([y({
    json: {
      type: n6.jsonValues
    }
  })], g6.prototype, "pixelType", void 0), e([o("pixelType")], g6.prototype, "readPixelType", null), e([r("pixelType")], g6.prototype, "writePixelType", null), e([y({
    constructOnly: true,
    type: m
  })], g6.prototype, "serviceRasterInfo", void 0), e([y()], g6.prototype, "sourceJSON", void 0), e([y(p2)], g6.prototype, "url", void 0), e([y({
    readOnly: true
  })], g6.prototype, "version", void 0), e([o("version", ["currentVersion", "fields", "timeInfo"])], g6.prototype, "readVersion", null), g6 = e([a4("esri.layers.mixins.ArcGISImageService")], g6), g6;
};

// ../../../node_modules/@arcgis/core/layers/ImageryLayer.js
var T2 = class extends l(l4(t(b(j3(Ce(f4(e2(l2(S(i2(f3))))))))))) {
  constructor(...e5) {
    super(...e5), this.isReference = null, this.operationalLayerType = "ArcGISImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.type = "imagery", this._debouncedSaveOperations = k((e6, r2, t6) => __async(this, null, function* () {
      const {
        save: s11,
        saveAs: i11
      } = yield import("./imageryUtils-PFQ5UKCM.js");
      switch (e6) {
        case A.SAVE:
          return s11(this, r2);
        case A.SAVE_AS:
          return i11(this, t6, r2);
      }
    }));
  }
  normalizeCtorArgs(e5, r2) {
    return "string" == typeof e5 ? __spreadValues({
      url: e5
    }, r2) : e5;
  }
  load(e5) {
    const r2 = null != e5 ? e5.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({
      supportedTypes: ["Image Service"]
    }, e5).catch(a2).then(() => this._fetchService(r2))), Promise.resolve(this);
  }
  get legendEnabled() {
    return !this._isPreviewLayer && (this._get("legendEnabled") ?? true);
  }
  set legendEnabled(e5) {
    this._set("legendEnabled", e5);
  }
  get listMode() {
    return this._isPreviewLayer ? "hide" : this._get("listMode");
  }
  set listMode(e5) {
    this._set("listMode", e5);
  }
  writeOperationalLayerType(e5, r2, t6) {
    const s11 = "vector-field" === this.renderer?.type;
    r2[t6] = s11 ? "ArcGISImageServiceVectorLayer" : "ArcGISImageServiceLayer";
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get _isPreviewLayer() {
    return !(!this.raster || !this.url?.toLowerCase().includes("/rasterrendering/imageserver"));
  }
  createPopupTemplate(e5) {
    const r2 = this.rasterFields, t6 = this.title, s11 = /* @__PURE__ */ new Set();
    let i11 = false, o3 = false;
    this.capabilities && (i11 = this.capabilities.operations.supportsQuery && this.fields && this.fields.length > 0, o3 = "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType);
    const a14 = /* @__PURE__ */ new Set();
    i11 && a14.add("raster.itempixelvalue");
    for (const n14 of r2) {
      const e6 = n14.name.toLowerCase();
      a14.has(e6) || e6.includes("raster.servicepixelvalue.") || s11.add(n14.name);
    }
    o3 && s11.add("raster.magnitude").add("raster.direction");
    const p21 = p3({
      fields: r2,
      title: t6
    }, __spreadProps(__spreadValues({}, e5), {
      visibleFieldNames: s11
    }));
    return p21?.fieldInfos && this.rasterInfo?.pixelType.startsWith("f") && p21.fieldInfos.forEach(({
      format: e6,
      fieldName: r3
    }) => {
      e6 && r3 && /^raster\.(item|service)pixelvalue/i.test(r3) && (e6.places = 2);
    }), p21;
  }
  queryFeatures(e5, r2) {
    return this.queryRasters(e5, r2).then((e6) => {
      if (e6?.features) for (const r3 of e6.features) r3.layer = r3.sourceLayer = this;
      return e6;
    });
  }
  queryFeatureCount(e5, r2) {
    return this.queryRasterCount(e5, r2);
  }
  redraw() {
    this.emit("redraw");
  }
  save(e5) {
    return __async(this, null, function* () {
      return this._debouncedSaveOperations(A.SAVE, e5);
    });
  }
  saveAs(e5, r2) {
    return __async(this, null, function* () {
      return this._debouncedSaveOperations(A.SAVE_AS, r2, e5);
    });
  }
  serviceSupportsSpatialReference(e5) {
    return t3(this, e5);
  }
  write(e5, r2) {
    if (!this._isPreviewLayer) return super.write(e5, r2);
    if (r2?.messages) {
      const e6 = `${r2.origin}/${r2.layerContainerType || "operational-layers"}`;
      r2.messages.push(new s("layer:unsupported", `Imagery preview layer (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e6}'`, {
        layer: this
      }));
    }
    return null;
  }
};
e([y(y4)], T2.prototype, "legendEnabled", null), e([y({
  type: ["show", "hide"]
})], T2.prototype, "listMode", null), e([y({
  type: Boolean,
  json: {
    read: false,
    write: {
      enabled: true,
      overridePolicy: () => ({
        enabled: false
      })
    }
  }
})], T2.prototype, "isReference", void 0), e([y({
  type: ["ArcGISImageServiceLayer"],
  json: {
    origins: {
      "web-map": {
        type: ["ArcGISImageServiceLayer", "ArcGISImageServiceVectorLayer"],
        read: false,
        write: {
          target: "layerType",
          ignoreOrigin: true
        }
      }
    }
  }
})], T2.prototype, "operationalLayerType", void 0), e([r("web-map", "operationalLayerType")], T2.prototype, "writeOperationalLayerType", null), e([y(s2)], T2.prototype, "popupEnabled", void 0), e([y({
  type: k2,
  json: {
    read: {
      source: "popupInfo"
    },
    write: {
      target: "popupInfo"
    }
  }
})], T2.prototype, "popupTemplate", void 0), e([y({
  readOnly: true
})], T2.prototype, "defaultPopupTemplate", null), e([y({
  readOnly: true,
  json: {
    read: false
  }
})], T2.prototype, "type", void 0), e([y({
  readOnly: true
})], T2.prototype, "_isPreviewLayer", null), T2 = e([a4("esri.layers.ImageryLayer")], T2);
var x2 = T2;

export {
  x2 as x
};
//# sourceMappingURL=chunk-ANZPTCB4.js.map
