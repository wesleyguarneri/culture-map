{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/widgets/Legend/support/heatmapRampUtils.js", "../../../../../../node_modules/@arcgis/core/renderers/support/utils.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport o from \"../../../renderers/support/HeatmapColorStop.js\";\nfunction r(r) {\n  if (!r.colorStops) return [];\n  const e = [...r.colorStops].filter(o => o.color?.a > 0);\n  let t = e.length - 1;\n  if (e && e[0]) {\n    const r = e[t];\n    r && 1 !== r.ratio && (e.push(new o({\n      ratio: 1,\n      color: r.color\n    })), t++);\n  }\n  return e.map((o, e) => {\n    let l = \"\";\n    return 0 === e ? l = r.legendOptions?.minLabel || \"low\" : e === t && (l = r.legendOptions?.maxLabel || \"high\"), {\n      color: o.color,\n      label: l,\n      ratio: o.ratio\n    };\n  }).reverse();\n}\nexport { r as getHeatmapRampStops };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { unique as e, isSome as l } from \"../../core/arrayUtils.js\";\nimport t from \"../../core/Logger.js\";\nimport { getOrCreateMapValue as i } from \"../../core/MapUtils.js\";\nimport { convertDateFormatToIntlOptions as o, formatDate as a } from \"../../intl/date.js\";\nimport { isTimeOnlyField as n } from \"../../layers/support/fieldUtils.js\";\nimport { format as s, round as r } from \"./numberUtils.js\";\nimport u from \"../visualVariables/support/ColorStop.js\";\nimport { isAnyDateField as f, formatAnyDate as d } from \"../../smartMapping/support/utils.js\";\nimport { getColorFromSymbol as p } from \"../../symbols/support/utils.js\";\nimport { getRampStops as m } from \"../../widgets/Legend/support/colorRampUtils.js\";\nimport { getHeatmapRampStops as c } from \"../../widgets/Legend/support/heatmapRampUtils.js\";\nconst y = () => t.getLogger(\"esri.renderers.support.utils\"),\n  g = {\n    lte: \"<=\",\n    gte: \">=\",\n    lt: \"<\",\n    gt: \">\",\n    pct: \"%\",\n    ld: \"â€“\"\n  },\n  h = {\n    millisecond: 0,\n    second: 1,\n    minute: 2,\n    hour: 3,\n    day: 4,\n    month: 5,\n    year: 6\n  },\n  b = {\n    millisecond: \"long-month-day-year-long-time\",\n    second: \"long-month-day-year-long-time\",\n    minute: \"long-month-day-year-short-time\",\n    hour: \"long-month-day-year-short-time\",\n    day: \"long-month-day-year\",\n    month: \"long-month-day-year\",\n    year: \"year\"\n  },\n  v = o(\"short-date\");\nasync function w(e, l, t) {\n  i(e, l, () => []).push(...t);\n}\nasync function x(l) {\n  const t = new Map();\n  if (!l) return t;\n  if (\"visualVariables\" in l && l.visualVariables) {\n    const e = l.visualVariables.filter(e => \"color\" === e.type);\n    for (const l of e) {\n      const e = ((await m(l)) ?? []).map(e => e.color);\n      await w(t, l.field || l.valueExpression, e);\n    }\n  }\n  if (\"heatmap\" === l.type) {\n    const e = c(l).map(e => e.color);\n    await w(t, l.field || l.valueExpression, e);\n  } else if (\"pie-chart\" === l.type) {\n    for (const e of l.attributes) await w(t, e.field || e.valueExpression, [e.color]);\n    await w(t, \"default\", [l?.othersCategory?.color, p(l.backgroundFillSymbol, null)]);\n  } else if (\"dot-density\" === l.type) {\n    for (const e of l.attributes) await w(t, e.field || e.valueExpression, [e.color]);\n    await w(t, \"default\", [l.backgroundColor]);\n  } else if (\"unique-value\" === l.type) {\n    if (\"predominance\" === l.authoringInfo?.type) for (const e of l.uniqueValueInfos ?? []) await w(t, e.value.toString(), [p(e.symbol, null)]);else {\n      const e = (l.uniqueValueInfos ?? []).map(e => p(e.symbol, null)),\n        {\n          field: i,\n          field2: o,\n          field3: a,\n          valueExpression: n\n        } = l;\n      (i || n) && (await w(t, i || n, e)), o && (await w(t, o, e)), a && (await w(t, a, e));\n    }\n  } else if (\"class-breaks\" === l.type) {\n    const e = l.classBreakInfos.map(e => p(e.symbol, null)),\n      {\n        field: i,\n        valueExpression: o\n      } = l;\n    await w(t, i ?? o, e);\n  } else \"simple\" === l.type && (await w(t, \"default\", [p(l.symbol, null)]));\n  return \"defaultSymbol\" in l && l.defaultSymbol && (await w(t, \"default\", [p(l.defaultSymbol, null)])), t.forEach((l, i) => {\n    const o = e(l.filter(Boolean), (e, l) => JSON.stringify(e) === JSON.stringify(l));\n    t.set(i, o);\n  }), t;\n}\nasync function V(e, l, t) {\n  const o = i(e, l, () => new Map());\n  for (const i of t) o.set(i.value, i.color);\n}\nasync function E(e) {\n  const l = new Map();\n  if (!e) return l;\n  if (\"unique-value\" !== e.type || e.authoringInfo?.type) {\n    if (\"class-breaks\" === e.type) {\n      const t = e.classBreakInfos.map(e => ({\n          value: e.minValue,\n          color: p(e.symbol, null)\n        })).reverse(),\n        {\n          field: i,\n          valueExpression: o\n        } = e;\n      await V(l, i ?? o, t);\n    } else \"simple\" === e.type && (await V(l, \"default\", [{\n      value: \"default\",\n      color: p(e.symbol, null)\n    }]));\n  } else {\n    const t = (e.uniqueValueInfos ?? []).map(e => ({\n        value: e.value,\n        color: p(e.symbol, null)\n      })),\n      {\n        field: i,\n        field2: o,\n        field3: a,\n        valueExpression: n,\n        fieldDelimiter: s\n      } = e,\n      r = [i, o, a].filter(Boolean).join(s || \"\");\n    (r || n) && (await V(l, r || n, t));\n  }\n  if (\"defaultSymbol\" in e && e.defaultSymbol && (await V(l, \"default\", [{\n    value: \"default\",\n    color: p(e.defaultSymbol, null)\n  }])), \"visualVariables\" in e && e.visualVariables) {\n    const t = e.visualVariables.filter(e => \"color\" === e.type);\n    for (const e of t) {\n      const t = (await m(e)) ?? [];\n      await V(l, e.field || e.valueExpression, t);\n    }\n  }\n  return l;\n}\nfunction F(e, l, t) {\n  let i = \"\";\n  return 0 === l ? i = g.lt + \" \" : l === t && (i = g.gt + \" \"), i + e;\n}\nfunction z(e) {\n  const {\n    values: l,\n    colors: t,\n    labelIndexes: i,\n    isDate: o\n  } = e;\n  return l.map((e, n) => {\n    let r = null;\n    if (!i || i.includes(n)) {\n      const t = o ? a(e) : s(e);\n      t && (r = F(t, n, l.length - 1));\n    }\n    return new u({\n      value: e,\n      color: t[n],\n      label: r\n    });\n  });\n}\nfunction S(e) {\n  let l = e.minValue,\n    t = e.maxValue;\n  const i = e.isFirstBreak ? \"\" : g.gt + \" \",\n    o = \"percent-of-total\" === e.normalizationType ? g.pct : \"\";\n  return l = null == l ? \"\" : s(l), t = null == t ? \"\" : s(t), i + l + o + \" \" + g.ld + \" \" + t + o;\n}\nfunction k(e) {\n  const l = e.classBreakInfos,\n    t = e.normalizationType;\n  let i = [];\n  if (l?.length) if (\"standard-deviation\" !== e.classificationMethod) {\n    if (e.round) {\n      i.push(l[0].minValue);\n      for (const e of l) i.push(e.maxValue);\n      i = r(i), l.forEach((e, l) => {\n        e.label = S({\n          minValue: 0 === l ? i[0] : i[l],\n          maxValue: i[l + 1],\n          isFirstBreak: 0 === l,\n          normalizationType: t\n        });\n      });\n    } else l.forEach((e, l) => {\n      e.label = S({\n        minValue: e.minValue,\n        maxValue: e.maxValue,\n        isFirstBreak: 0 === l,\n        normalizationType: t\n      });\n    });\n  } else y().warn(\"setLabelsForClassBreaks\", \"cannot set labels for class breaks generated using 'standard-deviation' method.\");\n}\nfunction j(e) {\n  const l = e.map(e => new Date(e)),\n    t = l.length;\n  let i = 1 / 0,\n    o = null;\n  for (let a = 0; a < t - 1; a++) {\n    const e = l[a];\n    let n = 1 / 0,\n      s = null;\n    for (let i = a + 1; i < t; i++) {\n      const t = l[i],\n        o = (e.getFullYear() !== t.getFullYear() ? \"year\" : e.getMonth() !== t.getMonth() && \"month\") || e.getDate() !== t.getDate() && \"day\" || e.getHours() !== t.getHours() && \"hour\" || e.getMinutes() !== t.getMinutes() && \"minute\" || e.getSeconds() !== t.getSeconds() && \"second\" || \"millisecond\",\n        a = h[o];\n      a < n && (n = a, s = o);\n    }\n    n < i && (i = n, o = s);\n  }\n  return o;\n}\nfunction I(e) {\n  const {\n    value: l,\n    domain: t,\n    fieldInfo: i,\n    dateFormatOptions: o\n  } = e;\n  let a = String(l);\n  const r = t && \"codedValues\" in t && t.codedValues ? t.getName(l) : null;\n  return r ? a = r : null != l && i && (f(i) || n(i)) ? a = d(l, o ?? {\n    fieldType: i.type\n  }) : \"number\" == typeof l && (a = s(l)), a;\n}\nfunction M(e, l) {\n  return \"normalizationField\" in e && e.normalizationField ? q(e.field, e.normalizationField) : \"field\" in e && e.field ? B(e.field) : \"valueExpression\" in e && e.valueExpression ? T(e.valueExpression, e.valueExpressionTitle, l) : null;\n}\nfunction B(e) {\n  return {\n    type: \"field\",\n    field: e\n  };\n}\nfunction q(e, l) {\n  return {\n    type: \"normalized-field\",\n    field: e,\n    normalizationField: l\n  };\n}\nfunction T(e, l, t) {\n  return {\n    type: \"expression\",\n    expression: e,\n    title: l,\n    returnType: t\n  };\n}\nfunction U(t, i) {\n  const o = [];\n  if (\"class-breaks\" === t.type || \"heatmap\" === t.type) o.push(M(t, \"number\"));else if (\"unique-value\" === t.type) {\n    const e = t.authoringInfo;\n    if (e && \"relationship\" === e.type) {\n      if (e.field1 && e.field2) {\n        const l = e.field1.field,\n          t = e.field2.field,\n          i = e.field1.normalizationField,\n          a = e.field2.normalizationField;\n        o.push(M({\n          field: l,\n          normalizationField: i\n        })), o.push(M({\n          field: t,\n          normalizationField: a\n        }));\n      }\n    } else {\n      const e = t.uniqueValueInfos?.[0];\n      let l = null;\n      if (e?.value) {\n        const t = typeof e.value;\n        \"string\" !== t && \"number\" !== t || (l = t);\n      }\n      o.push(M(t, l)), [t.field2, t.field3].forEach(e => e && o.push(B(e)));\n    }\n  } else \"attributes\" in t && t.attributes?.forEach(e => o.push(M(e, \"number\")));\n  const a = i ? i(t) : \"visualVariables\" in t ? t.visualVariables : null;\n  return a && a.forEach(e => o.push(M(e, \"number\"))), e(o.filter(l), (e, l) => \"field\" === e.type && \"field\" === l.type ? e.field === l.field : \"normalized-field\" === e.type && \"normalized-field\" === l.type ? e.field === l.field && e.normalizationField === l.normalizationField : \"expression\" === e.type && \"expression\" === l.type && e.expression === l.expression);\n}\nexport { j as calculateDateFormatInterval, S as createClassBreakLabel, z as createColorStops, I as createUniqueValueLabel, b as dateFormatIntervalOptions, M as getAttribute, U as getAttributes, E as getColorsForRendererValues, x as getColorsFromRenderer, k as setLabelsForClassBreaks, v as timelineDateFormatOptions };"],
  "mappings": "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",
  "names": ["r", "e", "l", "l", "e", "r", "a", "n"]
}
