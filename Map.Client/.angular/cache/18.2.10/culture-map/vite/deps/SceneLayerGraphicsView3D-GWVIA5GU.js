import {
  a as a2,
  f,
  i as i3,
  i2 as i4,
  u as u4,
  w as w2
} from "./chunk-OJZQSS6S.js";
import {
  i as i2
} from "./chunk-U46JKVZ5.js";
import {
  t2 as t5,
  u2 as u3
} from "./chunk-UKXHREMM.js";
import {
  G,
  K
} from "./chunk-JCGHSOIP.js";
import "./chunk-PA5PVFOE.js";
import "./chunk-XVYR2JNI.js";
import "./chunk-KGPFLNKT.js";
import "./chunk-M66N34RL.js";
import "./chunk-4E3ADDPV.js";
import "./chunk-TOQG323X.js";
import {
  P2,
  l as l3
} from "./chunk-K7KZCCPZ.js";
import "./chunk-5A6MLLPH.js";
import "./chunk-2WSNLRTZ.js";
import "./chunk-IIXY5BBS.js";
import "./chunk-SB6NP2J2.js";
import "./chunk-AXXQSWHU.js";
import "./chunk-PPMYY5TL.js";
import "./chunk-ONNA6736.js";
import "./chunk-ZEJV2HHS.js";
import "./chunk-7RD4KVUX.js";
import "./chunk-S2OEQYU7.js";
import "./chunk-UAMCUBIO.js";
import "./chunk-PR6QK2UX.js";
import "./chunk-HHHY7K7M.js";
import "./chunk-PRMR227H.js";
import "./chunk-APWDCJIJ.js";
import "./chunk-NEPAFG4J.js";
import "./chunk-E7VVOB2F.js";
import "./chunk-DOYOAB3G.js";
import "./chunk-DDIAZD6H.js";
import "./chunk-7YXVUZL6.js";
import "./chunk-6YVA5E7L.js";
import "./chunk-4KGPH7OX.js";
import {
  c
} from "./chunk-TLAW3ACJ.js";
import "./chunk-GFPWBDCO.js";
import "./chunk-MQUE5HQL.js";
import "./chunk-TKHURHLF.js";
import "./chunk-U7YHNT5S.js";
import "./chunk-UW23RIEM.js";
import "./chunk-R6CAUNOR.js";
import "./chunk-6BPYXCCQ.js";
import "./chunk-TMIIQZKR.js";
import "./chunk-ROVEMBDA.js";
import "./chunk-ZIDRXKSJ.js";
import "./chunk-DBK2ELNZ.js";
import "./chunk-S2GZKKIE.js";
import "./chunk-JMV2M56E.js";
import "./chunk-ZQYSUMPX.js";
import "./chunk-CZLVBJSQ.js";
import "./chunk-S2UCXOWF.js";
import "./chunk-VI6HLZLR.js";
import "./chunk-MYKOM3G6.js";
import "./chunk-6FZS4YUQ.js";
import "./chunk-JRZPZOI3.js";
import "./chunk-TP2RTSHJ.js";
import "./chunk-RDOYE3NP.js";
import "./chunk-DXJZ22ZH.js";
import "./chunk-LVYRNWV6.js";
import "./chunk-GW7WMRYJ.js";
import "./chunk-LWAFK7Z6.js";
import "./chunk-Z52R7W33.js";
import "./chunk-O7OCS6XP.js";
import "./chunk-BFWLPS7M.js";
import {
  C
} from "./chunk-67LE7VNQ.js";
import "./chunk-ENI3KAZB.js";
import "./chunk-ZVEHH7XL.js";
import "./chunk-BJM7H6OC.js";
import "./chunk-5MM5MT6Q.js";
import "./chunk-SCLVG2SO.js";
import "./chunk-557LD7Q2.js";
import "./chunk-B64VDY5O.js";
import "./chunk-MAG65NGG.js";
import "./chunk-X5UPCJEP.js";
import "./chunk-6R6EEJ3E.js";
import "./chunk-2ONAF54K.js";
import "./chunk-K74MUOGN.js";
import "./chunk-NLEBYD5G.js";
import {
  t as t4
} from "./chunk-MOCGEINB.js";
import {
  t as t3
} from "./chunk-NSSWLGUQ.js";
import {
  l as l2
} from "./chunk-CITBGG5A.js";
import "./chunk-6HTAUV5K.js";
import "./chunk-PFFFLPSP.js";
import "./chunk-EOYCWFZW.js";
import "./chunk-IJVQCMOT.js";
import "./chunk-UQMQLPLV.js";
import "./chunk-5JJ6GBOU.js";
import "./chunk-RP2GKJCD.js";
import "./chunk-KM65NCZ2.js";
import "./chunk-6YA72G7G.js";
import "./chunk-D4LAF4TH.js";
import "./chunk-QL5HR3YL.js";
import {
  o as o5
} from "./chunk-37FUJHR2.js";
import "./chunk-UOIZXQPU.js";
import "./chunk-D3AKDIJC.js";
import "./chunk-IM5W3NWZ.js";
import "./chunk-WVEBK4ZV.js";
import "./chunk-5NCKEQLF.js";
import "./chunk-ATQ5GYTB.js";
import "./chunk-ZUHJZKEM.js";
import "./chunk-B4EEJXBQ.js";
import "./chunk-JA2C7MTO.js";
import "./chunk-74INNEIP.js";
import "./chunk-7HBD4CJ3.js";
import "./chunk-K2LTET4M.js";
import "./chunk-WG5JLPNN.js";
import "./chunk-25PMMPR7.js";
import "./chunk-7XAWCQ7R.js";
import "./chunk-RASN5P76.js";
import "./chunk-5L3YXBNN.js";
import "./chunk-IFUKJDOU.js";
import "./chunk-LD5YIQXD.js";
import "./chunk-J7KF6IEI.js";
import "./chunk-GOKBAMCG.js";
import "./chunk-E3P3LIVT.js";
import "./chunk-HUX6Y26H.js";
import "./chunk-LN4EMOLP.js";
import "./chunk-PDYGQYJC.js";
import "./chunk-JS5N3Y4L.js";
import "./chunk-PO7V7AQE.js";
import "./chunk-JO42C6R3.js";
import "./chunk-PZH3N2FW.js";
import "./chunk-U4WO2GC4.js";
import "./chunk-JO76LYW5.js";
import "./chunk-A6XTYETO.js";
import "./chunk-EKCE56CG.js";
import "./chunk-4TJAOUC3.js";
import "./chunk-CILAEMQM.js";
import "./chunk-WRHEXEG3.js";
import "./chunk-3HAZL2RZ.js";
import "./chunk-XUAPJ5BK.js";
import "./chunk-TEOUFCJA.js";
import "./chunk-GTZOXRB5.js";
import "./chunk-3WPOFZBT.js";
import "./chunk-PPMHRAOP.js";
import "./chunk-75N5YDQB.js";
import "./chunk-3MNGTHM3.js";
import "./chunk-XGDLE7WK.js";
import "./chunk-QMUS26QM.js";
import "./chunk-GDEAPZ64.js";
import "./chunk-TCQSUQ7Y.js";
import "./chunk-GOOZVNO4.js";
import "./chunk-JUTKZ3GO.js";
import "./chunk-5RHKQDDL.js";
import "./chunk-BG32AOSQ.js";
import "./chunk-PEZTN5WV.js";
import "./chunk-FHW2TG7X.js";
import "./chunk-33LKI2Y7.js";
import "./chunk-YCQXFVJL.js";
import "./chunk-ZAP7ZEWR.js";
import "./chunk-YAGNWBGU.js";
import {
  t as t2
} from "./chunk-DE6MQ5XE.js";
import "./chunk-LQTSBE7P.js";
import "./chunk-GCFUJXGH.js";
import "./chunk-MBMY7SS6.js";
import "./chunk-ICUHXX2J.js";
import "./chunk-VIIVMRRO.js";
import "./chunk-ZKSEQXDM.js";
import "./chunk-675UQNXB.js";
import "./chunk-DXGCBLDW.js";
import "./chunk-Z3FHX4FD.js";
import "./chunk-SUUOAZQT.js";
import "./chunk-TGHJVD7I.js";
import "./chunk-OZG2NNUW.js";
import "./chunk-KTRZHJ2M.js";
import "./chunk-KOIKSJSQ.js";
import "./chunk-VUVXW4AC.js";
import "./chunk-LKHUGH5W.js";
import "./chunk-ODLAAWPY.js";
import "./chunk-VWVZLPC3.js";
import "./chunk-P2MXQ2EV.js";
import "./chunk-QZVEEM53.js";
import "./chunk-ACZYDHB3.js";
import "./chunk-JXVDTUGR.js";
import "./chunk-HAO4WCNW.js";
import "./chunk-X2OAE75B.js";
import "./chunk-UCPBGEQD.js";
import "./chunk-SIZK72CP.js";
import {
  h
} from "./chunk-Y37SHKPH.js";
import "./chunk-Z3XBAPJ2.js";
import "./chunk-EUVN3KSV.js";
import "./chunk-WBOVDU4O.js";
import "./chunk-TQYVLRAH.js";
import "./chunk-6A3XUATG.js";
import "./chunk-WX42XBL6.js";
import "./chunk-WBUJP5OW.js";
import "./chunk-L64P7DHA.js";
import "./chunk-EYYHTDAX.js";
import "./chunk-TVV62TZG.js";
import "./chunk-ZNDAVKXT.js";
import "./chunk-5XOZP4XS.js";
import "./chunk-ZVFENZUF.js";
import "./chunk-C2NHN5LF.js";
import "./chunk-OHXCVJMH.js";
import "./chunk-N3S77FRG.js";
import "./chunk-YYETZJJB.js";
import "./chunk-MD2IQSSQ.js";
import "./chunk-H6HXZTAS.js";
import "./chunk-VHERB2HE.js";
import {
  Z
} from "./chunk-Z6Z2SY6R.js";
import "./chunk-YZBHNRVB.js";
import "./chunk-EXODD7PD.js";
import "./chunk-C7VF4AR2.js";
import "./chunk-EU7HJNZD.js";
import "./chunk-4HODTCAO.js";
import "./chunk-RSQ7FJBQ.js";
import "./chunk-EK3IKAMF.js";
import "./chunk-IJVN5N2Q.js";
import "./chunk-JCWQ2LOQ.js";
import "./chunk-P7OSFLIX.js";
import "./chunk-ZDC4PV4Y.js";
import "./chunk-O7ZVERIH.js";
import "./chunk-IIZFTYAL.js";
import "./chunk-YSIUOTSV.js";
import "./chunk-NQEXQAS7.js";
import "./chunk-R4DKV4UN.js";
import "./chunk-SNHPS7NU.js";
import "./chunk-L3F4XA4B.js";
import "./chunk-DLRYNII2.js";
import "./chunk-ENQEWBGS.js";
import "./chunk-66QAJ2MI.js";
import "./chunk-WN3YAMRZ.js";
import "./chunk-NWICVENM.js";
import "./chunk-OUP4PSAG.js";
import "./chunk-A4RKV2C7.js";
import "./chunk-WU7FVYT7.js";
import "./chunk-SYYDVGKY.js";
import "./chunk-6HBAAUBO.js";
import "./chunk-YLE5AYZV.js";
import "./chunk-6V5NKLIC.js";
import "./chunk-CZQYBYHB.js";
import "./chunk-Q5ZRUB2Y.js";
import "./chunk-2XI572KI.js";
import "./chunk-R4P4UBKU.js";
import {
  e as e3,
  t
} from "./chunk-62WUYJJN.js";
import "./chunk-AWJPQWYU.js";
import "./chunk-JNWMZ6EJ.js";
import "./chunk-VS26W5Y5.js";
import "./chunk-PVO5NM6Q.js";
import "./chunk-ZQ57XGAE.js";
import "./chunk-UXW277HY.js";
import "./chunk-OR5F5ACQ.js";
import "./chunk-E2WAKNLZ.js";
import "./chunk-ROATEOHC.js";
import "./chunk-BIWDYV6F.js";
import "./chunk-4MXR7W7N.js";
import "./chunk-6UYQMUGI.js";
import "./chunk-D3XZUGMN.js";
import {
  I
} from "./chunk-YFQ32AQX.js";
import "./chunk-L4AYSXFJ.js";
import "./chunk-POQ3T5EH.js";
import "./chunk-LPEFONL3.js";
import "./chunk-SSMSHZ2C.js";
import "./chunk-DM4WHMQY.js";
import "./chunk-DON3YPGT.js";
import "./chunk-C7NRYPDG.js";
import "./chunk-Z3GMSC63.js";
import "./chunk-F35MWZH7.js";
import "./chunk-ED7UGR2X.js";
import "./chunk-YA5CTHMT.js";
import "./chunk-4QBFFLOC.js";
import "./chunk-O437BSYE.js";
import "./chunk-YZNT6QWD.js";
import "./chunk-YVOGHYE3.js";
import "./chunk-IBOZJLSO.js";
import "./chunk-JDUU4ZDX.js";
import "./chunk-TT5ZTQDR.js";
import {
  u as u2
} from "./chunk-2N3BR7QT.js";
import "./chunk-6MR4UDDL.js";
import "./chunk-N3IR233K.js";
import "./chunk-3AY5EJVP.js";
import {
  d as d3
} from "./chunk-XQCKIDQO.js";
import "./chunk-YFOAET4H.js";
import "./chunk-5U4TBXYS.js";
import "./chunk-6WG22V46.js";
import "./chunk-OOGIXDXG.js";
import "./chunk-KDJZAYOF.js";
import "./chunk-HCFDI7IX.js";
import "./chunk-AQJS6F3O.js";
import "./chunk-WUB6LJVL.js";
import "./chunk-QXSES7JX.js";
import "./chunk-5YIMTGEC.js";
import "./chunk-UFVMJL32.js";
import "./chunk-2SMFPIRI.js";
import {
  A as A2,
  N,
  Q,
  Y,
  te
} from "./chunk-VCFSVEDB.js";
import "./chunk-XCVOKQAA.js";
import "./chunk-3WQXHRJE.js";
import "./chunk-EBLQZUPS.js";
import "./chunk-URWREU3E.js";
import "./chunk-KE2YMCJC.js";
import {
  n as n5
} from "./chunk-L7ZKWTWL.js";
import {
  e as e2
} from "./chunk-O2DTA3XK.js";
import "./chunk-3UOXF3CT.js";
import "./chunk-WDDCGJTI.js";
import "./chunk-PA7WZX2U.js";
import "./chunk-GPUGMSHU.js";
import "./chunk-AIS5CSUZ.js";
import "./chunk-52UEU7LG.js";
import "./chunk-WJKYGQOY.js";
import "./chunk-GY52WOQZ.js";
import "./chunk-GAYJ4YPJ.js";
import "./chunk-PPMDUJ4E.js";
import "./chunk-ZTT6ENBS.js";
import "./chunk-MFZTGYUJ.js";
import "./chunk-R5ZE5A4K.js";
import "./chunk-24CN3HDP.js";
import "./chunk-SZWWBMQN.js";
import "./chunk-ZE47C44H.js";
import "./chunk-5GIS2C3K.js";
import "./chunk-XCOHDMBF.js";
import "./chunk-ZR5BOILP.js";
import "./chunk-QCBC3RJX.js";
import "./chunk-6XGV55XZ.js";
import "./chunk-HOH445RO.js";
import "./chunk-R3F4JMNC.js";
import "./chunk-63QCTVYB.js";
import "./chunk-W5ERGD4Y.js";
import {
  J
} from "./chunk-7B5YPLFX.js";
import {
  s
} from "./chunk-RDQF44TE.js";
import "./chunk-KKD7A2GN.js";
import "./chunk-ZWCV4HKG.js";
import "./chunk-N4KQPPPI.js";
import "./chunk-4OGGMTIH.js";
import "./chunk-NQVBBKAN.js";
import "./chunk-U74WRHVJ.js";
import "./chunk-TCPN7AEH.js";
import "./chunk-4MMTPKY4.js";
import "./chunk-DY7FJHTG.js";
import "./chunk-Q4KYZS3X.js";
import "./chunk-KVKFHRJ3.js";
import "./chunk-VWML4J2J.js";
import "./chunk-JYODC3YQ.js";
import "./chunk-BQZBOYBD.js";
import "./chunk-TYQXPPSP.js";
import "./chunk-W2IRSMFY.js";
import {
  b
} from "./chunk-TRSGUVSM.js";
import "./chunk-U3MA63JX.js";
import "./chunk-WYKKCLBI.js";
import "./chunk-PFMGJTQM.js";
import "./chunk-Q7SRMLJZ.js";
import "./chunk-PQ4T66BG.js";
import "./chunk-SWPHGZYB.js";
import "./chunk-DWASPXVI.js";
import "./chunk-TNWXOQKO.js";
import "./chunk-MAO5BVLA.js";
import "./chunk-T2S5VXNP.js";
import "./chunk-4U5GUJRA.js";
import "./chunk-7KRERHHR.js";
import "./chunk-T4AP6CTC.js";
import {
  d as d2
} from "./chunk-HD65DNIO.js";
import "./chunk-4KWLMXIA.js";
import "./chunk-BIUXKPKA.js";
import "./chunk-N6TJI25E.js";
import "./chunk-634JLXD4.js";
import "./chunk-Y3EDGYWG.js";
import "./chunk-UF6JOUSJ.js";
import "./chunk-T5JGQSO3.js";
import "./chunk-CIW3KHOW.js";
import "./chunk-J55F4AC2.js";
import "./chunk-IQLBZKUD.js";
import "./chunk-7MZZCQ64.js";
import "./chunk-LNRZHZOQ.js";
import "./chunk-DI6VABAK.js";
import {
  S
} from "./chunk-5EBAJR7X.js";
import "./chunk-5JA2JHV3.js";
import "./chunk-FUKSTKFU.js";
import "./chunk-MIQZ6UDY.js";
import "./chunk-JOJZ6YC5.js";
import "./chunk-L4TOCXR5.js";
import "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import "./chunk-7WP676SE.js";
import "./chunk-WPPFJVPN.js";
import "./chunk-SGSUM5YO.js";
import "./chunk-SG5TCCCK.js";
import "./chunk-6A7CWJED.js";
import "./chunk-DUTZNK67.js";
import {
  o as o4
} from "./chunk-IN6BQCWS.js";
import "./chunk-CRNUMTSV.js";
import "./chunk-JM7HAEY6.js";
import "./chunk-LJEOBI2I.js";
import "./chunk-2OMCGIU4.js";
import "./chunk-V5RMUGJJ.js";
import "./chunk-D2NB6D6N.js";
import "./chunk-M2NS3MSU.js";
import "./chunk-3RRMLFFN.js";
import "./chunk-DR5TVNEL.js";
import "./chunk-HT2T6PUB.js";
import "./chunk-K64AAM77.js";
import "./chunk-6EUVKE22.js";
import "./chunk-A3NNJ7XA.js";
import "./chunk-OKJHJ3CY.js";
import "./chunk-XTVPEVHA.js";
import "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import "./chunk-DZALMCYL.js";
import "./chunk-K226GFDN.js";
import "./chunk-4ZZRP4MA.js";
import "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-5I6J67HP.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-XWXBNAOW.js";
import "./chunk-GWC3DAGP.js";
import "./chunk-EODIWR2E.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-FYAEQPUY.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import {
  n as n4
} from "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-7RMVJCDW.js";
import "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import {
  i,
  o as o2
} from "./chunk-NYQ5CYNR.js";
import "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import {
  o as o3
} from "./chunk-AXVPJBVW.js";
import {
  l,
  n as n3
} from "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import {
  P,
  d
} from "./chunk-6WHTZNUH.js";
import "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import "./chunk-XNUH25NY.js";
import {
  o
} from "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e
} from "./chunk-4Z5SGKRM.js";
import "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3 as a,
  n as n2
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import {
  u
} from "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  n2 as n
} from "./chunk-WYIDUUN2.js";
import {
  A2 as A,
  w
} from "./chunk-DXLOWWK7.js";
import {
  __async
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/views/3d/layers/I3SPointsWorkerHandle.js
var r = class extends h {
  constructor(e4) {
    super("SceneLayerWorker", "dracoDecompressPointCloudData", {
      dracoDecompressPointCloudData: (e5) => [e5.geometryBuffer]
    }, e4, {
      hasInitialize: true
    });
  }
};

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/I3SGraphicsMap.js
var s2 = class extends o {
  constructor(e4, t6) {
    super(), this._updateAndCompare = e4, this._notifyUpdated = t6, this._nodes = /* @__PURE__ */ new Map(), this._graphics = /* @__PURE__ */ new Map(), this._duplicates = /* @__PURE__ */ new Map();
  }
  clear() {
    if (this._graphics.size > 0) {
      const e4 = this.toArray();
      this._graphics.clear(), this.emit("change", {
        added: [],
        removed: e4
      });
    }
    this._nodes.clear();
  }
  get length() {
    return this._graphics.size;
  }
  get(e4) {
    return this._graphics.get(e4);
  }
  getNode(e4) {
    return this._nodes.get(e4);
  }
  hasNode(e4) {
    return this._nodes.has(e4);
  }
  nodes() {
    return this._nodes.values();
  }
  addNode(e4, t6) {
    this._nodes.set(e4, t6);
    const s3 = t6.graphics;
    if (0 === s3.length) return;
    const i5 = /* @__PURE__ */ new Set();
    for (let o6 = 0; o6 < s3.length; o6++) {
      const t7 = s3[o6], n7 = t7.objectId, h2 = this._graphics.get(n7);
      if (h2) {
        i5.add(n7), t7 !== h2 && (s3[o6] = h2);
        const r2 = this._duplicates.get(n7);
        r2 ? r2.push(e4) : this._duplicates.set(n7, [h2.nodeIndex, e4]);
      } else t7.nodeIndex = e4, this._graphics.set(n7, t7);
    }
    i5.size && this._updateForeignGraphics(t6);
    const n6 = i5.size > 0 ? s3.filter((e5) => !i5.has(e5.objectId)) : s3;
    n6.length > 0 && this.emit("change", {
      added: n6,
      removed: []
    });
  }
  removeNode(e4) {
    const t6 = this._nodes.get(e4);
    if (!t6) return;
    this._nodes.delete(e4);
    const s3 = /* @__PURE__ */ new Set(), i5 = [];
    for (const n6 of t6.graphics) {
      const t7 = n6.objectId, o6 = this._graphics.get(t7);
      if (!o6) continue;
      const h2 = this._duplicates.get(t7);
      if (h2) {
        const i6 = h2.indexOf(e4);
        if (-1 === i6) continue;
        if (h2.splice(i6, 1), o6.nodeIndex === e4) {
          let e5 = this.getNode(h2[0]);
          for (let t8 = 1; t8 < h2.length; t8++) {
            const s4 = this.getNode(h2[t8]);
            (null == e5 || null != s4 && s4.node.level > e5.node.level) && (e5 = s4);
          }
          null != e5 && s3.add(e5);
        }
        1 === h2.length && this._duplicates.delete(t7);
      } else this._graphics.delete(t7), i5.push(n6);
    }
    i5.length > 0 && this.emit("change", {
      added: [],
      removed: i5
    }), s3.forEach((e5) => this._updateForeignGraphics(e5));
  }
  _updateForeignGraphics(e4) {
    const t6 = [], s3 = e4.node.index, i5 = e4.node.level;
    let n6 = 0;
    for (; n6 < e4.graphics.length; ) {
      const o6 = e4.graphics[n6].nodeIndex;
      if (o6 === s3) {
        n6++;
        continue;
      }
      let h2 = 1;
      for (; n6 + h2 < e4.graphics.length && e4.graphics[n6 + h2].nodeIndex === o6; ) h2++;
      const r2 = this.getNode(o6);
      if (null != r2 && r2.node.level > i5) n6 += h2;
      else {
        for (let i6 = n6; i6 < n6 + h2; i6++) {
          const n7 = e4.graphics[i6];
          n7.nodeIndex = s3, this._updateAndCompare(n7, e4, i6) && t6.push(n7);
        }
        n6 += h2;
      }
    }
    t6.length > 0 && this._notifyUpdated(t6);
  }
  toArray() {
    return Array.from(this._graphics.values());
  }
  find(e4) {
    let s3;
    return n2(this._graphics, (t6) => !!e4(t6) && (s3 = t6, true)), s3;
  }
  forEach(e4) {
    this._graphics.forEach((t6) => e4(t6));
  }
  forEachNode(e4) {
    this._nodes.forEach((t6, s3) => e4(t6, s3));
  }
  get nodeCount() {
    return this._nodes.size;
  }
  _checkInvariants() {
    const e4 = /* @__PURE__ */ new Map();
    this._nodes.forEach((t6, s3) => {
      t6.graphics.forEach((t7) => {
        e4.set(t7.objectId, 1 + (e4.get(t7.objectId) ?? 0)), this._duplicates.get(t7.objectId);
      });
    }), e4.forEach((e5, t6) => {
      const s3 = this._graphics.get(t6);
      if (!s3) return;
      if (!this._nodes.get(s3.nodeIndex)) return;
      const i5 = this._duplicates.get(t6);
      i5 && i5.forEach((e6) => {
        this._nodes.get(e6);
      });
    });
  }
};

// ../../../node_modules/@arcgis/core/views/3d/layers/SceneLayerGraphicsView3D.js
var re = i4();
var ie = class {
  constructor(e4, t6, r2, i5) {
    this.graphics = e4, this.featureIds = t6, this.attributeInfo = r2, this.node = i5;
  }
};
var se = class extends u3(t5(i2(l2(w2)))) {
  constructor() {
    super(...arguments), this.type = "scene-layer-graphics-3d", this._queryEngine = null, this._memCache = null, this._interactiveEditingSessions = /* @__PURE__ */ new Map(), this._pendingEditsQueue = Promise.resolve(), this.loadedGraphics = new s2((e4, t6, r2) => le(e4, t6, r2), (e4) => this.processor.graphicsCore.recreateGraphics(e4)), this.holeFilling = "always", this.progressiveLoadFactor = 1, this.supportsHeightUnitConversion = true, this._coordinatesOutsideExtentErrors = 0, this._maxCoordinatesOutsideExtentErrors = 20;
  }
  tryRecycleWith(e4, t6) {
    return e4.url === this.layer.url && this._i3sOverrides.isEmpty ? e4.load(t6).then(() => {
      Y(this.layer, e4, this._i3sOverrides), this.layer = e4, this._i3sOverrides.destroy();
      const t7 = this.view.resourceController?.memoryController;
      this._i3sOverrides = new G({
        view: this.view,
        layer: e4,
        memoryController: t7
      }), u(this._queryEngine), this._setupQueryEngine(), this.processor.resetObjectStates();
    }) : null;
  }
  initialize() {
    this.addResolvingPromise(this.layer.indexInfo);
    const e4 = this.view.resourceController?.memoryController;
    this._i3sOverrides = new G({
      view: this.view,
      layer: this.layer,
      memoryController: e4
    }), te(this.layer, this.view.spatialReference, this.view.viewingMode), this._fieldsHelper = new a2({
      layerView: this
    }), this._updatingHandles.add(() => this.layer.rangeInfos, (e5) => this._rangeInfosChanged(e5), P), this._updatingHandles.add(() => this.layer.renderer, (e5, t6) => this._rendererChange(e5, t6)), this._updatingHandles.add(() => [this.parsedDefinitionExpression, this._excludeObjectIdsSorted], () => this._filterChange()), this.addHandles(d(() => t2.I3S_TREE_SHOW_TILES, (e5) => {
      if (e5 && !this._treeDebugger) {
        const e6 = this._controller.crsIndex;
        import("./I3STreeDebugger-7RP7JCSS.js").then(({
          I3STreeDebugger: t6
        }) => {
          !this._treeDebugger && t2.I3S_TREE_SHOW_TILES && (this._treeDebugger = new t6({
            lv: this,
            view: this.view,
            nodeSR: e6
          }));
        });
      } else e5 || !this._treeDebugger || t2.I3S_TREE_SHOW_TILES || (this._treeDebugger.destroy(), this._treeDebugger = null);
    }, P)), this._set("processor", new P2({
      owner: this,
      preferredUpdatePolicy: C.ASYNC,
      scaleVisibilityEnabled: true,
      filterVisibilityEnabled: true,
      timeExtentEnabled: false,
      frustumVisibilityEnabled: false,
      elevationAlignmentEnabled: true,
      elevationFeatureExpressionEnabled: false,
      setUidToIdOnAdd: false,
      dataExtent: this.layer.fullExtent,
      updateClippingExtent: (e5) => this._updateClippingExtent(e5)
    })), this.processor.elevationAlignment?.events.on("invalidate-elevation", ({
      extent: e5,
      spatialReference: t6
    }) => this._controller.updateElevationChanged(e5, t6)), this.supportsHeightUnitConversion && (this._verticalScale = o4("point", this.layer.spatialReference, this.view.spatialReference)), this.addResolvingPromise(this.processor.initializePromise), this._memCache = this.view.resourceController.memoryController.newCache(`psl-${this.uid}`), this._controller = new K({
      layerView: this
    }), N(this.layer.geometryDefinitions) && (this._worker = new r((e5) => this.view.resourceController.immediate.schedule(e5))), this.addHandles(this.layer.on("apply-edits", (e5) => this._updatingHandles.addPromise(e5.result))), this.addHandles(this.layer.on("edits", (e5) => {
      const t6 = this._pendingEditsQueue.then(() => this._handleEdits(e5)).then();
      this._pendingEditsQueue = t6, this._updatingHandles.addPromise(t6);
    })), this.when(() => {
      this._setupQueryEngine(), this._updatingHandles.add(() => this.maximumNumberOfFeatures, (e5) => this._controller.featureTarget = e5, P), this._updatingHandles.add(() => this.suspended, (e5) => {
        e5 && this._removeAllNodeData();
      });
    });
  }
  destroy() {
    this._treeDebugger = u(this._treeDebugger), this._i3sOverrides = u(this._i3sOverrides), this._set("processor", u(this.processor)), this._controller = u(this._controller), this._queryEngine = u(this._queryEngine), this._worker = u(this._worker), this._memCache = u(this._memCache), this.loadedGraphics.clear(), this._fieldsHelper = u(this._fieldsHelper);
  }
  get i3slayer() {
    return this.layer;
  }
  get updatingProgressValue() {
    return this._controller?.updatingProgress ?? 1;
  }
  get requiredFields() {
    return this._fieldsHelper?.requiredFields ?? [];
  }
  get maximumNumberOfFeatures() {
    const e4 = this.processor?.graphicsCore?.displayFeatureLimit;
    return e4?.maximumNumberOfFeatures ?? 0;
  }
  set maximumNumberOfFeatures(e4) {
    null != e4 ? (this._override("maximumNumberOfFeatures", e4), this._controller.fixedFeatureTarget = true) : (this._clearOverride("maximumNumberOfFeatures"), this._controller.fixedFeatureTarget = false);
  }
  get maximumNumberOfFeaturesExceeded() {
    return !this.suspended && !!this._controller?.useMaximumNumberOfFeatures && !this._controller.leavesReached;
  }
  get _excludeObjectIdsSorted() {
    const e4 = this.layer.excludeObjectIds;
    return e4.length ? e4.toArray().sort((e5, t6) => e5 - t6) : null;
  }
  get lodFactor() {
    return "Labels" === this.layer.semantic ? 1 : this.view.qualitySettings.sceneService.point.lodFactor;
  }
  get hasM() {
    return false;
  }
  get hasZ() {
    return true;
  }
  get contentVisible() {
    return !this.suspended && !!this._controller?.rootNodeVisible;
  }
  get legendEnabled() {
    return this.contentVisible && true === this.i3slayer?.legendEnabled;
  }
  whenGraphicAttributes(e4, t6) {
    return __async(this, null, function* () {
      return A2(this.layer, e4, this._getObjectIdField(), t6, () => [...this.loadedGraphics.nodes()]);
    });
  }
  getHit(e4) {
    if (!this.loadedGraphics) return null;
    const t6 = c(this.loadedGraphics.find((t7) => t7.uid === e4), this.layer), r2 = this._getObjectIdField();
    return t6?.attributes?.[r2] ? (t6.layer = this.layer, t6.sourceLayer = this.layer, {
      type: "graphic",
      graphic: t6,
      layer: t6.layer
    }) : null;
  }
  whenGraphicBounds(e4, t6) {
    return this.processor.whenGraphicBounds(e4, t6);
  }
  computeAttachmentOrigin(e4, t6) {
    return this.processor.computeAttachmentOrigin(e4, t6);
  }
  isUpdating() {
    return !!(this._controller?.updating || this.processor?.updating || this._fieldsHelper?.updating || this.layerFilterUpdating);
  }
  highlight(e4) {
    return this.processor.highlight(e4, this.layer.objectIdField);
  }
  get updatePolicy() {
    return this.processor.graphicsCore.effectiveUpdatePolicy;
  }
  createInteractiveEditSession(e4) {
    return i3(this._attributeEditingContext, e4);
  }
  _decompressBinaryPointData(e4, t6) {
    return __async(this, null, function* () {
      const r2 = {
        geometryBuffer: e4.geometryBuffer
      };
      null == this._worker && (this._worker = new r((e5) => this.view.resourceController.immediate.schedule(e5)));
      const i5 = yield this._worker.invoke(r2, t6);
      if (null == i5) throw new Error("Failed to decompress Draco point data");
      return {
        positionData: i5.positions,
        featureIds: i5.featureIds
      };
    });
  }
  addNode(e4, t6, r2) {
    return __async(this, null, function* () {
      if (!ne(t6) && !ae(t6)) throw new Error();
      if (this.loadedGraphics.hasNode(e4.index)) return void n.getLogger(this).error("I3S node " + e4.id + " already added");
      const s3 = null != this.layer.fullExtent ? ue(this.layer.fullExtent.clone(), 0.5) : null, {
        featureIds: o6,
        pointPositions: a3
      } = ne(t6) ? yield this._extractBinaryPointPositions(e4, t6, r2) : this._extractLegacyPointPositions(t6), n6 = new Array();
      this._validatePositions(e4, o6, a3, s3, n6);
      const l4 = this._controller.crsVertex, d4 = this.view.spatialReference;
      n4(a3, l4, 0, a3, d4, 0, o6.length);
      const u5 = ne(t6) ? e4.level : 0, h2 = this._createGraphics(o6, a3, e4.index, u5), p = new ie(h2, o6, t6.attributeDataInfo, e4);
      if (yield this._i3sOverrides.applyAttributeOverrides(p.featureIds, t6.attributeDataInfo, r2), e4.numFeatures = p.graphics.length, this._updateNodeMemory(e4), de(p), n6.length > 0 && (this._computeObb(e4, n6, l4), this._controller.updateVisibility(e4.index)), !this._controller.isGeometryVisible(e4)) return void this._cacheNodeData(p);
      if (null != this._verticalScale) for (const i5 of p.graphics) this._verticalScale(i5.geometry);
      const g = this.view._stage.renderView.objectAndLayerIdRenderHelper;
      if (null != g) {
        const e5 = S(this.view.map, this.layer.uid);
        for (let t7 = 0; t7 < p.featureIds.length; t7++) {
          const r3 = p.featureIds[t7];
          g.setUidToObjectAndLayerId(r3, p.graphics[t7].uid, this.layer.id, this.layer.uid, this.layer.popupEnabled && !e5 && u2(this.layer, this.view.popup?.defaultPopupTemplateEnabled), p.node.resources.attributes, t7);
        }
      }
      this.loadedGraphics.addNode(e4.index, p), this._controller.updateLoadStatus(e4.index, true), this._filterNode(p), this._treeDebugger && this._treeDebugger.update();
    });
  }
  _computeObb(e4, t6, r2) {
    const i5 = this._controller.crsIndex, s3 = i5.isGeographic ? this.view.renderSpatialReference : i5;
    n4(t6, r2, 0, t6, s3, 0, t6.length / 3), e4.serviceObbInIndexSR = J(new s(t6, 3)), i5.isGeographic && (n5(e4.serviceObbInIndexSR.center, s3, pe, i5), e4.serviceObbInIndexSR.center = pe);
  }
  isNodeLoaded(e4) {
    return this.loadedGraphics.hasNode(e4);
  }
  isNodeReloading() {
    return false;
  }
  updateNodeState() {
  }
  _extractBinaryPointPositions(e4, t6, r2) {
    return __async(this, null, function* () {
      const i5 = yield this._decompressBinaryPointData(t6, r2), s3 = i5.positionData, o6 = 3, a3 = s3.length / o6, n6 = t(3 * a3), l4 = null != e4.serviceObbInIndexSR ? e4.serviceObbInIndexSR.center : l, d4 = Math.abs(l4[2]) * 2 ** -20;
      for (let u5 = 0; u5 < a3; u5++) {
        const e5 = u5 * o6;
        n6[e5] = s3[e5] + l4[0], n6[e5 + 1] = s3[e5 + 1] + l4[1], n6[e5 + 2] = s3[e5 + 2] + l4[2], Math.abs(n6[e5 + 2]) < d4 && (n6[e5 + 2] = 0);
      }
      return {
        featureIds: i5.featureIds ? e3(i5.featureIds) : [],
        pointPositions: n6
      };
    });
  }
  _extractLegacyPointPositions(e4) {
    const t6 = e4.pointData.length, r2 = t(3 * t6), i5 = new Array();
    for (let s3 = 0; s3 < t6; s3++) {
      const t7 = e4.pointData[s3], o6 = t7.featureDataPosition, a3 = o6.length, n6 = t7.geometries?.[0] ?? he[a3], l4 = t7.featureIds[0];
      if ("Embedded" !== n6.type || "points" !== n6.params.type || a3 < 2 || a3 > 3) continue;
      const d4 = n6.params.vertexAttributes?.position ?? [0, 0, 0], u5 = 3 * i5.length;
      r2[u5] = o6[0] + d4[0], r2[u5 + 1] = o6[1] + d4[1], r2[u5 + 2] = 3 === a3 ? o6[2] + d4[2] : NaN, i5.push(l4);
    }
    return {
      featureIds: i5,
      pointPositions: r2
    };
  }
  _validatePositions(e4, t6, r2, s3, o6) {
    if (null == s3 && e4.serviceObbInIndexSR) return;
    const a3 = t6.length, n6 = 3;
    for (let l4 = 0; l4 < a3; l4++) {
      const t7 = l4 * n6;
      o3(pe, r2[t7], r2[t7 + 1], r2[t7 + 2]);
      const a4 = !Number.isNaN(r2[2]);
      null == s3 || (a4 ? o2(s3, pe) : i(s3, pe)) || (this._coordinatesOutsideExtentErrors < this._maxCoordinatesOutsideExtentErrors && n.getLogger(this).error("Service Error: Coordinates outside of layer extent"), this._coordinatesOutsideExtentErrors + 1 === this._maxCoordinatesOutsideExtentErrors && n.getLogger(this).error("Maximum number of errors reached. Further errors are ignored."), this._coordinatesOutsideExtentErrors++), e4.serviceObbInIndexSR || o6.push(pe[0], pe[1], pe[2]);
    }
  }
  _createGraphics(e4, r2, i5, s3) {
    const o6 = e4.length, a3 = 3, n6 = this._getObjectIdField(), l4 = this.processor.graphicsCore, d4 = new Array(), u5 = this.view.spatialReference;
    for (let h2 = 0; h2 < o6; h2++) {
      const o7 = e4[h2], p = {};
      null != o7 && (p[n6] = o7);
      const c2 = o7 ?? d2.generateUID(), g = h2 * a3, m = isNaN(r2[g + 2]) ? void 0 : r2[g + 2], y2 = e2(r2[g], r2[g + 1], m, u5), f2 = this.loadedGraphics.get(c2);
      if (null != f2) (null == f2.level || f2.level < s3) && (ce.property = "geometry", ce.graphic = f2, ce.oldValue = f2.geometry, ce.newValue = y2, f2.geometry = y2, f2.level = s3, l4.graphicUpdateHandler(ce)), d4.push(f2);
      else {
        const e5 = d2.generateUID();
        d4.push({
          objectId: c2,
          uid: e5,
          geometry: y2,
          attributes: p,
          visible: true,
          nodeIndex: i5,
          level: s3
        });
      }
    }
    return d4;
  }
  _updateNodeMemory(e4) {
    e4.memory = 4096 + (null != e4.numFeatures ? e4.numFeatures * this.processor.graphicsCore.usedMemoryPerGraphic : 0);
  }
  _cacheNodeData(e4) {
    const t6 = e4.graphics.reduce((e5, t7) => Z(t7) + e5, A(e4.featureIds) + 1024);
    this._memCache.put(this._getMemCacheKey(e4.node), e4, t6);
  }
  _getMemCacheKey(e4) {
    return `${e4.index}`;
  }
  _removeAllNodeData() {
    this.loadedGraphics.forEachNode((e4, t6) => {
      if (e4) {
        const t7 = e4.node;
        this._updateNodeMemory(t7), this._cacheNodeData(e4);
      }
      this._controller.updateLoadStatus(t6, false);
    }), this._treeDebugger && this._treeDebugger.update(), this.loadedGraphics.clear();
  }
  removeNode(e4) {
    const t6 = this._removeNodeStageData(e4);
    t6 && (this._updateNodeMemory(t6.node), this._cacheNodeData(t6));
  }
  _removeNodeStageData(e4) {
    const t6 = this.loadedGraphics.getNode(e4);
    return null == t6 ? null : (this._controller.updateLoadStatus(e4, false), this.loadedGraphics.removeNode(e4), this._treeDebugger && this._treeDebugger.update(), t6);
  }
  loadCachedNodeData(e4) {
    return __async(this, null, function* () {
      return this._memCache?.pop(this._getMemCacheKey(e4));
    });
  }
  addCachedNodeData(e4, t6, r2, s3) {
    return __async(this, null, function* () {
      this.loadedGraphics.hasNode(e4.index) ? n.getLogger(this).error("I3S node " + e4.id + " already added") : (yield this._i3sOverrides.applyAttributeOverrides(t6.featureIds, r2, s3), t6.attributeInfo = r2, this.loadedGraphics.addNode(e4.index, t6), this._controller.updateLoadStatus(e4.index, true), this._updateNodeMemory(e4), de(t6), this._filterNode(t6), this._treeDebugger && this._treeDebugger.update());
    });
  }
  getLoadedNodeIds() {
    const e4 = [];
    return this.loadedGraphics.forEachNode((t6) => e4.push(t6.node.id)), e4.sort();
  }
  getVisibleNodes() {
    const e4 = new Array();
    return this.loadedGraphics.forEachNode((t6) => e4.push(t6.node)), e4;
  }
  getLoadedNodeIndices(e4) {
    this.loadedGraphics.forEachNode((t6, r2) => e4.push(r2));
  }
  getLoadedAttributes(e4) {
    const t6 = this.loadedGraphics.getNode(e4);
    if (null != t6?.attributeInfo) return t6.attributeInfo.loadedAttributes;
  }
  getAttributeData(e4) {
    const t6 = this.loadedGraphics.getNode(e4);
    if (null != t6?.attributeInfo) return t6.attributeInfo.attributeData;
  }
  _setAttributeData(e4, t6) {
    const r2 = this.loadedGraphics.getNode(e4);
    null != r2?.attributeInfo && (r2.attributeInfo.attributeData = t6, this._attributeValuesChanged(r2));
  }
  updateAttributes(e4, t6, r2) {
    return __async(this, null, function* () {
      const i5 = this.loadedGraphics.getNode(e4);
      null != i5 && (yield this._i3sOverrides.applyAttributeOverrides(i5.featureIds, t6, r2), i5.attributeInfo = t6, this._attributeValuesChanged(i5));
    });
  }
  _attributeValuesChanged(e4) {
    if (de(e4), this._filterNode(e4), this.processor.graphicsCore.labelsEnabled) {
      const t6 = e4.node.index, r2 = new Array();
      e4.graphics.forEach((e5) => e5.nodeIndex === t6 && r2.push(e5.uid)), this.processor.graphicsCore.updateLabelingInfo(r2);
    }
  }
  _updateClippingExtent(e4) {
    return this._controller && this._controller.updateClippingArea(e4), false;
  }
  _getObjectIdField() {
    return this.layer.objectIdField || o5;
  }
  _getGlobalIdField() {
    return this.layer.associatedLayer?.globalIdField;
  }
  _rendererChange(e4, t6) {
    return __async(this, null, function* () {
      const {
        layer: {
          fieldsIndex: r2
        }
      } = this, i5 = /* @__PURE__ */ new Set();
      let s3, o6;
      e4 ? (yield e4.collectRequiredFields(i5, r2), s3 = Array.from(i5).sort()) : s3 = [], i5.clear(), t6 ? (yield t6.collectRequiredFields(i5, r2), o6 = Array.from(i5).sort()) : o6 = [], s3.length === o6.length && s3.every((e5, t7) => s3[t7] === o6[t7]) || this._reloadAllNodes();
    });
  }
  _rangeInfosChanged(e4) {
    null != e4 && e4.length > 0 && n.getLogger(this).warn("Unsupported property: rangeInfos are currently only serialized to and from web scenes but do not affect rendering.");
  }
  _filterChange() {
    this.loadedGraphics.forEachNode((e4) => this._filterNode(e4));
  }
  _reloadAllNodes() {
    this._removeAllNodeData(), this._controller && this._controller.restartNodeLoading();
  }
  _filterNode(e4) {
    const t6 = this.parsedDefinitionExpression, i5 = this._excludeObjectIdsSorted, s3 = this._getObjectIdField();
    for (const o6 of e4.graphics) {
      const e5 = o6.visible, a3 = !t6 || this._evaluateClause(t6, o6), n6 = null == i5 || w(i5, o6.attributes[s3]) < 0;
      o6.visible = a3 && n6, e5 !== o6.visible && (ce.graphic = o6, ce.property = "visible", ce.oldValue = e5, ce.newValue = o6.visible, this.processor.graphicsCore.graphicUpdateHandler(ce));
    }
  }
  createQuery() {
    const e4 = {
      outFields: ["*"],
      returnGeometry: true,
      outSpatialReference: this.view.spatialReference
    };
    return null != this.filter ? this.filter.createQuery(e4) : new b(e4);
  }
  queryFeatures(e4, t6) {
    return this._queryEngine.executeQuery(this._ensureQuery(e4), t6?.signal);
  }
  queryObjectIds(e4, t6) {
    return this._queryEngine.executeQueryForIds(this._ensureQuery(e4), t6?.signal);
  }
  queryFeatureCount(e4, t6) {
    return this._queryEngine.executeQueryForCount(this._ensureQuery(e4), t6?.signal);
  }
  queryExtent(e4, t6) {
    return this._queryEngine.executeQueryForExtent(this._ensureQuery(e4), t6?.signal);
  }
  _ensureQuery(e4) {
    return this._addDefinitionExpressionToQuery(null == e4 ? this.createQuery() : b.from(e4));
  }
  _setupQueryEngine() {
    const e4 = () => this.processor.featureStore;
    this._queryEngine = new l3({
      context: {
        spatialReference: this.view.spatialReference,
        layer: this.layer,
        scheduler: this.view.resourceController.scheduler,
        get featureStore() {
          return e4();
        },
        hasZ: this.hasZ,
        hasM: this.hasM
      },
      priority: I.FEATURE_QUERY_ENGINE
    });
  }
  get usedMemory() {
    return this.processor?.graphicsCore?.usedMemory ?? 0;
  }
  get unloadedMemory() {
    return 0.8 * ((this._controller?.unloadedMemoryEstimate ?? 0) + (this.processor?.graphicsCore?.unprocessedMemoryEstimate ?? 0));
  }
  get ignoresMemoryFactor() {
    return this._controller && this._controller.fixedFeatureTarget;
  }
  _handleEdits(e4) {
    return __async(this, null, function* () {
      const t6 = this._attributeEditingContext, r2 = yield u4(t6, e4);
      f(t6, r2);
    });
  }
  get _attributeEditingContext() {
    const e4 = this._getObjectIdField(), t6 = this._getGlobalIdField();
    return {
      sessions: this._interactiveEditingSessions,
      fieldsIndex: this.layer.fieldsIndex,
      objectIdField: e4,
      globalIdField: t6,
      forEachNode: (e5) => this.loadedGraphics.forEachNode((t7) => e5(t7.node, t7.featureIds)),
      attributeStorageInfo: this.i3slayer.attributeStorageInfo ?? [],
      i3sOverrides: this._i3sOverrides,
      getAttributeData: (e5) => this.getAttributeData(e5),
      setAttributeData: (t7, r2, i5) => {
        this._setAttributeData(t7, r2);
        const s3 = this.loadedGraphics.getNode(t7);
        if (null != i5) {
          const t8 = this.loadedGraphics.get(i5.attributes[e4]);
          null != t8 && this.processor.graphicsCore.recreateGraphics([t8]);
        } else null != s3 && this.processor.graphicsCore.recreateGraphics(s3.graphics);
      },
      clearMemCache: () => {
      }
    };
  }
  get performanceInfo() {
    return new t3(this.usedMemory, this.loadedGraphics.length, -1, this.maximumNumberOfFeatures, this.loadedGraphics.nodeCount, this.processor.graphicsCore.performanceInfo);
  }
  get test() {
  }
};
e([y()], se.prototype, "processor", void 0), e([y({
  type: d3
})], se.prototype, "filter", void 0), e([y()], se.prototype, "loadedGraphics", void 0), e([y()], se.prototype, "i3slayer", null), e([y()], se.prototype, "_controller", void 0), e([y()], se.prototype, "updating", void 0), e([y()], se.prototype, "suspended", void 0), e([y()], se.prototype, "holeFilling", void 0), e([y(t4)], se.prototype, "updatingProgress", void 0), e([y()], se.prototype, "updatingProgressValue", null), e([y(re.requiredFields)], se.prototype, "requiredFields", null), e([y(re.availableFields)], se.prototype, "availableFields", void 0), e([y()], se.prototype, "_fieldsHelper", void 0), e([y({
  type: Number
})], se.prototype, "maximumNumberOfFeatures", null), e([y({
  readOnly: true
})], se.prototype, "maximumNumberOfFeaturesExceeded", null), e([y()], se.prototype, "_excludeObjectIdsSorted", null), e([y({
  readOnly: true
})], se.prototype, "lodFactor", null), e([y({
  readOnly: true
})], se.prototype, "hasM", null), e([y({
  readOnly: true
})], se.prototype, "hasZ", null), e([y()], se.prototype, "contentVisible", null), e([y({
  readOnly: true
})], se.prototype, "legendEnabled", null), se = e([a("esri.views.3d.layers.SceneLayerGraphicsView3D")], se);
var oe = se;
function ae(e4) {
  return "pointData" in e4;
}
function ne(e4) {
  return "geometryBuffer" in e4 && null !== e4.geometryBuffer;
}
function le(e4, t6, r2) {
  const i5 = t6.attributeInfo;
  if (null == i5?.loadedAttributes || null == i5.attributeData) return false;
  let s3 = false;
  for (const {
    name: o6
  } of i5.loadedAttributes) if (i5.attributeData[o6]) {
    const t7 = Q(i5.attributeData[o6], r2);
    t7 !== e4.attributes[o6] && (e4.attributes[o6] = t7, s3 = true);
  }
  return s3;
}
function de(e4) {
  const t6 = e4.attributeInfo, r2 = e4.node.index;
  if (null != t6?.loadedAttributes && null != t6.attributeData) for (let i5 = 0; i5 < e4.graphics.length; i5++) {
    const s3 = e4.graphics[i5];
    if (s3.nodeIndex === r2) {
      s3.attributes || (s3.attributes = {});
      for (const {
        name: e5
      } of t6.loadedAttributes) t6.attributeData[e5] && (s3.attributes[e5] = Q(t6.attributeData[e5], i5));
    }
  }
}
function ue(e4, t6) {
  return e4.xmin -= t6, e4.ymin -= t6, e4.xmax += t6, e4.ymax += t6, null != e4.zmin && null != e4.zmax && (e4.zmin -= t6, e4.zmax += t6), null != e4.mmin && null != e4.mmax && (e4.mmin -= t6, e4.mmax += t6), e4;
}
var he = {
  2: {
    type: "Embedded",
    params: {
      type: "points",
      vertexAttributes: {
        position: [0, 0]
      }
    }
  },
  3: {
    type: "Embedded",
    params: {
      type: "points",
      vertexAttributes: {
        position: [0, 0, 0]
      }
    }
  }
};
var pe = n3();
var ce = {
  graphic: null,
  property: null,
  oldValue: null,
  newValue: null
};
export {
  oe as default
};
//# sourceMappingURL=SceneLayerGraphicsView3D-GWVIA5GU.js.map
