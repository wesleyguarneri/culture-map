{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTangent.glsl.js", "../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/terrain/TileBlendInput.js", "../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/terrain/TerrainTexture.glsl.js", "../../../../../../node_modules/@arcgis/core/chunks/Terrain.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { glsl as n } from \"../../shaderModules/interfaces.js\";\nfunction e(e, t) {\n  e.varyings.add(\"tbnTangent\", \"vec3\"), e.varyings.add(\"tbnBiTangent\", \"vec3\"), t.spherical ? e.vertex.code.add(n`void forwardVertexTangent(vec3 n) {\ntbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), n));\ntbnBiTangent = normalize(cross(n, tbnTangent));\n}`) : e.vertex.code.add(n`void forwardVertexTangent(vec3 n) {\ntbnTangent = vec3(1.0, 0.0, 0.0);\ntbnBiTangent = normalize(cross(n, tbnTangent));\n}`), e.fragment.code.add(n`mat3 getTBNMatrix(vec3 n) {\nreturn mat3(tbnTangent, tbnBiTangent, n);\n}`);\n}\nexport { e as VertexTangent };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nvar o;\n!function (o) {\n  o[o.LayerOnly = 0] = \"LayerOnly\", o[o.ColorComposite = 1] = \"ColorComposite\", o[o.GridComposite = 2] = \"GridComposite\", o[o.COUNT = 3] = \"COUNT\";\n}(o || (o = {}));\nexport { o as TileBlendInput };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { ReadShadowMapPassParameters as e } from \"../shading/ReadShadowMap.glsl.js\";\nimport { BackgroundGrid as t } from \"./BackgroundGrid.glsl.js\";\nimport { TileBlendInput as o } from \"./TileBlendInput.js\";\nimport { glsl as r } from \"../../shaderModules/interfaces.js\";\nimport { Uniform as c } from \"../../shaderModules/Uniform.js\";\nclass n extends e {\n  constructor() {\n    super(...arguments), this.overlayOpacity = 1;\n  }\n}\nfunction s(e, c) {\n  const {\n    vertex: n,\n    fragment: s,\n    varyings: u\n  } = e;\n  u.add(\"vtc\", \"vec2\"), n.uniforms.add(new i(\"texOffsetAndScale\")), s.uniforms.add(new l(\"tex\")), s.uniforms.add(new a(\"textureOpacities\"));\n  const x = c.textureFadingEnabled && !c.renderOccluded;\n  x && (n.uniforms.add(new i(\"nextTexOffsetAndScale\")), u.add(\"nvtc\", \"vec2\"), s.uniforms.add(new l(\"texNext\")), s.uniforms.add(new a(\"nextTexOpacities\")), s.uniforms.add(new d(\"fadeFactor\")));\n  const f = c.tileBlendInput === o.ColorComposite,\n    v = c.tileBlendInput === o.GridComposite;\n  v && s.include(t), f && s.uniforms.add(new a(\"backgroundColor\")), n.code.add(r`\n  void forwardTextureCoordinatesWithTransform(in vec2 uv) {\n    vtc = uv * texOffsetAndScale.zw + texOffsetAndScale.xy;\n    ${x ? r`nvtc = uv * nextTexOffsetAndScale.zw + nextTexOffsetAndScale.xy;` : r``}\n  }`), s.code.add(r`\n    vec4 getColor(vec4 color, vec2 uv, vec3 opacities) {\n      ${v || f ? r`\n              if (opacities.y <= 0.0) {\n                return color * opacities.z * opacities.x;\n              }\n              vec4 bg = vec4(${f ? r`backgroundColor` : r`gridColor(uv)`} * opacities.y, opacities.y);\n              vec4 layer = color * opacities.z;\n              return (bg * (1.0 - layer.a) + layer) * opacities.x;` : r`return color;`}\n    }`), x ? s.code.add(r`vec4 getTileColor() {\nvec4 color = getColor(texture(tex, vtc), vtc, textureOpacities);\nif (fadeFactor >= 1.0) {\nreturn color;\n}\nvec4 nextColor = getColor(texture(texNext, nvtc), nvtc, nextTexOpacities);\nreturn mix(nextColor, color, fadeFactor);\n}`) : s.code.add(r`vec4 getTileColor() {\nreturn getColor(texture(tex, vtc), vtc, textureOpacities);\n}`);\n}\nclass d extends c {\n  constructor(e) {\n    super(e, \"float\");\n  }\n}\nclass a extends c {\n  constructor(e) {\n    super(e, \"vec3\");\n  }\n}\nclass i extends c {\n  constructor(e) {\n    super(e, \"vec4\");\n  }\n}\nclass l extends c {\n  constructor(e) {\n    super(e, \"sampler2D\");\n  }\n}\nexport { a as Float3Uniform, n as OverlayTerrainPassParameters, s as TerrainTexture, l as Texture2DUniform };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { translate as e } from \"../core/libs/gl-matrix-2/math/mat4.js\";\nimport { create as r } from \"../core/libs/gl-matrix-2/factories/mat4f64.js\";\nimport { n as o, s as i } from \"./vec32.js\";\nimport { create as a } from \"../core/libs/gl-matrix-2/factories/vec3f64.js\";\nimport { OverlayContent as l } from \"../views/3d/terrain/OverlayContent.js\";\nimport { addLinearDepth as t, addNearFar as n, ForwardLinearDepth as s } from \"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js\";\nimport { ShaderOutput as d } from \"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";\nimport { SliceDraw as c } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { Transform as v } from \"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";\nimport { NormalAttribute as m } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js\";\nimport { PositionAttribute as g } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl.js\";\nimport { TextureCoordinateAttribute as p } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";\nimport { VertexTangent as f } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTangent.glsl.js\";\nimport { OutputDepth as w } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js\";\nimport { OutputHighlight as h } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";\nimport { EvaluateAmbientOcclusion as u } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js\";\nimport { EvaluateSceneLighting as b, addAmbientBoostFactor as C, addLightingGlobalFactor as y } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js\";\nimport { addMainLightDirection as x, addMainLightIntensity as S } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js\";\nimport { NormalUtils as O } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl.js\";\nimport { PBRMode as j } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js\";\nimport { ReadShadowMapDraw as L } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js\";\nimport { OverlayMode as z, OverlayTerrain as P } from \"../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js\";\nimport { OverlayTerrainPassParameters as T, TerrainTexture as M } from \"../views/3d/webgl-engine/core/shaderLibrary/terrain/TerrainTexture.glsl.js\";\nimport { addProjViewLocalOrigin as N, addViewNormal as $, addCameraPosition as D } from \"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";\nimport { Float3PassUniform as W } from \"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";\nimport { glsl as V } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4DrawUniform as U } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4DrawUniform.js\";\nimport { ShaderBuilder as F } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as A } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nclass _ extends T {}\nfunction B(r) {\n  const a = new F(),\n    {\n      vertex: T,\n      fragment: _,\n      varyings: B\n    } = a;\n  a.include(g), a.include(m, r), a.include(p, r);\n  const q = () => {\n    a.include(O, r), T.code.add(V`vec3 getNormal() {\nfloat z = 1.0 - abs(normalCompressed.x) - abs(normalCompressed.y);\nvec3 n = vec3(normalCompressed + vec2(normalCompressed.x >= 0.0 ? 1.0 : -1.0,\nnormalCompressed.y >= 0.0 ? 1.0 : -1.0) * min(z, 0.0), z);\nreturn normalize(n);\n}`);\n  };\n  N(T, r), a.include(v, r);\n  const E = r.overlayMode !== z.Disabled,\n    I = E && r.invisible;\n  switch (r.output) {\n    case d.Color:\n      {\n        a.include(M, r), a.include(b, r), E && a.include(P, {\n          ...r,\n          pbrMode: r.pbrMode === j.Simplified ? j.TerrainWithWater : j.Water\n        });\n        const t = r.overlayMode === z.EnabledWithWater;\n        t && a.include(f, r), B.add(\"vnormal\", \"vec3\"), B.add(\"vpos\", \"vec3\"), B.add(\"vup\", \"vec3\"), q(), r.screenSizePerspective && $(T);\n        const n = r.receiveShadows && !r.renderOccluded;\n        n && a.include(s, r), r.screenSizePerspective && (B.add(\"screenSizeDistanceToCamera\", \"float\"), B.add(\"screenSizeCosAngle\", \"float\")), T.code.add(V`\n        void main(void) {\n          //Position\n          vpos = position;\n          vec3 positionWorld = position + localOrigin;\n          gl_Position = transformPosition(proj, view, vpos);\n\n          //Normal\n          vnormal = getNormal();\n\n          //Up\n          vup = getLocalUp(position, localOrigin);\n\n          ${t ? V`forwardVertexTangent(vnormal);` : V``}\n\n          //Texture UV\n          vec2 uv = getUV0();\n          forwardTextureCoordinatesWithTransform(uv);\n          ${E ? V`setOverlayVTC(uv);` : \"\"}\n          ${r.tileBorders ? V`forwardTextureCoordinates();` : \"\"}\n\n          ${r.screenSizePerspective ? V`\n          vec3 viewPos = (view * vec4(vpos, 1.0)).xyz;\n          screenSizeDistanceToCamera = length(viewPos);\n          vec3 viewSpaceNormal = (viewNormal * vec4(normalize(positionWorld), 1.0)).xyz;\n          screenSizeCosAngle = abs(viewSpaceNormal.z);` : \"\"}\n\n          ${n ? V`forwardLinearDepth();` : \"\"}\n\n        }\n      `), a.include(c, r), a.include(b, r), a.include(u, r), a.include(L, r), D(_, r), C(_), y(_), _.uniforms.add(T.uniforms.get(\"localOrigin\"), new W(\"viewDirection\", (e, r) => o(H, i(H, r.camera.viewMatrix[12], r.camera.viewMatrix[13], r.camera.viewMatrix[14])))), t && _.uniforms.add(new A(\"ovWaterTex\", (e, r) => r.overlay?.getTexture(l.WaterNormal)), new U(\"view\", (r, o) => e(k, o.camera.viewMatrix, r.origin))), _.code.add(V`const float sliceOpacity = 0.2;\nfloat lum(vec3 c) {\nreturn (min(min(c.r, c.g), c.b) + max(max(c.r, c.g), c.b)) * 0.5;\n}`), x(_), S(_), _.code.add(V`\n        void main() {\n          vec3 normal = normalize(vnormal);\n          float vndl = dot(normal, mainLightDirection);\n\n          float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n          float shadow = ${r.receiveShadows && !r.renderOccluded ? \"readShadowMap(vpos, linearDepth)\" : r.spherical ? \"lightingGlobalFactor * (1.0 - additionalAmbientScale)\" : \"0.0\"};\n\n          float ssao = evaluateAmbientOcclusionInverse();\n          vec4 tileColor = getTileColor();\n\n          ${E ? V`\n              vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);\n              vec4 overlayColor = overlayOpacity * overlayColorOpaque;\n              ${r.invisible ? V`if (overlayColor.a == 0.0) { discard; }` : \"\"}\n              vec4 groundColor = tileColor;\n              tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;` : \"\"}\n\n          // If combined alpha is 0 we can discard pixel. The performance impact by having a discard here\n          // is neglectable because terrain typically renders first into the framebuffer.\n          if(tileColor.a <= 0.0) {\n            discard;\n          }\n\n          bool sliced = rejectBySlice(vpos);\n          if (sliced) {\n            tileColor *= sliceOpacity;\n          }\n\n          vec3 albedo = tileColor.rgb;\n\n          // heuristic shading function used in the old terrain, now used to add ambient lighting\n\n          vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n          ${r.pbrMode === j.Simplified || r.pbrMode === j.TerrainWithWater ? V`fragColor = vec4(evaluatePBRSimplifiedLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight, normalize(vpos - cameraPosition), vup), tileColor.a);` : V`fragColor = vec4(evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);`}\n          ${t ? V`\n              vec4 overlayWaterMask = getOverlayColor(ovWaterTex, vtcOverlay);\n              float waterNormalLength = length(overlayWaterMask);\n              if (waterNormalLength > 0.95) {\n                mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);\n                vec4 waterOverlayColor = vec4(overlayColor.w > 0.0 ? overlayColorOpaque.xyz/overlayColor.w : vec3(1.0), overlayColor.w);\n                vec4 viewPosition = view*vec4(vpos, 1.0);\n                vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vpos - cameraPosition), shadow, vnormal, tbnMatrix, viewPosition.xyz,  vpos + localOrigin);\n                vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));\n                float opacity = sliced ? sliceOpacity : 1.0;\n                // un-gamma the ground color to mix in linear space\n                fragColor = mix(groundColor, waterColorNonLinear, waterColorLinear.w) * opacity;\n              }` : \"\"}\n          ${r.screenSizePerspective ? V`\n            float perspectiveScale = screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, vec4(0.0, 0.0, 0.0, 0.0));\n            if (perspectiveScale <= 0.25) {\n              fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n            }\n            else if (perspectiveScale <= 0.5) {\n              fragColor = mix(fragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n            }\n            else if (perspectiveScale >= 0.99) {\n              fragColor = mix(fragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n            }\n            else {\n              fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n            }` : \"\"}\n          ${r.visualizeNormals ? r.spherical ? V`\n                  vec3 localUp = normalize(vpos + localOrigin);\n                  vec3 right = normalize(cross(vec3(0.0, 0.0, 1.0), localUp));\n                  vec3 forward = normalize(cross(localUp, right));\n                  mat3 tbn = mat3(right, forward, localUp);\n                  vec3 tNormal = normalize(normal * tbn);\n                  fragColor = vec4(vec3(0.5) + 0.5 * tNormal, 0.0);\n              ` : V`\n                  vec3 tNormal = normalize(normal);\n                  fragColor = vec4(vec3(0.5) + 0.5 * tNormal, 0.0);\n              ` : \"\"}\n          ${r.tileBorders ? V`\n              vec2 dVuv = fwidth(vuv0);\n              vec2 edgeFactors = smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv0, 1.0 - vuv0));\n              float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);\n              fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);` : \"\"}\n          fragColor = highlightSlice(fragColor, vpos);\n        }\n      `);\n      }\n      break;\n    case d.Depth:\n      I && a.include(P, r), T.code.add(V`\n              void main(void) {\n                ${I ? V`setOverlayVTC(getUV0());` : \"\"}\n                gl_Position = transformPosition(proj, view, position);\n              }\n          `), _.code.add(V`\n              void main() {\n                ${I ? V`if (getCombinedOverlayColor().a == 0.0) { discard; }` : \"\"}\n              }\n          `);\n      break;\n    case d.Shadow:\n    case d.ShadowHighlight:\n    case d.ShadowExcludeHighlight:\n    case d.ViewshedShadow:\n      a.include(w, r), t(a), n(a), T.code.add(V`void main(void) {\ngl_Position = transformPositionWithDepth(proj, view, position, nearFar, linearDepth);\n}`), _.code.add(V`void main() {\noutputDepth(linearDepth);\n}`);\n      break;\n    case d.Normal:\n      I && a.include(P, r), B.add(\"vnormal\", \"vec3\"), $(T), q(), T.code.add(V`\n        void main(void) {\n          ${I ? V`setOverlayVTC(getUV0());` : \"\"}\n          gl_Position = transformPosition(proj, view, position);\n          vnormal = normalize((viewNormal * vec4(getNormal(), 1.0)).xyz);\n        }\n      `), _.code.add(V`\n        void main() {\n          ${I ? V`if (getCombinedOverlayColor().a == 0.0) { discard; }` : \"\"}\n          vec3 normal = normalize(vnormal);\n          if (gl_FrontFacing == false) {\n            normal = -normal;\n          }\n          fragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);\n        }\n      `);\n      break;\n    case d.Highlight:\n      E && a.include(P, r), T.code.add(V`\n          void main() {\n            ${E ? V`setOverlayVTC(getUV0());` : \"\"}\n            gl_Position = transformPosition(proj, view, position);\n          }\n        `), a.include(h, r), _.code.add(V`\n          void main() {\n            ${E ? V`if (getCombinedOverlayColor().a == 0.0) { discard; }` : \"\"}\n            outputHighlight();\n          }\n        `);\n  }\n  return r.output === d.ObjectAndLayerIdColor && (E ? (a.include(P, {\n    ...r,\n    pbrMode: j.Disabled\n  }), T.code.add(V`void main(void) {\ngl_Position = transformPosition(proj, view, position);\nsetOverlayVTC(getUV0());\n}`), _.code.add(V`void main() {\nfragColor = getOverlayColorTexel(vtcOverlay);\n}`)) : (T.code.add(V`void main(void) {\n        ${r.opaque ? V` gl_Position = transformPosition(proj, view, position);` : \"\"}\n      }`), _.code.add(V`void main() {\nfragColor = vec4(0.0);\n}`))), a;\n}\nconst k = r(),\n  H = a(),\n  q = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    TerrainPassParameters: _,\n    build: B\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { _ as T, q as a, B as b };"],
  "mappings": "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",
  "names": ["e", "t", "o", "o", "n", "h", "s", "e", "c", "u", "i", "a", "x", "d", "f", "o", "t", "n", "r", "a", "o", "_", "B", "q", "f", "s", "p", "t", "e", "i"]
}
