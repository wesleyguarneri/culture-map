import {
  n,
  t
} from "./chunk-DGHGAJW2.js";
import {
  d,
  f,
  j as j2,
  p as p2,
  y
} from "./chunk-L6LZ5TYL.js";
import {
  c,
  i as i3,
  o
} from "./chunk-7PCL3GUC.js";
import "./chunk-BO5GTO4F.js";
import {
  m
} from "./chunk-ROATEOHC.js";
import "./chunk-BIWDYV6F.js";
import {
  $
} from "./chunk-4MXR7W7N.js";
import "./chunk-6UYQMUGI.js";
import "./chunk-D3XZUGMN.js";
import "./chunk-YFQ32AQX.js";
import "./chunk-L4AYSXFJ.js";
import "./chunk-POQ3T5EH.js";
import {
  j,
  x
} from "./chunk-LPEFONL3.js";
import "./chunk-SSMSHZ2C.js";
import "./chunk-DM4WHMQY.js";
import "./chunk-DON3YPGT.js";
import {
  et,
  nt,
  tt
} from "./chunk-C7NRYPDG.js";
import "./chunk-Z3GMSC63.js";
import "./chunk-F35MWZH7.js";
import "./chunk-ED7UGR2X.js";
import "./chunk-YA5CTHMT.js";
import "./chunk-4QBFFLOC.js";
import "./chunk-O437BSYE.js";
import "./chunk-YZNT6QWD.js";
import "./chunk-YVOGHYE3.js";
import "./chunk-IBOZJLSO.js";
import {
  Z
} from "./chunk-Q7SRMLJZ.js";
import "./chunk-PQ4T66BG.js";
import "./chunk-SWPHGZYB.js";
import {
  i as i2
} from "./chunk-DWASPXVI.js";
import "./chunk-4U5GUJRA.js";
import "./chunk-J55F4AC2.js";
import "./chunk-LNRZHZOQ.js";
import "./chunk-DI6VABAK.js";
import "./chunk-5EBAJR7X.js";
import "./chunk-5JA2JHV3.js";
import "./chunk-FUKSTKFU.js";
import "./chunk-MIQZ6UDY.js";
import "./chunk-JOJZ6YC5.js";
import "./chunk-L4TOCXR5.js";
import "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import "./chunk-7WP676SE.js";
import "./chunk-SGSUM5YO.js";
import "./chunk-SG5TCCCK.js";
import "./chunk-6A7CWJED.js";
import "./chunk-DUTZNK67.js";
import "./chunk-IN6BQCWS.js";
import "./chunk-JM7HAEY6.js";
import "./chunk-A3NNJ7XA.js";
import "./chunk-OKJHJ3CY.js";
import "./chunk-XTVPEVHA.js";
import {
  H2 as H,
  K
} from "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import {
  p,
  u
} from "./chunk-S3IO7V4Q.js";
import "./chunk-4ZZRP4MA.js";
import "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import {
  i
} from "./chunk-CVB43GGP.js";
import "./chunk-XWXBNAOW.js";
import "./chunk-GWC3DAGP.js";
import "./chunk-EODIWR2E.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-FYAEQPUY.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-7RMVJCDW.js";
import "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import "./chunk-NYQ5CYNR.js";
import "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import "./chunk-AXVPJBVW.js";
import "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import {
  g2 as g
} from "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import "./chunk-6WHTZNUH.js";
import "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import "./chunk-XNUH25NY.js";
import "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import "./chunk-4Z5SGKRM.js";
import "./chunk-ANKOCGE2.js";
import "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  s2 as s
} from "./chunk-WYIDUUN2.js";
import "./chunk-DXLOWWK7.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/layers/graphics/sources/support/MemorySourceWorker.js
var R = g;
var q = {
  xmin: -180,
  ymin: -90,
  xmax: 180,
  ymax: 90,
  spatialReference: g
};
var D = {
  hasAttachments: false,
  capabilities: "query, editing, create, delete, update",
  useStandardizedQueries: true,
  supportsCoordinatesQuantization: true,
  supportsReturningQueryGeometry: true,
  advancedQueryCapabilities: {
    supportsQueryAttachments: false,
    supportsStatistics: true,
    supportsPercentileStatistics: true,
    supportsReturningGeometryCentroid: true,
    supportsQueryWithDistance: true,
    supportsDistinct: true,
    supportsReturningQueryExtent: true,
    supportsReturningGeometryProperties: false,
    supportsHavingClause: true,
    supportsOrderBy: true,
    supportsPagination: true,
    supportsQueryWithResultType: false,
    supportsSqlExpression: true,
    supportsDisjointSpatialRel: true
  }
};
function O(e) {
  return u(e) ? null != e.z : !!e.hasZ;
}
function w(e) {
  return u(e) ? null != e.m : !!e.hasM;
}
var S = class {
  constructor() {
    this._queryEngine = null, this._nextObjectId = null;
  }
  destroy() {
    this._queryEngine?.destroy(), this._queryEngine = this._createDefaultAttributes = null;
  }
  load(t2) {
    return __async(this, null, function* () {
      const i4 = [], {
        features: s2
      } = t2, n2 = this._inferLayerProperties(s2, t2.fields), r = t2.fields || [], a = null != t2.hasM ? t2.hasM : !!n2.hasM, p3 = null != t2.hasZ ? t2.hasZ : !!n2.hasZ, h = !t2.spatialReference && !n2.spatialReference, g2 = h ? R : t2.spatialReference || n2.spatialReference, I = h ? q : null, F = t2.geometryType || n2.geometryType, b = !F;
      let O2 = t2.objectIdField || n2.objectIdField, w2 = t2.timeInfo;
      const S2 = new Z(r);
      if (!b && (h && i4.push({
        name: "feature-layer:spatial-reference-not-found",
        message: "Spatial reference not provided or found in features. Defaults to WGS84"
      }), !F)) throw new s("feature-layer:missing-property", "geometryType not set and couldn't be inferred from the provided features");
      if (!O2) throw new s("feature-layer:missing-property", "objectIdField not set and couldn't be found in the provided fields");
      if (n2.objectIdField && O2 !== n2.objectIdField && (i4.push({
        name: "feature-layer:duplicated-oid-field",
        message: `Provided objectIdField "${O2}" doesn't match the field name "${n2.objectIdField}", found in the provided fields`
      }), O2 = n2.objectIdField), O2 && !n2.objectIdField) {
        const e = S2.get(O2);
        e ? (O2 = e.name, e.type = "esriFieldTypeOID", e.editable = false, e.nullable = false) : r.unshift({
          alias: O2,
          name: O2,
          type: "esriFieldTypeOID",
          editable: false,
          nullable: false
        });
      }
      for (const o2 of r) {
        if (null == o2.name && (o2.name = o2.alias), null == o2.alias && (o2.alias = o2.name), !o2.name) throw new s("feature-layer:invalid-field-name", "field name is missing", {
          field: o2
        });
        if (o2.name === O2 && (o2.type = "esriFieldTypeOID"), !i2.jsonValues.includes(o2.type)) throw new s("feature-layer:invalid-field-type", `invalid type for field "${o2.name}"`, {
          field: o2
        });
        null == o2.length && (o2.length = K(o2));
      }
      const v = {};
      for (const e of r) if ("esriFieldTypeOID" !== e.type && "esriFieldTypeGlobalID" !== e.type) {
        const t3 = H(e);
        void 0 !== t3 && (v[e.name] = t3);
      }
      if (w2) {
        if (w2.startTimeField) {
          const e = S2.get(w2.startTimeField);
          e ? (w2.startTimeField = e.name, e.type = "esriFieldTypeDate") : w2.startTimeField = null;
        }
        if (w2.endTimeField) {
          const e = S2.get(w2.endTimeField);
          e ? (w2.endTimeField = e.name, e.type = "esriFieldTypeDate") : w2.endTimeField = null;
        }
        if (w2.trackIdField) {
          const e = S2.get(w2.trackIdField);
          e ? w2.trackIdField = e.name : (w2.trackIdField = null, i4.push({
            name: "feature-layer:invalid-timeInfo-trackIdField",
            message: "trackIdField is missing",
            details: {
              timeInfo: w2
            }
          }));
        }
        w2.startTimeField || w2.endTimeField || (i4.push({
          name: "feature-layer:invalid-timeInfo",
          message: "startTimeField and endTimeField are missing or invalid",
          details: {
            timeInfo: w2
          }
        }), w2 = null);
      }
      const Q = S2.dateFields.length ? {
        timeZoneIANA: t2.dateFieldsTimeZone ?? i
      } : null;
      this._createDefaultAttributes = i3(v, O2);
      const M = {
        warnings: i4,
        featureErrors: [],
        layerDefinition: __spreadProps(__spreadValues({}, D), {
          drawingInfo: o(F),
          templates: c(v),
          extent: I,
          geometryType: F,
          objectIdField: O2,
          fields: r,
          hasZ: p3,
          hasM: a,
          timeInfo: w2,
          dateFieldsTimeReference: Q
        }),
        assignedObjectIds: {}
      };
      if (this._queryEngine = new $({
        fieldsIndex: Z.fromLayerJSON({
          fields: r,
          timeInfo: w2,
          dateFieldsTimeReference: Q
        }),
        geometryType: F,
        hasM: a,
        hasZ: p3,
        objectIdField: O2,
        spatialReference: g2,
        featureStore: new m({
          geometryType: F,
          hasM: a,
          hasZ: p3
        }),
        timeInfo: w2,
        cacheSpatialQueries: true
      }), !s2?.length) return this._nextObjectId = t, M;
      const Z2 = n(O2, s2);
      return this._nextObjectId = Z2 + 1, yield x(s2, g2), this._loadInitialFeatures(M, s2);
    });
  }
  applyEdits(e) {
    return __async(this, null, function* () {
      const {
        spatialReference: t2,
        geometryType: i4
      } = this._queryEngine;
      return yield Promise.all([j2(t2, i4), x(e.adds, t2), x(e.updates, t2)]), this._applyEdits(e);
    });
  }
  queryFeatures(e, t2 = {}) {
    return this._queryEngine.executeQuery(e, t2.signal);
  }
  queryFeatureCount(e, t2 = {}) {
    return this._queryEngine.executeQueryForCount(e, t2.signal);
  }
  queryObjectIds(e, t2 = {}) {
    return this._queryEngine.executeQueryForIds(e, t2.signal);
  }
  queryExtent(e, t2 = {}) {
    return this._queryEngine.executeQueryForExtent(e, t2.signal);
  }
  querySnapping(e, t2 = {}) {
    return this._queryEngine.executeQueryForSnapping(e, t2.signal);
  }
  _inferLayerProperties(e, i4) {
    let s2, n2, r = null, a = null, o2 = null;
    for (const l of e) {
      const e2 = l.geometry;
      if (null != e2 && (r || (r = p(e2)), a || (a = e2.spatialReference), null == s2 && (s2 = O(e2)), null == n2 && (n2 = w(e2)), r && a && null != s2 && null != n2)) break;
    }
    if (i4 && i4.length) {
      let e2 = null;
      i4.some((t2) => {
        const i5 = "esriFieldTypeOID" === t2.type, s3 = !t2.type && t2.name && "objectid" === t2.name.toLowerCase();
        return e2 = t2, i5 || s3;
      }) && (o2 = e2.name);
    }
    return {
      geometryType: r,
      spatialReference: a,
      objectIdField: o2,
      hasM: n2,
      hasZ: s2
    };
  }
  _loadInitialFeatures(e, i4) {
    return __async(this, null, function* () {
      const {
        geometryType: s2,
        hasM: r,
        hasZ: a,
        objectIdField: o2,
        spatialReference: l,
        featureStore: u2,
        fieldsIndex: d2
      } = this._queryEngine, f2 = [];
      for (const n2 of i4) {
        if (null != n2.uid && (e.assignedObjectIds[n2.uid] = -1), n2.geometry && s2 !== p(n2.geometry)) {
          e.featureErrors.push(f("Incorrect geometry type."));
          continue;
        }
        const i5 = this._createDefaultAttributes(), r2 = p2(d2, i5, n2.attributes, true);
        r2 ? e.featureErrors.push(r2) : (this._assignObjectId(i5, n2.attributes, true), n2.attributes = i5, null != n2.uid && (e.assignedObjectIds[n2.uid] = n2.attributes[o2]), null != n2.geometry && (n2.geometry = j(n2.geometry, n2.geometry.spatialReference, l)), f2.push(n2));
      }
      u2.addMany(et([], f2, s2, a, r, o2));
      const {
        fullExtent: c2,
        timeExtent: m2
      } = yield this._queryEngine.fetchRecomputedExtents();
      if (e.layerDefinition.extent = c2, m2) {
        const {
          start: t2,
          end: i5
        } = m2;
        e.layerDefinition.timeInfo.timeExtent = [t2, i5];
      }
      return e;
    });
  }
  _applyEdits(e) {
    return __async(this, null, function* () {
      const {
        adds: t2,
        updates: i4,
        deletes: s2
      } = e, n2 = {
        addResults: [],
        deleteResults: [],
        updateResults: [],
        uidToObjectId: {}
      };
      if (t2?.length && this._applyAddEdits(n2, t2), i4?.length && this._applyUpdateEdits(n2, i4), s2?.length) {
        for (const e2 of s2) n2.deleteResults.push(d(e2));
        this._queryEngine.featureStore.removeManyById(s2);
      }
      const {
        fullExtent: r,
        timeExtent: a
      } = yield this._queryEngine.fetchRecomputedExtents();
      return {
        extent: r,
        timeExtent: a,
        featureEditResults: n2
      };
    });
  }
  _applyAddEdits(e, i4) {
    const {
      addResults: s2
    } = e, {
      geometryType: r,
      hasM: a,
      hasZ: o2,
      objectIdField: l,
      spatialReference: u2,
      featureStore: d2,
      fieldsIndex: f2
    } = this._queryEngine, c2 = [];
    for (const n2 of i4) {
      if (n2.geometry && r !== p(n2.geometry)) {
        s2.push(f("Incorrect geometry type."));
        continue;
      }
      const i5 = this._createDefaultAttributes(), a2 = p2(f2, i5, n2.attributes);
      if (a2) s2.push(a2);
      else {
        if (this._assignObjectId(i5, n2.attributes), n2.attributes = i5, null != n2.uid) {
          const t2 = n2.attributes[l];
          e.uidToObjectId[n2.uid] = t2;
        }
        if (null != n2.geometry) {
          const e2 = n2.geometry.spatialReference ?? u2;
          n2.geometry = j(y(n2.geometry, e2), e2, u2);
        }
        c2.push(n2), s2.push(d(n2.attributes[l]));
      }
    }
    d2.addMany(et([], c2, r, o2, a, l));
  }
  _applyUpdateEdits({
    updateResults: e
  }, i4) {
    const {
      geometryType: s2,
      hasM: n2,
      hasZ: o2,
      objectIdField: l,
      spatialReference: u2,
      featureStore: d2,
      fieldsIndex: f2
    } = this._queryEngine;
    for (const c2 of i4) {
      const {
        attributes: i5,
        geometry: m2
      } = c2, y2 = i5?.[l];
      if (null == y2) {
        e.push(f(`Identifier field ${l} missing`));
        continue;
      }
      if (!d2.has(y2)) {
        e.push(f(`Feature with object id ${y2} missing`));
        continue;
      }
      const h = nt(d2.getFeature(y2), s2, o2, n2);
      if (null != m2) {
        if (s2 !== p(m2)) {
          e.push(f("Incorrect geometry type."));
          continue;
        }
        const i6 = m2.spatialReference ?? u2;
        h.geometry = j(y(m2, i6), i6, u2);
      }
      if (i5) {
        const t2 = p2(f2, h.attributes, i5);
        if (t2) {
          e.push(t2);
          continue;
        }
      }
      d2.add(tt(h, s2, o2, n2, l)), e.push(d(y2));
    }
  }
  _assignObjectId(e, t2, i4 = false) {
    const s2 = this._queryEngine.objectIdField;
    i4 && t2 && isFinite(t2[s2]) ? e[s2] = t2[s2] : e[s2] = this._nextObjectId++;
  }
};
export {
  S as default
};
//# sourceMappingURL=MemorySourceWorker-WXNE2XON.js.map
