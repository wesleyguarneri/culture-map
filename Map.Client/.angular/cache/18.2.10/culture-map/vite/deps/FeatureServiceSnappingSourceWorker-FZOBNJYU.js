import {
  i as i2,
  n as n2,
  r
} from "./chunk-QFQHRGZH.js";
import {
  E as E2
} from "./chunk-LM2N2I5R.js";
import {
  h as h3
} from "./chunk-PVO5NM6Q.js";
import {
  S as S2,
  c as c3,
  f as f3,
  x
} from "./chunk-ZQ57XGAE.js";
import "./chunk-UXW277HY.js";
import {
  a as a3
} from "./chunk-OR5F5ACQ.js";
import "./chunk-E2WAKNLZ.js";
import {
  m
} from "./chunk-ROATEOHC.js";
import {
  o as o4
} from "./chunk-BIWDYV6F.js";
import {
  $
} from "./chunk-4MXR7W7N.js";
import "./chunk-6UYQMUGI.js";
import "./chunk-D3XZUGMN.js";
import "./chunk-YFQ32AQX.js";
import "./chunk-L4AYSXFJ.js";
import "./chunk-POQ3T5EH.js";
import "./chunk-LPEFONL3.js";
import "./chunk-SSMSHZ2C.js";
import "./chunk-DM4WHMQY.js";
import "./chunk-DON3YPGT.js";
import {
  ct,
  gt,
  it
} from "./chunk-C7NRYPDG.js";
import "./chunk-Z3GMSC63.js";
import "./chunk-F35MWZH7.js";
import "./chunk-ED7UGR2X.js";
import "./chunk-YA5CTHMT.js";
import "./chunk-4QBFFLOC.js";
import "./chunk-O437BSYE.js";
import "./chunk-YZNT6QWD.js";
import "./chunk-YVOGHYE3.js";
import "./chunk-IBOZJLSO.js";
import "./chunk-W2IRSMFY.js";
import {
  b as b2
} from "./chunk-TRSGUVSM.js";
import "./chunk-U3MA63JX.js";
import "./chunk-WYKKCLBI.js";
import "./chunk-PFMGJTQM.js";
import "./chunk-Q7SRMLJZ.js";
import "./chunk-PQ4T66BG.js";
import "./chunk-SWPHGZYB.js";
import "./chunk-DWASPXVI.js";
import "./chunk-CIW3KHOW.js";
import "./chunk-J55F4AC2.js";
import "./chunk-LNRZHZOQ.js";
import "./chunk-DI6VABAK.js";
import "./chunk-5EBAJR7X.js";
import "./chunk-5JA2JHV3.js";
import "./chunk-FUKSTKFU.js";
import "./chunk-MIQZ6UDY.js";
import "./chunk-JOJZ6YC5.js";
import "./chunk-L4TOCXR5.js";
import "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import "./chunk-7WP676SE.js";
import "./chunk-SGSUM5YO.js";
import "./chunk-SG5TCCCK.js";
import "./chunk-6A7CWJED.js";
import "./chunk-DUTZNK67.js";
import "./chunk-IN6BQCWS.js";
import {
  g
} from "./chunk-CRNUMTSV.js";
import "./chunk-JM7HAEY6.js";
import {
  z
} from "./chunk-LJEOBI2I.js";
import {
  t as t2
} from "./chunk-2OMCGIU4.js";
import {
  h as h2
} from "./chunk-HMNBB7ED.js";
import "./chunk-3RRMLFFN.js";
import "./chunk-DR5TVNEL.js";
import "./chunk-K64AAM77.js";
import "./chunk-A3NNJ7XA.js";
import "./chunk-OKJHJ3CY.js";
import "./chunk-XTVPEVHA.js";
import "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import {
  y as y2
} from "./chunk-S3IO7V4Q.js";
import "./chunk-4ZZRP4MA.js";
import "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-XWXBNAOW.js";
import "./chunk-GWC3DAGP.js";
import "./chunk-EODIWR2E.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-FYAEQPUY.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-7RMVJCDW.js";
import "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import {
  E,
  c as c2,
  l,
  o as o3,
  u as u2
} from "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import {
  w as w2
} from "./chunk-NYQ5CYNR.js";
import "./chunk-O7UDKFOW.js";
import {
  f as f2
} from "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import "./chunk-AXVPJBVW.js";
import "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import {
  C,
  d as d2,
  p,
  w
} from "./chunk-6WHTZNUH.js";
import "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import {
  b,
  d
} from "./chunk-XNUH25NY.js";
import {
  o as o2
} from "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e as e3
} from "./chunk-4Z5SGKRM.js";
import {
  S,
  e2,
  f,
  i2 as i,
  o3 as o,
  u2 as u
} from "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3 as a2
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import {
  L,
  a,
  s
} from "./chunk-HJY2YILU.js";
import {
  e
} from "./chunk-7DA6A5LD.js";
import "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  n2 as n
} from "./chunk-WYIDUUN2.js";
import {
  c2 as c,
  h,
  t3 as t
} from "./chunk-DXLOWWK7.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/core/AsyncSequence.js
var r2 = class extends S {
  constructor() {
    super(...arguments), this.updating = false, this._pending = [];
  }
  push(s2, t4) {
    this._pending.push({
      promise: s2,
      callback: t4
    }), 1 === this._pending.length && this._process();
  }
  _process() {
    if (!this._pending.length) return void (this.updating = false);
    this.updating = true;
    const s2 = this._pending[0];
    s2.promise.then((t4) => s2.callback(t4)).catch(() => {
    }).then(() => {
      this._pending.shift(), this._process();
    });
  }
};
e3([y()], r2.prototype, "updating", void 0), r2 = e3([a2("esri.core.AsyncSequence")], r2);

// ../../../node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/PendingFeatureTile.js
var r3 = class {
  constructor(t4, e4) {
    this.data = t4, this.resolution = e4, this.state = {
      type: i3.CREATED
    }, this.alive = true;
  }
  process(t4) {
    switch (this.state.type) {
      case i3.CREATED:
        return this.state = this._gotoFetchCount(this.state, t4), this.state.task.promise.then(t4.resume, t4.resume);
      case i3.FETCH_COUNT:
        break;
      case i3.FETCHED_COUNT:
        return this.state = this._gotoFetchFeatures(this.state, t4), this.state.task.promise.then(t4.resume, t4.resume);
      case i3.FETCH_FEATURES:
        break;
      case i3.FETCHED_FEATURES:
        this.state = this._goToDone(this.state, t4);
      case i3.DONE:
    }
    return null;
  }
  get debugInfo() {
    return {
      data: this.data,
      featureCount: this._featureCount,
      state: this._stateToString
    };
  }
  get _featureCount() {
    switch (this.state.type) {
      case i3.CREATED:
      case i3.FETCH_COUNT:
        return 0;
      case i3.FETCHED_COUNT:
        return this.state.featureCount;
      case i3.FETCH_FEATURES:
        return this.state.previous.featureCount;
      case i3.FETCHED_FEATURES:
        return this.state.features.length;
      case i3.DONE:
        return this.state.previous.features.length;
    }
  }
  get _stateToString() {
    switch (this.state.type) {
      case i3.CREATED:
        return "created";
      case i3.FETCH_COUNT:
        return "fetch-count";
      case i3.FETCHED_COUNT:
        return "fetched-count";
      case i3.FETCH_FEATURES:
        return "fetch-features";
      case i3.FETCHED_FEATURES:
        return "fetched-features";
      case i3.DONE:
        return "done";
    }
  }
  _gotoFetchCount(s2, a4) {
    return {
      type: i3.FETCH_COUNT,
      previous: s2,
      task: d((t4) => __async(this, null, function* () {
        const s3 = yield b(a4.fetchCount(this, t4));
        this.state.type === i3.FETCH_COUNT && (this.state = u3(this.state, s3.ok ? s3.value : 1 / 0));
      }))
    };
  }
  _gotoFetchFeatures(s2, a4) {
    return {
      type: i3.FETCH_FEATURES,
      previous: s2,
      task: d((t4) => __async(this, null, function* () {
        const E4 = yield b(a4.fetchFeatures(this, s2.featureCount, t4));
        this.state.type === i3.FETCH_FEATURES && (this.state = T(this.state, E4.ok ? E4.value : []));
      }))
    };
  }
  _goToDone(t4, e4) {
    return e4.finish(this, t4.features), {
      type: i3.DONE,
      previous: t4
    };
  }
  reset() {
    const t4 = this.state;
    switch (this.state = {
      type: i3.CREATED
    }, t4.type) {
      case i3.CREATED:
      case i3.FETCHED_COUNT:
      case i3.FETCHED_FEATURES:
      case i3.DONE:
        break;
      case i3.FETCH_COUNT:
      case i3.FETCH_FEATURES:
        t4.task.abort();
    }
  }
  intersects(t4) {
    return null == t4 || !this.data.extent || (o3(t4, n3), E(this.data.extent, n3));
  }
};
function u3(t4, e4) {
  return {
    type: i3.FETCHED_COUNT,
    featureCount: e4,
    previous: t4
  };
}
function T(t4, e4) {
  return {
    type: i3.FETCHED_FEATURES,
    previous: t4,
    features: e4
  };
}
var i3;
!function(t4) {
  t4[t4.CREATED = 0] = "CREATED", t4[t4.FETCH_COUNT = 1] = "FETCH_COUNT", t4[t4.FETCHED_COUNT = 2] = "FETCHED_COUNT", t4[t4.FETCH_FEATURES = 3] = "FETCH_FEATURES", t4[t4.FETCHED_FEATURES = 4] = "FETCHED_FEATURES", t4[t4.DONE = 5] = "DONE";
}(i3 || (i3 = {}));
var n3 = u2();

// ../../../node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiledFetcher.js
var x2 = class extends S {
  get _minimumVerticesPerFeature() {
    switch (this.store?.featureStore.geometryType) {
      case "esriGeometryPoint":
      case "esriGeometryMultipoint":
        return 1;
      case "esriGeometryPolygon":
        return 4;
      case "esriGeometryPolyline":
        return 2;
    }
  }
  get _mandatoryOutFields() {
    const e4 = /* @__PURE__ */ new Set();
    return this.objectIdField && e4.add(this.objectIdField), this.globalIdField && e4.add(this.globalIdField), e4;
  }
  set outFields(e4) {
    const t4 = this._get("outFields"), i4 = o(e4, this._mandatoryOutFields);
    f(i4, t4) || (this._set("outFields", i4), e2(i4, t4) || this.refresh());
  }
  get outFields() {
    return this._get("outFields") ?? this._mandatoryOutFields;
  }
  set filter(e4) {
    const t4 = this._get("filter"), i4 = this._filterProperties(e4);
    JSON.stringify(t4) !== JSON.stringify(i4) && this._set("filter", i4);
  }
  set customParameters(e4) {
    const t4 = this._get("customParameters");
    JSON.stringify(t4) !== JSON.stringify(e4) && this._set("customParameters", e4);
  }
  get _configuration() {
    return {
      filter: this.filter,
      customParameters: this.customParameters,
      tileInfo: this.tileInfo,
      tileSize: this.tileSize
    };
  }
  set tileInfo(e4) {
    const t4 = this._get("tileInfo");
    t4 !== e4 && (null != e4 && null != t4 && JSON.stringify(e4) === JSON.stringify(t4) || (this._set("tileInfo", e4), this.store.tileInfo = e4));
  }
  set tileSize(e4) {
    this._get("tileSize") !== e4 && this._set("tileSize", e4);
  }
  get updating() {
    return this.updatingExcludingEdits || this._pendingEdits.updating;
  }
  get updatingExcludingEdits() {
    return this._updatingHandles.updating;
  }
  get hasZ() {
    return this.store.featureStore.hasZ;
  }
  constructor(e4) {
    super(e4), this.suspended = true, this.tilesOfInterest = [], this.availability = 0, this._pendingTiles = /* @__PURE__ */ new Map(), this._updatingHandles = new h3(), this._pendingEdits = new r2(), this._pendingEditsAbortController = new AbortController();
  }
  initialize() {
    this._initializeFetchExtent(), this._updatingHandles.add(() => this._configuration, () => this.refresh()), this._updatingHandles.add(() => this.tilesOfInterest, (e4, t4) => {
      h(e4, t4, ({
        id: e5
      }, {
        id: t5
      }) => e5 === t5) || this._process();
    }, C), this.addHandles(p(() => !this.suspended, () => this._process()));
  }
  destroy() {
    this._pendingTiles.forEach((e4) => this._deletePendingTile(e4)), this._pendingTiles.clear(), this.store.destroy(), this.tilesOfInterest.length = 0, this._pendingEditsAbortController.abort(), this._pendingEditsAbortController = null, this._updatingHandles.destroy();
  }
  refresh() {
    this.store.refresh(), this._pendingTiles.forEach((e4) => this._deletePendingTile(e4)), this._process();
  }
  applyEdits(e4) {
    this._pendingEdits.push(e4, (e5) => __async(this, null, function* () {
      if (0 === e5.addedFeatures.length && 0 === e5.updatedFeatures.length && 0 === e5.deletedFeatures.length) return;
      for (const [, i4] of this._pendingTiles) i4.reset();
      const t4 = __spreadProps(__spreadValues({}, e5), {
        deletedFeatures: e5.deletedFeatures.map(({
          objectId: e6,
          globalId: t5
        }) => e6 && -1 !== e6 ? e6 : this._lookupObjectIdByGlobalId(t5))
      });
      yield this._updatingHandles.addPromise(this.store.processEdits(t4, (e6, t5) => this._queryFeaturesById(e6, t5), this._pendingEditsAbortController.signal)), this._processPendingTiles();
    }));
  }
  _initializeFetchExtent() {
    if (!this.capabilities.query.supportsExtent || !g(this.url)) return;
    const e4 = d((e5) => __async(this, null, function* () {
      try {
        const t4 = yield x(this.url, new b2({
          where: "1=1",
          outSpatialReference: this.spatialReference,
          cacheHint: this.capabilities.query.supportsCacheHint ?? void 0
        }), {
          query: this._configuration.customParameters,
          signal: e5
        });
        this.store.extent = w2.fromJSON(t4.data?.extent);
      } catch (t4) {
        a(t4), n.getLogger(this).warn("Failed to fetch data extent", t4);
      }
    }));
    this._updatingHandles.addPromise(e4.promise.then(() => this._process())), this.addHandles(e(() => e4.abort()));
  }
  get debugInfo() {
    return {
      numberOfFeatures: this.store.featureStore.numFeatures,
      tilesOfInterest: this.tilesOfInterest,
      pendingTiles: Array.from(this._pendingTiles.values()).map((e4) => e4.debugInfo),
      storedTiles: this.store.debugInfo
    };
  }
  _process() {
    this._markTilesNotAlive(), this._createPendingTiles(), this._deletePendingTiles(), this._processPendingTiles();
  }
  _markTilesNotAlive() {
    for (const [, e4] of this._pendingTiles) e4.alive = false;
  }
  _createPendingTiles() {
    if (this.suspended) return;
    const e4 = this._collectMissingTilesInfo();
    if (this._setAvailability(null == e4 ? 1 : e4.coveredArea / e4.fullArea), null != e4) for (const {
      data: t4,
      resolution: i4
    } of e4.missingTiles) {
      const e5 = this._pendingTiles.get(t4.id);
      e5 ? (e5.resolution = i4, e5.alive = true) : this._createPendingTile(t4, i4);
    }
  }
  _collectMissingTilesInfo() {
    let e4 = null;
    for (let t4 = this.tilesOfInterest.length - 1; t4 >= 0; t4--) {
      const i4 = this.tilesOfInterest[t4], s2 = this.store.process(i4, (e5, t5) => this._verifyTileComplexity(e5, t5), this.outFields);
      null == e4 ? e4 = s2 : e4.prepend(s2);
    }
    return e4;
  }
  _deletePendingTiles() {
    for (const [, e4] of this._pendingTiles) e4.alive || this._deletePendingTile(e4);
  }
  _processPendingTiles() {
    const e4 = {
      fetchCount: (e5, t4) => this._fetchCount(e5, t4),
      fetchFeatures: (e5, t4, i4) => this._fetchFeatures(e5, t4, i4),
      finish: (e5, t4) => this._finishPendingTile(e5, t4),
      resume: () => this._processPendingTiles()
    };
    if (this._ensureFetchAllCounts(e4)) for (const [, t4] of this._pendingTiles) this._verifyTileComplexity(this.store.getFeatureCount(t4.data), t4.resolution) && this._updatingHandles.addPromise(t4.process(e4));
  }
  _verifyTileComplexity(e4, t4) {
    return this._verifyVertexComplexity(e4) && this._verifyFeatureDensity(e4, t4);
  }
  _verifyVertexComplexity(e4) {
    return e4 * this._minimumVerticesPerFeature < q;
  }
  _verifyFeatureDensity(e4, t4) {
    if (null == this.tileInfo) return false;
    const i4 = this.tileSize * t4;
    return e4 * (A / (i4 * i4)) < H;
  }
  _ensureFetchAllCounts(e4) {
    let t4 = true;
    for (const [, i4] of this._pendingTiles) i4.state.type < i3.FETCHED_COUNT && this._updatingHandles.addPromise(i4.process(e4)), i4.state.type <= i3.FETCH_COUNT && (t4 = false);
    return t4;
  }
  _finishPendingTile(e4, t4) {
    this.store.add(e4.data, t4), this._deletePendingTile(e4), this._updateAvailability();
  }
  _updateAvailability() {
    const e4 = this._collectMissingTilesInfo();
    this._setAvailability(null == e4 ? 1 : e4.coveredArea / e4.fullArea);
  }
  _setAvailability(e4) {
    this._set("availability", e4);
  }
  _createPendingTile(e4, t4) {
    const i4 = new r3(e4, t4);
    return this._pendingTiles.set(e4.id, i4), i4;
  }
  _deletePendingTile(e4) {
    e4.reset(), this._pendingTiles.delete(e4.data.id);
  }
  _fetchCount(e4, t4) {
    return __async(this, null, function* () {
      return this.store.fetchCount(e4.data, this.url, this._createCountQuery(e4), {
        query: this.customParameters,
        timeout: w3,
        signal: t4
      });
    });
  }
  _fetchFeatures(e4, t4, i4) {
    return __async(this, null, function* () {
      let s2 = 0;
      const r4 = [];
      let o5 = 0, n4 = t4;
      for (; ; ) {
        const l2 = this._createFeaturesQuery(e4), a4 = this._setPagingParameters(l2, s2, n4), {
          features: u4,
          exceededTransferLimit: d3
        } = yield this._queryFeatures(l2, i4);
        a4 && (s2 += l2.num), o5 += u4.length;
        for (const e5 of u4) r4.push(e5);
        if (n4 = t4 - o5, !a4 || !d3 || n4 <= 0) return r4;
      }
    });
  }
  _filterProperties(e4) {
    return null == e4 ? {
      where: "1=1",
      gdbVersion: void 0,
      timeExtent: void 0
    } : {
      where: e4.where || "1=1",
      timeExtent: e4.timeExtent,
      gdbVersion: e4.gdbVersion
    };
  }
  _lookupObjectIdByGlobalId(e4) {
    const t4 = this.globalIdField, i4 = this.objectIdField;
    if (null == t4) throw new Error("Expected globalIdField to be defined");
    let s2 = null;
    if (this.store.featureStore.forEach((r4) => {
      e4 === r4.attributes[t4] && (s2 = r4.objectId ?? r4.attributes[i4]);
    }), null == s2) throw new Error(`Expected to find a feature with globalId ${e4}`);
    return s2;
  }
  _queryFeaturesById(e4, t4) {
    const i4 = this._createFeaturesQuery();
    return i4.objectIds = e4, this._queryFeatures(i4, t4);
  }
  _queryFeatures(e4, t4) {
    return this.capabilities.query.supportsFormatPBF ? this._queryFeaturesPBF(e4, t4) : this._queryFeaturesJSON(e4, t4);
  }
  _queryFeaturesPBF(e4, t4) {
    return __async(this, null, function* () {
      const {
        sourceSpatialReference: i4
      } = this, {
        data: s2
      } = yield f3(this.url, e4, new a3({
        sourceSpatialReference: i4
      }), {
        query: this._configuration.customParameters,
        timeout: w3,
        signal: t4
      });
      return it(s2);
    });
  }
  _queryFeaturesJSON(e4, t4) {
    return __async(this, null, function* () {
      const {
        sourceSpatialReference: i4
      } = this, {
        data: s2
      } = yield c3(this.url, e4, i4, {
        query: this._configuration.customParameters,
        timeout: w3,
        signal: t4
      });
      return ct(s2, this.objectIdField);
    });
  }
  _createCountQuery(e4) {
    const t4 = this._createBaseQuery(e4);
    return this.capabilities.query.supportsCacheHint && (t4.cacheHint = true), t4;
  }
  _createFeaturesQuery(e4 = null) {
    const t4 = this._createBaseQuery(e4), i4 = null != e4?.data ? this.store.getAttributesForTile(e4?.data?.id) : null, s2 = o(i(this.outFields, i4 ?? /* @__PURE__ */ new Set()), this._mandatoryOutFields);
    return t4.outFields = Array.from(s2), t4.returnGeometry = true, null != e4 && (this.capabilities.query.supportsResultType ? t4.resultType = "tile" : this.capabilities.query.supportsCacheHint && (t4.cacheHint = true)), t4;
  }
  _createBaseQuery(e4) {
    const t4 = new b2({
      returnZ: this.hasZ,
      returnM: false,
      geometry: null != this.tileInfo && null != e4 ? c2(e4.data.extent, this.tileInfo.spatialReference) : void 0
    }), i4 = this._configuration.filter;
    return null != i4 && (t4.where = i4.where, t4.gdbVersion = i4.gdbVersion, t4.timeExtent = i4.timeExtent), t4.outSpatialReference = this.spatialReference, t4;
  }
  _setPagingParameters(e4, t4, i4) {
    if (!this.capabilities.query.supportsPagination) return false;
    const {
      supportsMaxRecordCountFactor: s2,
      supportsCacheHint: r4,
      tileMaxRecordCount: o5,
      maxRecordCount: n4,
      supportsResultType: l2
    } = this.capabilities.query, a4 = s2 ? b2.MAX_MAX_RECORD_COUNT_FACTOR : 1, u4 = a4 * ((l2 || r4) && o5 ? o5 : n4 || j);
    return e4.start = t4, s2 ? (e4.maxRecordCountFactor = Math.min(a4, Math.ceil(i4 / u4)), e4.num = Math.min(i4, e4.maxRecordCountFactor * u4)) : e4.num = Math.min(i4, u4), true;
  }
};
e3([y({
  constructOnly: true
})], x2.prototype, "url", void 0), e3([y({
  constructOnly: true
})], x2.prototype, "objectIdField", void 0), e3([y({
  constructOnly: true
})], x2.prototype, "globalIdField", void 0), e3([y({
  constructOnly: true
})], x2.prototype, "capabilities", void 0), e3([y({
  constructOnly: true
})], x2.prototype, "sourceSpatialReference", void 0), e3([y({
  constructOnly: true
})], x2.prototype, "spatialReference", void 0), e3([y({
  constructOnly: true
})], x2.prototype, "store", void 0), e3([y({
  readOnly: true
})], x2.prototype, "_minimumVerticesPerFeature", null), e3([y()], x2.prototype, "_mandatoryOutFields", null), e3([y()], x2.prototype, "outFields", null), e3([y()], x2.prototype, "suspended", void 0), e3([y()], x2.prototype, "filter", null), e3([y()], x2.prototype, "customParameters", null), e3([y({
  readOnly: true
})], x2.prototype, "_configuration", null), e3([y()], x2.prototype, "tileInfo", null), e3([y()], x2.prototype, "tileSize", null), e3([y()], x2.prototype, "tilesOfInterest", void 0), e3([y({
  readOnly: true
})], x2.prototype, "updating", null), e3([y({
  readOnly: true
})], x2.prototype, "updatingExcludingEdits", null), e3([y({
  readOnly: true
})], x2.prototype, "availability", void 0), e3([y()], x2.prototype, "hasZ", null), x2 = e3([a2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiledFetcher")], x2);
var j = 2e3;
var w3 = 6e5;
var q = 1e6;
var A = 25;
var H = 1;

// ../../../node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileCache.js
var t3 = class {
  constructor() {
    this._store = /* @__PURE__ */ new Map(), this._byteSize = 0;
  }
  set(t4, e4) {
    this.delete(t4), this._store.set(t4, e4), this._byteSize += e4.byteSize;
  }
  delete(t4) {
    const e4 = this._store.get(t4);
    return !!this._store.delete(t4) && (null != e4 && (this._byteSize -= e4.byteSize), true);
  }
  get(t4) {
    return this._used(t4), this._store.get(t4);
  }
  has(t4) {
    return this._used(t4), this._store.has(t4);
  }
  clear() {
    this._store.clear();
  }
  applyByteSizeLimit(t4, e4) {
    for (const [s2, r4] of this._store) {
      if (this._byteSize <= t4) break;
      this.delete(s2), e4(r4);
    }
  }
  values() {
    return this._store.values();
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]();
  }
  _used(t4) {
    const e4 = this._store.get(t4);
    e4 && (this._store.delete(t4), this._store.set(t4, e4));
  }
};

// ../../../node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileStore.js
var v = class extends S {
  constructor(e4) {
    super(e4), this.tileInfo = null, this.extent = null, this.maximumByteSize = 10 * E2.MEGABYTES, this._tileBounds = new o4(), this._tiles = new t3(), this._refCounts = /* @__PURE__ */ new Map(), this._tileFeatureCounts = /* @__PURE__ */ new Map(), this._tmpBoundingRect = u2();
  }
  add(e4, t4) {
    for (const r4 of t4) this._referenceFeature(r4.objectId);
    const s2 = this.featureStore.upsertMany(t4), i4 = s2.map((e5) => new Set(Object.keys(e5.attributes))).reduce((e5, t5) => u(e5, t5), new Set(Object.keys(s2[0]?.attributes ?? [])));
    this._addTileStorage(e4, new Set(s2.map((e5) => e5.objectId)), S3(s2), i4), this._tiles.applyByteSizeLimit(this.maximumByteSize, (e5) => this._removeTileStorage(e5));
  }
  getAttributesForTile(e4) {
    return e4 ? this._tiles.get(e4)?.attributeKeys : null;
  }
  destroy() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  clear() {
    this.featureStore.clear(), this._tileBounds.clear(), this._tiles.clear(), this._refCounts.clear();
  }
  refresh() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  processEdits(e4, t4, s2) {
    return this._processEditsDelete(e4.deletedFeatures.concat(e4.updatedFeatures)), this._processEditsRefetch(e4.addedFeatures.concat(e4.updatedFeatures), t4, s2);
  }
  _addTileStorage(e4, t4, s2, i4) {
    const r4 = e4.id;
    this._tiles.set(r4, new w4(e4, t4, s2, i4)), this._tileBounds.set(r4, e4.extent), this._tileFeatureCounts.set(r4, t4.size);
  }
  _remove({
    id: e4
  }) {
    const t4 = this._tiles.get(e4);
    t4 && this._removeTileStorage(t4);
  }
  _removeTileStorage(e4) {
    const t4 = [];
    for (const i4 of e4.objectIds) this._unreferenceFeature(i4) === x3.REMOVED && t4.push(i4);
    this.featureStore.removeManyById(t4);
    const s2 = e4.data.id;
    this._tiles.delete(s2), this._tileBounds.delete(s2);
  }
  _processEditsDelete(e4) {
    this.featureStore.removeManyById(e4);
    for (const [, t4] of this._tiles) {
      for (const s2 of e4) t4.objectIds.delete(s2);
      this._tileFeatureCounts.set(t4.data.id, t4.objectIds.size);
    }
    for (const t4 of e4) this._refCounts.delete(t4);
  }
  _processEditsRefetch(e4, t4, s2) {
    return __async(this, null, function* () {
      const i4 = (yield t4(e4, s2)).features, {
        hasZ: r4,
        hasM: o5
      } = this.featureStore;
      for (const n4 of i4) {
        const e5 = gt(this._tmpBoundingRect, n4.geometry, r4, o5);
        null != e5 && this._tileBounds.forEachInBounds(e5, (e6) => {
          const t5 = this._tiles.get(e6);
          this.featureStore.add(n4);
          const s3 = n4.objectId;
          t5.objectIds.has(s3) || (t5.objectIds.add(s3), this._referenceFeature(s3), this._tileFeatureCounts.set(t5.data.id, t5.objectIds.size));
        });
      }
    });
  }
  process(e4, t4 = () => true, s2) {
    if (null == this.tileInfo || !e4.extent || null != this.extent && !E(o3(this.extent, this._tmpBoundingRect), e4.extent)) return new j2(e4);
    const i4 = this.getAttributesForTile(e4.id);
    if (e2(s2, i4)) return new j2(e4);
    const r4 = this._createTileTree(e4, this.tileInfo);
    return this._simplify(r4, t4, null, 0, 1), this._collectMissingTiles(e4, r4, this.tileInfo, s2);
  }
  get debugInfo() {
    return Array.from(this._tiles.values()).map(({
      data: e4
    }) => ({
      data: e4,
      featureCount: this._tileFeatureCounts.get(e4.id) || 0
    }));
  }
  getFeatureCount(e4) {
    return this._tileFeatureCounts.get(e4.id) ?? 0;
  }
  fetchCount(e4, t4, s2, i4) {
    return __async(this, null, function* () {
      const r4 = this._tileFeatureCounts.get(e4.id);
      if (null != r4) return r4;
      const o5 = yield S2(t4, s2, i4);
      return this._tileFeatureCounts.set(e4.id, o5.data.count), o5.data.count;
    });
  }
  _createTileTree(e4, t4) {
    const s2 = new F(e4.level, e4.row, e4.col);
    return t4.updateTileInfo(s2, z.ExtrapolateOptions.POWER_OF_TWO), this._tileBounds.forEachInBounds(e4.extent, (i4) => {
      const r4 = this._tiles.get(i4)?.data;
      r4 && C2(e4, r4) && this._populateChildren(s2, r4, t4, this._tileFeatureCounts.get(r4.id) || 0);
    }), s2;
  }
  _populateChildren(e4, t4, s2, i4) {
    const r4 = t4.level - e4.level - 1;
    if (r4 < 0) return void (e4.isLeaf = true);
    const o5 = t4.row >> r4, n4 = t4.col >> r4, l2 = e4.row << 1, c4 = n4 - (e4.col << 1) + (o5 - l2 << 1), u4 = e4.children[c4];
    if (null != u4) this._populateChildren(u4, t4, s2, i4);
    else {
      const r5 = new F(e4.level + 1, o5, n4);
      s2.updateTileInfo(r5, z.ExtrapolateOptions.POWER_OF_TWO), e4.children[c4] = r5, this._populateChildren(r5, t4, s2, i4);
    }
  }
  _simplify(e4, t4, s2, i4, r4) {
    const o5 = r4 * r4;
    if (e4.isLeaf) return t4(this.getFeatureCount(e4), r4) ? 0 : (this._remove(e4), null != s2 && (s2.children[i4] = null), o5);
    const n4 = r4 / 2, l2 = n4 * n4;
    let c4 = 0;
    for (let u4 = 0; u4 < e4.children.length; u4++) {
      const s3 = e4.children[u4];
      c4 += null != s3 ? this._simplify(s3, t4, e4, u4, n4) : l2;
    }
    return 0 === c4 ? this._mergeChildren(e4) : 1 - c4 / o5 < I && (this._purge(e4), null != s2 && (s2.children[i4] = null), c4 = o5), c4;
  }
  _mergeChildren(e4) {
    const t4 = /* @__PURE__ */ new Set();
    let s2, i4 = 0;
    this._forEachLeaf(e4, (e5) => {
      const r4 = this._tiles.get(e5.id);
      if (r4) {
        s2 = s2 ? u(s2, r4.attributeKeys) : new Set(r4.attributeKeys), i4 += r4.byteSize;
        for (const e6 of r4.objectIds) t4.has(e6) || (t4.add(e6), this._referenceFeature(e6));
        this._remove(e5);
      }
    }), this._addTileStorage(e4, t4, i4, s2 ?? /* @__PURE__ */ new Set()), e4.isLeaf = true, e4.children[0] = e4.children[1] = e4.children[2] = e4.children[3] = null, this._tileFeatureCounts.set(e4.id, t4.size);
  }
  _forEachLeaf(e4, t4) {
    for (const s2 of e4.children) null != s2 && (s2.isLeaf ? t4(s2) : this._forEachLeaf(s2, t4));
  }
  _purge(e4) {
    if (null != e4) if (e4.isLeaf) this._remove(e4);
    else for (let t4 = 0; t4 < e4.children.length; t4++) {
      const s2 = e4.children[t4];
      this._purge(s2), e4.children[t4] = null;
    }
  }
  _collectMissingTiles(e4, t4, s2, i4) {
    const r4 = new b3(s2, e4, this.extent);
    return this._collectMissingTilesRecurse(t4, r4, 1, i4), r4.info;
  }
  _collectMissingTilesRecurse(e4, t4, s2, i4) {
    const r4 = this.getAttributesForTile(e4.id), o5 = r4 && !e2(i4, r4);
    if (o5 && t4.addMissing(e4.level, e4.row, e4.col, s2), e4.isLeaf) return;
    if (!e4.hasChildren) return void (o5 || t4.addMissing(e4.level, e4.row, e4.col, s2));
    const l2 = s2 / 2;
    for (let n4 = 0; n4 < e4.children.length; n4++) {
      const s3 = e4.children[n4];
      null == s3 ? t4.addMissing(e4.level + 1, (e4.row << 1) + ((2 & n4) >> 1), (e4.col << 1) + (1 & n4), l2) : this._collectMissingTilesRecurse(s3, t4, l2, i4);
    }
  }
  _referenceFeature(e4) {
    const t4 = (this._refCounts.get(e4) || 0) + 1;
    return this._refCounts.set(e4, t4), 1 === t4 ? x3.ADDED : x3.UNCHANGED;
  }
  _unreferenceFeature(e4) {
    const t4 = (this._refCounts.get(e4) || 0) - 1;
    return 0 === t4 ? (this._refCounts.delete(e4), x3.REMOVED) : (t4 > 0 && this._refCounts.set(e4, t4), x3.UNCHANGED);
  }
  get test() {
  }
};
function C2(e4, t4) {
  if (!e4 || !t4) return false;
  if (e4.level === t4.level) return e4.row === t4.row && e4.col === t4.col;
  const s2 = e4.level < t4.level, i4 = s2 ? e4 : t4, r4 = s2 ? t4 : e4, o5 = 1 << r4.level - i4.level;
  return Math.floor(r4.row / o5) === i4.row && Math.floor(r4.col / o5) === i4.col;
}
function S3(e4) {
  return e4.reduce((e5, t4) => e5 + E3(t4), 0);
}
function E3(e4) {
  return 32 + T2(e4.geometry) + t(e4.attributes);
}
function T2(e4) {
  if (null == e4) return 0;
  const t4 = c(e4.lengths, 4);
  return 32 + c(e4.coords, 8) + t4;
}
e3([y({
  constructOnly: true
})], v.prototype, "featureStore", void 0), e3([y()], v.prototype, "tileInfo", void 0), e3([y()], v.prototype, "extent", void 0), e3([y()], v.prototype, "maximumByteSize", void 0), v = e3([a2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTileStore")], v);
var w4 = class {
  constructor(e4, t4, s2, i4) {
    this.data = e4, this.objectIds = t4, this.byteSize = s2, this.attributeKeys = i4;
  }
};
var F = class {
  constructor(e4, t4, s2) {
    this.level = e4, this.row = t4, this.col = s2, this.isLeaf = false, this.extent = null, this.children = [null, null, null, null];
  }
  get hasChildren() {
    return !this.isLeaf && (null != this.children[0] || null != this.children[1] || null != this.children[2] || null != this.children[3]);
  }
};
var j2 = class {
  constructor(e4, t4 = []) {
    this.missingTiles = t4, this.fullArea = 0, this.coveredArea = 0, this.fullArea = l(e4.extent), this.coveredArea = this.fullArea;
  }
  prepend(e4) {
    this.missingTiles = e4.missingTiles.concat(this.missingTiles), this.coveredArea += e4.coveredArea, this.fullArea += e4.fullArea;
  }
};
var b3 = class {
  constructor(e4, t4, s2) {
    this._tileInfo = e4, this._extent = null, this.info = new j2(t4), null != s2 && (this._extent = o3(s2));
  }
  addMissing(e4, t4, s2, i4) {
    const r4 = new t2(null, e4, t4, s2);
    this._tileInfo.updateTileInfo(r4, z.ExtrapolateOptions.POWER_OF_TWO), null == r4.extent || null != this._extent && !E(this._extent, r4.extent) || (this.info.missingTiles.push({
      data: r4,
      resolution: i4
    }), this.info.coveredArea -= l(r4.extent));
  }
};
var I = 0.18751;
var x3;
!function(e4) {
  e4[e4.ADDED = 0] = "ADDED", e4[e4.REMOVED = 1] = "REMOVED", e4[e4.UNCHANGED = 2] = "UNCHANGED";
}(x3 || (x3 = {}));

// ../../../node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorker.js
var w5 = class extends o2.EventedAccessor {
  constructor() {
    super(...arguments), this._isInitializing = true, this.remoteClient = null, this._whenSetup = L(), this._elevationAligner = i2(), this._elevationFilter = r(), this._symbologyCandidatesFetcher = n2(), this._updatingHandles = new h3(), this._editsUpdatingHandles = new h3(), this._pendingApplyEdits = /* @__PURE__ */ new Map(), this._alignPointsInFeatures = (e4, t4) => __async(this, null, function* () {
      const i4 = {
        query: e4
      }, r4 = yield this.remoteClient.invoke("alignElevation", i4, {
        signal: t4
      });
      return s(t4), r4;
    }), this._getSymbologyCandidates = (e4, t4) => __async(this, null, function* () {
      const i4 = {
        candidates: e4,
        spatialReference: this._spatialReference.toJSON()
      }, r4 = yield this.remoteClient.invoke("getSymbologyCandidates", i4, {
        signal: t4
      });
      return s(t4), r4;
    });
  }
  get updating() {
    return this.updatingExcludingEdits || this._editsUpdatingHandles.updating || this._featureFetcher.updating;
  }
  get updatingExcludingEdits() {
    return this._featureFetcher.updatingExcludingEdits || this._isInitializing || this._updatingHandles.updating;
  }
  destroy() {
    this._featureFetcher?.destroy(), this._queryEngine?.destroy(), this._featureStore?.clear();
  }
  setup(e4) {
    return __async(this, null, function* () {
      if (this.destroyed) return {
        result: {}
      };
      const {
        geometryType: t4,
        objectIdField: i4,
        timeInfo: s2,
        fieldsIndex: n4
      } = e4.serviceInfo, {
        hasZ: o5
      } = e4, l2 = f2.fromJSON(e4.spatialReference);
      this._spatialReference = l2, this._featureStore = new m(__spreadProps(__spreadValues({}, e4.serviceInfo), {
        hasZ: o5,
        hasM: false
      })), this._queryEngine = new $({
        spatialReference: e4.spatialReference,
        featureStore: this._featureStore,
        geometryType: t4,
        fieldsIndex: n4,
        hasZ: o5,
        hasM: false,
        objectIdField: i4,
        timeInfo: s2
      }), this._featureFetcher = new x2({
        store: new v({
          featureStore: this._featureStore
        }),
        url: e4.serviceInfo.url,
        objectIdField: e4.serviceInfo.objectIdField,
        globalIdField: e4.serviceInfo.globalIdField,
        capabilities: e4.serviceInfo.capabilities,
        spatialReference: l2,
        sourceSpatialReference: f2.fromJSON(e4.serviceInfo.spatialReference),
        customParameters: e4.configuration.customParameters
      });
      const d3 = "3d" === e4.configuration.viewType;
      return this._elevationAligner = i2(d3, {
        elevationInfo: null != e4.elevationInfo ? h2.fromJSON(e4.elevationInfo) : null,
        alignPointsInFeatures: this._alignPointsInFeatures
      }), this._elevationFilter = r(d3), this.addHandles([d2(() => this._featureFetcher.availability, (e5) => this.emit("notify-availability", {
        availability: e5
      }), C), d2(() => this.updating, () => this._notifyUpdating())]), this._whenSetup.resolve(), this._isInitializing = false, this.configure(e4.configuration);
    });
  }
  configure(e4) {
    return __async(this, null, function* () {
      return yield this._updatingHandles.addPromise(this._whenSetup.promise), this._updateFeatureFetcherConfiguration(e4), j3;
    });
  }
  setSuspended(e4, t4) {
    return __async(this, null, function* () {
      return yield this._updatingHandles.addPromise(this._whenSetup.promise), s(t4), this._featureFetcher.suspended = e4, j3;
    });
  }
  updateOutFields(e4, t4) {
    return __async(this, null, function* () {
      return yield this._updatingHandles.addPromise(this._whenSetup.promise), s(t4), this._featureFetcher.outFields = new Set(e4 ?? []), j3;
    });
  }
  fetchCandidates(e4, t4) {
    return __async(this, null, function* () {
      yield this._whenSetup.promise, s(t4);
      const i4 = b4(e4), r4 = t4?.signal, n4 = yield this._queryEngine.executeQueryForSnapping(i4, r4);
      s(r4);
      const a4 = yield this._elevationAligner.alignCandidates(n4.candidates, f2.fromJSON(e4.point.spatialReference) ?? f2.WGS84, r4);
      s(r4);
      const o5 = yield this._symbologyCandidatesFetcher.fetch(a4, r4);
      s(r4);
      const l2 = 0 === o5.length ? a4 : a4.concat(o5);
      return {
        result: {
          candidates: this._elevationFilter.filter(i4, l2)
        }
      };
    });
  }
  updateTiles(e4, t4) {
    return __async(this, null, function* () {
      return yield this._updatingHandles.addPromise(this._whenSetup.promise), s(t4), this._featureFetcher.tileSize = e4.tileSize, this._featureFetcher.tilesOfInterest = e4.tiles, this._featureFetcher.tileInfo = null != e4.tileInfo ? z.fromJSON(e4.tileInfo) : null, j3;
    });
  }
  refresh(e4, t4) {
    return __async(this, null, function* () {
      return yield this._updatingHandles.addPromise(this._whenSetup.promise), s(t4), this._featureFetcher.refresh(), j3;
    });
  }
  whenNotUpdating(e4, t4) {
    return __async(this, null, function* () {
      return yield this._updatingHandles.addPromise(this._whenSetup.promise), s(t4), yield w(() => !this.updatingExcludingEdits, t4), s(t4), j3;
    });
  }
  getDebugInfo(e4, t4) {
    return __async(this, null, function* () {
      return s(t4), {
        result: this._featureFetcher.debugInfo
      };
    });
  }
  beginApplyEdits(e4, t4) {
    return __async(this, null, function* () {
      this._updatingHandles.addPromise(this._whenSetup.promise), s(t4);
      const r4 = L();
      return this._pendingApplyEdits.set(e4.id, r4), this._featureFetcher.applyEdits(r4.promise), this._editsUpdatingHandles.addPromise(r4.promise), j3;
    });
  }
  endApplyEdits(e4, t4) {
    return __async(this, null, function* () {
      const i4 = this._pendingApplyEdits.get(e4.id);
      return i4 && i4.resolve(e4.edits), s(t4), j3;
    });
  }
  notifyElevationSourceChange(e4, t4) {
    return __async(this, null, function* () {
      return this._elevationAligner.notifyElevationSourceChange(), j3;
    });
  }
  notifySymbologyChange(e4, t4) {
    return __async(this, null, function* () {
      return this._symbologyCandidatesFetcher.notifySymbologyChange(), j3;
    });
  }
  setSymbologySnappingSupported(e4) {
    return __async(this, null, function* () {
      return this._symbologyCandidatesFetcher = n2(e4, this._getSymbologyCandidates), j3;
    });
  }
  _updateFeatureFetcherConfiguration(e4) {
    this._featureFetcher.filter = null != e4.filter ? b2.fromJSON(e4.filter) : null, this._featureFetcher.customParameters = e4.customParameters;
  }
  _notifyUpdating() {
    this.emit("notify-updating", {
      updating: this.updating
    });
  }
};
e3([y({
  readOnly: true
})], w5.prototype, "updating", null), e3([y({
  readOnly: true
})], w5.prototype, "updatingExcludingEdits", null), e3([y()], w5.prototype, "_isInitializing", void 0), w5 = e3([a2("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorker")], w5);
var I2 = w5;
function b4(e4) {
  if (!e4.filter) return __spreadProps(__spreadValues({}, e4), {
    query: {
      where: "1=1"
    }
  });
  const {
    distance: t4,
    units: i4,
    spatialRel: s2,
    where: r4,
    timeExtent: n4,
    objectIds: a4
  } = e4.filter, o5 = {
    geometry: e4.filter.geometry ? y2(e4.filter.geometry) : void 0,
    distance: t4,
    units: i4,
    spatialRel: s2,
    timeExtent: n4,
    objectIds: a4,
    where: r4 ?? "1=1"
  };
  return __spreadProps(__spreadValues({}, e4), {
    query: o5
  });
}
var j3 = {
  result: {}
};
export {
  I2 as default
};
//# sourceMappingURL=FeatureServiceSnappingSourceWorker-FZOBNJYU.js.map
