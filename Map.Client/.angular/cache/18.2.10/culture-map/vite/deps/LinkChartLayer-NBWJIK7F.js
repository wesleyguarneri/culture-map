import {
  D,
  I,
  M,
  T2 as T,
  ae,
  b,
  h,
  w as w2
} from "./chunk-M27RJZHW.js";
import "./chunk-AX5IV6EC.js";
import {
  R
} from "./chunk-EMTRPOGO.js";
import "./chunk-CI7E4T7M.js";
import "./chunk-7PCL3GUC.js";
import "./chunk-ROATEOHC.js";
import "./chunk-BIWDYV6F.js";
import "./chunk-4MXR7W7N.js";
import "./chunk-6UYQMUGI.js";
import "./chunk-D3XZUGMN.js";
import "./chunk-YFQ32AQX.js";
import "./chunk-L4AYSXFJ.js";
import "./chunk-POQ3T5EH.js";
import "./chunk-LPEFONL3.js";
import "./chunk-SSMSHZ2C.js";
import "./chunk-DM4WHMQY.js";
import "./chunk-DON3YPGT.js";
import {
  ot
} from "./chunk-C7NRYPDG.js";
import "./chunk-Z3GMSC63.js";
import "./chunk-F35MWZH7.js";
import "./chunk-ED7UGR2X.js";
import "./chunk-YA5CTHMT.js";
import "./chunk-4QBFFLOC.js";
import "./chunk-O437BSYE.js";
import {
  e as e2
} from "./chunk-YZNT6QWD.js";
import "./chunk-YVOGHYE3.js";
import "./chunk-IBOZJLSO.js";
import "./chunk-USSQX44O.js";
import "./chunk-OTI4DGZ5.js";
import "./chunk-KQDYTHCF.js";
import "./chunk-TR6FCWXY.js";
import "./chunk-TROPJVOL.js";
import "./chunk-JKHDI77M.js";
import "./chunk-3AY5EJVP.js";
import "./chunk-XQCKIDQO.js";
import "./chunk-BNK4CEA6.js";
import "./chunk-6LDLRQX4.js";
import "./chunk-Z4YAQ5JI.js";
import "./chunk-K2XCQKCC.js";
import "./chunk-AJS4B62I.js";
import "./chunk-S5EXT7FA.js";
import "./chunk-YFOAET4H.js";
import "./chunk-5U4TBXYS.js";
import "./chunk-6WG22V46.js";
import "./chunk-OOGIXDXG.js";
import "./chunk-JFYQTYD3.js";
import "./chunk-KDJZAYOF.js";
import "./chunk-5453A3C5.js";
import "./chunk-HCFDI7IX.js";
import "./chunk-AQJS6F3O.js";
import "./chunk-WUB6LJVL.js";
import "./chunk-QXSES7JX.js";
import "./chunk-5YIMTGEC.js";
import "./chunk-YPU2P4KO.js";
import "./chunk-UFVMJL32.js";
import "./chunk-2SMFPIRI.js";
import "./chunk-2GMKFOCL.js";
import "./chunk-ZR5BOILP.js";
import "./chunk-QCBC3RJX.js";
import "./chunk-6XGV55XZ.js";
import "./chunk-HOH445RO.js";
import "./chunk-63QCTVYB.js";
import "./chunk-U74WRHVJ.js";
import "./chunk-TCPN7AEH.js";
import "./chunk-TRSGUVSM.js";
import "./chunk-U3MA63JX.js";
import "./chunk-WYKKCLBI.js";
import "./chunk-PFMGJTQM.js";
import "./chunk-Q7SRMLJZ.js";
import "./chunk-PQ4T66BG.js";
import "./chunk-SWPHGZYB.js";
import "./chunk-DWASPXVI.js";
import "./chunk-TNWXOQKO.js";
import "./chunk-MAO5BVLA.js";
import "./chunk-T2S5VXNP.js";
import "./chunk-4U5GUJRA.js";
import "./chunk-7KRERHHR.js";
import "./chunk-T4AP6CTC.js";
import "./chunk-HD65DNIO.js";
import "./chunk-4KWLMXIA.js";
import "./chunk-BIUXKPKA.js";
import "./chunk-N6TJI25E.js";
import "./chunk-634JLXD4.js";
import "./chunk-Y3EDGYWG.js";
import "./chunk-UF6JOUSJ.js";
import "./chunk-T5JGQSO3.js";
import "./chunk-CIW3KHOW.js";
import "./chunk-J55F4AC2.js";
import "./chunk-IQLBZKUD.js";
import "./chunk-7MZZCQ64.js";
import "./chunk-LNRZHZOQ.js";
import "./chunk-DI6VABAK.js";
import "./chunk-5EBAJR7X.js";
import "./chunk-5JA2JHV3.js";
import "./chunk-FUKSTKFU.js";
import "./chunk-MIQZ6UDY.js";
import "./chunk-JOJZ6YC5.js";
import "./chunk-L4TOCXR5.js";
import "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import "./chunk-7WP676SE.js";
import "./chunk-SGSUM5YO.js";
import "./chunk-SG5TCCCK.js";
import "./chunk-6A7CWJED.js";
import "./chunk-DUTZNK67.js";
import "./chunk-IN6BQCWS.js";
import "./chunk-JM7HAEY6.js";
import "./chunk-DOK4SACJ.js";
import {
  l
} from "./chunk-OUKUASAF.js";
import "./chunk-V5RMUGJJ.js";
import "./chunk-D2NB6D6N.js";
import {
  t
} from "./chunk-UWJIHV6Q.js";
import "./chunk-DSEUCBVP.js";
import "./chunk-UPDWQH75.js";
import "./chunk-RXWBJSJ5.js";
import {
  f
} from "./chunk-M2NS3MSU.js";
import "./chunk-HMNBB7ED.js";
import "./chunk-3RRMLFFN.js";
import "./chunk-DR5TVNEL.js";
import "./chunk-HT2T6PUB.js";
import "./chunk-K64AAM77.js";
import "./chunk-6EUVKE22.js";
import "./chunk-A3NNJ7XA.js";
import "./chunk-OKJHJ3CY.js";
import "./chunk-XTVPEVHA.js";
import "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import "./chunk-DZALMCYL.js";
import "./chunk-K226GFDN.js";
import "./chunk-4ZZRP4MA.js";
import "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-XWXBNAOW.js";
import "./chunk-GWC3DAGP.js";
import "./chunk-EODIWR2E.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-FYAEQPUY.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-7RMVJCDW.js";
import {
  m2 as m
} from "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import {
  w
} from "./chunk-NYQ5CYNR.js";
import {
  _
} from "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import "./chunk-AXVPJBVW.js";
import "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import {
  n as n2
} from "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import "./chunk-6WHTZNUH.js";
import {
  V
} from "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import "./chunk-XNUH25NY.js";
import "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e
} from "./chunk-4Z5SGKRM.js";
import "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3 as a,
  r2 as r
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import {
  s as s2
} from "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-WYIDUUN2.js";
import "./chunk-DXLOWWK7.js";
import {
  __async,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/layers/knowledgeGraph/IdealEdgeLengthTypeOptions.js
var e3;
!function(e5) {
  e5.MULTIPLIER = "multiplier", e5.ABSOLUTE = "absoluteValue";
}(e3 || (e3 = {}));

// ../../../node_modules/@arcgis/core/libs/linkchartlayout/LinkChartLayout.js
var e4;
var r2 = null;
function n3() {
  return e4 || (e4 = import("./lclayout-AZV43NRJ.js").then((t2) => t2.l).then(({
    default: e5
  }) => e5({
    locateFile: (e6) => n2(`esri/libs/linkchartlayout/${e6}`)
  })).then((t2) => {
    s3(t2);
  }), e4);
}
function s3(t2) {
  r2 = t2;
}
var u;
var o;
function l2(t2, e5, a2, n4, s4, u2) {
  const o2 = a2.length, l3 = s4.length, y3 = Float64Array.BYTES_PER_ELEMENT, i2 = Uint32Array.BYTES_PER_ELEMENT, c2 = Uint8Array.BYTES_PER_ELEMENT, E2 = 16, f3 = E2 + o2 * (c2 + 2 * y3) + l3 * (2 * i2), p2 = r2._malloc(f3);
  try {
    const c3 = p2 + E2 - p2 % E2, f4 = c3 + o2 * y3, A2 = f4 + o2 * y3, _3 = A2 + l3 * i2, P3 = _3 + l3 * i2, b3 = () => [r2.HEAPF64.subarray(c3 >> 3, (c3 >> 3) + o2), r2.HEAPF64.subarray(f4 >> 3, (f4 >> 3) + o2), r2.HEAPU32.subarray(A2 >> 2, (A2 >> 2) + l3), r2.HEAPU32.subarray(_3 >> 2, (_3 >> 2) + l3), r2.HEAPU8.subarray(P3, P3 + o2)], [g2, H2, L, h2, d] = b3();
    g2.set(a2), H2.set(n4), L.set(s4), h2.set(u2), d.set(e5);
    let C = t2(o2, P3, c3, f4, l3, A2, _3), F = null, m2 = null;
    if (C) {
      const t3 = r2.getLayoutLinksTypes(), e6 = r2.getLayoutLinksVerticesEndIndices(), a3 = r2.getLayoutLinksVertices(), n5 = r2.countLayoutLinksVertices();
      !l3 || t3 && e6 ? n5 && !a3 ? C = false : (F = {
        types: new Uint8Array(r2.HEAPU8.subarray(t3, t3 + l3)),
        vertexEndIndex: new Uint32Array(r2.HEAPU32.subarray(e6 >> 2, (e6 >> 2) + l3)),
        vertices: new Float64Array(r2.HEAPF64.subarray(a3 >> 3, (a3 >> 3) + 2 * n5))
      }, m2 = r2.getAuxiliaryGraphicElements()) : C = false;
    }
    const [R2, T2, U, B, v] = b3();
    return a2.set(R2), n4.set(T2), s4.set(U), u2.set(B), e5.set(v), {
      success: C,
      links: F,
      graphics: m2
    };
  } finally {
    r2._free(p2), r2.cleanupLayout();
  }
}
!function(t2) {
  t2[t2.None = 0] = "None", t2[t2.IsMovable = 1] = "IsMovable", t2[t2.IsGeographic = 2] = "IsGeographic", t2[t2.IsRoot = 4] = "IsRoot";
}(u || (u = {})), function(t2) {
  t2[t2.Regular = 0] = "Regular", t2[t2.Orthogonal = 1] = "Orthogonal", t2[t2.Curved = 2] = "Curved", t2[t2.Recursive = 3] = "Recursive";
}(o || (o = {}));
var y2 = 2;
var i = 1;
var c = -1;
var E;
var f2;
var p;
var A;
var _2;
var P;
var b2;
var g;
var H;
!function(t2) {
  function e5() {
    return r2.getMinIdealEdgeLength();
  }
  function a2(t3, e6, a3, n4, s4, u2 = y2, o2 = i, E2 = c) {
    return l2((t4, e7, a4, n5, s5, l3, y3) => r2.applyForceDirectedLayout(t4, e7, a4, n5, s5, l3, y3, u2, o2, E2), t3, e6, a3, n4, s4);
  }
  t2.getMinIdealEdgeLength = e5, t2.apply = a2;
}(E || (E = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4, u2 = y2, o2 = i, E2 = c) {
    return l2((t4, e7, a3, n5, s5, l3, y3) => r2.applyCommunityLayout(t4, e7, a3, n5, s5, l3, y3, u2, o2, E2), t3, e6, a2, n4, s4);
  }
  t2.apply = e5;
}(f2 || (f2 = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4) {
    return l2(r2.applySimpleLayout, t3, e6, a2, n4, s4);
  }
  t2.apply = e5;
}(p || (p = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4) {
    return l2(r2.applyHierarchicalLayout, t3, e6, a2, n4, s4);
  }
  t2.apply = e5;
}(A || (A = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4) {
    return l2(r2.applyRadialTreeLayout, t3, e6, a2, n4, s4);
  }
  t2.apply = e5;
}(_2 || (_2 = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4) {
    return l2(r2.applySmartTreeLayout, t3, e6, a2, n4, s4);
  }
  t2.apply = e5;
}(P || (P = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4, u2, o2, y3, i2) {
    return l2((t4, e7, a3, u3, o3, l3, c2) => {
      if (n4.length !== t4) return false;
      if (s4.length !== t4) return false;
      if (y3.length !== o3) return false;
      if (i2.length !== o3) return false;
      const E2 = Float64Array.BYTES_PER_ELEMENT, f3 = 16, p2 = r2._malloc(f3 + t4 * E2), A2 = r2._malloc(f3 + t4 * E2), _3 = r2._malloc(f3 + o3 * E2), P3 = r2._malloc(f3 + o3 * E2), b3 = p2 + f3 - p2 % f3, g2 = A2 + f3 - A2 % f3, H2 = _3 + f3 - _3 % f3, L = P3 + f3 - P3 % f3;
      try {
        return r2.HEAPF64.subarray(b3 >> 3, (b3 >> 3) + t4).set(n4), r2.HEAPF64.subarray(g2 >> 3, (g2 >> 3) + t4).set(s4), r2.HEAPF64.subarray(H2 >> 3, (H2 >> 3) + o3).set(y3), r2.HEAPF64.subarray(L >> 3, (L >> 3) + o3).set(i2), r2.applyChronologicalLayout(t4, e7, a3, u3, b3, g2, o3, l3, c2, H2, L);
      } finally {
        r2._free(p2), r2._free(A2), r2._free(_3), r2._free(P3);
      }
    }, t3, e6, a2, u2, o2);
  }
  t2.apply = e5;
}(b2 || (b2 = {})), function(t2) {
  t2[t2.Undirected = 0] = "Undirected", t2[t2.Directed = 1] = "Directed", t2[t2.Reversed = 2] = "Reversed";
}(g || (g = {})), function(t2) {
  t2[t2.ByCC_Raw = 0] = "ByCC_Raw", t2[t2.ByCC_NormalizeGlobally = 1] = "ByCC_NormalizeGlobally", t2[t2.ByCC_NormalizeByCC = 2] = "ByCC_NormalizeByCC";
}(H || (H = {}));

// ../../../node_modules/@arcgis/core/layers/LinkChartLayer.js
var j = class extends l(t(f)) {
  constructor(e5) {
    if (super(e5), this.dataPreloadedInLocalCache = false, this.defaultLinkChartConfig = null, this._currentLinkChartConfig = {
      layoutMode: "RADIAL_TREE"
    }, this._graphTypeLookup = /* @__PURE__ */ new Map(), this.dataManager = null, this.knowledgeGraph = null, this.layers = new V(), this.entityLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.relationshipLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.linkChartExtent = new w({
      xmin: -1e-7,
      ymin: -1e-7,
      xmax: 1e-7,
      ymax: 1e-7
    }), this.memberEntityTypes = null, this.memberRelationshipTypes = null, this.sublayerIdsCache = /* @__PURE__ */ new Map(), this.tables = new V(), this.type = "link-chart", this._originalInclusionList = e5.inclusionModeDefinition, e5.dataPreloadedInLocalCache && !e5.inclusionModeDefinition) throw new s("knowledge-graph:linkchart-layer-constructor", "If creating a link chart composite layer and configured that data is already loaded in the cache, you must specify an inclusion list so the Composite Layer knows what records belong to it");
  }
  normalizeCtorArgs(e5) {
    return {
      url: e5.url,
      title: e5.title,
      dataPreloadedInLocalCache: e5.dataPreloadedInLocalCache,
      defaultLinkChartConfig: e5.defaultLinkChartConfig
    };
  }
  _initializeLayerProperties(e5) {
    if (!this.title && this.url) {
      const e6 = this.url.split("/");
      this.title = e6[e6.length - 2];
    }
    const t2 = /* @__PURE__ */ new Set();
    let n4 = [], s4 = [];
    if (e5.inclusionModeDefinition && (!e5.inclusionModeDefinition.namedTypeDefinitions || e5.inclusionModeDefinition.namedTypeDefinitions.size < 1)) throw new s("knowledge-graph:composite-layer-constructor", "If an explicit inclusion definition is defined, at least one namedTypeDefinition must also be defined");
    e5.knowledgeGraph.dataModel.entityTypes?.forEach((e6) => {
      e6.name && this._graphTypeLookup.set(e6.name, e6);
    }), e5.knowledgeGraph.dataModel.relationshipTypes?.forEach((e6) => {
      e6.name && this._graphTypeLookup.set(e6.name, e6);
    }), e5.inclusionModeDefinition?.generateAllSublayers ? (n4 = e5.knowledgeGraph.dataModel.entityTypes ?? [], s4 = e5.knowledgeGraph.dataModel.relationshipTypes ?? []) : e5.inclusionModeDefinition?.namedTypeDefinitions && e5.inclusionModeDefinition?.namedTypeDefinitions.size > 0 ? e5.inclusionModeDefinition?.namedTypeDefinitions.forEach((a2, o3) => {
      const r3 = this._graphTypeLookup.get(o3);
      if (!r3) return n.getLogger(this).warn(`A named type, ${o3}, was in the inclusion list that wasn't in the data model and will be removed`), void e5.inclusionModeDefinition?.namedTypeDefinitions.delete(o3);
      "relationship" === r3.type ? t2.has(o3) || (t2.add(o3), s4.push(r3)) : "entity" === r3.type ? t2.has(o3) || (t2.add(o3), n4.push(r3)) : (n.getLogger(this).warn(`A named type, ${o3}, was in the inclusion list that wasn't properly modeled and will be removed`), e5.inclusionModeDefinition?.namedTypeDefinitions.delete(o3));
    }) : (n4 = e5.knowledgeGraph.dataModel.entityTypes ?? [], s4 = e5.knowledgeGraph.dataModel.relationshipTypes ?? []);
    const o2 = new M({
      knowledgeGraph: e5.knowledgeGraph,
      inclusionModeDefinition: e5.inclusionModeDefinition
    });
    this.knowledgeGraph = e5.knowledgeGraph, this.memberEntityTypes = n4, this.memberRelationshipTypes = s4, this.dataManager = o2;
  }
  load(e5) {
    return this.addResolvingPromise(new Promise((t2) => {
      R(this.url).then((a2) => {
        if (this._initializeLayerProperties({
          knowledgeGraph: a2,
          inclusionModeDefinition: this._originalInclusionList
        }), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.size || (this.dataManager.inclusionModeDefinition = {
          generateAllSublayers: false,
          namedTypeDefinitions: /* @__PURE__ */ new Map()
        }, this.dataManager.knowledgeGraph.dataModel.entityTypes?.forEach((e6) => {
          e6.name && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(e6.name, {
            useAllData: true
          });
        }), this.dataManager.knowledgeGraph.dataModel.relationshipTypes?.forEach((e6) => {
          e6.name && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(e6.name, {
            useAllData: true
          });
        })), this.dataPreloadedInLocalCache) this.loadLayerAssumingLocalCache(), this.dataManager.inclusionModeDefinition && (this.dataManager.inclusionModeDefinition.generateAllSublayers = false), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach((e6) => {
          e6.useAllData = false, e6.members?.forEach((e7) => {
            let t3;
            t3 = e7.linkChartLocation instanceof e2 ? e7.linkChartLocation : e7.linkChartLocation ? ot(e7.linkChartLocation) : null, t3 && 2 === t3.coords.length && 0 === t3.lengths.length ? this.entityLinkChartDiagramLookup.set(e7.id, t3) : this.relationshipLinkChartDiagramLookup.set(e7.id, t3);
          }), this.addResolvingPromise(this._initializeDiagram().then(() => __async(this, null, function* () {
            this.layers.forEach((e7) => __async(this, null, function* () {
              yield e7.refreshCachedQueryEngine();
            })), this.tables.forEach((e7) => __async(this, null, function* () {
              yield e7.refreshCachedQueryEngine();
            }));
          })));
        });
        else {
          const t3 = "GEOGRAPHIC" === this.defaultLinkChartConfig?.layoutMode;
          this.addResolvingPromise(this.dataManager.refreshCacheContent(void 0, false, t3, true).then(() => __async(this, null, function* () {
            s2(e5);
            const t4 = [], a3 = [];
            this.loadLayerAssumingLocalCache(), this.dataManager.inclusionModeDefinition && (this.dataManager.inclusionModeDefinition.generateAllSublayers = false, this.dataManager.inclusionModeDefinition.namedTypeDefinitions.forEach((e6) => {
              e6.useAllData = false;
            })), yield this._initializeDiagram(), this.layers.forEach((e6) => {
              a3.push(e6.refreshCachedQueryEngine()), t4.push(new Promise((t5) => {
                e6.on("layerview-create", () => {
                  t5(null);
                });
              }));
            }), this.tables.forEach((e6) => {
              a3.push(e6.refreshCachedQueryEngine());
            }), yield Promise.all(a3);
          })));
        }
        t2(null);
      });
    })), Promise.resolve(this);
  }
  addRecords(e5, t2) {
    return __async(this, null, function* () {
      let a2 = [];
      t2?.cascadeAddRelationshipEndNodes && this.dataManager.knowledgeGraph.dataModel && (a2 = yield h(e5, this.dataManager.knowledgeGraph));
      const i2 = e5.concat(a2).filter((e6) => !this.sublayerIdsCache.get(e6.typeName)?.has(e6.id));
      yield this._handleNewRecords(i2);
    });
  }
  removeRecords(_0) {
    return __async(this, arguments, function* (e5, {
      cascadeRemoveRelationships: t2 = true,
      recalculateLayout: a2 = false
    } = {
      cascadeRemoveRelationships: true,
      recalculateLayout: false
    }) {
      let i2 = [];
      for (const s4 of e5) false === this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(s4.typeName)?.useAllData && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(s4.typeName)?.members?.has(s4.id) && i2.push(s4);
      if (t2) {
        const e6 = /* @__PURE__ */ new Set(), t3 = [];
        for (const a3 of i2) if (this.dataManager.nodeConnectionsLookup.has(a3.id)) for (const t4 of this.dataManager.nodeConnectionsLookup.get(a3.id)) e6.add(t4);
        for (const a3 of e6) if (this.dataManager.memberIdTypeLookup.has(a3)) for (const e7 of this.dataManager.memberIdTypeLookup.get(a3)) this.dataManager.relationshipTypeNames.has(e7) && t3.push({
          id: a3,
          typeName: e7
        });
        i2 = i2.concat(t3);
      }
      this.dataManager.removeFromLayer(i2);
      for (const s4 of i2) this.sublayerIdsCache.get(s4.typeName)?.delete(s4.id), this.dataManager.relationshipTypeNames.has(s4.typeName) ? this.relationshipLinkChartDiagramLookup.delete(s4.id) : this.entityLinkChartDiagramLookup.delete(s4.id);
      a2 && (yield this.calculateLinkChartLayout(this._currentLinkChartConfig.layoutMode, this._currentLinkChartConfig.layoutOptions));
      const n4 = [];
      return this.layers.forEach((e6) => {
        n4.push(e6.refreshCachedQueryEngine());
      }), yield Promise.all(n4), this._refreshNamedTypes(), i2;
    });
  }
  expand(e5, t2) {
    return __async(this, null, function* () {
      const a2 = yield this.dataManager.getConnectedRecordIds(e5, t2), i2 = a2.filter((e6) => !this.sublayerIdsCache.get(e6.typeName)?.has(e6.id));
      return yield this._handleNewRecords(a2), {
        records: i2
      };
    });
  }
  loadLayerAssumingLocalCache() {
    this.memberRelationshipTypes.forEach((e5) => {
      const t2 = new ae({
        objectType: e5,
        parentCompositeLayer: this,
        graphType: "relationship",
        title: e5.name
      });
      t2.geometryType ? this.layers.push(t2) : this.tables.push(t2), this.dataManager.sublayerCaches.has(e5.name) || this.dataManager.sublayerCaches.set(e5.name, /* @__PURE__ */ new Map());
    }), this.memberEntityTypes.forEach((e5) => {
      const t2 = new ae({
        objectType: e5,
        parentCompositeLayer: this,
        graphType: "entity",
        title: e5.name
      });
      t2.geometryType ? this.layers.push(t2) : this.tables.push(t2), this.dataManager.sublayerCaches.has(e5.name) || this.dataManager.sublayerCaches.set(e5.name, /* @__PURE__ */ new Map());
    }), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach((e5, t2) => {
      const a2 = r(this.sublayerIdsCache, t2, () => /* @__PURE__ */ new Set());
      e5.members?.forEach((e6) => {
        if (a2.add(e6.id), e6.linkChartLocation) if (e6.linkChartLocation instanceof e2) this.dataManager.relationshipTypeNames.has(t2) ? this.relationshipLinkChartDiagramLookup.set(e6.id, e6.linkChartLocation) : this.entityLinkChartDiagramLookup.set(e6.id, e6.linkChartLocation);
        else {
          const a3 = ot(e6.linkChartLocation);
          this.dataManager.relationshipTypeNames.has(t2) ? this.relationshipLinkChartDiagramLookup.set(e6.id, e6.linkChartLocation ? a3 : null) : this.entityLinkChartDiagramLookup.set(e6.id, e6.linkChartLocation ? a3 : null);
        }
      });
    });
  }
  calculateLinkChartLayout(e5 = "RADIAL_TREE", t2) {
    return __async(this, null, function* () {
      const n4 = [], s4 = [], o2 = [];
      this.dataManager.sublayerCaches.forEach((e6, t3) => {
        this.dataManager.entityTypeNames.has(t3) ? e6.forEach((e7) => {
          n4.push({
            typeName: t3,
            feature: e7
          });
        }) : this.dataManager.relationshipTypeNames.has(t3) && e6.forEach((e7) => {
          s4.push({
            typeName: t3,
            feature: e7
          });
        });
      }), this.entityLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.relationshipLinkChartDiagramLookup = /* @__PURE__ */ new Map();
      const r3 = /* @__PURE__ */ new Map(), h2 = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map(), p2 = /* @__PURE__ */ new Map(), u2 = new Uint8Array(n4.length), L = new Float64Array(n4.length), C = new Float64Array(n4.length), k = new Uint32Array(s4.length), M2 = new Uint32Array(s4.length), I2 = [], j2 = "FORCE_DIRECTED", P3 = new w({
        xmin: -1e-7,
        ymin: -1e-7,
        xmax: 1e-7,
        ymax: 1e-7
      });
      let S, O = "FORCE_DIRECTED", z = 0, U = 0;
      switch (O = "GEOGRAPHIC" === e5 ? j2 : e5, O) {
        case "FORCE_DIRECTED":
          S = E.apply;
          break;
        case "COMMUNITY":
          S = f2.apply;
          break;
        case "HIERARCHICAL":
          S = A.apply;
          break;
        case "RADIAL_TREE":
          S = _2.apply;
          break;
        case "SMART_TREE":
          S = P.apply;
          break;
        default:
          S = p.apply;
      }
      n4.forEach(({
        typeName: a2,
        feature: i2
      }) => {
        if (t2?.lockedNodeLocations?.has(i2.attributes[w2])) {
          "GEOGRAPHIC" === e5 && this.dataManager.geographicLookup.has(a2) ? u2[z] = u.IsGeographic : u2[z] = u.None;
          const n5 = t2.lockedNodeLocations.get(i2.attributes[w2]);
          L[z] = n5.x, C[z] = n5.y;
        } else if ("GEOGRAPHIC" === e5 && this.dataManager.geographicLookup.has(a2)) {
          u2[z] = u.IsGeographic;
          let e6 = null;
          const t3 = i2.attributes[this.dataManager.geographicLookup.get(a2).name], n5 = this.dataManager.geographicLookup.get(a2)?.geometryType;
          switch (n5) {
            case "esriGeometryPoint":
              L[z] = t3?.x, C[z] = t3?.y;
              break;
            case "esriGeometryPolygon":
              e6 = t3?.centroid, null != e6?.x && null != e6?.y ? (L[z] = e6.x, C[z] = e6.y) : u2[z] = u.IsMovable;
              break;
            case "esriGeometryPolyline":
            case "esriGeometryMultipoint":
              e6 = t3?.extent?.center, null != e6?.x && null != e6?.y ? (L[z] = e6.x, C[z] = e6.y) : u2[z] = u.IsMovable;
              break;
            default:
              u2[z] = u.IsMovable;
          }
          (null == L[z] || null == C[z] || Number.isNaN(L[z]) || Number.isNaN(C[z])) && (u2[z] = u.IsMovable, L[z] = 0, C[z] = 0);
        } else u2[z] = u.IsMovable, L[z] = 0, C[z] = 0;
        p2.set(i2.attributes[w2], z), I2[z] = {
          feature: i2,
          typeName: a2
        }, z++;
      });
      let H2 = false;
      const B = /* @__PURE__ */ new Map();
      s4.forEach((e6) => {
        const t3 = e6.feature.attributes[b], a2 = e6.feature.attributes[T], i2 = p2.get(t3), n5 = p2.get(a2);
        if (void 0 !== i2 && void 0 !== n5) {
          const s5 = t3 + "-" + a2, r4 = B.get(s5), h3 = r4?.has(e6.typeName);
          h3 || (k[U] = i2, M2[U] = n5, void 0 === r4 ? B.set(s5, /* @__PURE__ */ new Map([[e6.typeName, U]])) : r4.set(e6.typeName, U), U++), o2.push(e6);
        } else H2 = true, this.relationshipLinkChartDiagramLookup.set(t3, null);
      }), H2 && n.getLogger(this).warn("A relationship is a member of this layer that has either origin or destination entity nodes that are not members. The diagram geometry will be set to null");
      const F = this._validateLayoutSettings(e5, t2), Q = this._convertLayoutSettingsToCalculationSettings(F);
      yield n3();
      const {
        success: K,
        links: Y
      } = S(u2, L, C, k.subarray(0, U), M2.subarray(0, U), Q.computationBudgetTime, Q.idealEdgeLengthMultiplier, Q.repulsionRadiusMultiplier);
      if (!K) throw new s("knowledge-graph:layout-failed", "Attempting to arrange the records in the specified layout failed");
      for (let a2 = 0; a2 < I2.length; a2++) {
        if (C[a2] > 84.9999 ? C[a2] = 84.9999 : C[a2] < -84.9999 && (C[a2] = -84.9999), L[a2] > 179.9999 ? L[a2] = 179.9999 : L[a2] < -179.9999 && (L[a2] = -179.9999), I2[a2].feature.attributes[D] = new _(L[a2], C[a2]), r3.has(I2[a2].typeName)) {
          const e7 = r3.get(I2[a2].typeName);
          e7?.set(I2[a2].feature.attributes[w2], I2[a2].feature);
        } else {
          const e7 = /* @__PURE__ */ new Map();
          e7.set(I2[a2].feature.attributes[w2], I2[a2].feature), r3.set(I2[a2].typeName, e7);
        }
        d.set(I2[a2].feature.attributes[w2], I2[a2].feature);
        const e6 = ot(I2[a2].feature.attributes[D]);
        this.entityLinkChartDiagramLookup.set(I2[a2].feature.attributes[w2], I2[a2].feature.attributes[D] ? e6 : null), I2[a2].feature.attributes[D].x < P3.xmin && (P3.xmin = I2[a2].feature.attributes[D].x), I2[a2].feature.attributes[D].x > P3.xmax && (P3.xmax = I2[a2].feature.attributes[D].x), I2[a2].feature.attributes[D].y < P3.ymin && (P3.ymin = I2[a2].feature.attributes[D].y), I2[a2].feature.attributes[D].y > P3.ymax && (P3.ymax = I2[a2].feature.attributes[D].y);
      }
      if (this.linkChartExtent.xmin = P3.xmin, this.linkChartExtent.xmax = P3.xmax, this.linkChartExtent.ymin = P3.ymin, this.linkChartExtent.ymax = P3.ymax, !Y) throw new s("knowledge-graph:layout-failed", "Attempting to retrieve link geometry from diagram engine failed");
      const $ = /* @__PURE__ */ new Map(), W = /* @__PURE__ */ new Map(), q = /* @__PURE__ */ new Map(), J = /* @__PURE__ */ new Set();
      for (let a2 = 0; a2 < o2.length; a2++) {
        const e6 = [], t3 = o2[a2], n5 = t3.feature.attributes[b], s5 = t3.feature.attributes[T], r4 = n5 + "-" + s5, u3 = B.get(r4).get(t3.typeName), f3 = 0 === u3 ? 0 : Y?.vertexEndIndex[u3 - 1];
        if (!J.has(u3)) {
          if (J.add(u3), Y.types[u3] === o.Recursive) {
            const t5 = [Y.vertices[2 * f3], Y.vertices[2 * f3 + 1]], a4 = [Y.vertices[2 * (f3 + 1)], Y.vertices[2 * (f3 + 1) + 1]], i2 = [0.5 * (t5[0] + a4[0]), 0.5 * (t5[1] + a4[1])], n6 = [i2[0] - t5[0], i2[1] - t5[1]], s6 = [i2[0] + n6[1], i2[1] - n6[0]], o3 = [i2[0] - n6[1], i2[1] + n6[0]];
            e6.push(t5), e6.push(s6), e6.push(a4), e6.push(o3), e6.push(t5);
          } else {
            if (Y.types[u3] !== o.Regular) {
              n.getLogger(this).warn("A relationship generated an unsupported link geometry type.  It will not be rendered");
              continue;
            }
            for (let t5 = f3; t5 < Y.vertexEndIndex[u3]; t5++) e6.push([Y.vertices[2 * t5], Y.vertices[2 * t5 + 1]]);
          }
          const t4 = I2[p2.get(n5)]?.feature.attributes[D], a3 = I2[p2.get(s5)]?.feature.attributes[D];
          e6[0][0] === t4.x && e6[0][1] === t4.y || (e6[0] = [t4.x, t4.y]), e6[e6.length - 1][0] === a3.x && e6[e6.length - 1][1] === a3.y || (e6[e6.length - 1] = [a3.x, a3.y]);
          for (let i2 = 1; i2 < e6.length - 1; i2++) e6[i2][1] > 85.5 ? e6[i2][1] = 85.5 : e6[i2][1] < -85.5 && (e6[i2][1] = -85.5), e6[i2][0] > 179.9999 ? e6[i2][0] = 179.9999 : e6[i2][0] < -179.9999 && (e6[i2][0] = -179.9999);
          $.has(r4) ? $.get(r4).push(e6) : $.set(r4, [e6]);
        }
        const L2 = $.get(r4);
        W.has(r4) || (W.set(r4, /* @__PURE__ */ new Map()), q.set(r4, /* @__PURE__ */ new Map()));
        const C2 = W.get(r4), k2 = q.get(r4);
        C2.has(t3.typeName) || (C2.set(t3.typeName, L2.shift()), k2.set(t3.typeName, 0));
        const M3 = C2.get(t3.typeName);
        k2.set(t3.typeName, k2.get(t3.typeName) + 1);
        const w3 = new m({
          paths: M3
        });
        if (t3.feature.attributes[D] = w3, h2.has(t3.typeName)) {
          const e7 = h2.get(t3.typeName);
          e7?.set(t3.feature.attributes[w2], t3.feature);
        } else {
          const e7 = /* @__PURE__ */ new Map();
          e7.set(t3.feature.attributes[w2], t3.feature), h2.set(t3.typeName, e7);
        }
        d.set(t3.feature.attributes[w2], t3.feature);
        const b3 = ot(t3.feature.attributes[D]);
        this.relationshipLinkChartDiagramLookup.set(t3.feature.attributes[w2], t3.feature.attributes[D] ? b3 : null);
      }
      for (const a2 of o2) a2.feature.attributes[I] = q.get(a2.feature.attributes[b] + "-" + a2.feature.attributes[T])?.get(a2.typeName) ?? null;
      return this._currentLinkChartConfig = {
        layoutMode: e5,
        layoutOptions: F
      }, {
        nodes: r3,
        links: h2,
        idMap: d
      };
    });
  }
  applyNewLinkChartLayout(e5 = "RADIAL_TREE", t2) {
    return __async(this, null, function* () {
      const a2 = [];
      yield this.calculateLinkChartLayout(e5, t2), this.layers.forEach((e6) => {
        a2.push(e6.refreshCachedQueryEngine());
      }), yield Promise.all(a2), this._refreshNamedTypes();
    });
  }
  getCurrentNodeLocations() {
    const e5 = /* @__PURE__ */ new Map();
    return this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((t2) => {
      t2?.members?.forEach((t3) => {
        const a2 = t3.linkChartLocation;
        let i2;
        const n4 = t3.id;
        a2 && (i2 = "x" in a2 ? {
          x: a2.x,
          y: a2.y
        } : {
          x: a2.coords[0],
          y: a2.coords[1]
        }, e5.set(n4, new _({
          x: i2.x,
          y: i2.y
        })));
      });
    }), e5;
  }
  synchronizeInclusionListWithCache() {
    return __async(this, null, function* () {
      return new Promise((e5) => {
        this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach((e6, t2) => {
          if (e6.useAllData = false, e6.members && e6.members.size > 0) {
            if (!this.dataManager.sublayerCaches.get(t2)) return;
            const a2 = new Set(Array.from(this.dataManager.sublayerCaches.get(t2).keys()));
            Array.from(e6.members.keys()).filter((e7) => !a2.has(e7)).forEach((t3) => {
              e6.members?.delete(t3);
            });
          }
        }), e5();
      });
    });
  }
  refreshLinkChartCache(e5) {
    return __async(this, null, function* () {
      yield this.dataManager.refreshCacheContent(e5);
      const t2 = [];
      this.layers.forEach((e6) => {
        t2.push(e6.refreshCachedQueryEngine());
      }), yield Promise.all(t2), this._refreshNamedTypes();
    });
  }
  connectEntities(e5) {
    return __async(this, null, function* () {
      let t2 = [];
      for (const i2 of this.dataManager.relationshipTypeNames) {
        const e6 = this.sublayerIdsCache.get(i2);
        e6 && (t2 = t2.concat(Array.from(e6.keys())));
      }
      const a2 = yield this.dataManager.getAttachedRelationships(e5, t2);
      return yield this._handleNewRecords(a2), {
        records: a2
      };
    });
  }
  _handleNewRecords(e5) {
    return __async(this, null, function* () {
      const t2 = [];
      this.dataManager.addToLayer(e5);
      for (const i2 of e5) this.sublayerIdsCache.has(i2.typeName) || (this.sublayerIdsCache.set(i2.typeName, /* @__PURE__ */ new Set()), t2.push(i2.typeName)), this.sublayerIdsCache.get(i2.typeName).add(i2.id);
      for (const i2 of t2) {
        const e6 = this._graphTypeLookup.get(i2);
        if (e6) {
          const t3 = new ae({
            objectType: e6,
            parentCompositeLayer: this,
            graphType: e6.type,
            title: i2
          });
          "entity" === e6.type ? this.dataManager.entityTypeNames.add(i2) : this.dataManager.relationshipTypeNames.add(i2), t3.geometryType ? this.layers.push(t3) : this.tables.push(t3), this.dataManager.sublayerCaches.set(i2, /* @__PURE__ */ new Map());
        }
      }
      yield this.dataManager.refreshCacheContent(e5.map((e6) => e6.id));
      const a2 = Object.assign({}, this._currentLinkChartConfig.layoutOptions);
      a2.lockedNodeLocations = this.getCurrentNodeLocations(), yield this.applyNewLinkChartLayout(this._currentLinkChartConfig.layoutMode, a2);
    });
  }
  _initializeDiagram() {
    return __async(this, null, function* () {
      this.defaultLinkChartConfig ? this.defaultLinkChartConfig.doNotRecalculateLayout ? (this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((e5, t2) => {
        e5?.members?.forEach((e6) => {
          const a2 = e6.linkChartLocation;
          let i2;
          const n4 = e6.id;
          if (!a2) return;
          i2 = "x" in a2 ? {
            x: a2.x,
            y: a2.y
          } : {
            x: a2.coords[0],
            y: a2.coords[1]
          };
          const s4 = ot(i2);
          this.dataManager.relationshipTypeNames.has(t2) ? this.relationshipLinkChartDiagramLookup.set(n4, s4) : this.entityLinkChartDiagramLookup.set(n4, s4), this.linkChartExtent.xmin > i2.x && (this.linkChartExtent.xmin = i2.x), this.linkChartExtent.xmax < i2.x && (this.linkChartExtent.xmax = i2.x), this.linkChartExtent.ymin > i2.y && (this.linkChartExtent.ymin = i2.y), this.linkChartExtent.ymax < i2.y && (this.linkChartExtent.ymax = i2.y);
        });
      }), this.memberRelationshipTypes.forEach((e5) => {
        e5.name && this.dataManager.sublayerCaches.get(e5.name)?.forEach((e6) => {
          const t2 = this.relationshipLinkChartDiagramLookup.get(e6.attributes[b]), a2 = this.relationshipLinkChartDiagramLookup.get(e6.attributes[T]);
          if (t2 && a2) {
            const i2 = ot(new m({
              paths: [[t2.coords[0], t2.coords[1]], [a2.coords[0], a2.coords[1]]]
            }));
            this.relationshipLinkChartDiagramLookup.set(e6.attributes[w2], i2);
          } else this.relationshipLinkChartDiagramLookup.set(e6.attributes[w2], null);
        });
      })) : yield this.calculateLinkChartLayout(this.defaultLinkChartConfig.layoutMode, __spreadValues({
        lockedNodeLocations: this.getCurrentNodeLocations()
      }, this.defaultLinkChartConfig.layoutOptions || {})) : yield this.calculateLinkChartLayout("RADIAL_TREE", {
        lockedNodeLocations: this.getCurrentNodeLocations()
      });
    });
  }
  _refreshNamedTypes() {
    for (const e5 of this.layers) e5.emit("refresh", {
      dataChanged: true
    });
    for (const e5 of this.tables) e5.emit("refresh", {
      dataChanged: true
    });
  }
  _validateLayoutSettings(e5, t2) {
    const a2 = (e6) => "number" == typeof e6 && !isNaN(e6), n4 = (e6) => a2(e6) && e6 >= 1, s4 = (e6) => a2(e6) && e6 >= 1, o2 = (e6) => Object.values(e3).includes(e6), r3 = (e6) => a2(e6) && e6 >= 0, h2 = /* @__PURE__ */ new Set(["FORCE_DIRECTED", "COMMUNITY", "GEOGRAPHIC"]), l3 = {};
    if (!h2.has(e5) || !t2) return !h2.has(e5) && t2 && n.getLogger(this).warn("Layout mode options were given for a layout mode that does not utilize them, settings will be ignored"), l3;
    const {
      computationBudgetTime: d,
      repulsionRadiusMultiplier: u2,
      idealEdgeLength: c2,
      idealEdgeLengthType: y3
    } = t2;
    s4(d) ? l3.computationBudgetTime = d : void 0 !== d && n.getLogger(this).warn("Invalid layout computationBudgetTime setting, will revert to default setting"), n4(u2) ? l3.repulsionRadiusMultiplier = u2 : void 0 !== u2 && n.getLogger(this).warn("Invalid layout repulsionRadiusMultiplier setting, will revert to default setting");
    const g2 = void 0 !== c2 || void 0 !== y3;
    return "GEOGRAPHIC" !== e5 && g2 ? n.getLogger(this).warn("Ideal edge length settings were specified for an incompatible layout mode, and will be ignored") : "GEOGRAPHIC" === e5 && g2 && (o2(y3) ? l3.idealEdgeLengthType = y3 : void 0 !== y3 && n.getLogger(this).warn('Invalid layout idealEdgeLengthType setting, will revert to "multiplier" setting'), r3(c2) ? l3.idealEdgeLength = c2 : void 0 !== c2 && n.getLogger(this).warn("Invalid layout idealEdgeLength setting, will revert to default setting")), l3;
  }
  _convertLayoutSettingsToCalculationSettings(e5) {
    let t2 = e5.idealEdgeLength;
    return e5.idealEdgeLengthType === e3.ABSOLUTE && (void 0 === t2 ? t2 = -1 : t2 *= -1), {
      computationBudgetTime: e5.computationBudgetTime,
      repulsionRadiusMultiplier: e5.repulsionRadiusMultiplier,
      idealEdgeLengthMultiplier: t2
    };
  }
};
e([y()], j.prototype, "dataPreloadedInLocalCache", void 0), e([y()], j.prototype, "defaultLinkChartConfig", void 0), e([y()], j.prototype, "dataManager", void 0), e([y()], j.prototype, "knowledgeGraph", void 0), e([y()], j.prototype, "layers", void 0), e([y()], j.prototype, "entityLinkChartDiagramLookup", void 0), e([y()], j.prototype, "relationshipLinkChartDiagramLookup", void 0), e([y()], j.prototype, "linkChartExtent", void 0), e([y()], j.prototype, "memberEntityTypes", void 0), e([y()], j.prototype, "memberRelationshipTypes", void 0), e([y()], j.prototype, "sublayerIdsCache", void 0), e([y()], j.prototype, "tables", void 0), e([y({
  json: {
    read: false
  }
})], j.prototype, "type", void 0), j = e([a("esri.layers.LinkChartLayer")], j);
var P2 = j;
export {
  P2 as default
};
//# sourceMappingURL=LinkChartLayer-NBWJIK7F.js.map
