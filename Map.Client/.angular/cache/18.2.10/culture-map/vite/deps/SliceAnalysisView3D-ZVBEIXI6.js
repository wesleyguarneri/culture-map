import {
  Ai,
  Ci,
  H as H2,
  I,
  Li,
  Mi,
  Ri,
  Vi,
  _i,
  ai,
  c as c4,
  ci,
  e as e2,
  ei,
  g as g2,
  gi,
  ji,
  li,
  mi,
  pi,
  ri,
  si,
  t as t6,
  ui,
  v as v2,
  xi
} from "./chunk-JGFBAWMN.js";
import {
  h as h2
} from "./chunk-5P5DJEOE.js";
import {
  M,
  f as f3,
  h as h3,
  j,
  m as m3,
  p as p3,
  r as r2,
  t as t7
} from "./chunk-2VS3JZZD.js";
import "./chunk-Z4AXZULQ.js";
import "./chunk-KD2H36E3.js";
import {
  t as t4
} from "./chunk-72NV56FN.js";
import {
  l as l2,
  n as n5
} from "./chunk-V6LWWR2Z.js";
import {
  O as O2
} from "./chunk-SR7MLPR2.js";
import {
  a as a2,
  v
} from "./chunk-FE5XLG7H.js";
import {
  o as o3
} from "./chunk-KEZPVBFI.js";
import {
  s as s2
} from "./chunk-ZRC4V45K.js";
import {
  w2 as w
} from "./chunk-ZYJAXFRJ.js";
import {
  p as p2
} from "./chunk-VRZ6RXNW.js";
import {
  m as m2
} from "./chunk-GN4ES4ZM.js";
import {
  t as t5
} from "./chunk-CGERANZG.js";
import "./chunk-XLRVEQZV.js";
import "./chunk-T35SJNQV.js";
import "./chunk-2CPAIFT3.js";
import "./chunk-Q666VSL3.js";
import "./chunk-67V5AGVJ.js";
import "./chunk-2CASBEEF.js";
import "./chunk-S2OEQYU7.js";
import {
  h
} from "./chunk-APWDCJIJ.js";
import "./chunk-4KGPH7OX.js";
import "./chunk-TLAW3ACJ.js";
import "./chunk-GFPWBDCO.js";
import "./chunk-MQUE5HQL.js";
import "./chunk-TKHURHLF.js";
import "./chunk-U7YHNT5S.js";
import "./chunk-UW23RIEM.js";
import "./chunk-R6CAUNOR.js";
import "./chunk-ZIDRXKSJ.js";
import {
  H,
  W,
  Z,
  ds
} from "./chunk-DBK2ELNZ.js";
import "./chunk-JMV2M56E.js";
import "./chunk-YNX4ZC52.js";
import "./chunk-LWAFK7Z6.js";
import "./chunk-O7OCS6XP.js";
import "./chunk-BFWLPS7M.js";
import "./chunk-67LE7VNQ.js";
import "./chunk-BJM7H6OC.js";
import "./chunk-2ONAF54K.js";
import {
  n as n4
} from "./chunk-FLWLBYXO.js";
import "./chunk-F2TT4B6M.js";
import "./chunk-M4YLDDTR.js";
import "./chunk-6PFH6TN3.js";
import "./chunk-Q7ENCKPJ.js";
import "./chunk-7HBD4CJ3.js";
import "./chunk-K2LTET4M.js";
import "./chunk-WG5JLPNN.js";
import "./chunk-25PMMPR7.js";
import "./chunk-7XAWCQ7R.js";
import "./chunk-RASN5P76.js";
import "./chunk-5L3YXBNN.js";
import "./chunk-IFUKJDOU.js";
import "./chunk-LD5YIQXD.js";
import "./chunk-J7KF6IEI.js";
import "./chunk-GOKBAMCG.js";
import "./chunk-E3P3LIVT.js";
import "./chunk-HUX6Y26H.js";
import "./chunk-XGDLE7WK.js";
import "./chunk-QMUS26QM.js";
import "./chunk-GDEAPZ64.js";
import "./chunk-TCQSUQ7Y.js";
import "./chunk-BG32AOSQ.js";
import "./chunk-PEZTN5WV.js";
import "./chunk-FHW2TG7X.js";
import "./chunk-33LKI2Y7.js";
import "./chunk-YCQXFVJL.js";
import "./chunk-ZAP7ZEWR.js";
import "./chunk-YAGNWBGU.js";
import "./chunk-DE6MQ5XE.js";
import "./chunk-LQTSBE7P.js";
import "./chunk-GCFUJXGH.js";
import "./chunk-MBMY7SS6.js";
import "./chunk-ICUHXX2J.js";
import "./chunk-VIIVMRRO.js";
import "./chunk-ZKSEQXDM.js";
import "./chunk-675UQNXB.js";
import "./chunk-DXGCBLDW.js";
import "./chunk-Z3FHX4FD.js";
import "./chunk-SUUOAZQT.js";
import "./chunk-TGHJVD7I.js";
import "./chunk-OZG2NNUW.js";
import "./chunk-KTRZHJ2M.js";
import "./chunk-KOIKSJSQ.js";
import "./chunk-VUVXW4AC.js";
import "./chunk-LKHUGH5W.js";
import "./chunk-ACZYDHB3.js";
import "./chunk-HAO4WCNW.js";
import "./chunk-X2OAE75B.js";
import "./chunk-UCPBGEQD.js";
import "./chunk-SIZK72CP.js";
import "./chunk-SLCHZ6DD.js";
import "./chunk-ZVFENZUF.js";
import "./chunk-N3S77FRG.js";
import "./chunk-YYETZJJB.js";
import "./chunk-MD2IQSSQ.js";
import "./chunk-P7OSFLIX.js";
import "./chunk-ZDC4PV4Y.js";
import "./chunk-DLRYNII2.js";
import "./chunk-WN3YAMRZ.js";
import "./chunk-NWICVENM.js";
import "./chunk-A4RKV2C7.js";
import "./chunk-WU7FVYT7.js";
import "./chunk-SYYDVGKY.js";
import "./chunk-YLE5AYZV.js";
import "./chunk-CZQYBYHB.js";
import "./chunk-Q5ZRUB2Y.js";
import "./chunk-62WUYJJN.js";
import "./chunk-JNWMZ6EJ.js";
import "./chunk-VS26W5Y5.js";
import {
  A as A3
} from "./chunk-MID6GR72.js";
import "./chunk-6OHQEV7Z.js";
import "./chunk-2N3BR7QT.js";
import "./chunk-6MR3LXEW.js";
import "./chunk-JPIYGHSR.js";
import "./chunk-6MR4UDDL.js";
import "./chunk-B7GRWOZI.js";
import "./chunk-SAOPWBKU.js";
import "./chunk-Z2JVKOTW.js";
import "./chunk-YW5DYBTP.js";
import "./chunk-2C54H6O6.js";
import "./chunk-UHMXQYZT.js";
import "./chunk-LZUPV7SL.js";
import "./chunk-2GRLWAHK.js";
import "./chunk-C3UDKWXD.js";
import "./chunk-YTFX4PFO.js";
import "./chunk-VOROPCKI.js";
import "./chunk-N3IR233K.js";
import "./chunk-DSMB46HB.js";
import "./chunk-USSQX44O.js";
import "./chunk-OTI4DGZ5.js";
import "./chunk-KQDYTHCF.js";
import "./chunk-TR6FCWXY.js";
import "./chunk-TROPJVOL.js";
import "./chunk-JKHDI77M.js";
import "./chunk-3AY5EJVP.js";
import "./chunk-XQCKIDQO.js";
import "./chunk-BNK4CEA6.js";
import "./chunk-BPMRTFHU.js";
import "./chunk-6LDLRQX4.js";
import "./chunk-Z4YAQ5JI.js";
import "./chunk-K2XCQKCC.js";
import "./chunk-AJS4B62I.js";
import "./chunk-S5EXT7FA.js";
import "./chunk-73Y7XDLH.js";
import "./chunk-YFOAET4H.js";
import "./chunk-5U4TBXYS.js";
import "./chunk-6WG22V46.js";
import "./chunk-OOGIXDXG.js";
import "./chunk-JFYQTYD3.js";
import "./chunk-KDJZAYOF.js";
import "./chunk-5453A3C5.js";
import "./chunk-HCFDI7IX.js";
import "./chunk-AQJS6F3O.js";
import "./chunk-WUB6LJVL.js";
import "./chunk-QXSES7JX.js";
import "./chunk-5YIMTGEC.js";
import "./chunk-YPU2P4KO.js";
import "./chunk-UFVMJL32.js";
import "./chunk-B67FUUE5.js";
import "./chunk-5GQ3OMCZ.js";
import "./chunk-2SMFPIRI.js";
import "./chunk-VCFSVEDB.js";
import "./chunk-XCVOKQAA.js";
import "./chunk-3WQXHRJE.js";
import "./chunk-EBLQZUPS.js";
import "./chunk-URWREU3E.js";
import "./chunk-KE2YMCJC.js";
import "./chunk-L7ZKWTWL.js";
import "./chunk-O2DTA3XK.js";
import "./chunk-3UOXF3CT.js";
import "./chunk-WDDCGJTI.js";
import "./chunk-PA7WZX2U.js";
import "./chunk-GPUGMSHU.js";
import "./chunk-AIS5CSUZ.js";
import "./chunk-52UEU7LG.js";
import "./chunk-WJKYGQOY.js";
import "./chunk-GY52WOQZ.js";
import "./chunk-GAYJ4YPJ.js";
import "./chunk-PPMDUJ4E.js";
import "./chunk-ZTT6ENBS.js";
import "./chunk-MFZTGYUJ.js";
import "./chunk-R5ZE5A4K.js";
import "./chunk-24CN3HDP.js";
import "./chunk-SZWWBMQN.js";
import "./chunk-ZE47C44H.js";
import {
  m
} from "./chunk-5GIS2C3K.js";
import "./chunk-XCOHDMBF.js";
import "./chunk-2GMKFOCL.js";
import "./chunk-ZR5BOILP.js";
import "./chunk-QCBC3RJX.js";
import "./chunk-6XGV55XZ.js";
import "./chunk-HOH445RO.js";
import "./chunk-R3F4JMNC.js";
import "./chunk-63QCTVYB.js";
import "./chunk-W5ERGD4Y.js";
import "./chunk-7B5YPLFX.js";
import "./chunk-RDQF44TE.js";
import "./chunk-KKD7A2GN.js";
import "./chunk-ZWCV4HKG.js";
import {
  E,
  F,
  S as S2,
  V,
  c as c3,
  f as f2,
  t as t3
} from "./chunk-N4KQPPPI.js";
import "./chunk-4OGGMTIH.js";
import "./chunk-NQVBBKAN.js";
import "./chunk-U74WRHVJ.js";
import "./chunk-TCPN7AEH.js";
import "./chunk-4MMTPKY4.js";
import "./chunk-DY7FJHTG.js";
import "./chunk-Q4KYZS3X.js";
import "./chunk-KVKFHRJ3.js";
import "./chunk-VWML4J2J.js";
import "./chunk-JYODC3YQ.js";
import "./chunk-BQZBOYBD.js";
import "./chunk-TYQXPPSP.js";
import "./chunk-W2IRSMFY.js";
import "./chunk-TRSGUVSM.js";
import "./chunk-U3MA63JX.js";
import "./chunk-WYKKCLBI.js";
import "./chunk-PFMGJTQM.js";
import "./chunk-Q7SRMLJZ.js";
import "./chunk-PQ4T66BG.js";
import "./chunk-SWPHGZYB.js";
import "./chunk-DWASPXVI.js";
import "./chunk-TNWXOQKO.js";
import "./chunk-MAO5BVLA.js";
import "./chunk-T2S5VXNP.js";
import "./chunk-4U5GUJRA.js";
import "./chunk-7KRERHHR.js";
import "./chunk-T4AP6CTC.js";
import "./chunk-HD65DNIO.js";
import "./chunk-4KWLMXIA.js";
import "./chunk-BIUXKPKA.js";
import {
  n as n3
} from "./chunk-N6TJI25E.js";
import "./chunk-634JLXD4.js";
import "./chunk-Y3EDGYWG.js";
import "./chunk-UF6JOUSJ.js";
import "./chunk-T5JGQSO3.js";
import "./chunk-CIW3KHOW.js";
import "./chunk-J55F4AC2.js";
import "./chunk-IQLBZKUD.js";
import "./chunk-7MZZCQ64.js";
import "./chunk-JOJZ6YC5.js";
import "./chunk-L4TOCXR5.js";
import {
  _,
  t as t2
} from "./chunk-IMVP5ADD.js";
import "./chunk-H7WPOTQH.js";
import "./chunk-RTWBKPWJ.js";
import "./chunk-HEWCRCJC.js";
import "./chunk-ZZEAVAVX.js";
import "./chunk-SJX5DIA7.js";
import "./chunk-6A7CWJED.js";
import "./chunk-LFKEQKEA.js";
import "./chunk-DUTZNK67.js";
import "./chunk-IN6BQCWS.js";
import "./chunk-CRNUMTSV.js";
import "./chunk-JM7HAEY6.js";
import "./chunk-DOK4SACJ.js";
import "./chunk-OUKUASAF.js";
import "./chunk-V5RMUGJJ.js";
import "./chunk-D2NB6D6N.js";
import "./chunk-UWJIHV6Q.js";
import "./chunk-ZUSCOMQM.js";
import "./chunk-DSEUCBVP.js";
import "./chunk-UPDWQH75.js";
import "./chunk-RXWBJSJ5.js";
import {
  f
} from "./chunk-M2NS3MSU.js";
import "./chunk-HMNBB7ED.js";
import "./chunk-3RRMLFFN.js";
import "./chunk-DR5TVNEL.js";
import "./chunk-HT2T6PUB.js";
import "./chunk-K64AAM77.js";
import "./chunk-6EUVKE22.js";
import "./chunk-A3NNJ7XA.js";
import "./chunk-OKJHJ3CY.js";
import {
  c as c2,
  d as d3,
  p
} from "./chunk-XTVPEVHA.js";
import "./chunk-DTUSTSEJ.js";
import "./chunk-JCWFGRHQ.js";
import "./chunk-JILEJ6R2.js";
import "./chunk-GAW5JHG4.js";
import "./chunk-OEKKQXBD.js";
import "./chunk-S3IO7V4Q.js";
import "./chunk-DZALMCYL.js";
import "./chunk-K226GFDN.js";
import "./chunk-4ZZRP4MA.js";
import {
  c,
  d as d2
} from "./chunk-7ZJ6P7J7.js";
import "./chunk-FPFZQCEQ.js";
import "./chunk-5I6J67HP.js";
import "./chunk-YVULORT6.js";
import "./chunk-PB33BAI3.js";
import "./chunk-CVB43GGP.js";
import "./chunk-EODIWR2E.js";
import "./chunk-LLDOZWVV.js";
import "./chunk-FYAEQPUY.js";
import "./chunk-7XMEZQ34.js";
import "./chunk-BDM2D6IC.js";
import "./chunk-U2ZVAEKG.js";
import "./chunk-EDSMXTFO.js";
import "./chunk-MNLT652N.js";
import "./chunk-OGZAGPIO.js";
import "./chunk-HJJIIYFF.js";
import "./chunk-7RMVJCDW.js";
import "./chunk-T6GCUITX.js";
import "./chunk-TUIGM7TV.js";
import "./chunk-IHVSZYZS.js";
import "./chunk-6CA6K3O7.js";
import "./chunk-NYQ5CYNR.js";
import "./chunk-O7UDKFOW.js";
import "./chunk-TKPMIAIW.js";
import "./chunk-NQOJNTB3.js";
import "./chunk-MFOQYQFG.js";
import "./chunk-NKCPFCP3.js";
import "./chunk-3ZXOUEQG.js";
import {
  O,
  P,
  g,
  o as o2,
  r,
  s,
  u as u2,
  z
} from "./chunk-AXVPJBVW.js";
import {
  n as n2,
  t
} from "./chunk-OXEPWRM7.js";
import "./chunk-POILQGXA.js";
import "./chunk-JJS7PR2U.js";
import "./chunk-L5YS4GSA.js";
import "./chunk-PRREDSOB.js";
import "./chunk-V5C6HSAM.js";
import "./chunk-SYATLP3H.js";
import "./chunk-V6AMQYXE.js";
import {
  A as A2,
  C,
  d
} from "./chunk-6WHTZNUH.js";
import "./chunk-EITGQLII.js";
import "./chunk-TIVJXVMN.js";
import "./chunk-XNUH25NY.js";
import "./chunk-WGAPNV7F.js";
import "./chunk-BXQGM56A.js";
import {
  e
} from "./chunk-4Z5SGKRM.js";
import {
  A,
  S
} from "./chunk-ANKOCGE2.js";
import {
  y
} from "./chunk-7CJXZOFG.js";
import "./chunk-IRGZKO7V.js";
import "./chunk-5SELS7VU.js";
import {
  a3 as a
} from "./chunk-DDYVXG4F.js";
import "./chunk-ANP42J2U.js";
import {
  o
} from "./chunk-HJY2YILU.js";
import "./chunk-7DA6A5LD.js";
import {
  l,
  u
} from "./chunk-2MMLMOWS.js";
import "./chunk-4323ZVPF.js";
import {
  n2 as n
} from "./chunk-WYIDUUN2.js";
import "./chunk-DXLOWWK7.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-JWIQHGQB.js";

// ../../../node_modules/@arcgis/core/views/3d/terrain/isTerrainSurfaceLayer.js
function a3(a4) {
  switch (a4.type) {
    case "building-scene":
    case "catalog":
    case "catalog-dynamic-group":
    case "catalog-footprint":
    case "csv":
    case "dimension":
    case "feature":
    case "geo-rss":
    case "geojson":
    case "graphics":
    case "group":
    case "integrated-mesh":
    case "integrated-mesh-3dtiles":
    case "kml":
    case "knowledge-graph":
    case "link-chart":
    case "knowledge-graph-sublayer":
    case "line-of-sight":
    case "map-notes":
    case "ogc-feature":
    case "oriented-imagery":
    case "point-cloud":
    case "route":
    case "scene":
    case "stream":
    case "voxel":
    case "subtype-group":
    case "unknown":
    case "unsupported":
    case "wfs":
    case null:
      return false;
    case "base-dynamic":
    case "base-elevation":
    case "base-tile":
    case "bing-maps":
    case "elevation":
    case "imagery":
    case "imagery-tile":
    case "map-image":
    case "media":
    case "open-street-map":
    case "tile":
    case "vector-tile":
    case "video":
    case "wcs":
    case "web-tile":
    case "wms":
    case "wmts":
      return true;
    default:
      return n3(a4.type), false;
  }
}

// ../../../node_modules/@arcgis/core/views/3d/analysis/Slice/SliceController.js
var v3 = class extends S {
  constructor(e3) {
    super(e3), this._internalChange = false, this._currentSlicePlane = null;
  }
  initialize() {
    this.addHandles(this.analysis.excludedLayers.on("before-add", (e3) => {
      const i = e3.item;
      null != i && (i instanceof f || i instanceof A3) ? i instanceof f && a3(i) ? (n.getLogger(this).error("excludedLayers", `Layer '${i.title}, id:${i.id}' of type '${i.type}' can not be individually excluded from slicing. Use 'excludeGroundSurface' instead.`), e3.preventDefault()) : this.analysis.excludedLayers.includes(i) && e3.preventDefault() : (n.getLogger(this).error("excludedLayers", "Invalid layer type, layer must derive from Layer or BuildingComponentSublayer"), e3.preventDefault());
    })), V2(this.view, this), this.addHandles([d(() => this.analysisViewData.plane, () => {
      this._internalChange || this._updateSlicePlaneFromBoundedPlane(), this._updateLayerViews();
    }, {
      sync: true
    }), d(() => this.analysis.excludeGroundSurface, () => this._updateLayerViews(), {
      sync: true
    }), this.analysis.excludedLayers.on("change", () => this._updateLayerViews()), d(() => [this.analysisViewData.active, this.analysisViewData.visible], () => {
      this._updateActiveController(), this._updateViewSlicePlane();
    }, {
      sync: true
    }), d(() => this._allLayerAndSubLayerViews, () => this._updateLayerViews())]), this.addHandles([d(() => this.analysis.shape, () => {
      this._internalChange || (this._updateBoundedPlaneFromSlicePlane(), this._updateViewSlicePlane());
    }, {
      sync: true
    })], "analysis"), this._updateActiveController(), this._updateBoundedPlaneFromSlicePlane(), this._updateViewSlicePlane();
  }
  destroy() {
    this.analysisViewData.active && (this.analysisViewData.active = false, this.view.slicePlane = null, this._updateActiveController(), this._updateViewSlicePlane()), L(this.view, this), this.set("view", null);
  }
  get _allLayerAndSubLayerViews() {
    const e3 = this.view.allLayerViews.items;
    return e3.concat(e3.filter(xi).flatMap(({
      sublayerViews: e4
    }) => e4.items));
  }
  _updateBoundedPlaneFromSlicePlane() {
    const e3 = this.analysis.shape, i = this._currentSlicePlane;
    if (null == i && null == e3 || null != i && null != e3 && e3.equals(i)) return;
    let a4 = null, l3 = null;
    if (null != e3?.position) {
      const i2 = e3.position.spatialReference, s3 = Li(e3, this.view);
      null == s3 && t5(this.analysis, i2, n.getLogger(this)), a4 = Vi(s3, this.view, {
        tiltEnabled: this.analysis.tiltEnabled
      }, W()), null != a4 && (l3 = {
        heading: e3.heading,
        tilt: e3.tilt,
        position: e3.position,
        width: e3.width,
        height: e3.height
      });
    }
    this._currentSlicePlane = l3, this._internalChange = true, this.analysisViewData.plane = a4, this._internalChange = false;
  }
  _updateSlicePlaneFromBoundedPlane() {
    const e3 = this.analysisViewData.plane, a4 = Ri(e3, this.view, this.view.spatialReference, new h2());
    let t8 = null;
    null != a4 && (t8 = {
      heading: a4.heading,
      tilt: a4.tilt,
      position: a4.position,
      width: a4.width,
      height: a4.height
    }), this._currentSlicePlane = t8, this._internalChange = true, this.analysis.shape = a4, this._internalChange = false, this._updateViewSlicePlane();
  }
  _updateActiveController() {
    if (m4) return;
    const e3 = _2(this.view);
    if (!e3) return;
    if (this.analysisViewData.active) null != e3.activeController && e3.activeController !== this ? (m4 = true, e3.activeController.analysisViewData.active = false, m4 = false) : null != e3.activeController && e3.activeController, this._updateLayerViews(), e3.activeController = this;
    else {
      if (null != e3.activeController && e3.activeController !== this) return;
      null != e3.activeController && e3.activeController === this && (e3.activeController = null, this._updateLayerViews());
    }
  }
  _updateViewSlicePlane() {
    g3(this.view);
  }
  _updateLayerViews() {
    const e3 = null != this.analysisViewData.plane && this.analysisViewData.visible && this.analysisViewData.active, i = [], a4 = (e4) => {
      "layers" in e4 ? e4.layers.forEach(a4) : i.push(e4);
    };
    this.analysis.excludedLayers.forEach(a4), this.view.allLayerViews.forEach((a5) => {
      a5.destroyed || ("slicePlaneEnabled" in a5 && (a5.slicePlaneEnabled = e3 && !i.includes(a5.layer)), "sublayerViews" in a5 && a5.sublayerViews.forEach((a6) => {
        a6.slicePlaneEnabled = e3 && !i.includes(a6.sublayer);
      }));
    }), null != this.view.basemapTerrain && (this.view.basemapTerrain.slicePlaneEnabled = e3 && !this.analysis.excludeGroundSurface);
  }
};
e([y()], v3.prototype, "view", void 0), e([y()], v3.prototype, "analysis", void 0), e([y()], v3.prototype, "analysisViewData", void 0), e([y()], v3.prototype, "_allLayerAndSubLayerViews", null), v3 = e([a("esri.views.3d.analysis.Slice.SliceController")], v3);
var f4 = /* @__PURE__ */ new Map();
var m4 = false;
function g3(e3) {
  const i = _2(e3), a4 = i?.activeController;
  null != a4?.analysisViewData.plane && a4.analysisViewData.visible ? e3.slicePlane = a4.analysisViewData.plane : e3.slicePlane = null;
}
function V2(e3, i) {
  f4.has(e3) || f4.set(e3, {
    all: [],
    activeController: null
  }), f4.get(e3)?.all.push(i);
}
function _2(e3) {
  return f4.get(e3);
}
function L(e3, i) {
  if (!f4.has(e3)) throw new Error("view expected in global slice register");
  const a4 = f4.get(e3), t8 = a4?.all.lastIndexOf(i) ?? -1;
  if (!a4 || -1 === t8) throw new Error("controller expected in global slice register");
  a4.all.splice(t8, 1), 0 === a4.all.length && f4.delete(e3);
}

// ../../../node_modules/@arcgis/core/views/3d/analysis/Slice/SliceTool.js
var Vt;
var bt = Vt = class extends o3 {
  constructor(t8) {
    super(t8), this._clock = o, this._previewPlaneOpacity = 1, this.removeIncompleteOnCancel = false, this._layersMode = "none", this.shiftManipulator = null, this.rotateHeadingManipulator = null, this.rotateTiltManipulator = null, this.resizeManipulators = null, this._frameTask = null, this._pointerMoveTimerMs = m3, this._prevPointerMoveTimeout = null, this._previewPlaneGridVisualElement = null, this._previewPlaneOutlineVisualElement = null, this._startPlane = W(), this._previewPlane = null, this._activeKeyModifiers = {}, this._lastCursorPosition = c(), this._resizeHandles = [{
      direction: [1, 0]
    }, {
      direction: [1, 1]
    }, {
      direction: [0, 1]
    }, {
      direction: [-1, 1]
    }, {
      direction: [-1, 0]
    }, {
      direction: [-1, -1]
    }, {
      direction: [0, -1]
    }, {
      direction: [1, -1]
    }], this._intersector = t4(t8.view.state.viewingMode);
  }
  initialize() {
    if (null == this.analysis) throw new Error("SliceTool requires valid analysis, but null was provided.");
    const t8 = (t9) => {
      this._updateManipulatorsInteractive(t9), t9.grabbing || (null != this.analysisViewData.plane && Z(this.analysisViewData.plane, this._startPlane), this.inputState = null);
    }, e3 = new I(this.view, H2.CENTER_ON_ARROW);
    this.shiftManipulator = e3, this.manipulators.add(e3), this.addHandles([this._createShiftDragPipeline(e3), e3.events.on("grab-changed", (i2) => {
      this._onShiftGrab(i2), t8(e3);
    })]);
    const i = !this.view._stage?.renderView.renderingContext.driverTest.svgPremultipliesAlpha.result, a4 = new g2(this.view, (t9, e4) => l2(this.view.textures, {
      accentColor: t9,
      contrastColor: e4,
      preMultiplyAlpha: i
    }));
    this.rotateHeadingManipulator = a4, this.manipulators.add(a4), this.addHandles([this._createRotateHeadingDragPipeline(a4), a4.events.on("grab-changed", (e4) => {
      this._onRotateHeadingGrab(e4), t8(a4);
    })]);
    const s3 = new g2(this.view, (t9, e4) => n5(this.view.textures, {
      accentColor: t9,
      contrastColor: e4,
      preMultiplyAlpha: i
    }));
    this.rotateTiltManipulator = s3, this.manipulators.add(s3), this.addHandles([this._createRotateTiltDragPipeline(s3), s3.events.on("grab-changed", (e4) => {
      this._onRotateTiltGrab(e4), t8(s3);
    })]), this.resizeManipulators = this._resizeHandles.map((e4, i2) => {
      const a5 = new v2(this.view, e4);
      return this.addHandles([this._createResizeDragPipeline(a5), a5.events.on("grab-changed", (e5) => {
        this._onResizeGrab(e5, i2), t8(a5);
      })]), a5;
    }), this.manipulators.addMany(this.resizeManipulators), this._previewPlaneGridVisualElement = ji(this.view), this._previewPlaneOutlineVisualElement = Ai(this.view), this._previewPlaneOutlineVisualElement.width = M, this.addHandles(d(() => [this.analysisViewData.plane, this.analysis.tiltEnabled], () => this._updateManipulators(), C));
    const o4 = d(() => this.state, (t9) => {
      "sliced" === t9 && this.finishToolCreation();
    }, A2);
    this.addHandles([o4, d(() => this.view.state.camera, () => this._onCameraChange())]);
  }
  destroy() {
    this._removeFrameTask(), this._clearPointerMoveTimeout(), this._previewPlaneOutlineVisualElement = u(this._previewPlaneOutlineVisualElement), this._previewPlaneGridVisualElement = u(this._previewPlaneGridVisualElement);
  }
  get state() {
    const t8 = !!this.analysisViewData.plane, e3 = !!this.inputState;
    return t8 ? t8 && e3 ? "slicing" : t8 && !e3 ? "sliced" : "ready" : "ready";
  }
  get cursor() {
    return this._isPlacingSlicePlane || "exclude" === this.layersMode ? "crosshair" : null != this._creatingPointerId ? "grabbing" : null;
  }
  set analysis(t8) {
    if (null == t8) throw new Error("SliceTool requires valid analysis, but null was provided.");
    this.removeHandles("analysis"), this._set("analysis", t8);
  }
  get layersMode() {
    return this._layersMode;
  }
  get inputState() {
    return this._get("inputState");
  }
  set inputState(t8) {
    this._set("inputState", t8), this.analysisViewData.showGrid = null != t8 && "resize" === t8.type, this._updateMaterials();
  }
  get _isPlacingSlicePlane() {
    return !this.inputState && !this.analysisViewData.plane && this.active;
  }
  get _creatingPointerId() {
    return null != this.inputState && "shift" === this.inputState.type ? this.inputState.creatingPointerId : null;
  }
  enterExcludeLayerMode() {
    null != this.analysisViewData.plane && (this._layersMode = "exclude", this.active || (this.view.activeTool = this));
  }
  exitExcludeLayerMode() {
    null != this.analysisViewData.plane && (this._layersMode = "none", this.active && (this.view.activeTool = null));
  }
  onDeactivate() {
    this._updatePreviewPlane(null);
  }
  onShow() {
    this._updateVisibility(true);
  }
  onHide() {
    this._updateVisibility(false);
  }
  _updateVisibility(t8) {
    this._updateManipulators(), t8 || this._clearPointerMoveTimeout();
  }
  onInputEvent(t8) {
    switch (t8.type) {
      case "pointer-drag":
        if (!kt(t8)) return;
        this._isPlacingSlicePlane ? this._onClickPlacePlane(t8) && t8.stopPropagation() : this._onPointerDrag(t8) && t8.stopPropagation();
        break;
      case "pointer-move":
        this._onPointerMove(t8);
        break;
      case "pointer-up":
        this._onPointerUp(t8) && t8.stopPropagation();
        break;
      case "immediate-click":
        if (!kt(t8)) return;
        this._onClickPlacePlane(t8) && t8.stopPropagation();
        break;
      case "click":
        if (!kt(t8)) return;
        this._onClickExcludeLayer(t8) && t8.stopPropagation();
        break;
      case "drag":
        this.inputState && t8.stopPropagation();
        break;
      case "key-down":
        this._onKeyDown(t8) && t8.stopPropagation();
        break;
      case "key-up":
        this._onKeyUp(t8) && t8.stopPropagation();
    }
  }
  onEditableChange() {
    this.analysisViewData.editable = this.internallyEditable;
  }
  _onPointerDrag(t8) {
    const e3 = this.inputState;
    if (t8.pointerId === this._creatingPointerId && null != e3 && "shift" === e3.type) {
      const i = n4(t8);
      return this.shiftManipulator.events.emit("drag", {
        action: e3.hasBeenDragged ? "update" : "start",
        pointerType: t8.pointerType,
        start: i,
        screenPoint: i
      }), e3.hasBeenDragged = true, true;
    }
    return false;
  }
  _onPointerMove(t8) {
    this._lastCursorPosition.x = t8.x, this._lastCursorPosition.y = t8.y, this._resetPointerMoveTimeout(), "touch" !== t8.pointerType && this._updatePreviewPlane(n4(t8), this._activeKeyModifiers);
  }
  _onCameraChange() {
    this._updatePreviewPlane(this._lastCursorPosition, this._activeKeyModifiers), this._updateManipulators();
  }
  _onPointerUp(t8) {
    if (t8.pointerId === this._creatingPointerId && null != this.analysisViewData.plane) {
      const e3 = n4(t8);
      return this.shiftManipulator.events.emit("drag", {
        action: "end",
        start: e3,
        screenPoint: e3
      }), Z(this.analysisViewData.plane, this._startPlane), this.inputState = null, true;
    }
    return false;
  }
  _onClickPlacePlane(t8) {
    if ("exclude" === this.layersMode) return false;
    if (this._isPlacingSlicePlane) {
      const i = n4(t8), a4 = W();
      if (this._pickPlane(i, false, this._activeKeyModifiers, a4)) {
        if ("pointer-drag" === t8.type) {
          const e3 = m2(this.view.state.camera, i, xt);
          this.inputState = Et(e3, t8.pointerId, a4.origin, a4);
        }
        return Z(a4, this._startPlane), this.analysis.shape = Ri(a4, this.view, this.view.spatialReference, new h2()), true;
      }
    }
    return false;
  }
  _onClickExcludeLayer(t8) {
    return !("exclude" !== this.layersMode || !this.created) && (this.view.hitTest(n4(t8)).then((t9) => {
      if (t9.results.length) {
        const e3 = t9.results[0], i = "graphic" === e3?.type && e3.graphic;
        if (i) {
          const t10 = i.sourceLayer || i.layer;
          t10 && this.analysis.excludedLayers.push(t10);
        }
      } else t9.ground.layer ? this.analysis.excludedLayers.push(t9.ground.layer) : this.analysis.excludeGroundSurface = true;
    }), this.exitExcludeLayerMode(), true);
  }
  _onKeyDown(t8) {
    return (t8.key === r2 || t8.key === t7) && (this._activeKeyModifiers[t8.key] = true, null != this._previewPlane && this._updatePreviewPlane(this._lastCursorPosition, this._activeKeyModifiers), true);
  }
  _onKeyUp(t8) {
    return !(t8.key !== r2 && t8.key !== t7 || !this._activeKeyModifiers[t8.key]) && (delete this._activeKeyModifiers[t8.key], null != this._previewPlane && this._updatePreviewPlane(this._lastCursorPosition, this._activeKeyModifiers), true);
  }
  _onShiftGrab(t8) {
    if ("start" !== t8.action || null == this.analysisViewData.plane || !t8.screenPoint) return;
    const e3 = m2(this.view.state.camera, t8.screenPoint, xt);
    Z(this.analysisViewData.plane, this._startPlane), this.inputState = Et(e3, null, this.shiftManipulator.renderLocation, this.analysisViewData.plane);
  }
  _createShiftDragPipeline(t8) {
    return p2(t8, (t9, e3, i) => {
      const a4 = this.inputState;
      if (null == a4 || "shift" !== a4.type) return;
      const s3 = null != this.analysisViewData.plane ? Z(this.analysisViewData.plane, W()) : null;
      e3.next(O2(this.view, a4.shiftPlane)).next(this._shiftDragAdjustSensitivity(a4)).next(this._shiftDragUpdatePlane(a4)), i.next(() => {
        null != s3 && this._updateBoundedPlane(s3);
      });
    });
  }
  _shiftDragAdjustSensitivity(t8) {
    return (e3) => {
      if (null == this.analysisViewData.plane) return null;
      const i = 1e-3, a4 = Math.min((1 - Math.abs(P(ds(this.analysisViewData.plane), e3.ray.direction) / s(e3.ray.direction))) / i, 1), s3 = -V(this._startPlane.plane, e3.renderEnd), n6 = -V(this._startPlane.plane, t8.startPoint);
      return t8.depth = t8.depth * (1 - a4) + s3 * a4 - n6, e3;
    };
  }
  _shiftDragUpdatePlane(t8) {
    return () => {
      if (null == this.analysisViewData.plane) return;
      const e3 = r(c3.get(), this._startPlane.origin), i = r(c3.get(), ds(this._startPlane));
      g(i, i, -t8.depth), u2(i, i, e3);
      const a4 = H(i, this.analysisViewData.plane.basis1, this.analysisViewData.plane.basis2, W());
      this._updateBoundedPlane(a4);
    };
  }
  _onRotateHeadingGrab(t8) {
    if ("start" !== t8.action || null == this.analysisViewData.plane || !t8.screenPoint) return;
    const e3 = li(this.analysisViewData.plane, this.view.renderCoordsHelper, _i.HEADING, E()), i = m2(this.view.state.camera, t8.screenPoint, xt), a4 = n2();
    S2(e3, i, a4) && (Z(this.analysisViewData.plane, this._startPlane), this.inputState = {
      type: "rotate",
      rotatePlane: e3,
      startPoint: a4
    });
  }
  _createRotateHeadingDragPipeline(t8) {
    return p2(t8, (t9, e3, i) => {
      const a4 = this.inputState;
      if (null == a4 || "rotate" !== a4.type) return;
      const s3 = null != this.analysisViewData.plane ? Z(this.analysisViewData.plane, W()) : null;
      e3.next(O2(this.view, a4.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(a4)).next(this._rotateDragUpdatePlaneFromRotate()), i.next(() => {
        null != s3 && this._updateBoundedPlane(s3);
      });
    });
  }
  _onRotateTiltGrab(t8) {
    if ("start" !== t8.action || null == this.analysisViewData.plane || !t8.screenPoint) return;
    const e3 = li(this.analysisViewData.plane, this.view.renderCoordsHelper, _i.TILT, E()), i = m2(this.view.state.camera, t8.screenPoint, xt), a4 = n2();
    S2(e3, i, a4) && (Z(this.analysisViewData.plane, this._startPlane), this.inputState = {
      type: "rotate",
      rotatePlane: e3,
      startPoint: a4
    });
  }
  _createRotateTiltDragPipeline(t8) {
    return p2(t8, (t9, e3, i) => {
      const a4 = this.inputState;
      if (null == a4 || "rotate" !== a4.type) return;
      const s3 = null != this.analysisViewData.plane ? Z(this.analysisViewData.plane, W()) : null;
      e3.next(O2(this.view, a4.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(a4)).next(this._rotateDragUpdatePlaneFromRotate()), i.next(() => {
        null != s3 && this._updateBoundedPlane(s3);
      });
    });
  }
  _rotateDragRenderPlaneToRotate(t8) {
    return (e3) => {
      if (null == this.analysisViewData.plane) return null;
      const i = F(t8.rotatePlane), a4 = w(t8.startPoint, e3.renderEnd, this.analysisViewData.plane.origin, i);
      return __spreadProps(__spreadValues({}, e3), {
        rotateAxis: i,
        rotateAngle: a4
      });
    };
  }
  _rotateDragUpdatePlaneFromRotate() {
    return (t8) => {
      if (null == this.analysisViewData.plane) return;
      const e3 = p(f2.get(), t8.rotateAngle, t8.rotateAxis);
      if (null == e3) return;
      const i = O(c3.get(), this._startPlane.basis1, e3), a4 = O(c3.get(), this._startPlane.basis2, e3), s3 = H(this.analysisViewData.plane.origin, i, a4, W());
      this._updateBoundedPlane(s3);
    };
  }
  _onResizeGrab(t8, e3) {
    if ("start" !== t8.action || null == this.analysisViewData.plane || !t8.screenPoint) return;
    const i = m2(this.view.state.camera, t8.screenPoint, xt), a4 = c3.get();
    S2(this.analysisViewData.plane.plane, i, a4) && (Z(this.analysisViewData.plane, this._startPlane), this.inputState = {
      type: "resize",
      activeHandleIdx: e3,
      startPoint: t(a4)
    });
  }
  _createResizeDragPipeline(t8) {
    return p2(t8, (t9, e3, i) => {
      const a4 = this.inputState;
      if (null == a4 || "resize" !== a4.type || null == this.analysisViewData.plane) return;
      const s3 = Z(this.analysisViewData.plane, W());
      e3.next(O2(this.view, this.analysisViewData.plane.plane)).next(this._resizeDragUpdatePlane(a4)), i.next(() => {
        this._updateBoundedPlane(s3);
      });
    });
  }
  _resizeDragUpdatePlane(t8) {
    return (e3) => {
      if (null == this.analysisViewData.plane) return;
      const i = this._resizeHandles[t8.activeHandleIdx], a4 = ri(i, t8.startPoint, e3.renderEnd, this.view.state.camera, this._startPlane, Z(this.analysisViewData.plane));
      this._updateBoundedPlane(a4);
    };
  }
  _updateBoundedPlane(t8) {
    const e3 = this.analysisViewData;
    if (null == e3) throw new Error("valid internal object expected");
    e3.plane = t8;
  }
  _updatePreviewPlane(t8, e3 = {}) {
    let i = this._previewPlane;
    if (this._previewPlane = null, null == t8) return this._removeFrameTask(), void this._updateManipulators();
    if (!this.analysisViewData.plane && this.active) {
      const a4 = null != i ? i : W();
      if (i = null != i ? Z(i, St) : null, this._pickPlane(t8, true, e3, a4)) {
        const t9 = f3;
        let e4 = false;
        null != i && (e4 = P(F(i.plane), F(a4.plane)) < t9 || P(z(c3.get(), i.basis1), z(c3.get(), a4.basis1)) < t9), e4 && (this._previewPlaneOpacity = 0), this._previewPlane = a4;
      }
    }
    null != this._previewPlane && null == this._frameTask && 0 === this._previewPlaneOpacity ? this._frameTask = A({
      update: ({
        deltaTime: t9
      }) => {
        this._previewPlaneOpacity = Math.min(this._previewPlaneOpacity + t9 / (1e3 * p3), 1), this._updateManipulators(), 1 === this._previewPlaneOpacity && this._removeFrameTask();
      }
    }) : null == this._previewPlane && null != this._frameTask ? this._removeFrameTask() : null != this._previewPlane && this._updateManipulators();
  }
  _removeFrameTask() {
    this._frameTask = l(this._frameTask);
  }
  _pickMinResult(t8) {
    const e3 = d2(t8, t3.get());
    return this.view.sceneIntersectionHelper.intersectToolIntersectorScreen(e3, this._intersector), this._intersector.results.min;
  }
  _pickPlane(t8, e3, i, a4) {
    const s3 = this._pickMinResult(t8), n6 = c3.get();
    if (!s3.getIntersectionPoint(n6)) return false;
    const r3 = s3.getTransformedNormal(c3.get()), l3 = this.view.state.camera;
    P(r3, l3.viewForward) > 0 && g(r3, r3, -1);
    const o4 = si(n6, l3), h5 = (e3 ? 1 : -1) * o4 * h3, p4 = g(c3.get(), r3, h5);
    u2(p4, p4, n6);
    const u3 = this.analysis.tiltEnabled ? Mi.TILTED : Mi.HORIZONTAL_OR_VERTICAL, c6 = i[r2] ? Mi.VERTICAL : i[t7] ? Mi.HORIZONTAL : u3;
    return ei(p4, r3, o4, o4, l3, c6, this.view.renderCoordsHelper, a4), true;
  }
  _clearPointerMoveTimeout() {
    this._prevPointerMoveTimeout = l(this._prevPointerMoveTimeout);
  }
  _resetPointerMoveTimeout() {
    this._clearPointerMoveTimeout(), this.shiftManipulator.state |= Ci, this.rotateHeadingManipulator.state |= Ci, this.rotateTiltManipulator.state |= Ci, this._prevPointerMoveTimeout = this._clock.setTimeout(() => {
      this.shiftManipulator.state &= ~Ci, this.rotateHeadingManipulator.state &= ~Ci, this.rotateTiltManipulator.state &= ~Ci;
    }, this._pointerMoveTimerMs);
  }
  _updateManipulators() {
    if (Vt.disableEngineLayers) return;
    let t8, e3 = false;
    if (null != this.analysisViewData.plane) t8 = this.analysisViewData.plane, e3 = false;
    else {
      if (null == this._previewPlane) return this.shiftManipulator.available = false, this.rotateHeadingManipulator.available = false, this.rotateTiltManipulator.available = false, this.resizeManipulators.forEach((t9) => t9.available = false), this._previewPlaneOutlineVisualElement.visible = false, void (this._previewPlaneGridVisualElement.visible = false);
      t8 = this._previewPlane, e3 = true;
    }
    const i = ci(t8, f2.get());
    e3 ? (this.shiftManipulator.available = false, this.rotateHeadingManipulator.available = false, this.rotateTiltManipulator.available = false, this.resizeManipulators.forEach((t9) => t9.available = false), this._previewPlaneOutlineVisualElement.attached = true, this._previewPlaneGridVisualElement.attached = true, this._previewPlaneOutlineVisualElement.visible = true, this._previewPlaneGridVisualElement.visible = true) : (this.shiftManipulator.available = true, this.rotateHeadingManipulator.available = true, this.rotateTiltManipulator.available = this.analysis.tiltEnabled, this.resizeManipulators.forEach((t9) => t9.available = true), ui(this.shiftManipulator, i, t8, this.view.state.camera), mi(this.rotateHeadingManipulator, i, t8, this.view.renderCoordsHelper), pi(this.rotateTiltManipulator, i, t8), this.resizeManipulators.forEach((e4, a5) => gi(e4, this._resizeHandles[a5], i, t8)), this._previewPlaneOutlineVisualElement.visible = false, this._previewPlaneGridVisualElement.visible = false);
    const a4 = o2(c3.get(), s(t8.basis1), s(t8.basis2), 1), s3 = d3(f2.get(), a4), n6 = c2(s3, i, s3);
    this._previewPlaneOutlineVisualElement.transform = n6, this._previewPlaneGridVisualElement.transform = n6, this._updateMaterials();
  }
  _updateMaterials() {
    const t8 = e2(this.view.effectiveTheme);
    t8[3] *= this._previewPlaneOpacity;
    const e3 = t2(t6);
    e3[3] *= this._previewPlaneOpacity, this._previewPlaneOutlineVisualElement.color = t8, this._previewPlaneGridVisualElement.backgroundColor = e3, this._previewPlaneGridVisualElement.gridColor = _;
  }
  _updateManipulatorsInteractive(t8) {
    if (!t8.grabbing) return this.shiftManipulator.interactive = true, this.rotateHeadingManipulator.interactive = true, this.rotateTiltManipulator.interactive = true, void this.resizeManipulators.forEach((t9) => {
      t9.interactive = true;
    });
    this.shiftManipulator.interactive = this.shiftManipulator === t8, this.rotateHeadingManipulator.interactive = this.rotateHeadingManipulator === t8, this.rotateTiltManipulator.interactive = this.rotateTiltManipulator === t8, this.resizeManipulators.forEach((e3) => {
      e3.interactive = e3 === t8;
    });
  }
  testData() {
    return {
      plane: this.analysisViewData.plane,
      setPointerMoveTimerMs: (t8) => {
        this._pointerMoveTimerMs = t8;
      }
    };
  }
};
bt.disableEngineLayers = false, e([y()], bt.prototype, "_clock", void 0), e([y({
  constructOnly: true
})], bt.prototype, "view", void 0), e([y()], bt.prototype, "analysisViewData", void 0), e([y({
  readOnly: true
})], bt.prototype, "state", null), e([y({
  readOnly: true
})], bt.prototype, "cursor", null), e([y()], bt.prototype, "analysis", null), e([y()], bt.prototype, "removeIncompleteOnCancel", void 0), e([y()], bt.prototype, "_layersMode", void 0), e([y()], bt.prototype, "layersMode", null), e([y({
  value: null
})], bt.prototype, "inputState", null), e([y()], bt.prototype, "_isPlacingSlicePlane", null), e([y()], bt.prototype, "_creatingPointerId", null), bt = Vt = e([a("esri.views.3d.analysis.Slice.SliceTool")], bt);
var Tt = bt;
function Et(t8, e3, i, a4) {
  const s3 = ai(i, ds(a4), t8.direction, E()), n6 = n2();
  return S2(s3, t8, n6) ? {
    type: "shift",
    creatingPointerId: e3,
    hasBeenDragged: false,
    shiftPlane: s3,
    depth: 0,
    startPoint: n6
  } : null;
}
function kt(t8) {
  return "mouse" !== t8.pointerType || 0 === t8.button;
}
var St = W();
var xt = m();

// ../../../node_modules/@arcgis/core/views/3d/analysis/Slice/SliceVisualization.js
var b = class extends S {
  constructor(i) {
    super(i), this._gridVisualElement = null, this._outlineVisualElement = null, this.showGrid = false, this.preview = true;
  }
  initialize() {
    const i = this.analysisViewData;
    if (null == i) throw new Error("expected internal object to be valid");
    this._gridVisualElement = ji(this.view), this._outlineVisualElement = Ai(this.view), this.addHandles([d(() => {
      const e3 = null != i.plane && this.analysisViewData.visible, {
        active: t8
      } = this.analysisViewData, {
        preview: s3,
        showGrid: o4,
        view: r3
      } = this, {
        effectiveTheme: l3
      } = r3;
      return {
        visible: e3,
        active: t8,
        preview: s3,
        showGrid: o4,
        gridColor: c4(l3),
        outlineColor: e2(l3)
      };
    }, (i2) => this._updateMaterials(i2), A2), d(() => i.plane, (i2) => this._updatePlane(i2), A2)], "internal");
  }
  destroy() {
    this._gridVisualElement = u(this._gridVisualElement), this._outlineVisualElement = u(this._outlineVisualElement), this.set("view", null);
  }
  _updatePlane(i) {
    if (null == i) return;
    this._gridVisualElement.attached = true, this._outlineVisualElement.attached = true;
    const e3 = o2(c3.get(), s(i.basis1), s(i.basis2), 1), t8 = d3(f2.get(), e3), s3 = ci(i, f2.get()), o4 = c2(t8, s3, t8);
    this._outlineVisualElement.transform = o4, this._gridVisualElement.transform = o4;
  }
  _updateMaterials({
    visible: i,
    active: e3,
    preview: t8,
    showGrid: s3,
    gridColor: o4,
    outlineColor: r3
  }) {
    this._outlineVisualElement.color = r3, this._outlineVisualElement.width = t8 ? M : j, this._outlineVisualElement.stipplePattern = e3 ? null : h(5), this._gridVisualElement.backgroundColor = t6, this._gridVisualElement.gridColor = s3 ? o4 : _, this._gridVisualElement.visible = i, this._outlineVisualElement.visible = i;
  }
};
e([y()], b.prototype, "view", void 0), e([y()], b.prototype, "analysis", void 0), e([y()], b.prototype, "analysisViewData", void 0), e([y()], b.prototype, "showGrid", void 0), e([y()], b.prototype, "preview", void 0), b = e([a("esri.views.3d.analysis.Slice.SliceVisualization")], b);

// ../../../node_modules/@arcgis/core/views/3d/analysis/SliceAnalysisView3D.js
var h4 = class extends s2(S) {
  constructor(s3) {
    super(s3), this.type = "slice-view-3d", this.analysis = null, this.tool = null, this.analysisVisualization = null, this.analysisController = null, this.plane = null, this.active = true;
  }
  initialize() {
    this.analysisVisualization = new b({
      view: this.view,
      analysis: this.analysis,
      analysisViewData: this
    }), this.analysisController = new v3({
      view: this.view,
      analysis: this.analysis,
      analysisViewData: this
    }), this.addHandles(a2(this, Tt));
  }
  destroy() {
    v(this), this.analysisVisualization = u(this.analysisVisualization), this.analysisController = u(this.analysisController);
  }
  get showGrid() {
    return this.analysisVisualization?.showGrid ?? false;
  }
  set showGrid(s3) {
    this.analysisVisualization && (this.analysisVisualization.showGrid = s3);
  }
  get editable() {
    return !this.analysisVisualization.preview;
  }
  set editable(s3) {
    this.analysisVisualization.preview = !s3;
  }
  get testData() {
  }
};
e([y({
  readOnly: true
})], h4.prototype, "type", void 0), e([y({
  constructOnly: true,
  nonNullable: true
})], h4.prototype, "analysis", void 0), e([y()], h4.prototype, "tool", void 0), e([y()], h4.prototype, "plane", void 0), e([y()], h4.prototype, "active", void 0), e([y()], h4.prototype, "showGrid", null), e([y()], h4.prototype, "editable", null), h4 = e([a("esri.views.3d.analysis.SliceAnalysisView3D")], h4);
var c5 = h4;
export {
  c5 as default
};
//# sourceMappingURL=SliceAnalysisView3D-ZVBEIXI6.js.map
