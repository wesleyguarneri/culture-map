import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  V as V3,
  m as m3,
  w
} from "./chunk-W255B427.js";
import {
  r as r3
} from "./chunk-QLFBFOUA.js";
import {
  a as a5,
  v as v2
} from "./chunk-LUQDD4XX.js";
import {
  o as o4
} from "./chunk-2FVMT5KX.js";
import {
  s
} from "./chunk-AOVKCTSO.js";
import {
  x as x2
} from "./chunk-MZ5BWUSD.js";
import {
  t as t5
} from "./chunk-DVWZMNZY.js";
import {
  c
} from "./chunk-6AG7CVLS.js";
import {
  e as e8,
  ee,
  f as f2
} from "./chunk-73EW5OP6.js";
import {
  p as p4
} from "./chunk-J5J3QXIV.js";
import {
  g as g2
} from "./chunk-NCXTRC7L.js";
import {
  f as f3
} from "./chunk-FJ65I6KE.js";
import "./chunk-F2LQGEBE.js";
import "./chunk-7RXQQ22H.js";
import "./chunk-VC76DE2W.js";
import "./chunk-O3EWP5OO.js";
import "./chunk-XUM2DDAI.js";
import {
  a as a4,
  p as p3
} from "./chunk-D7KGWTOO.js";
import "./chunk-SF5T5ZX3.js";
import "./chunk-7ZLUUE5X.js";
import "./chunk-4Y6TKPBN.js";
import {
  i
} from "./chunk-23QWXKUK.js";
import "./chunk-PDKNFFCG.js";
import "./chunk-AP543QXG.js";
import "./chunk-6SSO6SUU.js";
import "./chunk-ATL6GPJC.js";
import "./chunk-IPGNBAEV.js";
import "./chunk-N7TLJ6LV.js";
import "./chunk-VTFYXQEG.js";
import "./chunk-INUNNFZT.js";
import "./chunk-NF2MOJH5.js";
import "./chunk-2NPPOPEZ.js";
import "./chunk-JP4VYCP3.js";
import {
  n as n4
} from "./chunk-BKOZEXTL.js";
import "./chunk-NLRSH3TD.js";
import "./chunk-3Q4YEFJ3.js";
import {
  T,
  e as e7,
  i as i2
} from "./chunk-K6JW77RY.js";
import "./chunk-377KSYNB.js";
import "./chunk-PSH57UZT.js";
import {
  st
} from "./chunk-LEBOC3ZD.js";
import "./chunk-FSYMZVRK.js";
import "./chunk-T4DTOVU4.js";
import "./chunk-TO2KOAJE.js";
import "./chunk-L3REUUFH.js";
import "./chunk-JMJZXQF3.js";
import "./chunk-UT2ZOLZR.js";
import "./chunk-DTMLHZFB.js";
import "./chunk-5G57YAOP.js";
import {
  t as t4
} from "./chunk-YT42IT5O.js";
import {
  n as n3
} from "./chunk-WQIJCG2D.js";
import {
  u as u5
} from "./chunk-WOWVQEU2.js";
import "./chunk-62PN4TEW.js";
import "./chunk-OPXEKSUB.js";
import "./chunk-ZCCDVQ3H.js";
import {
  f,
  t as t3,
  u as u4
} from "./chunk-7VRJFZQR.js";
import "./chunk-4X2M4YSF.js";
import "./chunk-D5RCKR5Z.js";
import "./chunk-N4FQBAT2.js";
import "./chunk-K7U66W6G.js";
import "./chunk-WQMUOLHB.js";
import "./chunk-LVERV6OU.js";
import "./chunk-3FFTEL3W.js";
import "./chunk-4WON4QDF.js";
import "./chunk-45GTM6LF.js";
import "./chunk-XUZTWNKD.js";
import "./chunk-Q5PBA64J.js";
import "./chunk-TIAWSZQK.js";
import "./chunk-KWHFMZEB.js";
import "./chunk-FBMJVQWQ.js";
import "./chunk-WUTM5T74.js";
import "./chunk-RV5QLAWU.js";
import "./chunk-22UDIQGJ.js";
import "./chunk-XFLPRRYT.js";
import "./chunk-Z5ZLX3BE.js";
import "./chunk-23Q4INNG.js";
import "./chunk-LZSSTWLW.js";
import "./chunk-ALQIX2AS.js";
import "./chunk-D3VQCVGJ.js";
import "./chunk-6YHZYHJS.js";
import "./chunk-UVHNQY4M.js";
import "./chunk-FCVY35OB.js";
import "./chunk-TSTMST4X.js";
import "./chunk-I47GCEJP.js";
import "./chunk-LA4GCRJY.js";
import "./chunk-ZTMARHUQ.js";
import "./chunk-P5MJSFMN.js";
import "./chunk-HMPRRFR4.js";
import "./chunk-UE7ZYRIH.js";
import "./chunk-W24M6HII.js";
import "./chunk-FWGI52X4.js";
import "./chunk-E5RXQH35.js";
import "./chunk-62ZEBDPC.js";
import "./chunk-ZFMS3XGM.js";
import "./chunk-QWQJOAVR.js";
import "./chunk-YLQMUXQA.js";
import "./chunk-4U7LUZFD.js";
import "./chunk-T257OY4U.js";
import "./chunk-BMO2W6EC.js";
import "./chunk-QA265FYQ.js";
import "./chunk-HUOFTIIK.js";
import "./chunk-6NVF5BZF.js";
import "./chunk-ZDFN6OZC.js";
import "./chunk-DUV7OLAZ.js";
import "./chunk-KSOKDIBG.js";
import "./chunk-3NWWTJOW.js";
import "./chunk-TRF6JO5N.js";
import "./chunk-ZHVMMFTW.js";
import "./chunk-EPIUUGS2.js";
import "./chunk-TMXHZTIG.js";
import "./chunk-FIQ7DCCC.js";
import {
  h as h4,
  v
} from "./chunk-SNHVHW2N.js";
import {
  M
} from "./chunk-MLTNYBJG.js";
import "./chunk-HVJMAP6C.js";
import "./chunk-MDEPINSI.js";
import "./chunk-QATJRB5Q.js";
import "./chunk-7Z4UWMRU.js";
import "./chunk-YEB36ZCF.js";
import "./chunk-WHVSAUHM.js";
import "./chunk-LQUVB46M.js";
import "./chunk-GHPF24X4.js";
import "./chunk-UC4DX4SE.js";
import "./chunk-44O4APOL.js";
import "./chunk-LCPLUSDH.js";
import "./chunk-KINQ7OJ3.js";
import "./chunk-KYLW5XXS.js";
import "./chunk-B63XAMYJ.js";
import "./chunk-THUD7LGO.js";
import "./chunk-YSJVVDDH.js";
import "./chunk-DLWZ3HVT.js";
import "./chunk-B76NC7GX.js";
import {
  h as h3
} from "./chunk-HFXXFWYN.js";
import {
  F as F3,
  I
} from "./chunk-EXKCGLRO.js";
import "./chunk-WRLGLGM6.js";
import "./chunk-47DYJR3W.js";
import "./chunk-QRWQ6QBB.js";
import {
  a as a3,
  b as b2,
  m as m2
} from "./chunk-ZSJNH2BT.js";
import "./chunk-D3XX7CQS.js";
import "./chunk-ZFES27RA.js";
import "./chunk-XP2AJZUL.js";
import "./chunk-CZA7RDJP.js";
import "./chunk-BCNABTAE.js";
import "./chunk-3PPEJ4QJ.js";
import "./chunk-ZEOLGKXL.js";
import "./chunk-HITI6WDM.js";
import "./chunk-IS4RJOPJ.js";
import "./chunk-XK3CKE5Q.js";
import "./chunk-AMH7CZMY.js";
import "./chunk-7GHUVMBI.js";
import "./chunk-Q5JLNMWZ.js";
import "./chunk-AABDXAD3.js";
import "./chunk-LGS63R4F.js";
import "./chunk-L6FG3WIC.js";
import {
  b,
  k,
  m,
  p as p2
} from "./chunk-6ZLH7XBS.js";
import "./chunk-44ZUWZXU.js";
import {
  F as F2,
  G
} from "./chunk-NAG6YX7T.js";
import "./chunk-NHYYZMJR.js";
import "./chunk-U4EMQMDC.js";
import "./chunk-AVCKPV77.js";
import "./chunk-MNBTLVRM.js";
import "./chunk-GNCXYHNE.js";
import "./chunk-CSK4VZQ7.js";
import {
  t as t2
} from "./chunk-2TNGEJGS.js";
import "./chunk-OYGNGIHQ.js";
import "./chunk-GSG4T2KM.js";
import "./chunk-D7C26LZP.js";
import "./chunk-BZHHBBFX.js";
import "./chunk-GK5M6FUR.js";
import "./chunk-MRP3FBLV.js";
import "./chunk-Y7SJWJAL.js";
import "./chunk-A2FDYA6M.js";
import {
  e as e6
} from "./chunk-YGAXDKHF.js";
import "./chunk-4TOSJLKR.js";
import "./chunk-VZ37C3ID.js";
import "./chunk-Q5TIVVER.js";
import "./chunk-NVOJILW6.js";
import "./chunk-KYPTWEOO.js";
import "./chunk-WVFB3H4O.js";
import "./chunk-C7BQE556.js";
import "./chunk-ZREJ3Y2F.js";
import "./chunk-IR6CVPPC.js";
import "./chunk-BBUQOCRA.js";
import "./chunk-YBUJLIWZ.js";
import "./chunk-DL2B6IFJ.js";
import "./chunk-VOOO6FU5.js";
import "./chunk-IUPJR3FF.js";
import "./chunk-TGZW6QWO.js";
import "./chunk-OYIDHTXG.js";
import {
  u as u3
} from "./chunk-KUBMHTYA.js";
import "./chunk-FP37456K.js";
import "./chunk-VSQZQLTQ.js";
import "./chunk-K43CZ3M5.js";
import "./chunk-6EIBUVMG.js";
import "./chunk-JDVVCQU6.js";
import "./chunk-NXXQ35YM.js";
import {
  V as V2
} from "./chunk-LM3JDV4W.js";
import "./chunk-34V2CLL5.js";
import {
  h as h2
} from "./chunk-BGLJ2FAH.js";
import "./chunk-2EJFYNM7.js";
import "./chunk-ASCK5HJ5.js";
import "./chunk-5X5U7R6O.js";
import "./chunk-XNLAOXPY.js";
import "./chunk-KOI252FF.js";
import "./chunk-I2TVVMQ6.js";
import "./chunk-5EGQYY2H.js";
import "./chunk-JKPUNUQA.js";
import "./chunk-SR7PRON4.js";
import "./chunk-HGHPYGKP.js";
import "./chunk-4DSGTDZJ.js";
import {
  d as d4
} from "./chunk-VYTPFEL2.js";
import "./chunk-RLGDH6IY.js";
import "./chunk-MRPCXIVS.js";
import "./chunk-YTKVV2Y3.js";
import {
  D,
  F,
  j
} from "./chunk-GCVQXAS4.js";
import "./chunk-UFQD6AL4.js";
import "./chunk-EGBDRLCX.js";
import "./chunk-THZPD5CT.js";
import "./chunk-OBCA6CWH.js";
import "./chunk-2JI245BP.js";
import "./chunk-N34BRXVM.js";
import "./chunk-7QV7DHWN.js";
import "./chunk-4L4Y34YK.js";
import "./chunk-BXONKQKI.js";
import "./chunk-2HDBQXAR.js";
import "./chunk-RNF7VOCU.js";
import {
  _
} from "./chunk-TIRJMGGG.js";
import "./chunk-ZDRQSPB6.js";
import "./chunk-DCXDXGAR.js";
import "./chunk-BCCDYCTQ.js";
import "./chunk-AYL3HQHD.js";
import "./chunk-66YQWHHE.js";
import "./chunk-QGBMZIP4.js";
import "./chunk-AOEBZVTA.js";
import "./chunk-2OZSYJDX.js";
import {
  H,
  K,
  U,
  e as e5,
  g,
  p,
  r as r2,
  u as u2,
  x,
  z
} from "./chunk-MZM4INJV.js";
import {
  e as e4,
  n as n2,
  t
} from "./chunk-J4GMQHGL.js";
import "./chunk-MHPE4SZA.js";
import "./chunk-6SSA7P3A.js";
import "./chunk-FQBTLEUI.js";
import "./chunk-GS7Y3YOG.js";
import "./chunk-Y2HYKTTT.js";
import "./chunk-XLEC46FY.js";
import "./chunk-4AZPIP7K.js";
import {
  A,
  P,
  d as d3
} from "./chunk-LZSLQ24Q.js";
import {
  V
} from "./chunk-U3RHUXYK.js";
import "./chunk-7DBI6LQG.js";
import {
  d as d2
} from "./chunk-AUUN7RFQ.js";
import {
  o as o3
} from "./chunk-JAMSDYD6.js";
import "./chunk-PH6NPTP7.js";
import {
  e as e3
} from "./chunk-NUICEVIH.js";
import {
  S,
  r
} from "./chunk-NXK752PZ.js";
import {
  y
} from "./chunk-UVNLCXWD.js";
import "./chunk-PNUA7JOS.js";
import "./chunk-OR2FKGUM.js";
import {
  a3 as a2
} from "./chunk-UDMPWVPF.js";
import "./chunk-XJNKCEWL.js";
import {
  d
} from "./chunk-AIZ3T7E3.js";
import {
  e as e2,
  o as o2
} from "./chunk-6UEMNP3E.js";
import {
  e,
  o,
  u
} from "./chunk-6WGE3IUL.js";
import "./chunk-MLYB2YW4.js";
import {
  a,
  n2 as n
} from "./chunk-6JFGZTLU.js";
import {
  h
} from "./chunk-2ZJE6ZFX.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-XBPEBUD5.js";

// ../../../node_modules/@arcgis/core/views/3d/analysis/LineOfSightAnalysisResult.js
var s2 = class extends S {
  constructor(o5) {
    super(o5), this.target = null, this.intersectedGraphic = null, this.intersectedLocation = null, this.elevationAlignedTargetLocation = null, this.visible = void 0;
  }
};
e3([y()], s2.prototype, "target", void 0), e3([y()], s2.prototype, "intersectedGraphic", void 0), e3([y()], s2.prototype, "intersectedLocation", void 0), e3([y()], s2.prototype, "elevationAlignedTargetLocation", void 0), e3([y({
  type: Boolean
})], s2.prototype, "visible", void 0), s2 = e3([a2("esri.views.3d.analysis.LineOfSightAnalysisResult")], s2);

// ../../../node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightComputation.js
var i3 = class extends S {
  constructor(t6) {
    super(t6), this.elevationAlignedTargetLocation = null, this.inputPoints = {
      isValid: false,
      observer: n2(),
      observerSurfaceNormal: null,
      observerFeatureId: null,
      target: n2(),
      targetSurfaceNormal: null,
      targetFeatureId: null,
      observerAdjusted: n2(),
      targetAdjusted: n2()
    }, this.computationResult = {
      start: n2(),
      end: n2(),
      intersection: n2(),
      isValid: false,
      isTargetVisible: false
    }, this.result = null;
  }
  notifyResultChanged() {
    this.notifyChange("computationResult");
  }
  notifyInputPointsChanged() {
    this.notifyChange("inputPoints");
  }
};
e3([y()], i3.prototype, "target", void 0), e3([y()], i3.prototype, "elevationAlignedTargetLocation", void 0), e3([y()], i3.prototype, "inputPoints", void 0), e3([y()], i3.prototype, "computationResult", void 0), e3([y()], i3.prototype, "result", void 0), i3 = e3([a2("esri.views.3d.analysis.LineOfSight.LineOfSightComputation")], i3);

// ../../../node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightIntersectionResult.js
var m4;
var y2 = m4 = class extends S {
  constructor(r5) {
    super(r5);
  }
  clone() {
    return new m4({
      type: this.type,
      id: a(this.id),
      mapPoint: a(this.mapPoint),
      renderPoint: t(this.renderPoint),
      normal: a(this.normal),
      ray: a(this.ray),
      graphic: this.graphic
    });
  }
  equals(r5) {
    return this.type === r5.type && this.id === r5.id && o(this.mapPoint, r5.mapPoint) && H(this.renderPoint, r5.renderPoint) && h(this.normal, r5.normal) && p2(this.ray, r5.ray) && this.graphic === r5.graphic;
  }
};
e3([y()], y2.prototype, "type", void 0), e3([y({
  constructOnly: true
})], y2.prototype, "id", void 0), e3([y({
  constructOnly: true
})], y2.prototype, "mapPoint", void 0), e3([y({
  constructOnly: true
})], y2.prototype, "renderPoint", void 0), e3([y({
  constructOnly: true
})], y2.prototype, "normal", void 0), e3([y({
  constructOnly: true
})], y2.prototype, "graphic", void 0), e3([y({
  constructOnly: true
})], y2.prototype, "ray", void 0), y2 = m4 = e3([a2("esri.views.3d.analysis.LineOfSight.LineOfSightIntersectionResult")], y2);

// ../../../node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightRayIntersector.js
var C = class extends S {
  constructor(e11) {
    super(e11), this._terrainIntersectionOptionsLayerUids = /* @__PURE__ */ new Set(["terrain"]);
  }
  initialize() {
    this.intersector = T(this.view.state.viewingMode), this.intersector.options.hud = false, this.intersector.options.store = e7.MIN;
  }
  getScreenPointIntersection(e11) {
    const r5 = d4(e11, t2.get()), i5 = g2(this.view.state.camera, r5, T2);
    return this._getRayIntersection(i5);
  }
  _getRayIntersection(e11, r5) {
    if (null == e11 || null == this.view.sceneIntersectionHelper) return null;
    const {
      intersector: t6
    } = this;
    t6.options.store = e7.MIN, this.view.sceneIntersectionHelper.intersectToolIntersectorRay(e11, t6, r5);
    const i5 = t6.results.min, o5 = n2();
    if (!i5.getIntersectionPoint(o5)) return null;
    if (null != r5?.maxDistance && p(o5, e11.origin) > r5.maxDistance ** 2) return null;
    const n5 = this.view.renderCoordsHelper.fromRenderCoords(o5, new _({
      spatialReference: this.view.spatialReference
    })), a6 = t(i5.normal);
    if (a4(i5)) return new y2({
      type: i2.OBJECT,
      id: `${i5.target.layerUid}/${i5.target.nodeIndex}/${i5.target.componentIndex}`,
      mapPoint: n5,
      renderPoint: o5,
      normal: a6,
      ray: b(e11),
      graphic: null
    });
    if (p3(i5)) return new y2({
      type: i2.OBJECT,
      id: `${i5.target.layerUid}/${i5.target.graphicUid}`,
      mapPoint: n5,
      renderPoint: o5,
      normal: a6,
      ray: b(e11),
      graphic: null
    });
    if (n4(i5)) return new y2({
      type: i2.TERRAIN,
      id: i5.target.lij.slice(),
      mapPoint: n5,
      renderPoint: o5,
      normal: a6,
      ray: b(e11),
      graphic: null
    });
    const c3 = m3(i5, this.view);
    if (null != c3) {
      const r6 = c3.layer, t7 = c3.sourceLayer;
      let i6;
      if (t7) {
        if ("scene" === t7.type) i6 = M(c3, t7.objectIdField);
        else i6 = c3.uid;
      } else i6 = c3.uid;
      return new y2({
        type: i2.OBJECT,
        id: `${r6?.uid}/${i6}`,
        mapPoint: n5,
        renderPoint: o5,
        normal: a6,
        ray: b(e11),
        graphic: c3
      });
    }
    return null;
  }
  updateFromGroundIntersection(e11, r5, t6) {
    const i5 = L, o5 = O, s4 = S2, m6 = $;
    r2(o5, e11), this.view.renderCoordsHelper.worldUpAtPosition(o5, s4), z(s4, s4);
    const u8 = this.view.basemapTerrain.visibleElevationBounds, d8 = (r5 >= 0 ? 1 : -1) * ((u8 ? Math.abs(u8.max - u8.min) : 100) + Math.abs(r5));
    g(m6, s4, d8), u2(i5, o5, m6), k(i5, o5, T2);
    const f5 = this._getRayIntersection(T2, {
      include: this._terrainIntersectionOptionsLayerUids,
      maxDistance: d8
    });
    if (null != f5) {
      const e12 = $;
      return g(e12, s4, r5), u2(t6, f5.renderPoint, e12), t(f5.normal);
    }
    return r2(t6, e11), null;
  }
};
e3([y()], C.prototype, "view", void 0), e3([y()], C.prototype, "intersector", void 0), C = e3([a2("esri.views.3d.analysis.LineOfSight.LineOfSightRayIntersector")], C);
var L = n2();
var O = n2();
var S2 = n2();
var $ = n2();
var T2 = m();

// ../../../node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightController.js
var U2 = class extends o3.EventedMixin(S) {
  constructor(e11) {
    super(e11), this.updateOnCameraChange = true, this._observerGroundOffsetRenderSpace = 0, this._effectiveObserverElevationMode = "absolute-height", this._observerFeatureId = null, this._updatingHandles = new h3(), this._frameTask = F3, this._computationHandles = new r(), this._externalObserverUpdate = true;
  }
  initialize() {
    const e11 = this.view.resourceController?.scheduler;
    this._frameTask = e11 ? e11.registerTask(I.LINE_OF_SIGHT_TOOL) : F3, this._intersector = new C({
      view: this.view
    }), this.addHandles([this._connectObserver(), this._connectComputations(), this._connectTargets()]);
  }
  destroy() {
    this._computationHandles.destroy(), this._computations.removeAll(), this._updatingHandles.destroy();
  }
  get updating() {
    return this._frameTask.updating || this._updatingHandles.updating;
  }
  get priority() {
    return this._frameTask.priority;
  }
  set priority(e11) {
    this._frameTask.priority = e11;
  }
  get _computations() {
    return this.analysisViewData.computations;
  }
  get _elevationAlignedObserverPositionRenderSpace() {
    return this.analysisViewData.observerEngineLocation;
  }
  set _elevationAlignedObserverPositionRenderSpace(e11) {
    this.analysisViewData.observerEngineLocation = e11;
  }
  get _screenPixelSize() {
    return this.view.state.camera.computeScreenPixelSizeAt(this._elevationAlignedObserverPositionRenderSpace);
  }
  _computeResult(e11) {
    const t6 = e11.computation, {
      inputPoints: n5,
      computationResult: o5
    } = t6, {
      observerAdjusted: i5,
      targetAdjusted: r5
    } = n5, {
      start: s4,
      end: a6
    } = o5;
    r2(s4, i5), r2(a6, r5);
    this._canCompute(t6) ? this._computeIntersection(e11) : q(e11), t6.notifyResultChanged(), this.emit("result-changed", {
      target: e11.computation.target,
      result: t6.result
    });
  }
  _updateAdjustedPointsFromFeatures(e11) {
    const n5 = this.view, {
      sceneIntersectionHelper: o5
    } = n5, {
      inputPoints: i5
    } = e11, {
      observerAdjusted: r5,
      observerFeatureId: s4,
      targetFeatureId: a6,
      targetAdjusted: l2
    } = i5;
    if (null == s4 && null == a6) return;
    const u8 = x(r5, l2), c3 = this._intersector.intersector, d8 = k(i5.observer, i5.target, Q);
    c3.options.store = e7.ALL, o5.intersectToolIntersectorRay(d8, c3);
    let p5 = null, g3 = null, h6 = null, v3 = null;
    for (const m6 of c3.results.all) {
      const e12 = m3(m6, this.view);
      if (null == e12 || null == m6.distanceInRenderSpace) continue;
      const o6 = t3(e12);
      null != o6 && (null != s4 && o6 === s4 && (null == p5 && (p5 = Z(m6, n5, u8)), m6.distanceInRenderSpace < p5 && (h6 = m6)), null != a6 && o6 === a6 && (null == g3 && (g3 = Z(m6, n5, u8)), null == v3 && m6.distanceInRenderSpace < u8 && u8 - m6.distanceInRenderSpace < g3 && (v3 = m6)));
    }
    null != h6 && h6.getIntersectionPoint(r5) && (i5.observerSurfaceNormal = h6.getTransformedNormal(n2())), null != v3 && v3.getIntersectionPoint(l2) && (i5.targetSurfaceNormal = v3.getTransformedNormal(n2()));
  }
  _adjustStartEndPositions(e11) {
    const t6 = this._screenPixelSize, n5 = this.view, {
      inputPoints: o5
    } = e11, {
      observer: i5,
      observerSurfaceNormal: r5,
      target: s4,
      targetSurfaceNormal: a6,
      observerAdjusted: l2,
      targetAdjusted: u8
    } = o5, c3 = K2;
    r2(l2, i5), r2(u8, s4), this._updateAdjustedPointsFromFeatures(e11), null != r5 ? r2(c3, r5) : e5(c3, u8, l2);
    const d8 = t6;
    z(c3, c3), g(c3, c3, Math.min(d8, 1)), u2(l2, l2, c3), null != a6 ? r2(c3, a6) : e5(c3, l2, u8);
    const p5 = n5.state.camera.computeScreenPixelSizeAt(u8);
    z(c3, c3), g(c3, c3, Math.min(p5, 1)), u2(u8, u8, c3);
  }
  _computeIntersection({
    computation: e11,
    interpolationInfo: t6
  }) {
    const {
      view: n5
    } = this, {
      sceneIntersectionHelper: o5,
      renderCoordsHelper: i5
    } = n5;
    if (null == o5) return;
    const r5 = this._intersector.intersector, {
      computationResult: s4,
      inputPoints: a6
    } = e11, {
      observer: l2,
      target: u8
    } = a6, {
      start: c3,
      end: d8
    } = s4, p5 = k(c3, d8, Q);
    r5.options.store = e7.MIN, o5.intersectToolIntersectorRay(p5, r5);
    const g3 = r5.results.min, m6 = s4.intersection, v3 = K2;
    let f5 = true;
    if (null != g3 && g3.getIntersectionPoint(m6)) {
      r2(t6.originalIntersection, m6), r2(t6.originalObserver, c3), r2(t6.originalTarget, d8), i5.fromRenderCoords(m6, v3, n5.spatialReference);
      const e12 = 1 - U(d8, u8) / U(c3, u8);
      f5 = U(l2, m6) >= e12 * U(l2, u8);
    }
    const _3 = new _(v3, n5.spatialReference);
    {
      const {
        result: t7,
        target: o6
      } = e11;
      null != t7 ? (t7.target = o6, t7.intersectedGraphic = f5 ? null : m3(g3, n5), t7.intersectedLocation = f5 ? null : _3, t7.visible = f5) : e11.result = new s2({
        target: o6,
        elevationAlignedTargetLocation: e11.elevationAlignedTargetLocation,
        intersectedGraphic: f5 ? null : m3(g3, n5),
        intersectedLocation: f5 ? null : _3,
        visible: f5
      });
    }
    s4.isValid = a6.isValid = true, s4.isTargetVisible = f5;
  }
  _canCompute(e11) {
    const t6 = this.analysisViewData.elevationAlignedObserver, n5 = this.view.frustum;
    if (null == t6 || null == e11.elevationAlignedTargetLocation || null == n5) return false;
    const {
      observerAdjusted: o5,
      targetAdjusted: i5
    } = e11.inputPoints, r5 = n5.intersectsPoint(o5), s4 = n5.intersectsPoint(i5);
    return r5 && s4;
  }
  _onObserverPositionChange(e11, n5, o5, i5, r5) {
    if (this._externalObserverUpdate = r5, null == e11) return this.analysisViewData.elevationAlignedObserver = null, void (this._observerFeatureId = null);
    if (null == n5) return t5(this.analysis, e11.spatialReference, n.getLogger(this)), void (this.analysisViewData.elevationAlignedObserver = null);
    const s4 = B(n5, o5), {
      absoluteZ: a6,
      elevation: u8
    } = b2(n5.x, n5.y, n5.z, this.view.spatialReference, this.view, s4), c3 = n5.clone();
    c3.z = a6, this._effectiveObserverElevationMode = s4.mode, this.analysisViewData.elevationAlignedObserver = c3;
    const d8 = n2();
    this.view.renderCoordsHelper.toRenderCoords(c3, d8), this._elevationAlignedObserverPositionRenderSpace = d8, this._observerGroundOffsetRenderSpace = a6 - u8, this._observerFeatureId = t3(i5), this.priority = I.LINE_OF_SIGHT_TOOL_INTERACTIVE;
  }
  _onObserverRenderSpacePositionChangeForComputation(e11, t6, n5, o5, i5) {
    const {
      inputPoints: r5
    } = e11;
    switch (r2(r5.observer, t6), r5.observerFeatureId = i5, r5.observerSurfaceNormal = null, o5) {
      case "on-the-ground":
      case "relative-to-ground": {
        const e12 = this._intersector.updateFromGroundIntersection(r5.observer, n5, r5.observer);
        null == r5.observerFeatureId && (r5.observerSurfaceNormal = e12);
      }
    }
    this._adjustStartEndPositions(e11), e11.notifyInputPointsChanged(), this.priority = I.LINE_OF_SIGHT_TOOL_INTERACTIVE;
  }
  _onTargetPositionChange(e11, n5, o5, i5, r5, s4 = true) {
    const a6 = e11.inputPoints;
    if (s4 && (a6.isValid = false), null == o5) return null != n5 && t5(this.analysis, n5.spatialReference, n.getLogger(this)), e11.elevationAlignedTargetLocation = null, void e11.notifyInputPointsChanged();
    const u8 = B(o5, i5), {
      absoluteZ: c3,
      elevation: d8
    } = b2(o5.x, o5.y, o5.z, this.view.spatialReference, this.view, u8), p5 = o5.clone();
    switch (p5.z = c3, e11.elevationAlignedTargetLocation = p5, this.view.renderCoordsHelper.toRenderCoords(e11.elevationAlignedTargetLocation, a6.target), a6.targetFeatureId = t3(r5), a6.targetSurfaceNormal = null, u8.mode) {
      case "on-the-ground":
      case "relative-to-ground": {
        const e12 = this._intersector.updateFromGroundIntersection(a6.target, c3 - d8, a6.target);
        null == a6.targetFeatureId && (a6.targetSurfaceNormal = e12);
      }
    }
    this._adjustStartEndPositions(e11), e11.notifyInputPointsChanged(), this.priority = I.LINE_OF_SIGHT_TOOL_INTERACTIVE;
  }
  _connectComputationToTarget(e11) {
    return o2([this._updatingHandles.add(() => ({
      computation: e11,
      targetPosition: e11.target.position,
      targetElevationInfo: e11.target.elevationInfo,
      targetFeatureInfo: e11.target.feature,
      projectedTargetPosition: V2(e11.target.position, this.view.spatialReference)
    }), ({
      computation: e12,
      targetPosition: t6,
      targetElevationInfo: n5,
      targetFeatureInfo: o5,
      projectedTargetPosition: i5
    }) => {
      null == i5.pending ? this._onTargetPositionChange(e12, t6, i5.geometry, n5, o5) : this._updatingHandles.addPromise(i5.pending);
    }, P)]);
  }
  _connectComputationToObserver(e11) {
    return this._updatingHandles.add(() => ({
      computation: e11,
      observer: this.analysisViewData.elevationAlignedObserver
    }), ({
      computation: e12
    }) => {
      this._externalObserverUpdate && (e12.inputPoints.isValid = false, e12.notifyInputPointsChanged());
    }, P);
  }
  _connectComputationToRenderSpaceObserver(e11) {
    return this._updatingHandles.add(() => ({
      computation: e11,
      observer: this._elevationAlignedObserverPositionRenderSpace,
      observerGroundOffset: this._observerGroundOffsetRenderSpace,
      observerElevationMode: this._effectiveObserverElevationMode,
      observerFeatureId: this._observerFeatureId
    }), ({
      computation: e12,
      observer: t6,
      observerGroundOffset: n5,
      observerElevationMode: o5,
      observerFeatureId: i5
    }) => {
      this._onObserverRenderSpacePositionChangeForComputation(e12, t6, n5, o5, i5);
    }, P);
  }
  _connectComputationToCamera(e11) {
    return this._updatingHandles.add(() => ({
      camera: this.view.state.camera,
      isDirty: this._isCameraDirty
    }), ({
      isDirty: t6
    }) => {
      !this.updateOnCameraChange || e11.inputPoints.isValid && !t6 || e11.notifyInputPointsChanged();
    });
  }
  _connectComputationToSlicePlane(e11) {
    return this._updatingHandles.add(() => this.view.slicePlane, () => {
      e11.inputPoints.isValid = false, e11.notifyInputPointsChanged();
    });
  }
  _connectComputationToElevation(e11) {
    const t6 = (n5, o5) => {
      const i5 = this.analysis.observer, r5 = e11.target;
      let s4 = null, a6 = null, l2 = null, u8 = null, c3 = null, d8 = null;
      if (null != i5?.position) {
        const e12 = V2(i5.position, this.view.spatialReference);
        if (null != e12.pending) return this._updatingHandles.addPromise(e12.pending), void e12.pending.finally(() => t6(n5, o5));
        s4 = e12.geometry, a6 = i5.elevationInfo, l2 = i5.feature;
      }
      if (null != r5.position) {
        const e12 = V2(r5.position, this.view.spatialReference);
        if (null != e12.pending) return this._updatingHandles.addPromise(e12.pending), void e12.pending.finally(() => t6(n5, o5));
        u8 = e12.geometry, c3 = r5.elevationInfo, d8 = r5.feature;
      }
      null == s4 && null == u8 || (i(n5, o5, W, this.view.spatialReference), null != s4 && F(W, s4) && this._onObserverPositionChange(null != i5 ? i5.position : null, s4, a6, l2, false), null != u8 && F(W, u8) && this._onTargetPositionChange(e11, r5.position, u8, c3, d8, false), null != s4 && null != u8 && j(W, s4, u8) && e11.notifyInputPointsChanged());
    };
    return this.view.elevationProvider.on("elevation-change", ({
      extent: e12,
      spatialReference: n5
    }) => t6(e12, n5));
  }
  _connectComputationToTask(e11) {
    let t6 = null;
    const n5 = {
      computation: e11,
      interpolationInfo: {
        originalIntersection: n2(),
        originalObserver: n2(),
        originalTarget: n2()
      }
    };
    return o2([this._updatingHandles.add(() => e11.inputPoints, () => {
      t6 = e(t6), t6 = d2((e12) => __async(this, null, function* () {
        yield d(this._frameTask.schedule(() => this._computeResult(n5), e12));
      }));
    }, {
      initial: true,
      equals: () => false
    }), e2(() => t6 = e(t6))]);
  }
  _connectComputation(e11) {
    const t6 = this._computationHandles;
    t6.has(e11) || t6.add([this._connectComputationToTarget(e11), this._connectComputationToObserver(e11), this._connectComputationToRenderSpaceObserver(e11), this._connectComputationToCamera(e11), this._connectComputationToSlicePlane(e11), this._connectComputationToElevation(e11), this._connectComputationToTask(e11)], e11);
  }
  _disconnectComputation(e11) {
    this._computationHandles.remove(e11);
  }
  _onComputationCollectionChange({
    added: e11,
    removed: t6
  }) {
    for (const n5 of t6) this._disconnectComputation(n5);
    for (const n5 of e11) this._connectComputation(n5);
  }
  _onTargetCollectionChange({
    added: e11,
    removed: t6
  }) {
    for (const n5 of t6) this._removeTarget(n5);
    for (const n5 of e11) this._addTarget(n5);
  }
  _onCursorTargetChange(e11, t6) {
    null != t6 && this._removeTarget(t6), null != e11 && this._addTarget(e11);
  }
  _addTarget(e11) {
    this._computations.some((t6) => t6.target === e11) || this._computations.add(new i3({
      target: e11
    }));
  }
  _removeTarget(e11) {
    const t6 = this._computations.findIndex((t7) => t7.target === e11);
    this._computations.removeAt(t6);
  }
  _connectObserver() {
    return o2([this._updatingHandles.add(() => ({
      observerPosition: null != this.analysis.observer ? this.analysis.observer.position : null,
      projectedObserverPosition: V2(null != this.analysis.observer ? this.analysis.observer.position : null, this.view.spatialReference),
      observerElevationInfo: null != this.analysis.observer ? this.analysis.observer.elevationInfo : null,
      observerFeatureInfo: null != this.analysis.observer ? this.analysis.observer.feature : null
    }), ({
      observerPosition: e11,
      projectedObserverPosition: t6,
      observerElevationInfo: n5,
      observerFeatureInfo: o5
    }) => {
      null == t6.pending ? this._onObserverPositionChange(e11, t6.geometry, n5, o5, true) : this._updatingHandles.addPromise(t6.pending);
    }, P)]);
  }
  _connectComputations() {
    return this._updatingHandles.addOnCollectionChange(() => this._computations, (e11) => this._onComputationCollectionChange(e11), {
      initial: true,
      final: true
    });
  }
  _connectTargets() {
    return o2([this._updatingHandles.addOnCollectionChange(() => this.analysis.targets, (e11) => this._onTargetCollectionChange(e11), {
      initial: true,
      final: true
    }), this._updatingHandles.add(() => this.analysisViewData.cursorTarget, (e11, t6) => {
      this._onCursorTargetChange(e11, t6);
    })]);
  }
  get _isCameraDirty() {
    const e11 = this.analysisViewData.elevationAlignedObserver, {
      view: t6
    } = this, {
      renderCoordsHelper: n5
    } = t6;
    if (null == e11 || null == n5) return false;
    const o5 = K2;
    n5.toRenderCoords(e11, o5);
    const i5 = t6.state.camera.computeScreenPixelSizeAt(o5);
    return Math.abs((i5 - this._screenPixelSize) / this._screenPixelSize) > J;
  }
};
function Z(e11, t6, n5) {
  if (w(e11)) {
    const o5 = V3(e11, t6);
    if (null != o5) return Math.min(o5 * X, n5);
  }
  return 1e-5 * n5;
}
function B(e11, t6) {
  return e11.hasZ ? t6 ?? {
    mode: "absolute-height",
    offset: 0
  } : {
    mode: "on-the-ground",
    offset: 0
  };
}
function q({
  computation: e11,
  interpolationInfo: t6
}) {
  const {
    computationResult: n5,
    inputPoints: o5
  } = e11, {
    start: i5,
    end: r5,
    intersection: s4
  } = n5, {
    originalIntersection: a6,
    originalObserver: l2,
    originalTarget: u8
  } = t6;
  if (r2(s4, a6), o5.isValid) {
    const e12 = K2, t7 = U(l2, a6) / U(l2, u8);
    K(e12, i5, l2), g(e12, e12, 1 - t7), u2(s4, s4, e12), K(e12, r5, u8), g(e12, e12, t7), u2(s4, s4, e12), n5.isValid = true;
  } else e11.result = null, n5.isValid = false, n5.isTargetVisible = false;
}
e3([y({
  constructOnly: true
})], U2.prototype, "analysis", void 0), e3([y({
  constructOnly: true
})], U2.prototype, "analysisViewData", void 0), e3([y({
  constructOnly: true
})], U2.prototype, "view", void 0), e3([y()], U2.prototype, "updating", null), e3([y()], U2.prototype, "priority", null), e3([y()], U2.prototype, "updateOnCameraChange", void 0), e3([y()], U2.prototype, "_computations", null), e3([y()], U2.prototype, "_elevationAlignedObserverPositionRenderSpace", null), e3([y()], U2.prototype, "_observerGroundOffsetRenderSpace", void 0), e3([y()], U2.prototype, "_effectiveObserverElevationMode", void 0), e3([y()], U2.prototype, "_observerFeatureId", void 0), e3([y()], U2.prototype, "_screenPixelSize", null), e3([y({
  readOnly: true
})], U2.prototype, "_updatingHandles", void 0), e3([y()], U2.prototype, "_frameTask", void 0), e3([y()], U2.prototype, "_isCameraDirty", null), U2 = e3([a2("esri.views.3d.analysis.LineOfSight.LineOfSightController")], U2);
var J = 0.1;
var K2 = n2();
var Q = m();
var W = D();
var X = 0.05;

// ../../../node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightConfiguration.js
var e9 = class {
  constructor() {
    this.glowWidth = 8, this.innerWidth = 0.75;
  }
};
var r4 = new e9();
function s3(o5) {
  const t6 = o5.accentColor;
  return {
    glowColor: t6,
    innerColor: G(t6),
    globalAlpha: 0.75 * t6.a
  };
}
var i4 = class {
  constructor() {
    this.size = 0.5;
  }
};
var c2 = new i4();
function l(o5) {
  return F2(o5.accentColor, 0.75);
}
var h5 = class {
  constructor() {
    this.size = 0.5, this.visibleColor = new u3([3, 252, 111, 0.75]), this.occludedColor = new u3([252, 3, 69, 0.75]), this.undefinedColor = new u3([127, 127, 127, 0.75]);
  }
};
var u6 = new h5();
var d5 = class {
  constructor() {
    this.innerWidth = 2, this.outerWidth = 8, this.visibleInnerColor = new u3([3, 252, 111, 1]), this.visibleOuterColor = new u3([3, 252, 111, 0.15]), this.occludedInnerColor = new u3([252, 3, 69, 1]), this.occludedOuterColor = new u3([252, 3, 69, 0.1]), this.undefinedInnerColor = new u3([255, 255, 255, 1]), this.undefinedOuterColor = new u3([127, 127, 127, 0.2]);
  }
};
var w2 = new d5();

// ../../../node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightManipulators.js
var f4 = class extends ee {
  constructor(e11, i5) {
    const s4 = f2(l(e11.effectiveTheme)), l2 = st(s4, c2.size, 32, 32), f5 = new e8(l2);
    super({
      view: e11,
      renderObjects: [f5],
      metadata: i5,
      elevationInfo: {
        mode: "absolute-height",
        offset: 0
      }
    }), r3(this), this.themeHandle = d3(() => ({
      color: l(e11.effectiveTheme)
    }), (e12) => {
      s4.setParameters(e12);
    });
  }
  destroy() {
    this.themeHandle.remove(), super.destroy();
  }
};
var d6 = class extends ee {
  constructor(e11, t6) {
    const {
      size: o5,
      visibleColor: r5,
      occludedColor: s4,
      undefinedColor: n5
    } = u6;
    super({
      view: e11,
      renderObjects: [u7(o5, r5, u5.Custom1), u7(o5, s4, u5.Custom2), u7(o5, n5, u5.Custom3)],
      metadata: t6,
      elevationInfo: {
        mode: "absolute-height",
        offset: 0
      }
    }), r3(this);
  }
};
function u7(t6, o5, r5) {
  return new e8(st(f2(u3.toUnitRGBA(o5)), t6, 32, 32), r5);
}

// ../../../node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightTool.js
var I2;
!function(e11) {
  e11.Ready = "ready", e11.Creating = "creating", e11.Created = "created";
}(I2 || (I2 = {}));
var O2 = class extends o4 {
  constructor(e11) {
    super(e11), this.removeIncompleteOnCancel = false, this.analysisViewData = null, this._latestPointerMovePointerType = null, this._laserlineVisualElement = null, this._grabbedManipulator = null, this._analysisHandles = new r(), this._updatingHandles = new h3(), this._manipulatorHandles = new r(), this._targetTrackerManipulator = null;
  }
  initialize() {
    this._intersector = new C({
      view: this.view
    }), this.addHandles(d3(() => this.state, (e11) => {
      e11 === I2.Created && this.finishToolCreation();
    }, A)), this._observerManipulator = this._createObserverManipulator(), this._createLaserLine(), this.addHandles([this._updatingHandles.add(() => this.analysisViewData?.elevationAlignedObserver, (e11) => this._onObserverLocationChange(e11), P), this._updatingHandles.add(() => s3(this.view.effectiveTheme), ({
      glowColor: e11,
      innerColor: t6,
      globalAlpha: i5
    }) => this._updateLaserLineStyle(e11, t6, i5), P), this._updatingHandles.add(() => this._laserLineRendererDependencies(), (e11) => this._updateLaserLineRenderer(e11)), this._connectComputations(), this._updatingHandles.addWhen(() => !this._shouldRenderTracker, () => this._clearCursorTracker(), P)]);
  }
  destroy() {
    this._updatingHandles = u(this._updatingHandles), this._manipulatorHandles = u(this._manipulatorHandles), this._analysisHandles = u(this._analysisHandles), this._observerManipulator = null, this._clearCursorTracker(), this._removeLaserLine(), this._intersector = null, this._set("analysis", null);
  }
  get state() {
    return this.active ? this.hasGrabbedManipulators ? I2.Created : I2.Creating : null != this.analysis.observer?.position ? I2.Created : I2.Ready;
  }
  get cursor() {
    return this.active && this._showTracker ? "crosshair" : null;
  }
  get updating() {
    return null != this.analysisViewData && this.analysisViewData.updating || this._updatingHandles.updating;
  }
  get _showTracker() {
    return this.active && "mouse" === this._latestPointerMovePointerType;
  }
  get _shouldRenderTracker() {
    return this._showTracker && null != this.analysis.observer?.position && !this.hasGrabbedManipulators;
  }
  continue() {
    this.view.activeTool = this;
  }
  stop() {
    this.view.activeTool = null;
  }
  onEditableChange() {
    this.analysisViewData.editable = this.internallyEditable;
  }
  onInputEvent(e11) {
    switch (e11.type) {
      case "immediate-double-click":
        this._doubleClickHandler(e11);
        break;
      case "key-down":
        this._keyDownHandler(e11);
        break;
      case "pointer-move":
        this._pointerMoveHandler(e11);
    }
  }
  onInputEventAfter(e11) {
    if ("immediate-click" === e11.type) this._clickHandler(e11);
  }
  onShow() {
  }
  onHide() {
  }
  onDeactivate() {
    this._clearCursorTracker();
  }
  _connectComputations() {
    return this._updatingHandles.addOnCollectionChange(() => this.analysisViewData.computations, (e11) => this._onComputationsCollectionChange(e11), {
      initial: true,
      final: true
    });
  }
  _onComputationsCollectionChange({
    added: e11,
    removed: t6
  }) {
    for (const i5 of t6) this._disconnectComputation(i5);
    for (const i5 of e11) this._connectComputation(i5);
  }
  _connectComputation(e11) {
    if (this.destroyed) return void n.getLogger(this).warn("Attempting to connect an analysis to a destroyed LineOfSight tool. Ignoring.");
    const t6 = this._analysisHandles;
    if (t6.has(e11)) return;
    const i5 = this._createTargetManipulator(e11.target);
    null == this._targetTrackerManipulator && i5.metadata.target === this.analysisViewData.cursorTarget && (this._targetTrackerManipulator = i5, this._targetTrackerManipulator.available = false, this._targetTrackerManipulator.interactive = false, this._updateLaserLineRenderer()), t6.add([this._updatingHandles.add(() => j2(e11), () => D2(i5, e11), P), this._updatingHandles.add(() => e11.elevationAlignedTargetLocation, (e12) => this._onTargetLocationChange(e12, i5), P)], e11);
  }
  _disconnectComputation(e11) {
    if (this.destroyed) return void n.getLogger(this).warn("Attempting to disconnect an analysis from a destroyed LineOfSight tool. Ignoring.");
    this._analysisHandles.remove(e11);
    const t6 = this._getTargetManipulator(e11.target);
    null != t6 && (this.manipulators.remove(t6), this._manipulatorHandles.remove(t6), null != this._targetTrackerManipulator && this._targetTrackerManipulator === t6 && (this._targetTrackerManipulator = null));
  }
  _clearCursorTracker() {
    this.analysisViewData.cursorTarget = u(this.analysisViewData.cursorTarget);
  }
  _createTargetManipulator(e11) {
    const t6 = {
      target: e11,
      type: "target"
    }, i5 = new d6(this.view, t6);
    return this._manipulatorHandles.add([this._createTargetManipulatorDragPipeline(i5), i5.events.on("grab-changed", (e12) => this._manipulatorGrabChanged(i5, e12)), i5.events.on("immediate-click", (e12) => this._manipulatorClick(i5, e12))], i5), this.manipulators.add(i5), null != e11.position ? i5.elevationAlignedLocation = e11.position : i5.available = false, i5;
  }
  _getTargetManipulator(e11) {
    let t6 = null;
    return this.manipulators.forEach((i5) => {
      const a6 = i5.manipulator;
      null == t6 && "target" === a6.metadata.type && a6.metadata.target === e11 && (t6 = a6);
    }), t6;
  }
  _createObserverManipulator() {
    const e11 = new f4(this.view, {
      type: "observer",
      intersection: null
    });
    return this._manipulatorHandles.add([this._createObserverManipulatorDragPipeline(e11), e11.events.on("grab-changed", (t6) => this._manipulatorGrabChanged(e11, t6)), e11.events.on("immediate-click", (t6) => this._manipulatorClick(e11, t6))], e11), this.manipulators.add(e11), e11;
  }
  _screenToIntersection() {
    return (e11) => {
      const t6 = this._intersector.getScreenPointIntersection(e11.screenEnd);
      return null == t6 ? null : __spreadProps(__spreadValues({}, e11), {
        intersection: t6
      });
    };
  }
  _createTargetManipulatorDragPipeline(e11) {
    return p4(e11, (t6, i5, a6) => {
      i5.next(this._screenToIntersection()).next(this._updateTargetDragStep(e11)).next(() => this._updateLaserLineRenderer()), a6.next(R(e11.metadata.target)).next(() => this._updateLaserLineRenderer());
    });
  }
  _createObserverManipulatorDragPipeline(e11) {
    return p4(e11, (e12, t6, i5) => {
      t6.next(this._screenToIntersection()).next(this._updateObserverDragStep()).next(() => this._updateLaserLineRenderer()), i5.next(this._cancelObserverDragStep()).next(() => this._updateLaserLineRenderer());
    });
  }
  _updateObserverDragStep() {
    return (e11) => (null != e11.intersection.mapPoint ? (null == this.analysis.observer && (this.analysis.observer = new u4()), this._updateFromIntersection(this.analysis.observer, e11.intersection)) : this.analysis.observer = null, e11);
  }
  _cancelObserverDragStep() {
    const e11 = null != this.analysis.observer?.position ? this.analysis.observer.clone() : null;
    return (t6) => (this.analysis.observer = e11, t6);
  }
  _updateTargetDragStep(e11) {
    return (t6) => {
      this._updateFromIntersection(e11.metadata.target, t6.intersection);
      const i5 = t6.intersection.mapPoint;
      return null != i5 && (e11.elevationAlignedLocation = i5), t6;
    };
  }
  _manipulatorGrabChanged(e11, t6) {
    switch (t6.action) {
      case "start":
        this._grabbedManipulator = e11;
        break;
      case "end":
        this._grabbedManipulator === e11 && (this._grabbedManipulator = null);
    }
  }
  _laserLineRendererDependencies() {
    return {
      laserlineVisualElement: this._laserlineVisualElement,
      grabbedManipulator: this._grabbedManipulator,
      shouldRenderTracker: this._shouldRenderTracker,
      observerPosition: null != this.analysis.observer ? this.analysis.observer.position : null,
      visible: this.visible
    };
  }
  _updateLaserLineRenderer(e11 = this._laserLineRendererDependencies()) {
    const {
      laserlineVisualElement: t6,
      grabbedManipulator: i5,
      shouldRenderTracker: a6,
      observerPosition: n5,
      visible: r5
    } = e11;
    if (null == t6) return;
    const s4 = null != i5 ? i5 : a6 && null != n5 ? this._targetTrackerManipulator : null;
    null != s4 && r5 ? (t6.visible = true, t6.heightManifoldTarget = s4.renderLocation, s4 !== this._observerManipulator ? t6.lineVerticalPlaneSegment = h4(this._observerManipulator.renderLocation, s4.renderLocation, E) : t6.lineVerticalPlaneSegment = null) : (t6.visible = false, t6.heightManifoldTarget = null, t6.lineVerticalPlaneSegment = null);
  }
  _createLaserLine() {
    this._removeLaserLine();
    const {
      glowWidth: e11,
      innerWidth: t6
    } = r4;
    this._laserlineVisualElement = new c({
      view: this.view,
      attached: true,
      visible: this.visible,
      style: {
        glowWidth: e11,
        innerWidth: t6
      },
      isDecoration: true
    });
  }
  _removeLaserLine() {
    null != this._laserlineVisualElement && (this._laserlineVisualElement.destroy(), this._laserlineVisualElement = null);
  }
  _updateLaserLineStyle(e11, i5, a6) {
    const n5 = this._laserlineVisualElement;
    if (null == n5) return;
    const r5 = n5.style;
    n5.style = __spreadProps(__spreadValues({}, r5), {
      glowColor: u3.toUnitRGB(e11),
      innerColor: u3.toUnitRGB(i5),
      globalAlpha: a6
    });
  }
  _onObserverLocationChange(e11) {
    null != e11 ? (this._observerManipulator.metadata.intersection = null, this._observerManipulator.available = true, this._observerManipulator.elevationAlignedLocation = e11) : this._observerManipulator.available = false;
  }
  _onTargetLocationChange(e11, t6) {
    null != e11 ? (t6.elevationAlignedLocation = e11, t6 !== this._targetTrackerManipulator && (t6.available = true)) : t6.available = false;
  }
  _addPointFromClickEvent(e11) {
    const t6 = this._intersector.getScreenPointIntersection(e11);
    if (null != t6?.mapPoint) if (null != this.analysis.observer?.position) {
      this._clearCursorTracker();
      const e12 = new f();
      this._updateFromIntersection(e12, t6), this.analysis.targets.add(e12);
    } else {
      const e12 = new u4();
      this._updateFromIntersection(e12, t6), this.analysis.observer = e12;
    }
  }
  _clickHandler(e11) {
    this.active && e11.button !== t4.Right && (this._addPointFromClickEvent(n3(e11)), e11.stopPropagation());
  }
  _doubleClickHandler(e11) {
    this.active && e11.button !== t4.Right && (this.stop(), e11.stopPropagation());
  }
  _keyDownHandler(e11) {
    this.active && "Escape" === e11.key && (this.stop(), e11.stopPropagation());
  }
  _pointerMoveHandler(e11) {
    if (this.hasGrabbedManipulators) return;
    if (this._latestPointerMovePointerType = e11.pointerType, this._updateLaserLineRenderer(), !this._showTracker || null == this.analysis.observer?.position) return;
    const t6 = n3(e11), i5 = this._intersector.getScreenPointIntersection(t6);
    null != i5?.mapPoint && (null == this.analysisViewData.cursorTarget && (this.analysisViewData.cursorTarget = new f()), this._updateFromIntersection(this.analysisViewData.cursorTarget, i5), this._updateLaserLineRenderer());
  }
  _updateFromIntersection(e11, t6) {
    if (null == t6.mapPoint) return e11.position = null, e11.elevationInfo = null, void (e11.feature = null);
    switch (t6.type) {
      case i2.OBJECT:
        if (null != t6.graphic) {
          const i6 = t6.graphic, a6 = a3(i6);
          "on-the-ground" === a6.mode && (a6.mode = "relative-to-ground", a6.offset = 0), e11.elevationInfo = new h2(a6), e11.feature = i6;
        } else e11.elevationInfo = null, e11.feature = null;
        break;
      case i2.TERRAIN:
        e11.elevationInfo = new h2({
          mode: "on-the-ground"
        }), e11.feature = null;
        break;
      default:
        e11.elevationInfo = null, e11.feature = null;
    }
    const i5 = t6.mapPoint.clone();
    i5.z = m2(this.view, i5, {
      mode: "absolute-height",
      offset: 0
    }, e11.elevationInfo), e11.position = i5;
  }
  _manipulatorClick(e11, t6) {
    if ("observer" === e11.metadata.type || e11.grabbing || e11.dragging || t6.button !== t4.Right || this.analysis.targets.length <= 1) return;
    const {
      target: i5
    } = e11.metadata;
    this.analysis.targets.remove(i5), t6.stopPropagation();
  }
  get testInfo() {
  }
};
function R(e11) {
  const t6 = e11.position?.clone();
  return (i5) => (e11.position = t6, i5);
}
function D2(e11, t6) {
  const {
    isValid: i5,
    isTargetVisible: a6
  } = t6.computationResult;
  e11.state = i5 ? a6 ? u5.Custom1 : u5.Custom2 : u5.Custom3;
}
function j2(e11) {
  const {
    isValid: t6,
    isTargetVisible: i5
  } = e11.computationResult;
  return {
    isValid: t6,
    isTargetVisible: i5
  };
}
e3([y({
  constructOnly: true
})], O2.prototype, "view", void 0), e3([y({
  constructOnly: true
})], O2.prototype, "analysis", void 0), e3([y({
  readOnly: true
})], O2.prototype, "state", null), e3([y({
  readOnly: true
})], O2.prototype, "cursor", null), e3([y()], O2.prototype, "removeIncompleteOnCancel", void 0), e3([y({
  readOnly: true
})], O2.prototype, "updating", null), e3([y({
  constructOnly: true
})], O2.prototype, "analysisViewData", void 0), e3([y({
  readOnly: true
})], O2.prototype, "_showTracker", null), e3([y()], O2.prototype, "_latestPointerMovePointerType", void 0), e3([y()], O2.prototype, "_shouldRenderTracker", null), e3([y()], O2.prototype, "_laserlineVisualElement", void 0), e3([y()], O2.prototype, "_grabbedManipulator", void 0), O2 = e3([a2("esri.views.3d.analysis.LineOfSight.LineOfSightTool")], O2);
var E = v();

// ../../../node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightVisualElement.js
var e10 = class {
  constructor(e11, i5, t6, s4) {
    this.visibleLineVisualElement = e11, this.occludedLineVisualElement = i5, this.undefinedLineVisualElement = t6, this.targetVisualElement = s4;
  }
  destroy() {
    this.visibleLineVisualElement.destroy(), this.occludedLineVisualElement.destroy(), this.undefinedLineVisualElement.destroy(), this.targetVisualElement.destroy();
  }
};

// ../../../node_modules/@arcgis/core/views/3d/analysis/LineOfSight/LineOfSightVisualization.js
var b3 = class extends S {
  constructor(i5) {
    super(i5), this._lineOfSightVisualElements = new Array(), this._computationHandles = new r(), this._updatingHandles = new h3();
  }
  initialize() {
    this.addHandles(this._connectComputations()), this._createObserverVisualization();
  }
  destroy() {
    this._updatingHandles = u(this._updatingHandles), this._computationHandles = u(this._computationHandles), this._observerVisualElement = u(this._observerVisualElement);
  }
  get visible() {
    return this.analysisViewData.visible;
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get interactiveAndEditable() {
    return this.analysisViewData.interactive && this.analysisViewData.editable;
  }
  get test() {
  }
  _createLineOfSightVisualization() {
    const i5 = w2, e11 = this.view, o5 = this.isDecoration, n5 = {
      view: e11,
      attached: true,
      width: i5.outerWidth,
      innerWidth: i5.innerWidth,
      isDecoration: o5
    }, s4 = u3.toUnitRGBA(i5.visibleOuterColor), r5 = u3.toUnitRGBA(i5.visibleInnerColor), a6 = u3.toUnitRGBA(i5.occludedOuterColor), l2 = u3.toUnitRGBA(i5.occludedInnerColor), c3 = u3.toUnitRGBA(i5.undefinedOuterColor), d8 = u3.toUnitRGBA(i5.undefinedInnerColor), u8 = new f3(__spreadProps(__spreadValues({}, n5), {
      color: s4,
      innerColor: r5
    })), m6 = new f3(__spreadProps(__spreadValues({}, n5), {
      color: a6,
      innerColor: l2
    })), p5 = new f3(__spreadProps(__spreadValues({}, n5), {
      color: c3,
      innerColor: d8
    })), b4 = new x2(__spreadProps(__spreadValues({
      view: e11,
      attached: true
    }, _2), {
      size: 8,
      isDecoration: o5
    })), y4 = new e10(u8, m6, p5, b4);
    return this._lineOfSightVisualElements.push(y4), y4;
  }
  _destroyLineOfSightVisualization(i5) {
    i5.destroy(), this._lineOfSightVisualElements.splice(this._lineOfSightVisualElements.indexOf(i5), 1);
  }
  _updateLineOfSightVisualization(i5, e11, o5) {
    const n5 = w2, {
      computationResult: s4,
      inputPoints: r5
    } = i5, {
      start: a6,
      end: l2,
      intersection: c3,
      isValid: m6,
      isTargetVisible: p5
    } = s4, {
      observer: v3
    } = r5, g3 = V4;
    g3[12] = v3[0], g3[13] = v3[1], g3[14] = v3[2];
    const f5 = e5(y3, a6, v3), b4 = e5(C2, l2, v3), _3 = e5(O3, c3, v3), {
      visibleLineVisualElement: A2,
      occludedLineVisualElement: E2,
      undefinedLineVisualElement: w3,
      targetVisualElement: j3
    } = e11, L2 = null == this.analysisViewData.elevationAlignedObserver || null == i5.elevationAlignedTargetLocation, S3 = this.visible && !L2;
    A2.visible = S3, E2.visible = S3, w3.visible = S3, j3.visible = S3, j3.attached = !o5.interactiveAndEditable, S3 && (A2.geometry = null, E2.geometry = null, w3.geometry = null, j3.geometry = i5.elevationAlignedTargetLocation, m6 ? p5 ? (A2.geometry = [[e4(f5), e4(b4)]], A2.transform = g3, A2.color = u3.toUnitRGBA(n5.visibleOuterColor), j3.color = u3.toUnitRGBA(n5.visibleInnerColor)) : (A2.geometry = [[e4(f5), e4(_3)]], A2.transform = g3, A2.color = u3.toUnitRGBA(n5.occludedOuterColor), E2.geometry = [[e4(_3), e4(b4)]], E2.transform = g3, j3.color = u3.toUnitRGBA(n5.occludedInnerColor)) : (w3.geometry = [[e4(f5), e4(b4)]], w3.transform = g3, j3.color = u3.toUnitRGBA(n5.undefinedInnerColor)));
  }
  _getLineOfSightVisualizationDependencies(i5) {
    const {
      computationResult: t6
    } = i5, {
      occludedOuterColor: e11,
      visibleOuterColor: o5
    } = w2;
    return {
      computationResult: t6,
      occludedOuterColor: e11,
      visibleOuterColor: o5,
      visible: this.visible,
      interactiveAndEditable: this.interactiveAndEditable
    };
  }
  _connectComputation(i5) {
    const t6 = this._computationHandles;
    if (t6.has(i5)) return;
    const e11 = this._createLineOfSightVisualization();
    t6.add([this._updatingHandles.add(() => this._getLineOfSightVisualizationDependencies(i5), (t7) => this._updateLineOfSightVisualization(i5, e11, t7), {
      initial: true,
      equals: () => false
    }), e2(() => this._destroyLineOfSightVisualization(e11))], i5);
  }
  _disconnectComputation(i5) {
    this._computationHandles.remove(i5);
  }
  _connectComputations() {
    return this._updatingHandles.addOnCollectionChange(() => this.analysisViewData.computations, (i5) => this._onComputationsCollectionChange(i5), {
      initial: true,
      final: true
    });
  }
  _onComputationsCollectionChange({
    added: i5,
    removed: t6
  }) {
    for (const e11 of t6) this._disconnectComputation(e11);
    for (const e11 of i5) this._connectComputation(e11);
  }
  _createObserverVisualization() {
    const i5 = u3.toUnitRGBA(w2.visibleInnerColor), e11 = new x2(__spreadProps(__spreadValues({
      view: this.view,
      color: i5
    }, _2), {
      isDecoration: this.isDecoration
    }));
    this._observerVisualElement = e11, this.addHandles(this._updatingHandles.add(() => ({
      observer: this.analysisViewData.elevationAlignedObserver,
      interactiveAndEditable: this.interactiveAndEditable,
      visible: this.visible
    }), ({
      observer: i6,
      interactiveAndEditable: t6,
      visible: o5
    }) => {
      null != i6 && !t6 && o5 ? (e11.geometry = i6, this._observerVisualElement.attached = true) : e11.attached = false;
    }, P));
  }
};
e3([y({
  constructOnly: true
})], b3.prototype, "analysis", void 0), e3([y({
  constructOnly: true
})], b3.prototype, "analysisViewData", void 0), e3([y({
  constructOnly: true
})], b3.prototype, "view", void 0), e3([y({
  readOnly: true
})], b3.prototype, "visible", null), e3([y({
  constructOnly: true
})], b3.prototype, "isDecoration", void 0), e3([y()], b3.prototype, "updating", null), e3([y()], b3.prototype, "interactiveAndEditable", null), e3([y()], b3.prototype, "test", null), b3 = e3([a2("esri.views.3d.analysis.LineOfSight.LineOfSightVisualization")], b3);
var _2 = {
  size: 6,
  pixelSnappingEnabled: false,
  primitive: "circle",
  elevationInfo: {
    mode: "absolute-height",
    offset: 0
  },
  outlineSize: 0
};
var y3 = n2();
var C2 = n2();
var O3 = n2();
var V4 = e6();

// ../../../node_modules/@arcgis/core/views/3d/analysis/LineOfSightAnalysisView3D.js
var m5 = class extends s(o3.EventedMixin(S)) {
  constructor(t6) {
    super(t6), this.type = "line-of-sight-view-3d", this.analysis = null, this.tool = null, this.computations = new V(), this.elevationAlignedObserver = null, this.observerEngineLocation = n2(), this.cursorTarget = null, this.editable = true;
  }
  initialize() {
    const t6 = this.view, i5 = this.analysis;
    this._analysisController = new U2({
      analysis: i5,
      analysisViewData: this,
      view: t6
    }), this._analysisVisualization = new b3({
      analysis: i5,
      analysisViewData: this,
      view: t6,
      isDecoration: !this.parent
    }), this.addHandles([this._analysisController.on("result-changed", (t7) => {
      t7.target !== this.cursorTarget && this.emit("result-changed", t7);
    }), a5(this, O2)]);
  }
  destroy() {
    v2(this), this._analysisController = u(this._analysisController), this._analysisVisualization = u(this._analysisVisualization);
  }
  get results() {
    return this.computations.map((t6) => t6.result);
  }
  get priority() {
    return this._analysisController.priority;
  }
  set priority(t6) {
    this._analysisController.priority = t6;
  }
  get updating() {
    return null != this._analysisController && this._analysisController.updating || null != this._analysisVisualization && this._analysisVisualization.updating;
  }
  getResultForTarget(t6) {
    return this.computations.find((i5) => i5.target === t6)?.result;
  }
  get testInfo() {
  }
};
e3([y({
  readOnly: true
})], m5.prototype, "type", void 0), e3([y({
  constructOnly: true,
  nonNullable: true
})], m5.prototype, "analysis", void 0), e3([y()], m5.prototype, "tool", void 0), e3([y({
  readOnly: true
})], m5.prototype, "results", null), e3([y()], m5.prototype, "priority", null), e3([y()], m5.prototype, "computations", void 0), e3([y()], m5.prototype, "elevationAlignedObserver", void 0), e3([y()], m5.prototype, "observerEngineLocation", void 0), e3([y()], m5.prototype, "cursorTarget", void 0), e3([y()], m5.prototype, "updating", null), e3([y()], m5.prototype, "editable", void 0), e3([y()], m5.prototype, "_analysisController", void 0), e3([y()], m5.prototype, "_analysisVisualization", void 0), m5 = e3([a2("esri.views.3d.analysis.LineOfSightAnalysisView3D")], m5);
var d7 = m5;
export {
  d7 as default
};
//# sourceMappingURL=LineOfSightAnalysisView3D-VPVFQNXM.js.map
