{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/materials/PatternStyle.js", "../../../../../../node_modules/@arcgis/core/chunks/Pattern.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nvar a;\n!function (a) {\n  a[a.Horizontal = 0] = \"Horizontal\", a[a.Vertical = 1] = \"Vertical\", a[a.Cross = 2] = \"Cross\", a[a.ForwardDiagonal = 3] = \"ForwardDiagonal\", a[a.BackwardDiagonal = 4] = \"BackwardDiagonal\", a[a.DiagonalCross = 5] = \"DiagonalCross\", a[a.COUNT = 6] = \"COUNT\";\n}(a || (a = {}));\nexport { a as Style };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { ShaderOutput as e } from \"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";\nimport { SliceDraw as o } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { Transform as r } from \"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";\nimport { ObjectAndLayerIdColor as t } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js\";\nimport { VertexColor as a } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js\";\nimport { OutputHighlight as i } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";\nimport { multipassTerrainTest as l } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";\nimport { VisualVariables as n } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js\";\nimport { symbolAlphaCutoff as c } from \"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";\nimport { ColorConversion as d } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { addProjViewLocalOrigin as s, addCameraPosition as p } from \"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";\nimport { Float4PassUniform as g } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as v } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as u } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as m } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { TransparencyPassType as f } from \"../views/3d/webgl-engine/lib/TransparencyPassType.js\";\nimport { VertexAttribute as w } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nimport { Style as h } from \"../views/3d/webgl-engine/materials/PatternStyle.js\";\nconst b = .70710678118,\n  y = b,\n  C = .08715574274;\nfunction S(S) {\n  const T = new m(),\n    x = S.multipassEnabled && S.output === e.Color,\n    {\n      vertex: P,\n      fragment: R,\n      attributes: A,\n      varyings: V\n    } = T;\n  s(P, S), T.include(r, S), T.include(a, S), T.include(n, S), T.include(t, S), S.draped ? P.uniforms.add(new v(\"worldToScreenRatio\", (e, o) => 1 / o.screenToPCSRatio)) : A.add(w.BOUNDINGRECT, \"mat3\"), A.add(w.POSITION, \"vec3\"), A.add(w.UVMAPSPACE, \"vec4\"), S.vvColor && A.add(w.COLORFEATUREATTRIBUTE, \"float\"), V.add(\"vColor\", \"vec4\"), V.add(\"vpos\", \"vec3\"), V.add(\"vuv\", \"vec2\"), x && V.add(\"depth\", \"float\"), P.uniforms.add(new g(\"uColor\", e => e.color));\n  const $ = S.style === h.ForwardDiagonal || S.style === h.BackwardDiagonal || S.style === h.DiagonalCross;\n  return $ && P.code.add(u`\n      const mat2 rotate45 = mat2(${u.float(b)}, ${u.float(-y)},\n                                 ${u.float(y)}, ${u.float(b)});\n    `), S.draped || (p(P, S), P.uniforms.add(new v(\"worldToScreenPerDistanceRatio\", (e, o) => 1 / o.camera.perScreenPixelRatio)), P.code.add(u`vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {\nfloat projectedLength = dot(halfVector, point - center) / dot(halfVector, halfVector);\nreturn center + halfVector * clamp(projectedLength, -1.0, 1.0);\n}`), P.code.add(u`vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {\nfloat d = dot(planeNormal, planePoint);\nfloat t = (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);\nreturn rayOrigin + t * rayDir;\n}`), P.code.add(u`\n      float boundingRectDistanceToCamera() {\n        vec3 center = vec3(boundingRect[0][0], boundingRect[0][1], boundingRect[0][2]);\n        vec3 halfU = vec3(boundingRect[1][0], boundingRect[1][1], boundingRect[1][2]);\n        vec3 halfV = vec3(boundingRect[2][0], boundingRect[2][1], boundingRect[2][2]);\n        vec3 n = normalize(cross(halfU, halfV));\n\n        vec3 viewDir = - vec3(view[0][2], view[1][2], view[2][2]);\n\n        float viewAngle = dot(viewDir, n);\n        float minViewAngle = ${u.float(C)};\n\n        if (abs(viewAngle) < minViewAngle) {\n          // view direction is (almost) parallel to plane -> clamp it to min angle\n          float normalComponent = sign(viewAngle) * minViewAngle - viewAngle;\n          viewDir = normalize(viewDir + normalComponent * n);\n        }\n\n        // intersect view direction with infinite plane that contains bounding rect\n        vec3 planeProjected = intersectRayPlane(viewDir, cameraPosition, n, center);\n\n        // clip to bounds by projecting to u and v line segments individually\n        vec3 uProjected = projectPointToLineSegment(center, halfU, planeProjected);\n        vec3 vProjected = projectPointToLineSegment(center, halfV, planeProjected);\n\n        // use to calculate the closest point to camera on bounding rect\n        vec3 closestPoint = uProjected + vProjected - center;\n\n        return length(closestPoint - cameraPosition);\n      }\n    `)), P.code.add(u`\n    vec2 scaledUV() {\n      vec2 uv = uvMapSpace.xy ${$ ? \" * rotate45\" : \"\"};\n      vec2 uvCellOrigin = uvMapSpace.zw ${$ ? \" * rotate45\" : \"\"};\n\n      ${S.draped ? \"\" : u`\n            float distanceToCamera = boundingRectDistanceToCamera();\n            float worldToScreenRatio = worldToScreenPerDistanceRatio / distanceToCamera;\n          `}\n\n      // Logarithmically discretize ratio to avoid jittering\n      float step = 0.1;\n      float discreteWorldToScreenRatio = log(worldToScreenRatio);\n      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;\n      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);\n\n      vec2 uvOffset = mod(uvCellOrigin * discreteWorldToScreenRatio, ${u.float(S.patternSpacing)});\n      return uvOffset + (uv * discreteWorldToScreenRatio);\n    }\n  `), P.code.add(u`\n    void main(void) {\n      vuv = scaledUV();\n      vpos = position;\n      ${x ? \"depth = (view * vec4(vpos, 1.0)).z;\" : \"\"}\n      forwardNormalizedVertexColor();\n      forwardObjectAndLayerIdColor();\n      ${S.hasVertexColors ? \"vColor *= uColor;\" : S.vvColor ? \"vColor = uColor * interpolateVVColor(colorFeatureAttribute);\" : \"vColor = uColor;\"}\n      gl_Position = transformPosition(proj, view, vpos);\n    }\n  `), T.include(o, S), R.include(d), S.draped && R.uniforms.add(new v(\"texelSize\", (e, o) => 1 / o.camera.pixelRatio)), S.output === e.Highlight && T.include(i, S), x && T.include(l, S), S.output !== e.Highlight && (R.code.add(u`\n      const float lineWidth = ${u.float(S.lineWidth)};\n      const float spacing = ${u.float(S.patternSpacing)};\n      const float spacingINV = ${u.float(1 / S.patternSpacing)};\n\n      float coverage(float p, float txlSize) {\n        p = mod(p, spacing);\n\n        float halfTxlSize = txlSize / 2.0;\n\n        float start = p - halfTxlSize;\n        float end = p + halfTxlSize;\n\n        float coverage = (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;\n        coverage -= min(lineWidth, mod(start, spacing));\n        coverage -= max(lineWidth - mod(end, spacing), 0.0);\n\n        return coverage / txlSize;\n      }\n    `), S.draped || R.code.add(u`const int maxSamples = 5;\nfloat sampleAA(float p) {\nvec2 dxdy = abs(vec2(dFdx(p), dFdy(p)));\nfloat fwidth = dxdy.x + dxdy.y;\nivec2 samples = 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));\nvec2 invSamples = 1.0 / vec2(samples);\nfloat accumulator = 0.0;\nfor (int j = 0; j < maxSamples; j++) {\nif(j >= samples.y) {\nbreak;\n}\nfor (int i = 0; i < maxSamples; i++) {\nif(i >= samples.x) {\nbreak;\n}\nvec2 step = vec2(i,j) * invSamples - 0.5;\naccumulator += coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);\n}\n}\naccumulator /= float(samples.x * samples.y);\nreturn accumulator;\n}`)), S.transparencyPassType === f.ColorAlpha && (T.outputs.add(\"fragColor\", \"vec4\", 0), T.outputs.add(\"fragAlpha\", \"float\", 1)), R.code.add(u`\n    void main() {\n      discardBySlice(vpos);\n      ${x ? \"terrainDepthTest(depth);\" : \"\"}\n      vec4 color = vColor;\n      color = highlightSlice(color, vpos);\n\n      ${S.output !== e.Highlight ? u`color.a *= ${j(S)};` : \"\"}\n\n      ${S.output === e.ObjectAndLayerIdColor ? u`color.a = 1.0;` : \"\"}\n\n      if (color.a < ${u.float(c)}) {\n        discard;\n      }\n\n      ${S.output === e.Color ? u`fragColor = color; ${S.transparencyPassType === f.ColorAlpha ? u`\n                    fragColor = premultiplyAlpha(fragColor);\n                    fragAlpha = fragColor.a;` : \"\"}` : \"\"}\n      ${S.output === e.Highlight ? u`outputHighlight();` : \"\"}\n      ${S.output === e.ObjectAndLayerIdColor ? u`outputObjectAndLayerIdColor();` : \"\"}\n    }\n  `), T;\n}\nfunction j(e) {\n  function o(o) {\n    return e.draped ? u`coverage(vuv.${o}, texelSize)` : u`sampleAA(vuv.${o})`;\n  }\n  switch (e.style) {\n    case h.ForwardDiagonal:\n    case h.Horizontal:\n      return o(\"y\");\n    case h.BackwardDiagonal:\n    case h.Vertical:\n      return o(\"x\");\n    case h.DiagonalCross:\n    case h.Cross:\n      return u`\n        1.0 - (1.0 - ${o(\"x\")}) * (1.0 - ${o(\"y\")})\n      `;\n    default:\n      return \"0.0\";\n  }\n}\nconst T = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: S\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { T as P, S as b };"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA,IAAIA;AACJ,CAAC,SAAUA,IAAG;AACZ,EAAAA,GAAEA,GAAE,aAAa,CAAC,IAAI,cAAcA,GAAEA,GAAE,WAAW,CAAC,IAAI,YAAYA,GAAEA,GAAE,QAAQ,CAAC,IAAI,SAASA,GAAEA,GAAE,kBAAkB,CAAC,IAAI,mBAAmBA,GAAEA,GAAE,mBAAmB,CAAC,IAAI,oBAAoBA,GAAEA,GAAE,gBAAgB,CAAC,IAAI,iBAAiBA,GAAEA,GAAE,QAAQ,CAAC,IAAI;AACzP,EAAEA,OAAMA,KAAI,CAAC,EAAE;;;ACef,IAAM,IAAI;AAAV,IACE,IAAI;AADN,IAEE,IAAI;AACN,SAAS,EAAEC,IAAG;AACZ,QAAMC,KAAI,IAAIC,GAAE,GACd,IAAIF,GAAE,oBAAoBA,GAAE,WAAWE,GAAE,OACzC;AAAA,IACE,QAAQC;AAAA,IACR,UAAU;AAAA,IACV,YAAY;AAAA,IACZ,UAAU;AAAA,EACZ,IAAIF;AACN,IAAEE,IAAGH,EAAC,GAAGC,GAAE,QAAQC,IAAGF,EAAC,GAAGC,GAAE,QAAQG,IAAGJ,EAAC,GAAGC,GAAE,QAAQ,GAAGD,EAAC,GAAGC,GAAE,QAAQI,IAAGL,EAAC,GAAGA,GAAE,SAASG,GAAE,SAAS,IAAI,IAAID,GAAE,sBAAsB,CAACE,IAAGF,OAAM,IAAIA,GAAE,gBAAgB,CAAC,IAAI,EAAE,IAAI,EAAE,cAAc,MAAM,GAAG,EAAE,IAAI,EAAE,UAAU,MAAM,GAAG,EAAE,IAAI,EAAE,YAAY,MAAM,GAAGF,GAAE,WAAW,EAAE,IAAI,EAAE,uBAAuB,OAAO,GAAG,EAAE,IAAI,UAAU,MAAM,GAAG,EAAE,IAAI,QAAQ,MAAM,GAAG,EAAE,IAAI,OAAO,MAAM,GAAG,KAAK,EAAE,IAAI,SAAS,OAAO,GAAGG,GAAE,SAAS,IAAI,IAAIC,GAAE,UAAU,CAAAA,OAAKA,GAAE,KAAK,CAAC;AACrc,QAAM,IAAIJ,GAAE,UAAUM,GAAE,mBAAmBN,GAAE,UAAUM,GAAE,oBAAoBN,GAAE,UAAUM,GAAE;AAC3F,SAAO,KAAKH,GAAE,KAAK,IAAI;AAAA,mCACU,EAAE,MAAM,CAAC,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC;AAAA,mCAC1B,EAAE,MAAM,CAAC,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AAAA,KACvD,GAAGH,GAAE,WAAW,EAAEG,IAAGH,EAAC,GAAGG,GAAE,SAAS,IAAI,IAAID,GAAE,iCAAiC,CAACE,IAAGF,OAAM,IAAIA,GAAE,OAAO,mBAAmB,CAAC,GAAGC,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA,EAG3I,GAAGA,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA,EAId,GAAGA,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAUe,EAAE,MAAM,CAAC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAoBpC,IAAIA,GAAE,KAAK,IAAI;AAAA;AAAA,gCAEY,IAAI,gBAAgB,EAAE;AAAA,0CACZ,IAAI,gBAAgB,EAAE;AAAA;AAAA,QAExDH,GAAE,SAAS,KAAK;AAAA;AAAA;AAAA,WAGb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uEAQ4D,EAAE,MAAMA,GAAE,cAAc,CAAC;AAAA;AAAA;AAAA,GAG7F,GAAGG,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA,QAIT,IAAI,wCAAwC,EAAE;AAAA;AAAA;AAAA,QAG9CH,GAAE,kBAAkB,sBAAsBA,GAAE,UAAU,iEAAiE,kBAAkB;AAAA;AAAA;AAAA,GAG9I,GAAGC,GAAE,QAAQ,GAAGD,EAAC,GAAG,EAAE,QAAQI,EAAC,GAAGJ,GAAE,UAAU,EAAE,SAAS,IAAI,IAAIE,GAAE,aAAa,CAACE,IAAGF,OAAM,IAAIA,GAAE,OAAO,UAAU,CAAC,GAAGF,GAAE,WAAWE,GAAE,aAAaD,GAAE,QAAQ,GAAGD,EAAC,GAAG,KAAKC,GAAE,QAAQK,IAAGN,EAAC,GAAGA,GAAE,WAAWE,GAAE,cAAc,EAAE,KAAK,IAAI;AAAA,gCACnM,EAAE,MAAMF,GAAE,SAAS,CAAC;AAAA,8BACtB,EAAE,MAAMA,GAAE,cAAc,CAAC;AAAA,iCACtB,EAAE,MAAM,IAAIA,GAAE,cAAc,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAgBzD,GAAGA,GAAE,UAAU,EAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqB7B,IAAIA,GAAE,yBAAyBE,GAAE,eAAeD,GAAE,QAAQ,IAAI,aAAa,QAAQ,CAAC,GAAGA,GAAE,QAAQ,IAAI,aAAa,SAAS,CAAC,IAAI,EAAE,KAAK,IAAI;AAAA;AAAA;AAAA,QAGrI,IAAI,6BAA6B,EAAE;AAAA;AAAA;AAAA;AAAA,QAInCD,GAAE,WAAWE,GAAE,YAAY,eAAe,EAAEF,EAAC,CAAC,MAAM,EAAE;AAAA;AAAA,QAEtDA,GAAE,WAAWE,GAAE,wBAAwB,oBAAoB,EAAE;AAAA;AAAA,sBAE/C,EAAE,MAAM,CAAC,CAAC;AAAA;AAAA;AAAA;AAAA,QAIxBF,GAAE,WAAWE,GAAE,QAAQ,uBAAuBF,GAAE,yBAAyBE,GAAE,aAAa;AAAA;AAAA,gDAEhD,EAAE,KAAK,EAAE;AAAA,QACjDF,GAAE,WAAWE,GAAE,YAAY,wBAAwB,EAAE;AAAA,QACrDF,GAAE,WAAWE,GAAE,wBAAwB,oCAAoC,EAAE;AAAA;AAAA,GAElF,GAAGD;AACN;AACA,SAAS,EAAEG,IAAG;AACZ,WAASF,GAAEA,IAAG;AACZ,WAAOE,GAAE,SAAS,iBAAiBF,EAAC,iBAAiB,iBAAiBA,EAAC;AAAA,EACzE;AACA,UAAQE,GAAE,OAAO;AAAA,IACf,KAAKE,GAAE;AAAA,IACP,KAAKA,GAAE;AACL,aAAOJ,GAAE,GAAG;AAAA,IACd,KAAKI,GAAE;AAAA,IACP,KAAKA,GAAE;AACL,aAAOJ,GAAE,GAAG;AAAA,IACd,KAAKI,GAAE;AAAA,IACP,KAAKA,GAAE;AACL,aAAO;AAAA,uBACUJ,GAAE,GAAG,CAAC,cAAcA,GAAE,GAAG,CAAC;AAAA;AAAA,IAE7C;AACE,aAAO;AAAA,EACX;AACF;AACA,IAAM,IAAI,OAAO,OAAO,OAAO,eAAe;AAAA,EAC5C,WAAW;AAAA,EACX,OAAO;AACT,GAAG,OAAO,aAAa;AAAA,EACrB,OAAO;AACT,CAAC,CAAC;",
  "names": ["a", "S", "T", "o", "P", "e", "d", "a"]
}
