import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  l
} from "./chunk-6A4CZ4JY.js";
import "./chunk-TFW6WS6R.js";
import {
  Ze
} from "./chunk-FJ3AI2QH.js";
import "./chunk-XUSZNRTW.js";
import "./chunk-W26QF64E.js";
import "./chunk-D3XX7CQS.js";
import "./chunk-D5ZVYTUT.js";
import "./chunk-MY2HOJQI.js";
import "./chunk-CAYYEMNX.js";
import "./chunk-6NY22YWY.js";
import "./chunk-JBJJW35I.js";
import "./chunk-PXTZCDRW.js";
import "./chunk-GVEKX2VV.js";
import "./chunk-MM5HQGRH.js";
import "./chunk-JA5GJ7PX.js";
import "./chunk-Q6OCJ3NG.js";
import "./chunk-DD6UQHSS.js";
import "./chunk-FALQTRQL.js";
import "./chunk-GGTDLTZW.js";
import "./chunk-2W7YKBRA.js";
import "./chunk-GLFGRGCP.js";
import "./chunk-WQZJGTGX.js";
import "./chunk-VFQA3B5S.js";
import "./chunk-NOH3NLJ5.js";
import "./chunk-LX5BT6XP.js";
import "./chunk-PLGJMWC5.js";
import "./chunk-UGFQYEND.js";
import "./chunk-XC5RDNAY.js";
import "./chunk-KXVPQVTB.js";
import "./chunk-ARN5GJBK.js";
import "./chunk-MPLS4PY6.js";
import "./chunk-AGBPYPP3.js";
import "./chunk-IKBXTTSU.js";
import "./chunk-VMZV7772.js";
import "./chunk-3FR2T2I2.js";
import "./chunk-LOZRWPGI.js";
import "./chunk-GZ64OOAB.js";
import "./chunk-WR2NVDOI.js";
import "./chunk-EPLJRYUV.js";
import "./chunk-VYRCS5VR.js";
import {
  p
} from "./chunk-OOK3QTWF.js";
import "./chunk-VFYCIIDC.js";
import "./chunk-PQUZDC3L.js";
import "./chunk-UUQ5O7GK.js";
import {
  d
} from "./chunk-6XY35LS7.js";
import "./chunk-T42EJVJR.js";
import "./chunk-D3QK4EV3.js";
import "./chunk-JTDKNK44.js";
import "./chunk-RR7OQLEK.js";
import "./chunk-NAG6YX7T.js";
import "./chunk-WFNAKG2H.js";
import "./chunk-EKHRAAS6.js";
import "./chunk-IEB4ZCRH.js";
import "./chunk-7QOUHKW5.js";
import "./chunk-NHYYZMJR.js";
import "./chunk-WVSTX2NW.js";
import "./chunk-EXPZNTF3.js";
import {
  b
} from "./chunk-ORYC4PVJ.js";
import "./chunk-DXIKKLD7.js";
import "./chunk-VQNXE43R.js";
import "./chunk-VZ37C3ID.js";
import "./chunk-5R3HARKC.js";
import "./chunk-BKSTWG4S.js";
import "./chunk-FSG7HOZQ.js";
import "./chunk-Q5TIVVER.js";
import "./chunk-ZPMUEGLK.js";
import "./chunk-GNFDYYU3.js";
import "./chunk-X36BR2QB.js";
import "./chunk-RGG3YJQA.js";
import "./chunk-GBJYL7OX.js";
import "./chunk-GHKVDSKU.js";
import "./chunk-NVOJILW6.js";
import "./chunk-KYPTWEOO.js";
import "./chunk-WVFB3H4O.js";
import "./chunk-C7BQE556.js";
import "./chunk-ZREJ3Y2F.js";
import "./chunk-IR6CVPPC.js";
import "./chunk-BBUQOCRA.js";
import "./chunk-YBUJLIWZ.js";
import "./chunk-DL2B6IFJ.js";
import "./chunk-VOOO6FU5.js";
import "./chunk-IUPJR3FF.js";
import "./chunk-TGZW6QWO.js";
import "./chunk-OYIDHTXG.js";
import "./chunk-KUBMHTYA.js";
import "./chunk-E5NWFBZG.js";
import "./chunk-FP37456K.js";
import "./chunk-VSQZQLTQ.js";
import "./chunk-K43CZ3M5.js";
import "./chunk-6EIBUVMG.js";
import "./chunk-XCCMILGI.js";
import "./chunk-NBJSAHZT.js";
import "./chunk-BD24XM4D.js";
import "./chunk-NXXQ35YM.js";
import "./chunk-3BXPVUY5.js";
import "./chunk-LM3JDV4W.js";
import "./chunk-34V2CLL5.js";
import "./chunk-CXNERL22.js";
import "./chunk-7V4JSBFA.js";
import "./chunk-REIMIECM.js";
import "./chunk-EO2EW5KR.js";
import "./chunk-JEFPXTYT.js";
import "./chunk-MVS2BECH.js";
import "./chunk-UZ7IOCF3.js";
import "./chunk-OS542PQQ.js";
import "./chunk-3B5GODXR.js";
import "./chunk-NKXXHQDD.js";
import "./chunk-7TBQUMV3.js";
import "./chunk-TPLUZX3A.js";
import "./chunk-BGLJ2FAH.js";
import "./chunk-2EJFYNM7.js";
import "./chunk-DC5LRNPY.js";
import "./chunk-ASCK5HJ5.js";
import "./chunk-5X5U7R6O.js";
import "./chunk-XNLAOXPY.js";
import "./chunk-ZT7V2AVD.js";
import "./chunk-C2OXE4NQ.js";
import "./chunk-KOI252FF.js";
import "./chunk-I2TVVMQ6.js";
import "./chunk-5EGQYY2H.js";
import "./chunk-JKPUNUQA.js";
import "./chunk-SR7PRON4.js";
import "./chunk-HGHPYGKP.js";
import "./chunk-4DSGTDZJ.js";
import "./chunk-VYTPFEL2.js";
import "./chunk-RLGDH6IY.js";
import "./chunk-MRPCXIVS.js";
import "./chunk-YTKVV2Y3.js";
import "./chunk-GCVQXAS4.js";
import "./chunk-UFQD6AL4.js";
import "./chunk-EGBDRLCX.js";
import "./chunk-THZPD5CT.js";
import "./chunk-OBCA6CWH.js";
import "./chunk-2JI245BP.js";
import "./chunk-ZEZ3LI2L.js";
import "./chunk-N34BRXVM.js";
import "./chunk-KETDH2J4.js";
import "./chunk-7QV7DHWN.js";
import {
  m
} from "./chunk-4L4Y34YK.js";
import {
  f as f2,
  h
} from "./chunk-BXONKQKI.js";
import "./chunk-2HDBQXAR.js";
import {
  w
} from "./chunk-RNF7VOCU.js";
import "./chunk-TIRJMGGG.js";
import {
  f
} from "./chunk-ZDRQSPB6.js";
import {
  o
} from "./chunk-DCXDXGAR.js";
import "./chunk-BCCDYCTQ.js";
import "./chunk-AYL3HQHD.js";
import "./chunk-66YQWHHE.js";
import "./chunk-QGBMZIP4.js";
import "./chunk-AOEBZVTA.js";
import "./chunk-2OZSYJDX.js";
import "./chunk-MZM4INJV.js";
import "./chunk-J4GMQHGL.js";
import "./chunk-MHPE4SZA.js";
import "./chunk-6SSA7P3A.js";
import "./chunk-FQBTLEUI.js";
import "./chunk-GS7Y3YOG.js";
import "./chunk-Y2HYKTTT.js";
import {
  I
} from "./chunk-XLEC46FY.js";
import "./chunk-4AZPIP7K.js";
import "./chunk-G73HQZEL.js";
import "./chunk-LZSLQ24Q.js";
import "./chunk-U3RHUXYK.js";
import "./chunk-7DBI6LQG.js";
import "./chunk-AUUN7RFQ.js";
import "./chunk-JAMSDYD6.js";
import "./chunk-PH6NPTP7.js";
import {
  e
} from "./chunk-NUICEVIH.js";
import "./chunk-NXK752PZ.js";
import {
  y
} from "./chunk-UVNLCXWD.js";
import "./chunk-PNUA7JOS.js";
import "./chunk-OR2FKGUM.js";
import {
  a3 as a2
} from "./chunk-UDMPWVPF.js";
import "./chunk-XJNKCEWL.js";
import {
  a,
  k
} from "./chunk-AIZ3T7E3.js";
import "./chunk-6UEMNP3E.js";
import "./chunk-6WGE3IUL.js";
import "./chunk-MLYB2YW4.js";
import {
  s2 as s
} from "./chunk-6JFGZTLU.js";
import {
  has
} from "./chunk-2ZJE6ZFX.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-XBPEBUD5.js";

// ../../../node_modules/@arcgis/core/layers/graphics/sources/CSVSource.js
var c = class extends m {
  constructor(t) {
    super(t), this.type = "csv", this.refresh = k((t2) => __async(this, null, function* () {
      yield this.load();
      const {
        extent: e2,
        timeExtent: o2
      } = yield this._connection.invoke("refresh", t2);
      return e2 && (this.sourceJSON.extent = e2), o2 && (this.sourceJSON.timeInfo.timeExtent = [o2.start, o2.end]), {
        dataChanged: true,
        updates: {
          extent: this.sourceJSON.extent,
          timeInfo: this.sourceJSON.timeInfo
        }
      };
    }));
  }
  load(t) {
    const e2 = null != t ? t.signal : null;
    return this.addResolvingPromise(this._startWorker(e2)), Promise.resolve(this);
  }
  destroy() {
    this._connection?.close(), this._connection = null;
  }
  openPorts() {
    return __async(this, null, function* () {
      return yield this.load(), this._connection.openPorts();
    });
  }
  queryFeatures(_0) {
    return __async(this, arguments, function* (t, e2 = {}) {
      yield this.load(e2);
      const o2 = yield this._connection.invoke("queryFeatures", t ? t.toJSON() : null, e2);
      return d.fromJSON(o2);
    });
  }
  queryFeaturesJSON(_0) {
    return __async(this, arguments, function* (t, e2 = {}) {
      return yield this.load(e2), this._connection.invoke("queryFeatures", t ? t.toJSON() : null, e2);
    });
  }
  queryFeatureCount(_0) {
    return __async(this, arguments, function* (t, e2 = {}) {
      return yield this.load(e2), this._connection.invoke("queryFeatureCount", t ? t.toJSON() : null, e2);
    });
  }
  queryObjectIds(_0) {
    return __async(this, arguments, function* (t, e2 = {}) {
      return yield this.load(e2), this._connection.invoke("queryObjectIds", t ? t.toJSON() : null, e2);
    });
  }
  queryExtent(_0) {
    return __async(this, arguments, function* (t, e2 = {}) {
      yield this.load(e2);
      const o2 = yield this._connection.invoke("queryExtent", t ? t.toJSON() : null, e2);
      return {
        count: o2.count,
        extent: w.fromJSON(o2.extent)
      };
    });
  }
  querySnapping(_0) {
    return __async(this, arguments, function* (t, e2 = {}) {
      return yield this.load(e2), this._connection.invoke("querySnapping", t, e2);
    });
  }
  _startWorker(t) {
    return __async(this, null, function* () {
      this._connection = yield p("CSVSourceWorker", {
        strategy: has("feature-layers-workers") ? "dedicated" : "local",
        signal: t,
        registryTarget: this
      });
      const {
        url: e2,
        delimiter: o2,
        fields: i,
        latitudeField: s2,
        longitudeField: n,
        spatialReference: a3,
        timeInfo: c2
      } = this.loadOptions, l2 = yield this._connection.invoke("load", {
        url: e2,
        customParameters: this.customParameters,
        parsingOptions: {
          delimiter: o2,
          fields: i?.map((t2) => t2.toJSON()),
          latitudeField: s2,
          longitudeField: n,
          spatialReference: a3?.toJSON(),
          timeInfo: c2?.toJSON()
        }
      }, {
        signal: t
      });
      this.locationInfo = l2.locationInfo, this.sourceJSON = l2.layerDefinition, this.delimiter = l2.delimiter;
    });
  }
};
e([y()], c.prototype, "type", void 0), e([y()], c.prototype, "loadOptions", void 0), e([y()], c.prototype, "customParameters", void 0), e([y()], c.prototype, "locationInfo", void 0), e([y()], c.prototype, "sourceJSON", void 0), e([y()], c.prototype, "delimiter", void 0), c = e([a2("esri.layers.graphics.sources.CSVSource")], c);

// ../../../node_modules/@arcgis/core/layers/CSVLayer.js
function h2(e2, r) {
  throw new s(r, `CSVLayer (title: ${e2.title}, id: ${e2.id}) cannot be saved to a portal item`);
}
var m2 = class extends Ze {
  constructor(...e2) {
    super(...e2), this.geometryType = "point", this.capabilities = l(false, false), this.delimiter = null, this.editingEnabled = false, this.fields = null, this.latitudeField = null, this.locationType = "coordinates", this.longitudeField = null, this.operationalLayerType = "CSV", this.outFields = ["*"], this.path = null, this.spatialReference = f.WGS84, this.source = null, this.type = "csv";
  }
  normalizeCtorArgs(e2, t) {
    return "string" == typeof e2 ? __spreadValues({
      url: e2
    }, t) : e2;
  }
  load(e2) {
    const t = null != e2 ? e2.signal : null, i = this.loadFromPortal({
      supportedTypes: ["CSV"],
      supportsData: false
    }, e2).catch(a).then(() => __async(this, null, function* () {
      return this.initLayerProperties(yield this.createGraphicsSource(t));
    }));
    return this.addResolvingPromise(i), Promise.resolve(this);
  }
  get isTable() {
    return this.loaded && null == this.geometryType;
  }
  readWebMapLabelsVisible(e2, t) {
    return null != t.showLabels ? t.showLabels : !!t.layerDefinition?.drawingInfo?.labelingInfo;
  }
  set url(e2) {
    if (!e2) return void this._set("url", e2);
    const t = I(e2);
    this._set("url", t.path), t.query && (this.customParameters = __spreadValues(__spreadValues({}, this.customParameters), t.query));
  }
  createGraphicsSource(e2) {
    return __async(this, null, function* () {
      const t = new c({
        loadOptions: {
          delimiter: this.delimiter,
          fields: this.fields,
          latitudeField: this.latitudeField ?? void 0,
          longitudeField: this.longitudeField ?? void 0,
          spatialReference: this.spatialReference ?? void 0,
          timeInfo: this.timeInfo ?? void 0,
          url: this.url
        },
        customParameters: this.customParameters ?? void 0
      });
      return this._set("source", t), yield t.load({
        signal: e2
      }), this.read({
        locationInfo: t.locationInfo,
        columnDelimiter: t.delimiter
      }, {
        origin: "service",
        url: this.parsedUrl
      }), t;
    });
  }
  queryFeatures(e2, t) {
    return this.load().then(() => this.source.queryFeatures(b.from(e2) || this.createQuery())).then((e3) => {
      if (e3?.features) for (const t2 of e3.features) t2.layer = t2.sourceLayer = this;
      return e3;
    });
  }
  queryObjectIds(e2, t) {
    return this.load().then(() => this.source.queryObjectIds(b.from(e2) || this.createQuery()));
  }
  queryFeatureCount(e2, t) {
    return this.load().then(() => this.source.queryFeatureCount(b.from(e2) || this.createQuery()));
  }
  queryExtent(e2, t) {
    return this.load().then(() => this.source.queryExtent(b.from(e2) || this.createQuery()));
  }
  read(e2, t) {
    super.read(e2, t), t && "service" === t.origin && this.revert(["latitudeField", "longitudeField"], "service");
  }
  write(e2, t) {
    return super.write(e2, __spreadProps(__spreadValues({}, t), {
      writeLayerSchema: true
    }));
  }
  clone() {
    throw new s("csv-layer:clone", `CSVLayer (title: ${this.title}, id: ${this.id}) cannot be cloned`);
  }
  save(e2) {
    return __async(this, null, function* () {
      return h2(this, "csv-layer:save");
    });
  }
  saveAs(e2, t) {
    return __async(this, null, function* () {
      return h2(this, "csv-layer:save-as");
    });
  }
  hasDataChanged() {
    return __async(this, null, function* () {
      try {
        const {
          dataChanged: e2,
          updates: t
        } = yield this.source.refresh(this.customParameters);
        return null != t && this.read(t, {
          origin: "service",
          url: this.parsedUrl,
          ignoreDefaults: true
        }), e2;
      } catch {
      }
      return false;
    });
  }
  _verifyFields() {
  }
  _verifySource() {
  }
  _hasMemorySource() {
    return false;
  }
};
e([y({
  readOnly: true,
  json: {
    read: false,
    write: false
  }
})], m2.prototype, "capabilities", void 0), e([y({
  type: [",", " ", ";", "|", "	"],
  json: {
    read: {
      source: "columnDelimiter"
    },
    write: {
      target: "columnDelimiter",
      ignoreOrigin: true
    }
  }
})], m2.prototype, "delimiter", void 0), e([y({
  readOnly: true,
  type: Boolean,
  json: {
    origins: {
      "web-scene": {
        read: false,
        write: false
      }
    }
  }
})], m2.prototype, "editingEnabled", void 0), e([y({
  json: {
    read: {
      source: "layerDefinition.fields"
    },
    write: {
      target: "layerDefinition.fields"
    }
  }
})], m2.prototype, "fields", void 0), e([y({
  type: Boolean,
  readOnly: true
})], m2.prototype, "isTable", null), e([o("web-map", "labelsVisible", ["layerDefinition.drawingInfo.labelingInfo", "showLabels"])], m2.prototype, "readWebMapLabelsVisible", null), e([y({
  type: String,
  json: {
    read: {
      source: "locationInfo.latitudeFieldName"
    },
    write: {
      target: "locationInfo.latitudeFieldName",
      ignoreOrigin: true
    }
  }
})], m2.prototype, "latitudeField", void 0), e([y({
  type: ["show", "hide"]
})], m2.prototype, "listMode", void 0), e([y({
  type: ["coordinates"],
  json: {
    read: {
      source: "locationInfo.locationType"
    },
    write: {
      target: "locationInfo.locationType",
      ignoreOrigin: true,
      isRequired: true
    }
  }
})], m2.prototype, "locationType", void 0), e([y({
  type: String,
  json: {
    read: {
      source: "locationInfo.longitudeFieldName"
    },
    write: {
      target: "locationInfo.longitudeFieldName",
      ignoreOrigin: true
    }
  }
})], m2.prototype, "longitudeField", void 0), e([y({
  type: ["CSV"]
})], m2.prototype, "operationalLayerType", void 0), e([y()], m2.prototype, "outFields", void 0), e([y({
  type: String,
  json: {
    origins: {
      "web-scene": {
        read: false,
        write: false
      }
    },
    read: false,
    write: false
  }
})], m2.prototype, "path", void 0), e([y({
  json: {
    read: false
  },
  cast: null,
  type: c,
  readOnly: true
})], m2.prototype, "source", void 0), e([y({
  json: {
    read: false
  },
  value: "csv",
  readOnly: true
})], m2.prototype, "type", void 0), e([y({
  json: {
    read: f2,
    write: {
      isRequired: true,
      ignoreOrigin: true,
      writer: h
    }
  }
})], m2.prototype, "url", null), m2 = e([a2("esri.layers.CSVLayer")], m2);
var f3 = m2;
export {
  f3 as default
};
//# sourceMappingURL=CSVLayer-JBGR5QXW.js.map
