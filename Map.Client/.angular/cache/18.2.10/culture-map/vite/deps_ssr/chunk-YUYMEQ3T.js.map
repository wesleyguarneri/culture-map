{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/views/3d/environment/CloudsParameters.js", "../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/TextureCubePassUniform.js", "../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/CloudsParallaxShading.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { clamp as t } from \"../../../core/mathUtils.js\";\nimport { rotate as a } from \"../../../core/libs/gl-matrix-2/math/mat4.js\";\nimport { IDENTITY as i, create as s } from \"../../../core/libs/gl-matrix-2/factories/mat4f64.js\";\nimport { l as e, n as o, j as r, f as h, c as d } from \"../../../chunks/vec32.js\";\nimport { create as n, fromValues as c } from \"../../../core/libs/gl-matrix-2/factories/vec3f64.js\";\nimport { create as F, fromPoints as l, axis as f } from \"../../../geometry/support/axisAngleDegrees.js\";\nimport { earth as p } from \"../../../geometry/support/Ellipsoid.js\";\nimport { CloudsTextureChannels as u, CloudsRenderingStages as _, ensureClouds as D } from \"./CloudsData.js\";\nimport { weatherHeightLimit as m } from \"./weather.js\";\nimport { RenderState as E } from \"../../support/RenderState.js\";\nclass A {\n  constructor() {\n    this.readChannels = u.RG, this.renderingStage = _.FINISHED, this.startTime = 0, this.startTimeHeightFade = 0, this.cameraPositionLastFrame = n(), this.parallax = new C(), this.parallaxNew = new C(), this.pointOnGround = n(), this.fadeMode = O.HIDE, this.fadeFactor = 0, this.opacity = 0;\n  }\n  updateParallax(t) {\n    const s = this.parallax,\n      o = e(t.eye);\n    if (s.radiusCurvatureCorrectionFactor = .84 * Math.sqrt(Math.max(o * o - p.radius * p.radius, 0)) / o, l(g, s.anchorPointClouds, S), a(s.transform, i, S[3], f(S)), this.fadeMode === O.CROSS_FADE) {\n      const t = this.parallaxNew;\n      l(g, t.anchorPointClouds, S), a(t.transform, i, S[3], f(S));\n    }\n  }\n  updateFading(t, a, i, s) {\n    this.isFading && this._advanceFading(i, s), this._evaluateFading(t, a, i);\n  }\n  _evaluateFading(t, a, i) {\n    const s = t.relativeElevation,\n      e = this._calculateDistanceToAnchorPoint(t);\n    if ((s > 1.7 * m || s < -m || e > x) && this.opacity > 0) this._setFade(O.HIDE, i);else if (!this.isFading) if ((s > m || s < -.35 * m || e > M) && this.opacity > 0) this._setFade(O.FADE_OUT, i);else if (s <= m && s >= -.35 * m && a === E.IDLE && D(this.data)) {\n      if (0 === this.opacity) return void this._setFade(O.FADE_IN, i);\n      (e > y || this.renderingStage === _.FADING) && this._setFade(O.CROSS_FADE, i);\n    }\n  }\n  _advanceFading(t, a) {\n    this._switchReadChannels(), this._updateAnchorPoint(), this._advanceFadingFactorAndOpacity(t, a);\n  }\n  _advanceFadingFactorAndOpacity(a, i) {\n    if (this.fadeFactor < 1) return this.fadeFactor = i ? t((a - this.startTime) / (I * i), 0, 1) : 1, this.fadeMode === O.FADE_OUT && (this.opacity = 1 - this.fadeFactor), this.fadeMode === O.FADE_IN && (this.opacity = this.fadeFactor), void (this.fadeMode === O.CROSS_FADE && (this.opacity = 1));\n    this.fadeFactor = 0, this.fadeMode === O.FADE_OUT && (this.opacity = 0), this.fadeMode === O.FADE_IN && (this.opacity = 1), this.fadeMode === O.CROSS_FADE && (this.opacity = 1), this.fadeMode = O.NONE;\n  }\n  _switchReadChannels() {\n    const t = this.fadeMode === O.CROSS_FADE && 1 === this.fadeFactor,\n      a = this.fadeMode === O.FADE_IN && 0 === this.fadeFactor;\n    this.renderingStage === _.FADING && (t || a) && (this.readChannels = 1 - this.readChannels, this.renderingStage = _.FINISHED);\n  }\n  _calculateDistanceToAnchorPoint(t) {\n    return o(this.pointOnGround, t.eye), r(this.pointOnGround, this.pointOnGround, p.radius), e(h(N, this.parallax.anchorPointClouds, this.pointOnGround));\n  }\n  _updateAnchorPoint() {\n    this.fadeMode === O.CROSS_FADE && (0 === this.fadeFactor && d(this.parallaxNew.anchorPointClouds, this.pointOnGround), 1 === this.fadeFactor && d(this.parallax.anchorPointClouds, this.parallaxNew.anchorPointClouds)), this.fadeMode === O.FADE_IN && 0 === this.fadeFactor && d(this.parallax.anchorPointClouds, this.pointOnGround);\n  }\n  _setFade(t, a) {\n    switch (t) {\n      case O.HIDE:\n        this.opacity = 0;\n        break;\n      case O.FADE_OUT:\n        this.opacity = 1;\n        break;\n      case O.FADE_IN:\n        this.opacity = 0;\n        break;\n      case O.CROSS_FADE:\n        this.opacity = 1;\n    }\n    this.fadeMode = t, this.fadeFactor = 0, this.startTime = a;\n  }\n  get isFading() {\n    return this.fadeMode === O.FADE_OUT || this.fadeMode === O.FADE_IN || this.fadeMode === O.CROSS_FADE;\n  }\n}\nvar O;\n!function (t) {\n  t[t.NONE = 0] = \"NONE\", t[t.HIDE = 1] = \"HIDE\", t[t.FADE_OUT = 2] = \"FADE_OUT\", t[t.FADE_IN = 3] = \"FADE_IN\", t[t.CROSS_FADE = 4] = \"CROSS_FADE\";\n}(O || (O = {}));\nclass C {\n  constructor() {\n    this.anchorPointClouds = n(), this.radiusCurvatureCorrectionFactor = 0, this.transform = s();\n  }\n}\nconst g = c(0, 0, 1),\n  S = F(),\n  N = n(),\n  I = 1.25,\n  y = 34e3,\n  M = 64e3,\n  x = 2e5;\nexport { A as CloudsParameters, O as FadeMode, y as crossFadeDistanceThreshold, M as fadeOutDistanceThreshold, x as hideDistanceThreshold };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { Uniform as e } from \"./Uniform.js\";\nimport { BindType as r } from \"../shaderTechnique/BindType.js\";\nclass s extends e {\n  constructor(e, s) {\n    super(e, \"samplerCube\", r.Pass, (r, o, t) => r.bindTexture(e, s(o, t)));\n  }\n}\nexport { s as TextureCubePassUniform };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { clamp as o } from \"../../../../../../core/mathUtils.js\";\nimport { earth as a } from \"../../../../../../geometry/support/Ellipsoid.js\";\nimport { CloudsTextureChannels as t, CloudsRenderingStages as e } from \"../../../../environment/CloudsData.js\";\nimport { FadeMode as r } from \"../../../../environment/CloudsParameters.js\";\nimport { cloudsHeight as i } from \"../../../../environment/weather.js\";\nimport { addMainLightDirection as n, addMainLightIntensity as d } from \"../shading/MainLighting.glsl.js\";\nimport { BooleanPassUniform as c } from \"../../shaderModules/BooleanPassUniform.js\";\nimport { Float3PassUniform as l } from \"../../shaderModules/Float3PassUniform.js\";\nimport { FloatPassUniform as s } from \"../../shaderModules/FloatPassUniform.js\";\nimport { glsl as u } from \"../../shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as C } from \"../../shaderModules/Matrix4PassUniform.js\";\nimport { TextureCubePassUniform as m } from \"../../shaderModules/TextureCubePassUniform.js\";\nfunction v(v) {\n  const R = v.fragment;\n  R.uniforms.add(new C(\"rotationMatrixClouds\", (o, a) => a.cloudsFade.parallax.transform), new C(\"rotationMatrixCloudsCrossFade\", (o, a) => a.cloudsFade.parallaxNew.transform), new l(\"anchorPosition\", (o, a) => a.cloudsFade.parallax.anchorPointClouds), new l(\"anchorPositionCrossFade\", (o, a) => a.cloudsFade.parallaxNew.anchorPointClouds), new s(\"cloudsHeight\", () => i), new s(\"radiusCurvatureCorrectionFactor\", (o, a) => a.cloudsFade.parallax.radiusCurvatureCorrectionFactor), new s(\"totalFadeInOut\", (o, a) => 1 - a.cloudsFade.opacity), new s(\"crossFadeAnchorFactor\", (a, t) => o(t.cloudsFade.fadeFactor, 0, 1)), new m(\"cubeMap\", (o, a) => a.cloudsFade.data?.cubeMap?.colorTexture ?? null), new c(\"crossFade\", (o, a) => a.cloudsFade.fadeMode === r.CROSS_FADE), new c(\"readChannelsRG\", (o, a) => a.cloudsFade.readChannels === t.RG), new c(\"fadeTextureChannels\", (o, a) => a.cloudsFade.renderingStage === e.FADING)), R.constants.add(\"planetRadius\", \"float\", a.radius), R.code.add(u`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos)\n{\nfloat radiusClouds = planetRadius + cloudsHeight;\nfloat B = 2.0 * dot(cameraPosition, dir);\nfloat C = dot(cameraPosition, cameraPosition) - radiusClouds * radiusClouds;\nfloat det = B * B - 4.0 * C;\nfloat pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));\nvec3 intersectionPont = cameraPosition + dir * pointIntDist;\nintersectionPont =  intersectionPont - spherePos;\nreturn intersectionPont;\n}`), R.code.add(u`vec3 correctForPlanetCurvature(vec3 dir)\n{\ndir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;\nreturn dir;\n}`), R.code.add(u`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)\n{\nreturn (rotMat * vec4(inVec, 0.0)).xyz;\n}`), n(R), d(R), R.code.add(u`const float SUNSET_TRANSITION_FACTOR = 0.3;\nconst vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);\nconst float RIM_SCATTERING_FACTOR = 140.0;\nconst float BACKLIGHT_FACTOR = 0.2;\nconst float BACKLIGHT_SCATTERING_FACTOR = 10.0;\nconst float BACKLIGHT_TRANSITION_FACTOR = 0.3;\nvec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds)\n{\nfloat upDotLight = dot(normalize(cameraPosition), normalize(mainLightDirection));\nfloat dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(mainLightDirection)), 0.0);\nfloat sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);\nvec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);\nvec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);\nvec3 combinedLight = clamp((mainLightIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));\nvec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));\nfloat scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);\nfloat rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);\nvec3 directSunScattering = RIM_COLOR * rimLightIntensity * (pow(dirDotLight, RIM_SCATTERING_FACTOR)) * scatteringMod;\nfloat additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;\nreturn vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);\n}`), R.code.add(u`vec4 getCloudData(vec3 rayDir, bool readOtherChannel)\n{\nvec4 cloudData = texture(cubeMap, rayDir);\nfloat mu = dot(rayDir, vec3(0, 0, 1));\nbool readChannels = readChannelsRG ^^ readOtherChannel;\nif (readChannels) {\ncloudData = vec4(vec3(cloudData.r), cloudData.g);\n} else {\ncloudData = vec4(vec3(cloudData.b), cloudData.a);\n}\nif (length(cloudData) == 0.0) {\nreturn vec4(cloudData.rgb, 1.0);\n}\nreturn cloudData;\n}`), R.code.add(u`vec4 renderCloudsNoFade(vec3 worldRay, vec3 cameraPosition)\n{\nvec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);\nvec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));\nvec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\nvec4 cloudData = getCloudData(worldRayRotatedCorrected, false);\nfloat totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);\nif (length(cloudData.rgb) == 0.0) {\ntotalTransmittance = 1.0;\n}\nreturn vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), totalTransmittance);\n}`), R.code.add(u`vec4 renderCloudsCrossFade(vec3 worldRay, vec3 cameraPosition)\n{\nvec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);\nvec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));\nvec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\nvec4 cloudData = getCloudData(worldRayRotatedCorrected, false);\nvec4 cloudColor = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);\nintersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade);\nworldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));\nworldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\ncloudData = getCloudData(worldRayRotatedCorrected, fadeTextureChannels);\nvec4 cloudColorCrossFade = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);\ncloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);\nfloat totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);\nif (length(cloudColor.rgb) == 0.0) {\ntotalTransmittance = 1.0;\n}\nreturn vec4(cloudColor.rgb, totalTransmittance);\n}`), R.code.add(u`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition)\n{\nreturn crossFade ? renderCloudsCrossFade(worldRay, cameraPosition) : renderCloudsNoFade(worldRay, cameraPosition);\n}`);\n}\nexport { v as CloudsParallaxShading };"],
  "mappings": "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",
  "names": ["n", "t", "s", "o", "g", "a", "i", "e", "y", "I", "N", "r", "b", "s", "a", "e", "r", "o", "t", "v", "e", "o", "a", "t", "s", "n"]
}
