import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  a as a2,
  f,
  i as i3,
  i2 as i4,
  u as u4,
  w as w2
} from "./chunk-Q6JOR5GI.js";
import {
  i as i2
} from "./chunk-6JE54UIZ.js";
import {
  t2 as t5,
  u2 as u3
} from "./chunk-XNA3CM7P.js";
import {
  G,
  K
} from "./chunk-TBYDZF6B.js";
import "./chunk-ZCGUBY7N.js";
import "./chunk-BWEUXIU7.js";
import "./chunk-2EXBKB4E.js";
import "./chunk-VN66JXYD.js";
import "./chunk-6U6SXU74.js";
import "./chunk-LJYYJZLF.js";
import {
  P2,
  l as l3
} from "./chunk-D65ISPAR.js";
import "./chunk-SQLC7OUS.js";
import "./chunk-643BP7AU.js";
import "./chunk-UGYP7KWT.js";
import "./chunk-HKIMJMAK.js";
import "./chunk-TB56ZLSL.js";
import "./chunk-NVXUR2U4.js";
import "./chunk-2RZQMCBM.js";
import "./chunk-BZIXBYMC.js";
import "./chunk-K2ZPKMR7.js";
import "./chunk-OPYMVWCV.js";
import "./chunk-U56HLK7D.js";
import "./chunk-23QWXKUK.js";
import "./chunk-PDKNFFCG.js";
import "./chunk-3CXCTPDQ.js";
import "./chunk-IRKNVCIL.js";
import "./chunk-BV256A2V.js";
import "./chunk-KJGRJNY4.js";
import "./chunk-AJ474NL3.js";
import "./chunk-X3HF4XA3.js";
import "./chunk-AP543QXG.js";
import "./chunk-6SSO6SUU.js";
import "./chunk-ATL6GPJC.js";
import {
  c
} from "./chunk-IPGNBAEV.js";
import "./chunk-N7TLJ6LV.js";
import "./chunk-VTFYXQEG.js";
import "./chunk-INUNNFZT.js";
import "./chunk-NF2MOJH5.js";
import "./chunk-2NPPOPEZ.js";
import "./chunk-JP4VYCP3.js";
import "./chunk-BKOZEXTL.js";
import "./chunk-NLRSH3TD.js";
import "./chunk-3Q4YEFJ3.js";
import "./chunk-K6JW77RY.js";
import "./chunk-377KSYNB.js";
import "./chunk-VYDQSSRF.js";
import "./chunk-AL4PULDK.js";
import "./chunk-PSH57UZT.js";
import "./chunk-GRGU5GK7.js";
import "./chunk-AEOIGAYL.js";
import "./chunk-KRRPY5PU.js";
import "./chunk-YUYMEQ3T.js";
import "./chunk-ZTTGFJJT.js";
import "./chunk-TFCCIKDP.js";
import "./chunk-FT6GF7ST.js";
import "./chunk-TNVMQBUP.js";
import "./chunk-GM77XP2M.js";
import "./chunk-JTDHZ664.js";
import "./chunk-4FKLKPBD.js";
import "./chunk-IQWWKVQ4.js";
import "./chunk-4B3LNBOC.js";
import "./chunk-KAKCJGSZ.js";
import "./chunk-LEBOC3ZD.js";
import "./chunk-FSYMZVRK.js";
import {
  C
} from "./chunk-T4DTOVU4.js";
import "./chunk-4EO5HMDC.js";
import "./chunk-GYNRSS5Q.js";
import "./chunk-TO2KOAJE.js";
import "./chunk-JZISCETB.js";
import "./chunk-DM6DHTKZ.js";
import "./chunk-OEBP4L4N.js";
import "./chunk-L3REUUFH.js";
import "./chunk-JMJZXQF3.js";
import "./chunk-UT2ZOLZR.js";
import "./chunk-VH65OWFZ.js";
import "./chunk-DTMLHZFB.js";
import "./chunk-C22SF7N4.js";
import {
  t as t4
} from "./chunk-J53R4G62.js";
import {
  t as t3
} from "./chunk-R7WTJU3N.js";
import {
  l as l2
} from "./chunk-ECUSUVZM.js";
import "./chunk-CQIKG7VH.js";
import "./chunk-XKOGWI3D.js";
import "./chunk-UZL2AATT.js";
import "./chunk-LWIPFUZ3.js";
import "./chunk-JRL65HQ7.js";
import {
  o as o5
} from "./chunk-3ILFY654.js";
import "./chunk-AEX7USXS.js";
import "./chunk-N7GIZJ5Z.js";
import "./chunk-AEJ7YVFP.js";
import "./chunk-CXYUBZAK.js";
import "./chunk-LUORW76W.js";
import "./chunk-OPXEKSUB.js";
import "./chunk-3SFUX3VL.js";
import "./chunk-ZCCDVQ3H.js";
import "./chunk-GJ3FZNZ2.js";
import "./chunk-IIFJBCK7.js";
import "./chunk-PZKTCBLJ.js";
import "./chunk-HRIGBQ5I.js";
import "./chunk-5ZLERKFB.js";
import "./chunk-62NDSO75.js";
import "./chunk-IOTEB5UE.js";
import "./chunk-MOCYVZAJ.js";
import "./chunk-N4FQBAT2.js";
import "./chunk-K7U66W6G.js";
import "./chunk-WQMUOLHB.js";
import "./chunk-LVERV6OU.js";
import "./chunk-3FFTEL3W.js";
import "./chunk-4WON4QDF.js";
import "./chunk-45GTM6LF.js";
import "./chunk-XUZTWNKD.js";
import "./chunk-Q5PBA64J.js";
import "./chunk-TIAWSZQK.js";
import "./chunk-KWHFMZEB.js";
import "./chunk-FBMJVQWQ.js";
import "./chunk-WUTM5T74.js";
import "./chunk-ONVI4SC3.js";
import "./chunk-PEIYDOPW.js";
import "./chunk-JA3N2M36.js";
import "./chunk-TV5XWCY5.js";
import "./chunk-6CEQ5OKG.js";
import "./chunk-ARXBOZID.js";
import "./chunk-HFMWGPCY.js";
import "./chunk-H6YDISWJ.js";
import "./chunk-2IRGMYX2.js";
import "./chunk-EJJ75QBE.js";
import "./chunk-OU2TYICP.js";
import "./chunk-DZAXDRPA.js";
import "./chunk-RV5QLAWU.js";
import "./chunk-T7SGV75D.js";
import "./chunk-HRVAAVBD.js";
import "./chunk-7GRSBOIB.js";
import "./chunk-AA5NMQ6N.js";
import "./chunk-Z4PRO5ND.js";
import "./chunk-MHGADXDL.js";
import "./chunk-VYJ7IUDT.js";
import "./chunk-2ZXVDYHF.js";
import "./chunk-TYNTF5BJ.js";
import "./chunk-22UDIQGJ.js";
import "./chunk-XFLPRRYT.js";
import "./chunk-Z5ZLX3BE.js";
import "./chunk-23Q4INNG.js";
import "./chunk-LZSSTWLW.js";
import "./chunk-ALQIX2AS.js";
import "./chunk-D3VQCVGJ.js";
import "./chunk-PFTDB6ZJ.js";
import "./chunk-6YHZYHJS.js";
import "./chunk-UVHNQY4M.js";
import "./chunk-FCVY35OB.js";
import "./chunk-TSTMST4X.js";
import "./chunk-I47GCEJP.js";
import "./chunk-LA4GCRJY.js";
import "./chunk-ZTMARHUQ.js";
import "./chunk-P5MJSFMN.js";
import "./chunk-HMPRRFR4.js";
import "./chunk-UE7ZYRIH.js";
import {
  t as t2
} from "./chunk-W24M6HII.js";
import "./chunk-FWGI52X4.js";
import "./chunk-E5RXQH35.js";
import "./chunk-62ZEBDPC.js";
import "./chunk-ZFMS3XGM.js";
import "./chunk-QWQJOAVR.js";
import "./chunk-YLQMUXQA.js";
import "./chunk-4U7LUZFD.js";
import "./chunk-T257OY4U.js";
import "./chunk-BMO2W6EC.js";
import "./chunk-QA265FYQ.js";
import "./chunk-HUOFTIIK.js";
import "./chunk-5JRJJYA6.js";
import "./chunk-4J7E4E75.js";
import "./chunk-4XL4QIZH.js";
import "./chunk-6NVF5BZF.js";
import "./chunk-ZDFN6OZC.js";
import "./chunk-DUV7OLAZ.js";
import "./chunk-KSOKDIBG.js";
import "./chunk-3NWWTJOW.js";
import "./chunk-TRF6JO5N.js";
import "./chunk-ZHVMMFTW.js";
import {
  h
} from "./chunk-C7GHK6X7.js";
import "./chunk-C2EMSI4B.js";
import "./chunk-KSVRNA4R.js";
import "./chunk-4UXMYOWI.js";
import "./chunk-2H3S7IXI.js";
import "./chunk-2B3WLK32.js";
import "./chunk-JARG4EKD.js";
import "./chunk-YT63GLYW.js";
import "./chunk-AD33ZJKF.js";
import "./chunk-A2RMQRQR.js";
import "./chunk-FEREHKJY.js";
import "./chunk-EPIUUGS2.js";
import "./chunk-2CXNO3UO.js";
import "./chunk-EJXWYKCR.js";
import "./chunk-CE7BUKSQ.js";
import "./chunk-NOVQFMBE.js";
import "./chunk-TMXHZTIG.js";
import "./chunk-FIQ7DCCC.js";
import "./chunk-SNHVHW2N.js";
import "./chunk-REW5WWC2.js";
import "./chunk-SSFPH7CE.js";
import {
  Z
} from "./chunk-MLTNYBJG.js";
import "./chunk-HVJMAP6C.js";
import "./chunk-FWYSNIVU.js";
import "./chunk-MDEPINSI.js";
import "./chunk-Q2RVB4BK.js";
import "./chunk-SKOGSS6Z.js";
import "./chunk-G3WMCIUE.js";
import "./chunk-WS7U2AGS.js";
import "./chunk-U4NXHH3L.js";
import "./chunk-2LHHRVKS.js";
import "./chunk-QATJRB5Q.js";
import "./chunk-7Z4UWMRU.js";
import "./chunk-IQEF4U4C.js";
import "./chunk-KB6CBN72.js";
import "./chunk-BCMXVFG5.js";
import "./chunk-FB2GCV4L.js";
import "./chunk-NOBDTR4N.js";
import "./chunk-5RF6XDV4.js";
import "./chunk-Q47GASPN.js";
import "./chunk-YEB36ZCF.js";
import "./chunk-BFSKQ7XP.js";
import "./chunk-WHVSAUHM.js";
import "./chunk-LQUVB46M.js";
import "./chunk-GHPF24X4.js";
import "./chunk-PK6A5N2R.js";
import "./chunk-UC4DX4SE.js";
import "./chunk-44O4APOL.js";
import "./chunk-LCPLUSDH.js";
import "./chunk-KINQ7OJ3.js";
import "./chunk-KYLW5XXS.js";
import "./chunk-MIIC4I55.js";
import "./chunk-B63XAMYJ.js";
import "./chunk-THUD7LGO.js";
import "./chunk-A45QR3VT.js";
import "./chunk-MYCEJRPQ.js";
import {
  e as e3,
  t
} from "./chunk-YSJVVDDH.js";
import "./chunk-53Z6KOJR.js";
import "./chunk-DLWZ3HVT.js";
import "./chunk-B76NC7GX.js";
import "./chunk-HFXXFWYN.js";
import "./chunk-BY3XBMAH.js";
import "./chunk-OO7WNZEW.js";
import "./chunk-LU7PU2CS.js";
import "./chunk-4O23HCRT.js";
import "./chunk-BYXMUOMW.js";
import "./chunk-YEWOBDQB.js";
import "./chunk-FWEBARAB.js";
import "./chunk-RHUWRAPT.js";
import "./chunk-VY63YX6I.js";
import {
  I
} from "./chunk-EXKCGLRO.js";
import "./chunk-WRLGLGM6.js";
import "./chunk-47DYJR3W.js";
import "./chunk-NE35ZNG6.js";
import "./chunk-ZLSZAC2I.js";
import "./chunk-QRWQ6QBB.js";
import "./chunk-TFW6WS6R.js";
import "./chunk-X5QZGB37.js";
import "./chunk-T5C2TZNO.js";
import "./chunk-AOGKNBDG.js";
import "./chunk-F4FQ67JP.js";
import "./chunk-FDI2X6GO.js";
import "./chunk-3XHDZQO5.js";
import "./chunk-2BLQXT54.js";
import "./chunk-JSWVKNBA.js";
import "./chunk-LL33G4DK.js";
import "./chunk-CILHMGNK.js";
import "./chunk-UZFXFPGS.js";
import "./chunk-BK3AMA5C.js";
import "./chunk-2BOKEEZV.js";
import {
  u as u2
} from "./chunk-VENH3UKS.js";
import "./chunk-ZSJNH2BT.js";
import "./chunk-GGTDLTZW.js";
import {
  d as d3
} from "./chunk-2W7YKBRA.js";
import "./chunk-KXVPQVTB.js";
import "./chunk-ARN5GJBK.js";
import "./chunk-MPLS4PY6.js";
import "./chunk-AGBPYPP3.js";
import "./chunk-3FR2T2I2.js";
import "./chunk-GZ64OOAB.js";
import "./chunk-WR2NVDOI.js";
import "./chunk-EPLJRYUV.js";
import "./chunk-VYRCS5VR.js";
import "./chunk-OOK3QTWF.js";
import "./chunk-VFYCIIDC.js";
import "./chunk-6XY35LS7.js";
import "./chunk-JTDKNK44.js";
import "./chunk-RR7OQLEK.js";
import {
  A as A2,
  N,
  Q,
  Y,
  te
} from "./chunk-ZWAQV54Z.js";
import "./chunk-5PXOWPHT.js";
import "./chunk-OGKROLZ3.js";
import "./chunk-BHG37GSO.js";
import "./chunk-QI5HKZYN.js";
import "./chunk-RIZOHDTP.js";
import {
  n as n5
} from "./chunk-ZFES27RA.js";
import {
  e as e2
} from "./chunk-XP2AJZUL.js";
import "./chunk-CZA7RDJP.js";
import "./chunk-FYE6XHDR.js";
import "./chunk-NCMX3DAD.js";
import "./chunk-BCNABTAE.js";
import "./chunk-3PPEJ4QJ.js";
import "./chunk-ZEOLGKXL.js";
import "./chunk-HITI6WDM.js";
import "./chunk-IS4RJOPJ.js";
import "./chunk-XK3CKE5Q.js";
import "./chunk-AMH7CZMY.js";
import "./chunk-EAVSYZXD.js";
import "./chunk-7GHUVMBI.js";
import "./chunk-Q5JLNMWZ.js";
import "./chunk-AABDXAD3.js";
import "./chunk-LGS63R4F.js";
import "./chunk-L6FG3WIC.js";
import "./chunk-6ZLH7XBS.js";
import "./chunk-44ZUWZXU.js";
import "./chunk-NAG6YX7T.js";
import "./chunk-EKHRAAS6.js";
import "./chunk-IEB4ZCRH.js";
import "./chunk-7QOUHKW5.js";
import "./chunk-NHYYZMJR.js";
import "./chunk-U4EMQMDC.js";
import "./chunk-WVSTX2NW.js";
import "./chunk-MKFGPBQ3.js";
import {
  J
} from "./chunk-AVCKPV77.js";
import {
  s
} from "./chunk-MNBTLVRM.js";
import "./chunk-GNCXYHNE.js";
import "./chunk-CSK4VZQ7.js";
import "./chunk-2TNGEJGS.js";
import "./chunk-OYGNGIHQ.js";
import "./chunk-GSG4T2KM.js";
import "./chunk-D7C26LZP.js";
import "./chunk-BZHHBBFX.js";
import "./chunk-GK5M6FUR.js";
import "./chunk-MRP3FBLV.js";
import "./chunk-Y7SJWJAL.js";
import "./chunk-A2FDYA6M.js";
import "./chunk-YGAXDKHF.js";
import "./chunk-4TOSJLKR.js";
import "./chunk-EXPZNTF3.js";
import {
  b
} from "./chunk-ORYC4PVJ.js";
import "./chunk-DXIKKLD7.js";
import "./chunk-VQNXE43R.js";
import "./chunk-VZ37C3ID.js";
import "./chunk-5R3HARKC.js";
import "./chunk-BKSTWG4S.js";
import "./chunk-FSG7HOZQ.js";
import "./chunk-Q5TIVVER.js";
import "./chunk-ZPMUEGLK.js";
import "./chunk-GNFDYYU3.js";
import "./chunk-X36BR2QB.js";
import "./chunk-RGG3YJQA.js";
import "./chunk-GBJYL7OX.js";
import "./chunk-GHKVDSKU.js";
import {
  d as d2
} from "./chunk-NVOJILW6.js";
import "./chunk-KYPTWEOO.js";
import "./chunk-WVFB3H4O.js";
import "./chunk-C7BQE556.js";
import "./chunk-ZREJ3Y2F.js";
import "./chunk-IR6CVPPC.js";
import "./chunk-BBUQOCRA.js";
import "./chunk-YBUJLIWZ.js";
import "./chunk-DL2B6IFJ.js";
import "./chunk-VOOO6FU5.js";
import "./chunk-IUPJR3FF.js";
import "./chunk-TGZW6QWO.js";
import "./chunk-OYIDHTXG.js";
import "./chunk-KUBMHTYA.js";
import "./chunk-NU4K6CTR.js";
import "./chunk-42ZAWY2C.js";
import {
  S
} from "./chunk-TVHVZK5G.js";
import "./chunk-P2MUOE6G.js";
import "./chunk-CRYYUS4E.js";
import "./chunk-V33IUWAS.js";
import "./chunk-E5NWFBZG.js";
import "./chunk-FP37456K.js";
import "./chunk-VSQZQLTQ.js";
import "./chunk-K43CZ3M5.js";
import "./chunk-6EIBUVMG.js";
import "./chunk-UAETKRWQ.js";
import "./chunk-YCXNHEGB.js";
import "./chunk-CSATD3VX.js";
import "./chunk-NXXQ35YM.js";
import "./chunk-LM3JDV4W.js";
import {
  o as o4
} from "./chunk-34V2CLL5.js";
import "./chunk-CXNERL22.js";
import "./chunk-7V4JSBFA.js";
import "./chunk-KAHESDP5.js";
import "./chunk-ONRZ4VTT.js";
import "./chunk-JEFPXTYT.js";
import "./chunk-MVS2BECH.js";
import "./chunk-TPLUZX3A.js";
import "./chunk-2EJFYNM7.js";
import "./chunk-DC5LRNPY.js";
import "./chunk-ASCK5HJ5.js";
import "./chunk-5X5U7R6O.js";
import "./chunk-XNLAOXPY.js";
import "./chunk-ZT7V2AVD.js";
import "./chunk-C2OXE4NQ.js";
import "./chunk-KOI252FF.js";
import "./chunk-I2TVVMQ6.js";
import "./chunk-5EGQYY2H.js";
import "./chunk-JKPUNUQA.js";
import "./chunk-SR7PRON4.js";
import "./chunk-HGHPYGKP.js";
import "./chunk-4DSGTDZJ.js";
import "./chunk-VYTPFEL2.js";
import "./chunk-RLGDH6IY.js";
import "./chunk-MRPCXIVS.js";
import "./chunk-YTKVV2Y3.js";
import "./chunk-GCVQXAS4.js";
import "./chunk-UFQD6AL4.js";
import "./chunk-EGBDRLCX.js";
import "./chunk-THZPD5CT.js";
import "./chunk-OBCA6CWH.js";
import "./chunk-2JI245BP.js";
import "./chunk-CBOFHWPI.js";
import "./chunk-ABIG6PT5.js";
import "./chunk-ZEZ3LI2L.js";
import "./chunk-N34BRXVM.js";
import "./chunk-KETDH2J4.js";
import "./chunk-7QV7DHWN.js";
import "./chunk-4L4Y34YK.js";
import "./chunk-BXONKQKI.js";
import "./chunk-2HDBQXAR.js";
import {
  i,
  o as o2
} from "./chunk-RNF7VOCU.js";
import "./chunk-TIRJMGGG.js";
import "./chunk-ZDRQSPB6.js";
import "./chunk-DCXDXGAR.js";
import "./chunk-BCCDYCTQ.js";
import "./chunk-AYL3HQHD.js";
import "./chunk-66YQWHHE.js";
import {
  n as n4
} from "./chunk-QGBMZIP4.js";
import "./chunk-AOEBZVTA.js";
import "./chunk-2OZSYJDX.js";
import {
  o as o3
} from "./chunk-MZM4INJV.js";
import {
  l,
  n as n3
} from "./chunk-J4GMQHGL.js";
import "./chunk-MHPE4SZA.js";
import "./chunk-6SSA7P3A.js";
import "./chunk-FQBTLEUI.js";
import "./chunk-GS7Y3YOG.js";
import "./chunk-Y2HYKTTT.js";
import "./chunk-XLEC46FY.js";
import "./chunk-4AZPIP7K.js";
import "./chunk-G73HQZEL.js";
import {
  P,
  d
} from "./chunk-LZSLQ24Q.js";
import "./chunk-U3RHUXYK.js";
import "./chunk-7DBI6LQG.js";
import "./chunk-AUUN7RFQ.js";
import {
  o
} from "./chunk-JAMSDYD6.js";
import "./chunk-PH6NPTP7.js";
import {
  e
} from "./chunk-NUICEVIH.js";
import "./chunk-NXK752PZ.js";
import {
  y
} from "./chunk-UVNLCXWD.js";
import "./chunk-PNUA7JOS.js";
import "./chunk-OR2FKGUM.js";
import {
  a3 as a,
  n as n2
} from "./chunk-UDMPWVPF.js";
import "./chunk-XJNKCEWL.js";
import "./chunk-AIZ3T7E3.js";
import "./chunk-6UEMNP3E.js";
import {
  u
} from "./chunk-6WGE3IUL.js";
import "./chunk-MLYB2YW4.js";
import {
  n2 as n
} from "./chunk-6JFGZTLU.js";
import {
  A2 as A,
  w
} from "./chunk-2ZJE6ZFX.js";
import {
  __async
} from "./chunk-XBPEBUD5.js";

// ../../../node_modules/@arcgis/core/views/3d/layers/I3SPointsWorkerHandle.js
var r = class extends h {
  constructor(e4) {
    super("SceneLayerWorker", "dracoDecompressPointCloudData", {
      dracoDecompressPointCloudData: (e5) => [e5.geometryBuffer]
    }, e4, {
      hasInitialize: true
    });
  }
};

// ../../../node_modules/@arcgis/core/views/3d/layers/i3s/I3SGraphicsMap.js
var s2 = class extends o {
  constructor(e4, t6) {
    super(), this._updateAndCompare = e4, this._notifyUpdated = t6, this._nodes = /* @__PURE__ */ new Map(), this._graphics = /* @__PURE__ */ new Map(), this._duplicates = /* @__PURE__ */ new Map();
  }
  clear() {
    if (this._graphics.size > 0) {
      const e4 = this.toArray();
      this._graphics.clear(), this.emit("change", {
        added: [],
        removed: e4
      });
    }
    this._nodes.clear();
  }
  get length() {
    return this._graphics.size;
  }
  get(e4) {
    return this._graphics.get(e4);
  }
  getNode(e4) {
    return this._nodes.get(e4);
  }
  hasNode(e4) {
    return this._nodes.has(e4);
  }
  nodes() {
    return this._nodes.values();
  }
  addNode(e4, t6) {
    this._nodes.set(e4, t6);
    const s3 = t6.graphics;
    if (0 === s3.length) return;
    const i5 = /* @__PURE__ */ new Set();
    for (let o6 = 0; o6 < s3.length; o6++) {
      const t7 = s3[o6], n7 = t7.objectId, h2 = this._graphics.get(n7);
      if (h2) {
        i5.add(n7), t7 !== h2 && (s3[o6] = h2);
        const r2 = this._duplicates.get(n7);
        r2 ? r2.push(e4) : this._duplicates.set(n7, [h2.nodeIndex, e4]);
      } else t7.nodeIndex = e4, this._graphics.set(n7, t7);
    }
    i5.size && this._updateForeignGraphics(t6);
    const n6 = i5.size > 0 ? s3.filter((e5) => !i5.has(e5.objectId)) : s3;
    n6.length > 0 && this.emit("change", {
      added: n6,
      removed: []
    });
  }
  removeNode(e4) {
    const t6 = this._nodes.get(e4);
    if (!t6) return;
    this._nodes.delete(e4);
    const s3 = /* @__PURE__ */ new Set(), i5 = [];
    for (const n6 of t6.graphics) {
      const t7 = n6.objectId, o6 = this._graphics.get(t7);
      if (!o6) continue;
      const h2 = this._duplicates.get(t7);
      if (h2) {
        const i6 = h2.indexOf(e4);
        if (-1 === i6) continue;
        if (h2.splice(i6, 1), o6.nodeIndex === e4) {
          let e5 = this.getNode(h2[0]);
          for (let t8 = 1; t8 < h2.length; t8++) {
            const s4 = this.getNode(h2[t8]);
            (null == e5 || null != s4 && s4.node.level > e5.node.level) && (e5 = s4);
          }
          null != e5 && s3.add(e5);
        }
        1 === h2.length && this._duplicates.delete(t7);
      } else this._graphics.delete(t7), i5.push(n6);
    }
    i5.length > 0 && this.emit("change", {
      added: [],
      removed: i5
    }), s3.forEach((e5) => this._updateForeignGraphics(e5));
  }
  _updateForeignGraphics(e4) {
    const t6 = [], s3 = e4.node.index, i5 = e4.node.level;
    let n6 = 0;
    for (; n6 < e4.graphics.length; ) {
      const o6 = e4.graphics[n6].nodeIndex;
      if (o6 === s3) {
        n6++;
        continue;
      }
      let h2 = 1;
      for (; n6 + h2 < e4.graphics.length && e4.graphics[n6 + h2].nodeIndex === o6; ) h2++;
      const r2 = this.getNode(o6);
      if (null != r2 && r2.node.level > i5) n6 += h2;
      else {
        for (let i6 = n6; i6 < n6 + h2; i6++) {
          const n7 = e4.graphics[i6];
          n7.nodeIndex = s3, this._updateAndCompare(n7, e4, i6) && t6.push(n7);
        }
        n6 += h2;
      }
    }
    t6.length > 0 && this._notifyUpdated(t6);
  }
  toArray() {
    return Array.from(this._graphics.values());
  }
  find(e4) {
    let s3;
    return n2(this._graphics, (t6) => !!e4(t6) && (s3 = t6, true)), s3;
  }
  forEach(e4) {
    this._graphics.forEach((t6) => e4(t6));
  }
  forEachNode(e4) {
    this._nodes.forEach((t6, s3) => e4(t6, s3));
  }
  get nodeCount() {
    return this._nodes.size;
  }
  _checkInvariants() {
    const e4 = /* @__PURE__ */ new Map();
    this._nodes.forEach((t6, s3) => {
      t6.graphics.forEach((t7) => {
        e4.set(t7.objectId, 1 + (e4.get(t7.objectId) ?? 0)), this._duplicates.get(t7.objectId);
      });
    }), e4.forEach((e5, t6) => {
      const s3 = this._graphics.get(t6);
      if (!s3) return;
      if (!this._nodes.get(s3.nodeIndex)) return;
      const i5 = this._duplicates.get(t6);
      i5 && i5.forEach((e6) => {
        this._nodes.get(e6);
      });
    });
  }
};

// ../../../node_modules/@arcgis/core/views/3d/layers/SceneLayerGraphicsView3D.js
var re = i4();
var ie = class {
  constructor(e4, t6, r2, i5) {
    this.graphics = e4, this.featureIds = t6, this.attributeInfo = r2, this.node = i5;
  }
};
var se = class extends u3(t5(i2(l2(w2)))) {
  constructor() {
    super(...arguments), this.type = "scene-layer-graphics-3d", this._queryEngine = null, this._memCache = null, this._interactiveEditingSessions = /* @__PURE__ */ new Map(), this._pendingEditsQueue = Promise.resolve(), this.loadedGraphics = new s2((e4, t6, r2) => le(e4, t6, r2), (e4) => this.processor.graphicsCore.recreateGraphics(e4)), this.holeFilling = "always", this.progressiveLoadFactor = 1, this.supportsHeightUnitConversion = true, this._coordinatesOutsideExtentErrors = 0, this._maxCoordinatesOutsideExtentErrors = 20;
  }
  tryRecycleWith(e4, t6) {
    return e4.url === this.layer.url && this._i3sOverrides.isEmpty ? e4.load(t6).then(() => {
      Y(this.layer, e4, this._i3sOverrides), this.layer = e4, this._i3sOverrides.destroy();
      const t7 = this.view.resourceController?.memoryController;
      this._i3sOverrides = new G({
        view: this.view,
        layer: e4,
        memoryController: t7
      }), u(this._queryEngine), this._setupQueryEngine(), this.processor.resetObjectStates();
    }) : null;
  }
  initialize() {
    this.addResolvingPromise(this.layer.indexInfo);
    const e4 = this.view.resourceController?.memoryController;
    this._i3sOverrides = new G({
      view: this.view,
      layer: this.layer,
      memoryController: e4
    }), te(this.layer, this.view.spatialReference, this.view.viewingMode), this._fieldsHelper = new a2({
      layerView: this
    }), this._updatingHandles.add(() => this.layer.rangeInfos, (e5) => this._rangeInfosChanged(e5), P), this._updatingHandles.add(() => this.layer.renderer, (e5, t6) => this._rendererChange(e5, t6)), this._updatingHandles.add(() => [this.parsedDefinitionExpression, this._excludeObjectIdsSorted], () => this._filterChange()), this.addHandles(d(() => t2.I3S_TREE_SHOW_TILES, (e5) => {
      if (e5 && !this._treeDebugger) {
        const e6 = this._controller.crsIndex;
        import("./I3STreeDebugger-BCRIMNG3.js").then(({
          I3STreeDebugger: t6
        }) => {
          !this._treeDebugger && t2.I3S_TREE_SHOW_TILES && (this._treeDebugger = new t6({
            lv: this,
            view: this.view,
            nodeSR: e6
          }));
        });
      } else e5 || !this._treeDebugger || t2.I3S_TREE_SHOW_TILES || (this._treeDebugger.destroy(), this._treeDebugger = null);
    }, P)), this._set("processor", new P2({
      owner: this,
      preferredUpdatePolicy: C.ASYNC,
      scaleVisibilityEnabled: true,
      filterVisibilityEnabled: true,
      timeExtentEnabled: false,
      frustumVisibilityEnabled: false,
      elevationAlignmentEnabled: true,
      elevationFeatureExpressionEnabled: false,
      setUidToIdOnAdd: false,
      dataExtent: this.layer.fullExtent,
      updateClippingExtent: (e5) => this._updateClippingExtent(e5)
    })), this.processor.elevationAlignment?.events.on("invalidate-elevation", ({
      extent: e5,
      spatialReference: t6
    }) => this._controller.updateElevationChanged(e5, t6)), this.supportsHeightUnitConversion && (this._verticalScale = o4("point", this.layer.spatialReference, this.view.spatialReference)), this.addResolvingPromise(this.processor.initializePromise), this._memCache = this.view.resourceController.memoryController.newCache(`psl-${this.uid}`), this._controller = new K({
      layerView: this
    }), N(this.layer.geometryDefinitions) && (this._worker = new r((e5) => this.view.resourceController.immediate.schedule(e5))), this.addHandles(this.layer.on("apply-edits", (e5) => this._updatingHandles.addPromise(e5.result))), this.addHandles(this.layer.on("edits", (e5) => {
      const t6 = this._pendingEditsQueue.then(() => this._handleEdits(e5)).then();
      this._pendingEditsQueue = t6, this._updatingHandles.addPromise(t6);
    })), this.when(() => {
      this._setupQueryEngine(), this._updatingHandles.add(() => this.maximumNumberOfFeatures, (e5) => this._controller.featureTarget = e5, P), this._updatingHandles.add(() => this.suspended, (e5) => {
        e5 && this._removeAllNodeData();
      });
    });
  }
  destroy() {
    this._treeDebugger = u(this._treeDebugger), this._i3sOverrides = u(this._i3sOverrides), this._set("processor", u(this.processor)), this._controller = u(this._controller), this._queryEngine = u(this._queryEngine), this._worker = u(this._worker), this._memCache = u(this._memCache), this.loadedGraphics.clear(), this._fieldsHelper = u(this._fieldsHelper);
  }
  get i3slayer() {
    return this.layer;
  }
  get updatingProgressValue() {
    return this._controller?.updatingProgress ?? 1;
  }
  get requiredFields() {
    return this._fieldsHelper?.requiredFields ?? [];
  }
  get maximumNumberOfFeatures() {
    const e4 = this.processor?.graphicsCore?.displayFeatureLimit;
    return e4?.maximumNumberOfFeatures ?? 0;
  }
  set maximumNumberOfFeatures(e4) {
    null != e4 ? (this._override("maximumNumberOfFeatures", e4), this._controller.fixedFeatureTarget = true) : (this._clearOverride("maximumNumberOfFeatures"), this._controller.fixedFeatureTarget = false);
  }
  get maximumNumberOfFeaturesExceeded() {
    return !this.suspended && !!this._controller?.useMaximumNumberOfFeatures && !this._controller.leavesReached;
  }
  get _excludeObjectIdsSorted() {
    const e4 = this.layer.excludeObjectIds;
    return e4.length ? e4.toArray().sort((e5, t6) => e5 - t6) : null;
  }
  get lodFactor() {
    return "Labels" === this.layer.semantic ? 1 : this.view.qualitySettings.sceneService.point.lodFactor;
  }
  get hasM() {
    return false;
  }
  get hasZ() {
    return true;
  }
  get contentVisible() {
    return !this.suspended && !!this._controller?.rootNodeVisible;
  }
  get legendEnabled() {
    return this.contentVisible && true === this.i3slayer?.legendEnabled;
  }
  whenGraphicAttributes(e4, t6) {
    return __async(this, null, function* () {
      return A2(this.layer, e4, this._getObjectIdField(), t6, () => [...this.loadedGraphics.nodes()]);
    });
  }
  getHit(e4) {
    if (!this.loadedGraphics) return null;
    const t6 = c(this.loadedGraphics.find((t7) => t7.uid === e4), this.layer), r2 = this._getObjectIdField();
    return t6?.attributes?.[r2] ? (t6.layer = this.layer, t6.sourceLayer = this.layer, {
      type: "graphic",
      graphic: t6,
      layer: t6.layer
    }) : null;
  }
  whenGraphicBounds(e4, t6) {
    return this.processor.whenGraphicBounds(e4, t6);
  }
  computeAttachmentOrigin(e4, t6) {
    return this.processor.computeAttachmentOrigin(e4, t6);
  }
  isUpdating() {
    return !!(this._controller?.updating || this.processor?.updating || this._fieldsHelper?.updating || this.layerFilterUpdating);
  }
  highlight(e4) {
    return this.processor.highlight(e4, this.layer.objectIdField);
  }
  get updatePolicy() {
    return this.processor.graphicsCore.effectiveUpdatePolicy;
  }
  createInteractiveEditSession(e4) {
    return i3(this._attributeEditingContext, e4);
  }
  _decompressBinaryPointData(e4, t6) {
    return __async(this, null, function* () {
      const r2 = {
        geometryBuffer: e4.geometryBuffer
      };
      null == this._worker && (this._worker = new r((e5) => this.view.resourceController.immediate.schedule(e5)));
      const i5 = yield this._worker.invoke(r2, t6);
      if (null == i5) throw new Error("Failed to decompress Draco point data");
      return {
        positionData: i5.positions,
        featureIds: i5.featureIds
      };
    });
  }
  addNode(e4, t6, r2) {
    return __async(this, null, function* () {
      if (!ne(t6) && !ae(t6)) throw new Error();
      if (this.loadedGraphics.hasNode(e4.index)) return void n.getLogger(this).error("I3S node " + e4.id + " already added");
      const s3 = null != this.layer.fullExtent ? ue(this.layer.fullExtent.clone(), 0.5) : null, {
        featureIds: o6,
        pointPositions: a3
      } = ne(t6) ? yield this._extractBinaryPointPositions(e4, t6, r2) : this._extractLegacyPointPositions(t6), n6 = new Array();
      this._validatePositions(e4, o6, a3, s3, n6);
      const l4 = this._controller.crsVertex, d4 = this.view.spatialReference;
      n4(a3, l4, 0, a3, d4, 0, o6.length);
      const u5 = ne(t6) ? e4.level : 0, h2 = this._createGraphics(o6, a3, e4.index, u5), p = new ie(h2, o6, t6.attributeDataInfo, e4);
      if (yield this._i3sOverrides.applyAttributeOverrides(p.featureIds, t6.attributeDataInfo, r2), e4.numFeatures = p.graphics.length, this._updateNodeMemory(e4), de(p), n6.length > 0 && (this._computeObb(e4, n6, l4), this._controller.updateVisibility(e4.index)), !this._controller.isGeometryVisible(e4)) return void this._cacheNodeData(p);
      if (null != this._verticalScale) for (const i5 of p.graphics) this._verticalScale(i5.geometry);
      const g = this.view._stage.renderView.objectAndLayerIdRenderHelper;
      if (null != g) {
        const e5 = S(this.view.map, this.layer.uid);
        for (let t7 = 0; t7 < p.featureIds.length; t7++) {
          const r3 = p.featureIds[t7];
          g.setUidToObjectAndLayerId(r3, p.graphics[t7].uid, this.layer.id, this.layer.uid, this.layer.popupEnabled && !e5 && u2(this.layer, this.view.popup?.defaultPopupTemplateEnabled), p.node.resources.attributes, t7);
        }
      }
      this.loadedGraphics.addNode(e4.index, p), this._controller.updateLoadStatus(e4.index, true), this._filterNode(p), this._treeDebugger && this._treeDebugger.update();
    });
  }
  _computeObb(e4, t6, r2) {
    const i5 = this._controller.crsIndex, s3 = i5.isGeographic ? this.view.renderSpatialReference : i5;
    n4(t6, r2, 0, t6, s3, 0, t6.length / 3), e4.serviceObbInIndexSR = J(new s(t6, 3)), i5.isGeographic && (n5(e4.serviceObbInIndexSR.center, s3, pe, i5), e4.serviceObbInIndexSR.center = pe);
  }
  isNodeLoaded(e4) {
    return this.loadedGraphics.hasNode(e4);
  }
  isNodeReloading() {
    return false;
  }
  updateNodeState() {
  }
  _extractBinaryPointPositions(e4, t6, r2) {
    return __async(this, null, function* () {
      const i5 = yield this._decompressBinaryPointData(t6, r2), s3 = i5.positionData, o6 = 3, a3 = s3.length / o6, n6 = t(3 * a3), l4 = null != e4.serviceObbInIndexSR ? e4.serviceObbInIndexSR.center : l, d4 = Math.abs(l4[2]) * 2 ** -20;
      for (let u5 = 0; u5 < a3; u5++) {
        const e5 = u5 * o6;
        n6[e5] = s3[e5] + l4[0], n6[e5 + 1] = s3[e5 + 1] + l4[1], n6[e5 + 2] = s3[e5 + 2] + l4[2], Math.abs(n6[e5 + 2]) < d4 && (n6[e5 + 2] = 0);
      }
      return {
        featureIds: i5.featureIds ? e3(i5.featureIds) : [],
        pointPositions: n6
      };
    });
  }
  _extractLegacyPointPositions(e4) {
    const t6 = e4.pointData.length, r2 = t(3 * t6), i5 = new Array();
    for (let s3 = 0; s3 < t6; s3++) {
      const t7 = e4.pointData[s3], o6 = t7.featureDataPosition, a3 = o6.length, n6 = t7.geometries?.[0] ?? he[a3], l4 = t7.featureIds[0];
      if ("Embedded" !== n6.type || "points" !== n6.params.type || a3 < 2 || a3 > 3) continue;
      const d4 = n6.params.vertexAttributes?.position ?? [0, 0, 0], u5 = 3 * i5.length;
      r2[u5] = o6[0] + d4[0], r2[u5 + 1] = o6[1] + d4[1], r2[u5 + 2] = 3 === a3 ? o6[2] + d4[2] : NaN, i5.push(l4);
    }
    return {
      featureIds: i5,
      pointPositions: r2
    };
  }
  _validatePositions(e4, t6, r2, s3, o6) {
    if (null == s3 && e4.serviceObbInIndexSR) return;
    const a3 = t6.length, n6 = 3;
    for (let l4 = 0; l4 < a3; l4++) {
      const t7 = l4 * n6;
      o3(pe, r2[t7], r2[t7 + 1], r2[t7 + 2]);
      const a4 = !Number.isNaN(r2[2]);
      null == s3 || (a4 ? o2(s3, pe) : i(s3, pe)) || (this._coordinatesOutsideExtentErrors < this._maxCoordinatesOutsideExtentErrors && n.getLogger(this).error("Service Error: Coordinates outside of layer extent"), this._coordinatesOutsideExtentErrors + 1 === this._maxCoordinatesOutsideExtentErrors && n.getLogger(this).error("Maximum number of errors reached. Further errors are ignored."), this._coordinatesOutsideExtentErrors++), e4.serviceObbInIndexSR || o6.push(pe[0], pe[1], pe[2]);
    }
  }
  _createGraphics(e4, r2, i5, s3) {
    const o6 = e4.length, a3 = 3, n6 = this._getObjectIdField(), l4 = this.processor.graphicsCore, d4 = new Array(), u5 = this.view.spatialReference;
    for (let h2 = 0; h2 < o6; h2++) {
      const o7 = e4[h2], p = {};
      null != o7 && (p[n6] = o7);
      const c2 = o7 ?? d2.generateUID(), g = h2 * a3, m = isNaN(r2[g + 2]) ? void 0 : r2[g + 2], y2 = e2(r2[g], r2[g + 1], m, u5), f2 = this.loadedGraphics.get(c2);
      if (null != f2) (null == f2.level || f2.level < s3) && (ce.property = "geometry", ce.graphic = f2, ce.oldValue = f2.geometry, ce.newValue = y2, f2.geometry = y2, f2.level = s3, l4.graphicUpdateHandler(ce)), d4.push(f2);
      else {
        const e5 = d2.generateUID();
        d4.push({
          objectId: c2,
          uid: e5,
          geometry: y2,
          attributes: p,
          visible: true,
          nodeIndex: i5,
          level: s3
        });
      }
    }
    return d4;
  }
  _updateNodeMemory(e4) {
    e4.memory = 4096 + (null != e4.numFeatures ? e4.numFeatures * this.processor.graphicsCore.usedMemoryPerGraphic : 0);
  }
  _cacheNodeData(e4) {
    const t6 = e4.graphics.reduce((e5, t7) => Z(t7) + e5, A(e4.featureIds) + 1024);
    this._memCache.put(this._getMemCacheKey(e4.node), e4, t6);
  }
  _getMemCacheKey(e4) {
    return `${e4.index}`;
  }
  _removeAllNodeData() {
    this.loadedGraphics.forEachNode((e4, t6) => {
      if (e4) {
        const t7 = e4.node;
        this._updateNodeMemory(t7), this._cacheNodeData(e4);
      }
      this._controller.updateLoadStatus(t6, false);
    }), this._treeDebugger && this._treeDebugger.update(), this.loadedGraphics.clear();
  }
  removeNode(e4) {
    const t6 = this._removeNodeStageData(e4);
    t6 && (this._updateNodeMemory(t6.node), this._cacheNodeData(t6));
  }
  _removeNodeStageData(e4) {
    const t6 = this.loadedGraphics.getNode(e4);
    return null == t6 ? null : (this._controller.updateLoadStatus(e4, false), this.loadedGraphics.removeNode(e4), this._treeDebugger && this._treeDebugger.update(), t6);
  }
  loadCachedNodeData(e4) {
    return __async(this, null, function* () {
      return this._memCache?.pop(this._getMemCacheKey(e4));
    });
  }
  addCachedNodeData(e4, t6, r2, s3) {
    return __async(this, null, function* () {
      this.loadedGraphics.hasNode(e4.index) ? n.getLogger(this).error("I3S node " + e4.id + " already added") : (yield this._i3sOverrides.applyAttributeOverrides(t6.featureIds, r2, s3), t6.attributeInfo = r2, this.loadedGraphics.addNode(e4.index, t6), this._controller.updateLoadStatus(e4.index, true), this._updateNodeMemory(e4), de(t6), this._filterNode(t6), this._treeDebugger && this._treeDebugger.update());
    });
  }
  getLoadedNodeIds() {
    const e4 = [];
    return this.loadedGraphics.forEachNode((t6) => e4.push(t6.node.id)), e4.sort();
  }
  getVisibleNodes() {
    const e4 = new Array();
    return this.loadedGraphics.forEachNode((t6) => e4.push(t6.node)), e4;
  }
  getLoadedNodeIndices(e4) {
    this.loadedGraphics.forEachNode((t6, r2) => e4.push(r2));
  }
  getLoadedAttributes(e4) {
    const t6 = this.loadedGraphics.getNode(e4);
    if (null != t6?.attributeInfo) return t6.attributeInfo.loadedAttributes;
  }
  getAttributeData(e4) {
    const t6 = this.loadedGraphics.getNode(e4);
    if (null != t6?.attributeInfo) return t6.attributeInfo.attributeData;
  }
  _setAttributeData(e4, t6) {
    const r2 = this.loadedGraphics.getNode(e4);
    null != r2?.attributeInfo && (r2.attributeInfo.attributeData = t6, this._attributeValuesChanged(r2));
  }
  updateAttributes(e4, t6, r2) {
    return __async(this, null, function* () {
      const i5 = this.loadedGraphics.getNode(e4);
      null != i5 && (yield this._i3sOverrides.applyAttributeOverrides(i5.featureIds, t6, r2), i5.attributeInfo = t6, this._attributeValuesChanged(i5));
    });
  }
  _attributeValuesChanged(e4) {
    if (de(e4), this._filterNode(e4), this.processor.graphicsCore.labelsEnabled) {
      const t6 = e4.node.index, r2 = new Array();
      e4.graphics.forEach((e5) => e5.nodeIndex === t6 && r2.push(e5.uid)), this.processor.graphicsCore.updateLabelingInfo(r2);
    }
  }
  _updateClippingExtent(e4) {
    return this._controller && this._controller.updateClippingArea(e4), false;
  }
  _getObjectIdField() {
    return this.layer.objectIdField || o5;
  }
  _getGlobalIdField() {
    return this.layer.associatedLayer?.globalIdField;
  }
  _rendererChange(e4, t6) {
    return __async(this, null, function* () {
      const {
        layer: {
          fieldsIndex: r2
        }
      } = this, i5 = /* @__PURE__ */ new Set();
      let s3, o6;
      e4 ? (yield e4.collectRequiredFields(i5, r2), s3 = Array.from(i5).sort()) : s3 = [], i5.clear(), t6 ? (yield t6.collectRequiredFields(i5, r2), o6 = Array.from(i5).sort()) : o6 = [], s3.length === o6.length && s3.every((e5, t7) => s3[t7] === o6[t7]) || this._reloadAllNodes();
    });
  }
  _rangeInfosChanged(e4) {
    null != e4 && e4.length > 0 && n.getLogger(this).warn("Unsupported property: rangeInfos are currently only serialized to and from web scenes but do not affect rendering.");
  }
  _filterChange() {
    this.loadedGraphics.forEachNode((e4) => this._filterNode(e4));
  }
  _reloadAllNodes() {
    this._removeAllNodeData(), this._controller && this._controller.restartNodeLoading();
  }
  _filterNode(e4) {
    const t6 = this.parsedDefinitionExpression, i5 = this._excludeObjectIdsSorted, s3 = this._getObjectIdField();
    for (const o6 of e4.graphics) {
      const e5 = o6.visible, a3 = !t6 || this._evaluateClause(t6, o6), n6 = null == i5 || w(i5, o6.attributes[s3]) < 0;
      o6.visible = a3 && n6, e5 !== o6.visible && (ce.graphic = o6, ce.property = "visible", ce.oldValue = e5, ce.newValue = o6.visible, this.processor.graphicsCore.graphicUpdateHandler(ce));
    }
  }
  createQuery() {
    const e4 = {
      outFields: ["*"],
      returnGeometry: true,
      outSpatialReference: this.view.spatialReference
    };
    return null != this.filter ? this.filter.createQuery(e4) : new b(e4);
  }
  queryFeatures(e4, t6) {
    return this._queryEngine.executeQuery(this._ensureQuery(e4), t6?.signal);
  }
  queryObjectIds(e4, t6) {
    return this._queryEngine.executeQueryForIds(this._ensureQuery(e4), t6?.signal);
  }
  queryFeatureCount(e4, t6) {
    return this._queryEngine.executeQueryForCount(this._ensureQuery(e4), t6?.signal);
  }
  queryExtent(e4, t6) {
    return this._queryEngine.executeQueryForExtent(this._ensureQuery(e4), t6?.signal);
  }
  _ensureQuery(e4) {
    return this._addDefinitionExpressionToQuery(null == e4 ? this.createQuery() : b.from(e4));
  }
  _setupQueryEngine() {
    const e4 = () => this.processor.featureStore;
    this._queryEngine = new l3({
      context: {
        spatialReference: this.view.spatialReference,
        layer: this.layer,
        scheduler: this.view.resourceController.scheduler,
        get featureStore() {
          return e4();
        },
        hasZ: this.hasZ,
        hasM: this.hasM
      },
      priority: I.FEATURE_QUERY_ENGINE
    });
  }
  get usedMemory() {
    return this.processor?.graphicsCore?.usedMemory ?? 0;
  }
  get unloadedMemory() {
    return 0.8 * ((this._controller?.unloadedMemoryEstimate ?? 0) + (this.processor?.graphicsCore?.unprocessedMemoryEstimate ?? 0));
  }
  get ignoresMemoryFactor() {
    return this._controller && this._controller.fixedFeatureTarget;
  }
  _handleEdits(e4) {
    return __async(this, null, function* () {
      const t6 = this._attributeEditingContext, r2 = yield u4(t6, e4);
      f(t6, r2);
    });
  }
  get _attributeEditingContext() {
    const e4 = this._getObjectIdField(), t6 = this._getGlobalIdField();
    return {
      sessions: this._interactiveEditingSessions,
      fieldsIndex: this.layer.fieldsIndex,
      objectIdField: e4,
      globalIdField: t6,
      forEachNode: (e5) => this.loadedGraphics.forEachNode((t7) => e5(t7.node, t7.featureIds)),
      attributeStorageInfo: this.i3slayer.attributeStorageInfo ?? [],
      i3sOverrides: this._i3sOverrides,
      getAttributeData: (e5) => this.getAttributeData(e5),
      setAttributeData: (t7, r2, i5) => {
        this._setAttributeData(t7, r2);
        const s3 = this.loadedGraphics.getNode(t7);
        if (null != i5) {
          const t8 = this.loadedGraphics.get(i5.attributes[e4]);
          null != t8 && this.processor.graphicsCore.recreateGraphics([t8]);
        } else null != s3 && this.processor.graphicsCore.recreateGraphics(s3.graphics);
      },
      clearMemCache: () => {
      }
    };
  }
  get performanceInfo() {
    return new t3(this.usedMemory, this.loadedGraphics.length, -1, this.maximumNumberOfFeatures, this.loadedGraphics.nodeCount, this.processor.graphicsCore.performanceInfo);
  }
  get test() {
  }
};
e([y()], se.prototype, "processor", void 0), e([y({
  type: d3
})], se.prototype, "filter", void 0), e([y()], se.prototype, "loadedGraphics", void 0), e([y()], se.prototype, "i3slayer", null), e([y()], se.prototype, "_controller", void 0), e([y()], se.prototype, "updating", void 0), e([y()], se.prototype, "suspended", void 0), e([y()], se.prototype, "holeFilling", void 0), e([y(t4)], se.prototype, "updatingProgress", void 0), e([y()], se.prototype, "updatingProgressValue", null), e([y(re.requiredFields)], se.prototype, "requiredFields", null), e([y(re.availableFields)], se.prototype, "availableFields", void 0), e([y()], se.prototype, "_fieldsHelper", void 0), e([y({
  type: Number
})], se.prototype, "maximumNumberOfFeatures", null), e([y({
  readOnly: true
})], se.prototype, "maximumNumberOfFeaturesExceeded", null), e([y()], se.prototype, "_excludeObjectIdsSorted", null), e([y({
  readOnly: true
})], se.prototype, "lodFactor", null), e([y({
  readOnly: true
})], se.prototype, "hasM", null), e([y({
  readOnly: true
})], se.prototype, "hasZ", null), e([y()], se.prototype, "contentVisible", null), e([y({
  readOnly: true
})], se.prototype, "legendEnabled", null), se = e([a("esri.views.3d.layers.SceneLayerGraphicsView3D")], se);
var oe = se;
function ae(e4) {
  return "pointData" in e4;
}
function ne(e4) {
  return "geometryBuffer" in e4 && null !== e4.geometryBuffer;
}
function le(e4, t6, r2) {
  const i5 = t6.attributeInfo;
  if (null == i5?.loadedAttributes || null == i5.attributeData) return false;
  let s3 = false;
  for (const {
    name: o6
  } of i5.loadedAttributes) if (i5.attributeData[o6]) {
    const t7 = Q(i5.attributeData[o6], r2);
    t7 !== e4.attributes[o6] && (e4.attributes[o6] = t7, s3 = true);
  }
  return s3;
}
function de(e4) {
  const t6 = e4.attributeInfo, r2 = e4.node.index;
  if (null != t6?.loadedAttributes && null != t6.attributeData) for (let i5 = 0; i5 < e4.graphics.length; i5++) {
    const s3 = e4.graphics[i5];
    if (s3.nodeIndex === r2) {
      s3.attributes || (s3.attributes = {});
      for (const {
        name: e5
      } of t6.loadedAttributes) t6.attributeData[e5] && (s3.attributes[e5] = Q(t6.attributeData[e5], i5));
    }
  }
}
function ue(e4, t6) {
  return e4.xmin -= t6, e4.ymin -= t6, e4.xmax += t6, e4.ymax += t6, null != e4.zmin && null != e4.zmax && (e4.zmin -= t6, e4.zmax += t6), null != e4.mmin && null != e4.mmax && (e4.mmin -= t6, e4.mmax += t6), e4;
}
var he = {
  2: {
    type: "Embedded",
    params: {
      type: "points",
      vertexAttributes: {
        position: [0, 0]
      }
    }
  },
  3: {
    type: "Embedded",
    params: {
      type: "points",
      vertexAttributes: {
        position: [0, 0, 0]
      }
    }
  }
};
var pe = n3();
var ce = {
  graphic: null,
  property: null,
  oldValue: null,
  newValue: null
};
export {
  oe as default
};
//# sourceMappingURL=SceneLayerGraphicsView3D-AY52ESDF.js.map
