import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  o as o6
} from "./chunk-JECKI4WE.js";
import {
  n as n7
} from "./chunk-33J3D7DK.js";
import {
  o as o5
} from "./chunk-JLIVZPBI.js";
import {
  W as W2,
  r
} from "./chunk-BNFJNBHR.js";
import "./chunk-CIJQ7JPR.js";
import "./chunk-RVAIZQSS.js";
import {
  h as h2
} from "./chunk-I6EZE7ZH.js";
import "./chunk-NP5MLSB6.js";
import "./chunk-6C3NPNB6.js";
import {
  M as M2,
  a as a3,
  b as b3,
  i as i2,
  n as n5,
  n2 as n6,
  p,
  p2,
  s as s7,
  t2 as t3
} from "./chunk-SM7IYUF6.js";
import "./chunk-Y72ZILQ6.js";
import {
  i as i3
} from "./chunk-V4U3XK2O.js";
import {
  d2 as d5
} from "./chunk-7DRGM3JS.js";
import "./chunk-LR3PYNHM.js";
import "./chunk-VM4DYPO2.js";
import "./chunk-PXFPCKFW.js";
import "./chunk-RAYFUCRQ.js";
import "./chunk-ONQZSDXQ.js";
import "./chunk-FWYSNIVU.js";
import "./chunk-MDEPINSI.js";
import "./chunk-Q2RVB4BK.js";
import "./chunk-SKOGSS6Z.js";
import "./chunk-G3WMCIUE.js";
import "./chunk-WS7U2AGS.js";
import "./chunk-U4NXHH3L.js";
import {
  e as e4
} from "./chunk-J7FRIDYV.js";
import {
  $ as $2
} from "./chunk-52IB6TIO.js";
import {
  _
} from "./chunk-QWE4DSVN.js";
import "./chunk-2LHHRVKS.js";
import "./chunk-QATJRB5Q.js";
import "./chunk-7Z4UWMRU.js";
import "./chunk-IQEF4U4C.js";
import "./chunk-QJK66QPF.js";
import "./chunk-KB6CBN72.js";
import "./chunk-BCMXVFG5.js";
import "./chunk-FB2GCV4L.js";
import {
  a as a2
} from "./chunk-NOBDTR4N.js";
import "./chunk-5RF6XDV4.js";
import "./chunk-Q47GASPN.js";
import {
  r as r2
} from "./chunk-VUWWHENY.js";
import "./chunk-LCPLUSDH.js";
import "./chunk-KINQ7OJ3.js";
import "./chunk-KYLW5XXS.js";
import "./chunk-B76NC7GX.js";
import "./chunk-HFXXFWYN.js";
import {
  S as S2,
  c as c3,
  d as d4
} from "./chunk-BY3XBMAH.js";
import "./chunk-OO7WNZEW.js";
import {
  b as b2,
  h
} from "./chunk-LU7PU2CS.js";
import {
  n as n4
} from "./chunk-4O23HCRT.js";
import "./chunk-MWMAA7SE.js";
import "./chunk-LUKDK354.js";
import "./chunk-6A4CZ4JY.js";
import "./chunk-MWDGD75N.js";
import {
  $
} from "./chunk-FWEBARAB.js";
import {
  o as o4
} from "./chunk-RHUWRAPT.js";
import "./chunk-VY63YX6I.js";
import "./chunk-EXKCGLRO.js";
import "./chunk-WRLGLGM6.js";
import "./chunk-47DYJR3W.js";
import {
  j as j2,
  x
} from "./chunk-NE35ZNG6.js";
import "./chunk-ZLSZAC2I.js";
import "./chunk-QRWQ6QBB.js";
import "./chunk-TFW6WS6R.js";
import {
  K,
  N,
  Nt,
  O,
  at,
  ct,
  et,
  ft,
  gt,
  nt,
  pt,
  rt,
  w as w2
} from "./chunk-X5QZGB37.js";
import "./chunk-T5C2TZNO.js";
import "./chunk-AOGKNBDG.js";
import "./chunk-F4FQ67JP.js";
import "./chunk-FDI2X6GO.js";
import "./chunk-3XHDZQO5.js";
import {
  e as e3,
  s as s4
} from "./chunk-2BLQXT54.js";
import {
  e as e2
} from "./chunk-JSWVKNBA.js";
import "./chunk-CILHMGNK.js";
import "./chunk-2BOKEEZV.js";
import "./chunk-WFNAKG2H.js";
import "./chunk-EKHRAAS6.js";
import {
  d as d3,
  s as s6,
  y as y2
} from "./chunk-IEB4ZCRH.js";
import {
  O as O2,
  c as c4
} from "./chunk-7QOUHKW5.js";
import "./chunk-NHYYZMJR.js";
import "./chunk-U4EMQMDC.js";
import "./chunk-BZHHBBFX.js";
import "./chunk-EXPZNTF3.js";
import {
  b
} from "./chunk-ORYC4PVJ.js";
import "./chunk-DXIKKLD7.js";
import "./chunk-VQNXE43R.js";
import "./chunk-VZ37C3ID.js";
import {
  Z
} from "./chunk-5R3HARKC.js";
import "./chunk-BKSTWG4S.js";
import "./chunk-FSG7HOZQ.js";
import "./chunk-Q5TIVVER.js";
import "./chunk-X36BR2QB.js";
import "./chunk-RGG3YJQA.js";
import "./chunk-YBUJLIWZ.js";
import "./chunk-DL2B6IFJ.js";
import {
  i
} from "./chunk-VOOO6FU5.js";
import "./chunk-IUPJR3FF.js";
import "./chunk-TGZW6QWO.js";
import "./chunk-OYIDHTXG.js";
import "./chunk-KUBMHTYA.js";
import "./chunk-NU4K6CTR.js";
import "./chunk-42ZAWY2C.js";
import "./chunk-TVHVZK5G.js";
import "./chunk-P2MUOE6G.js";
import "./chunk-CRYYUS4E.js";
import "./chunk-V33IUWAS.js";
import "./chunk-E5NWFBZG.js";
import {
  s as s5
} from "./chunk-FP37456K.js";
import "./chunk-VSQZQLTQ.js";
import "./chunk-K43CZ3M5.js";
import "./chunk-6EIBUVMG.js";
import "./chunk-YCXNHEGB.js";
import "./chunk-CSATD3VX.js";
import "./chunk-NXXQ35YM.js";
import "./chunk-LM3JDV4W.js";
import "./chunk-34V2CLL5.js";
import {
  g
} from "./chunk-CXNERL22.js";
import "./chunk-7V4JSBFA.js";
import {
  z
} from "./chunk-KAHESDP5.js";
import "./chunk-ONRZ4VTT.js";
import {
  c as c2
} from "./chunk-DC5LRNPY.js";
import "./chunk-ZT7V2AVD.js";
import "./chunk-C2OXE4NQ.js";
import "./chunk-KOI252FF.js";
import "./chunk-I2TVVMQ6.js";
import {
  n as n3
} from "./chunk-5EGQYY2H.js";
import "./chunk-JKPUNUQA.js";
import "./chunk-SR7PRON4.js";
import "./chunk-HGHPYGKP.js";
import "./chunk-4DSGTDZJ.js";
import {
  u as u3
} from "./chunk-VYTPFEL2.js";
import "./chunk-RLGDH6IY.js";
import {
  j
} from "./chunk-MRPCXIVS.js";
import "./chunk-YTKVV2Y3.js";
import "./chunk-GCVQXAS4.js";
import "./chunk-UFQD6AL4.js";
import "./chunk-THZPD5CT.js";
import "./chunk-OBCA6CWH.js";
import "./chunk-2JI245BP.js";
import "./chunk-CBOFHWPI.js";
import "./chunk-ABIG6PT5.js";
import "./chunk-ZEZ3LI2L.js";
import "./chunk-N34BRXVM.js";
import "./chunk-KETDH2J4.js";
import "./chunk-7QV7DHWN.js";
import "./chunk-4L4Y34YK.js";
import "./chunk-BXONKQKI.js";
import "./chunk-2HDBQXAR.js";
import {
  w
} from "./chunk-RNF7VOCU.js";
import "./chunk-TIRJMGGG.js";
import {
  f as f2
} from "./chunk-ZDRQSPB6.js";
import "./chunk-DCXDXGAR.js";
import "./chunk-BCCDYCTQ.js";
import "./chunk-AYL3HQHD.js";
import "./chunk-66YQWHHE.js";
import "./chunk-QGBMZIP4.js";
import "./chunk-AOEBZVTA.js";
import {
  M
} from "./chunk-2OZSYJDX.js";
import "./chunk-MZM4INJV.js";
import "./chunk-J4GMQHGL.js";
import "./chunk-MHPE4SZA.js";
import {
  W2 as W,
  o as o3
} from "./chunk-6SSA7P3A.js";
import {
  s as s3
} from "./chunk-FQBTLEUI.js";
import "./chunk-GS7Y3YOG.js";
import "./chunk-Y2HYKTTT.js";
import {
  U
} from "./chunk-XLEC46FY.js";
import "./chunk-4AZPIP7K.js";
import "./chunk-G73HQZEL.js";
import {
  d as d2
} from "./chunk-LZSLQ24Q.js";
import "./chunk-U3RHUXYK.js";
import "./chunk-7DBI6LQG.js";
import "./chunk-AUUN7RFQ.js";
import {
  o as o2
} from "./chunk-JAMSDYD6.js";
import "./chunk-PH6NPTP7.js";
import {
  e
} from "./chunk-NUICEVIH.js";
import {
  S
} from "./chunk-NXK752PZ.js";
import {
  y
} from "./chunk-UVNLCXWD.js";
import "./chunk-PNUA7JOS.js";
import "./chunk-OR2FKGUM.js";
import {
  a3 as a
} from "./chunk-UDMPWVPF.js";
import {
  t as t2
} from "./chunk-XJNKCEWL.js";
import {
  L,
  c2 as c,
  d,
  f2 as f,
  m,
  s as s2
} from "./chunk-AIZ3T7E3.js";
import {
  o
} from "./chunk-6UEMNP3E.js";
import {
  n as n2,
  u as u2
} from "./chunk-6WGE3IUL.js";
import "./chunk-MLYB2YW4.js";
import {
  n2 as n,
  s2 as s,
  u
} from "./chunk-6JFGZTLU.js";
import {
  has,
  t
} from "./chunk-2ZJE6ZFX.js";
import {
  __async,
  __asyncGenerator,
  __await,
  __forAwait,
  __spreadProps,
  __spreadValues,
  __yieldStar
} from "./chunk-XBPEBUD5.js";

// ../../../node_modules/@arcgis/core/views/2d/layers/features/PipelineConnectionHandlers.js
var t4 = class {
  constructor(e12) {
    this._client = e12, this.layerView = this._client.createInvokeProxy(""), this.container = this._client.createInvokeProxy("container"), this._eventLog = this._client.createInvokeProxy("eventLog");
  }
  onEvent(t16) {
    O2(this._eventLog.onEvent(t16));
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/mesh/MultiTileMeshData.js
var i4 = 1;
var n8 = 2;
var h3 = 4;
var o7 = 8;
var c5 = 16;
var a4 = 32;
var l = 64;
var f3 = 128;
function u4(e12) {
  switch (e12) {
    case i4:
    case o7:
    case a4:
      return -1;
    case n8:
    case l:
      return 0;
    case h3:
    case c5:
    case f3:
      return 1;
  }
}
function m2(e12) {
  switch (e12) {
    case i4:
    case n8:
    case h3:
      return -1;
    case o7:
    case c5:
      return 0;
    case a4:
    case l:
    case f3:
      return 1;
  }
}
var _2 = i4 | o7 | a4;
var d6 = h3 | c5 | f3;
var p3 = i4 | n8 | h3;
var y3 = a4 | l | f3;
var g2 = class {
  constructor(e12, s17, r8, i11 = 0) {
    this.tileKey = e12, this._bufferingEnabled = s17, this._sizeHint = i11, this._meshes = {
      self: new n5(this.id, this._sizeHint),
      neighbors: new Array()
    }, this._currentRecordOverlaps = 0, this._currentEntityOverlaps = 0, this._copyBufferedDataIntoSelf = r8 && this._bufferingEnabled && 0 === e12.level;
  }
  get id() {
    return this.tileKey.id;
  }
  vertexCount() {
    return this._meshes.self.vertexCount();
  }
  indexCount() {
    return this._meshes.self.indexCount();
  }
  indexEnsureSize(e12) {
    this._meshes.self.indexEnsureSize(e12);
  }
  entityStart(e12, s17 = e12) {
    this._currentEntityOverlaps = 0, this._meshes.self.entityStart(e12, s17);
  }
  entityRecordCount() {
    return this._meshes.self.entityRecordCount();
  }
  entityEnd() {
    if (this._meshes.self.entityEnd(), this._bufferingEnabled) {
      if (this._copyBufferedDataIntoSelf) return;
      for (let e12 = 0; e12 < 8; e12++) {
        const s17 = 1 << e12;
        !!(this._currentEntityOverlaps & s17) && this._meshes.neighbors[e12].entityEnd();
      }
    }
  }
  recordStart(e12, s17, t16) {
    this._currentRecordOverlaps = 0, this._meshes.self.recordStart(e12, s17, t16);
  }
  recordEnd(e12 = 0) {
    const s17 = this._meshes.self.recordEnd(this._currentRecordOverlaps);
    return s17 && 0 !== this._currentRecordOverlaps ? (this._copyIntoNeighbors(), this._currentEntityOverlaps |= this._currentRecordOverlaps, true) : s17;
  }
  recordBounds(e12, s17, t16, r8) {
    this._bufferingEnabled && this._addOverlap(e12, s17, t16, r8);
  }
  recordCount() {
    return this._meshes.self.recordCount();
  }
  metricStart(e12) {
    this._meshes.self.metricStart(e12);
  }
  metricBoxWrite(e12) {
    this._meshes.self.metricBoxWrite(e12);
  }
  metricEnd() {
    this._meshes.self.metricEnd();
  }
  vertexWrite(e12) {
    this._meshes.self.vertexWrite(e12);
  }
  vertexWriteF32(e12) {
    this._meshes.self.vertexWriteF32(e12);
  }
  vertexWriteRegion(e12) {
    this._meshes.self.vertexWriteRegion(e12);
  }
  indexWrite(e12) {
    this._meshes.self.indexWrite(e12);
  }
  serialize(s17) {
    const t16 = {
      message: [],
      transferList: []
    }, i11 = this._meshes.self.serialize();
    return t16.message.push(__spreadValues({
      tileId: this.tileKey.id
    }, i11.message)), t16.transferList.push(...i11.transferList), this._meshes.neighbors.forEach((i12, n17) => {
      const h6 = i12.serialize(), o16 = 1 << n17, c10 = u4(o16), a12 = m2(o16), l9 = o5(new e4(this.tileKey), c10, a12, s17);
      t16.message.push(__spreadValues({
        tileId: l9.id
      }, h6.message)), t16.transferList.push(...h6.transferList);
    }), t16;
  }
  _addOverlap(e12, t16, r8, i11) {
    const n17 = Math.min(a2 / 2, r8), h6 = Math.min(a2 / 2, i11), o16 = 255 ^ ((e12 < 0 + n17 ? d6 : e12 >= a2 - n17 ? _2 : d6 | _2) | (t16 < 0 + h6 ? y3 : t16 >= a2 - h6 ? p3 : y3 | p3));
    this._currentRecordOverlaps |= o16;
  }
  _copyIntoNeighbors() {
    for (let e12 = 0; e12 < 8; e12++) {
      const r8 = 1 << e12;
      if (!!(this._currentRecordOverlaps & r8)) {
        if (this._copyBufferedDataIntoSelf) {
          const e13 = -u4(r8) * a2, t16 = -m2(r8) * a2;
          if (0 !== t16) continue;
          this._meshes.self.copyLast(e13, t16);
          continue;
        }
        if (!this._meshes.neighbors[e12]) {
          const s17 = Math.floor(this._sizeHint / 16);
          this._meshes.neighbors[e12] = new n5(r8, s17);
        }
        const i11 = this._meshes.neighbors[e12], n17 = -u4(r8) * a2, h6 = -m2(r8) * a2;
        i11.copyLastFrom(this._meshes.self, n17, h6);
      }
    }
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/MeshFactory.js
var s8 = class {
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/util/Matcher.js
var t5 = class _t {
  constructor() {
    this._defaultResult = null, this._backgroundFillResult = null;
  }
  static from(e12, s17) {
    return __async(this, null, function* () {
      const l9 = new _t();
      return l9.setDefault(yield e12.createMeshWriters(s17.meshes)), l9;
    });
  }
  size() {
    return 1;
  }
  getDefault() {
    return this._defaultResult;
  }
  setDefault(t16) {
    this._defaultResult = t16;
  }
  getBackgroundFill() {
    return this._backgroundFillResult;
  }
  setBackgroundFill(t16) {
    this._backgroundFillResult = t16;
  }
  match(t16, e12) {
    const s17 = this.doMatch(t16, e12) || this.getDefault();
    if (s17 && s17.length > 0) {
      const t17 = this.getBackgroundFill();
      if (t17) return [...t17, ...s17];
    }
    return s17;
  }
  getSortKey(t16, e12) {
    return 0;
  }
  doMatch(t16, e12) {
    return null;
  }
  fetchResources(t16, e12) {
    return __async(this, null, function* () {
    });
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/util/DictionaryMatcher.js
var e5 = class _e extends t5 {
  static fromDictionaryRenderer(t16, s17) {
    return __async(this, null, function* () {
      return new _e(t16, s17);
    });
  }
  constructor(t16, e12) {
    super(), this._context = t16, this._schema = e12, this._hashToGroup = /* @__PURE__ */ new Map();
  }
  get fieldMap() {
    return this._schema.fieldMap;
  }
  fetchResources(t16, e12) {
    return __async(this, null, function* () {
      const s17 = e12.getCursor(), r8 = [];
      for (; s17.next(); ) r8.push(this._updateMeshWriterGroup(t16, s17));
      yield Promise.all(r8);
    });
  }
  match(t16, e12) {
    const s17 = t16.getAttributeHash();
    return this._hashToGroup.get(s17);
  }
  _updateMeshWriterGroup(t16, e12) {
    return __async(this, null, function* () {
      const s17 = e12.readLegacyFeatureForDisplay(), r8 = e12.getAttributeHash();
      if (this._hashToGroup.has(r8)) return;
      this._hashToGroup.set(r8, null);
      const a12 = yield t16.fetchDictionaryResourceImmediate({
        type: "dictionary-request",
        feature: s17
      });
      if (!a12) return;
      const h6 = yield this._context.createMeshWriters(a12.meshes);
      this._hashToGroup.set(r8, h6);
    });
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/util/IntervalMatcher.js
var e6 = class _e extends t5 {
  constructor(t16, e12) {
    super(), this._intervals = [], this._isMaxInclusive = e12, this._field = t16;
  }
  static fromIntervalSchema(t16, s17) {
    return __async(this, null, function* () {
      const i11 = yield t16.storage.createComputedField(s17), r8 = new _e(i11, s17.isMaxInclusive);
      yield Promise.all(s17.intervals.map((e12) => __async(this, null, function* () {
        const s18 = yield t16.createMeshWriters(e12.meshes);
        r8.add(e12, s18);
      })));
      const a12 = yield t16.createMeshWriters(s17.defaultSymbol);
      r8.setDefault(a12);
      const n17 = yield t16.createMeshWriters(s17.backgroundFill);
      return r8.setBackgroundFill(n17), r8;
    });
  }
  add(t16, e12) {
    this._intervals.push({
      interval: t16,
      result: e12
    }), this._intervals.sort((t17, e13) => t17.interval.min - e13.interval.min);
  }
  size() {
    return super.size() + this._intervals.length;
  }
  doMatch(t16, e12) {
    const s17 = this._field?.read(t16, e12);
    if (null == s17 || isNaN(s17) || s17 === 1 / 0 || s17 === -1 / 0) return null;
    for (let i11 = 0; i11 < this._intervals.length; i11++) {
      const {
        interval: t17,
        result: e13
      } = this._intervals[i11], r8 = s17 >= t17.min, a12 = this._isMaxInclusive ? s17 <= t17.max : s17 < t17.max;
      if (r8 && a12) return e13;
    }
    return null;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/util/LabelMatcher.js
var a5 = class _a extends t5 {
  static fromLabelSchema(e12, s17) {
    return __async(this, null, function* () {
      const r8 = s17.classes.map((a12) => __async(this, null, function* () {
        const s18 = yield e12.createMeshWriters(a12.meshes);
        return {
          minScale: a12.minScale,
          maxScale: a12.maxScale,
          meshes: s18,
          expression: null,
          where: yield e12.storage.createWhereClause(a12.where)
        };
      })), t16 = yield Promise.all(r8);
      return new _a(t16);
    });
  }
  constructor(e12) {
    super(), this._labels = e12;
  }
  match(e12, a12) {
    if (!this._labels.length) return null;
    const s17 = this._getLabels(a12.$view.scale), r8 = [];
    for (const t16 of s17) t16.where && !t16.where(e12) || r8.push(...t16.meshes);
    return r8;
  }
  _getLabels(e12) {
    return this._labels.filter((a12) => this._validForTileScale(a12, e12));
  }
  _validForTileScale(e12, a12) {
    const s17 = a12 - a12 / 4, r8 = a12 + a12 / 2;
    return (!e12.minScale || e12.minScale >= s17) && (!e12.maxScale || e12.maxScale <= r8);
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/util/MapMatcher.js
var t6 = class _t extends t5 {
  constructor(e12, t16) {
    super(), this._defaultSymbolSortKey = 0, this._nullResult = null, this._resultsMap = /* @__PURE__ */ new Map(), this._fields = [], this._fields = e12, this._separator = t16 || "";
  }
  static fromMatcherSchema(e12, l9) {
    return __async(this, null, function* () {
      const s17 = l9.expression ? [e12.storage.createComputedField({
        expression: l9.expression
      })] : [l9.field ? e12.storage.createComputedField({
        field: l9.field
      }) : null, l9.field2 ? e12.storage.createComputedField({
        field: l9.field2
      }) : null, l9.field3 ? e12.storage.createComputedField({
        field: l9.field3
      }) : null], r8 = (yield Promise.all(s17)).filter((e13) => !!e13), i11 = new _t(r8, l9.fieldDelimiter), a12 = yield e12.createMeshWriters(l9.defaultSymbol);
      i11.setDefault(a12);
      const u8 = yield e12.createMeshWriters(l9.backgroundFill);
      return i11.setBackgroundFill(u8), yield Promise.all(l9.map.map((t16, l10) => __async(this, null, function* () {
        const s18 = yield e12.createMeshWriters(t16.symbol);
        "<Null>" === t16.value ? i11.setNullResult(s18) : i11.add(t16.value, s18, l10 + 1);
      }))), i11;
    });
  }
  setNullResult(e12) {
    this._nullResult = e12;
  }
  getSortKey(e12, t16) {
    const l9 = this._getValueFromFields(e12, t16);
    if (null == l9 || "" === l9 || "<Null>" === l9) return 0;
    const s17 = this._resultsMap.get(l9.toString());
    return s17 ? s17.sortKey : this._defaultSymbolSortKey;
  }
  add(e12, t16, l9) {
    this._resultsMap.set(e12.toString(), {
      meshWriters: t16,
      sortKey: l9
    }), this._defaultSymbolSortKey = Math.max(this._defaultSymbolSortKey, l9 + 1);
  }
  size() {
    return super.size() + this._resultsMap.size;
  }
  doMatch(e12, t16) {
    const l9 = this._getValueFromFields(e12, t16);
    if (null !== this._nullResult && (null == l9 || "" === l9 || "<Null>" === l9)) return this._nullResult;
    if (null == l9) return null;
    const s17 = l9.toString();
    return this._resultsMap.get(s17)?.meshWriters;
  }
  _getValueFromFields(e12, t16) {
    const l9 = [];
    for (const s17 of this._fields) {
      const r8 = s17.read(e12, t16);
      null == r8 || "" === r8 ? l9.push("<Null>") : l9.push(r8);
    }
    return l9.join(this._separator);
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/util/createMatcher.js
function c6(c10, u8) {
  return __async(this, null, function* () {
    switch (u8.type) {
      case "simple":
      case "heatmap":
      case "dot-density":
      case "pie-chart":
        return t5.from(c10, u8);
      case "interval":
        return e6.fromIntervalSchema(c10, u8);
      case "dictionary":
        return e5.fromDictionaryRenderer(c10, u8);
      case "label":
        return a5.fromLabelSchema(c10, u8);
      case "map":
        return t6.fromMatcherSchema(c10, u8);
      case "subtype":
        return n9.fromSubtypes(c10, u8);
      case "cluster":
        return o8.fromClusterSchema(c10, u8);
      default:
        throw new Error("Impl");
    }
  });
}
var n9 = class _n extends t5 {
  constructor(e12, t16) {
    super(), this._subMatchers = e12, this._subtypeField = t16;
  }
  static fromSubtypes(e12, t16) {
    return __async(this, null, function* () {
      const r8 = /* @__PURE__ */ new Map(), s17 = [];
      for (const a12 in t16.renderers) {
        const n17 = parseInt(a12, 10), o16 = c6(e12, t16.renderers[a12]).then((e13) => r8.set(n17, e13));
        s17.push(o16);
      }
      return yield Promise.all(s17), new _n(r8, t16.subtypeField);
    });
  }
  match(e12, t16) {
    const r8 = e12.readAttribute(this._subtypeField), s17 = this._subMatchers.get(r8);
    return s17 ? s17.match(e12, t16) : null;
  }
};
var o8 = class _o extends t5 {
  static fromClusterSchema(e12, t16) {
    return __async(this, null, function* () {
      const [r8, s17] = yield Promise.all([c6(e12, t16.feature), c6(e12, t16.cluster)]);
      return new _o(r8, s17);
    });
  }
  constructor(e12, t16) {
    super(), this._featureMatcher = e12, this._clusterMatcher = t16;
  }
  match(e12, t16) {
    return 1 === e12.readAttribute("cluster_count") ? this._featureMatcher.match(e12, t16) : this._clusterMatcher.match(e12, t16);
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/FeatureMeshFactory.js
var s9 = class _s extends s8 {
  static create(e12, o16) {
    return __async(this, null, function* () {
      const r8 = yield c6(e12, o16.symbology), c10 = o16.labels ? yield c6(e12, o16.labels) : null;
      return new _s(r8, c10);
    });
  }
  constructor(e12, t16) {
    super(), this._symbology = e12, this._labels = t16;
  }
  destroy() {
  }
  enqueueMatcherRequests(e12, t16) {
    return __async(this, null, function* () {
      yield Promise.all([this._symbology.fetchResources(e12, t16), this._labels?.fetchResources(e12, t16)]);
    });
  }
  enqueueWriterRequests(e12, t16, s17) {
    const o16 = this._symbology.match(t16, s17);
    if (o16) {
      for (const r8 of o16) r8.enqueueRequest(e12, t16, s17);
      if (this._labels) {
        const o17 = this._labels.match(t16, s17);
        if (!o17) return;
        for (const r8 of o17) r8.enqueueRequest(e12, t16, s17);
      }
    }
  }
  write(e12, t16, s17, o16, r8) {
    const c10 = this._symbology.match(s17, o16);
    if (!c10) return;
    for (const i11 of c10) i11.write(e12, t16, s17, o16, r8);
    if (e12.entityRecordCount() >= 1 && this._labels) {
      const i11 = this._labels.match(s17, o16);
      if (!i11) return;
      for (const a12 of i11) a12.setReferences(c10), a12.write(e12, t16, s17, o16, r8);
    }
  }
  getSortKey(e12, t16) {
    return this._symbology.getSortKey(e12, t16);
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/util/MatcherContext.js
var s10 = class {
  constructor(s17, r8, t16, e12) {
    this.storage = s17, this.proxy = r8, this.viewParams = t16, this.registry = e12;
  }
  createMeshWriters(s17) {
    return __async(this, null, function* () {
      const r8 = s17.map((s18) => this.registry.createMeshWriter(this.storage, this.proxy, this.viewParams, s18));
      return Promise.all(r8);
    });
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/ProcessorTileMessageQueue.js
var e7 = class {
  constructor(e12) {
    this._outstandingMessages = [], this._queue = new _({
      concurrency: e12.concurrency,
      process: (s17) => e12.process(s17)
    });
  }
  push(s17) {
    return __async(this, null, function* () {
      if (s17.end) return yield Promise.all(this._outstandingMessages), yield this._queue.push(s17), void (this._outstandingMessages = []);
      const e12 = this._queue.push(s17);
      return this._outstandingMessages.push(e12), e12;
    });
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/aggregation/ComputedAggregateField.js
var s11 = class _s {
  static create(i11, e12) {
    return __async(this, null, function* () {
      if ("count" === e12.statisticType) {
        const i12 = new r(1);
        return new _s(e12.name, e12.alias, e12.type, e12.statisticType, i12);
      }
      const a12 = yield i11.createComputedField({
        expression: e12.onStatisticExpression?.expression,
        field: e12.onStatisticField
      });
      return new _s(e12.name, e12.alias, e12.type, e12.statisticType, a12);
    });
  }
  constructor(t16, s17, i11, e12, a12) {
    this.name = t16, this.alias = s17, this.type = i11, this.statisticType = e12, this.computed = a12;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/processor/AProcessorStrategy.js
var t7 = class {
  constructor(t16) {
    this.subscription = t16, this.handledChunks = /* @__PURE__ */ new Set();
  }
  destroy() {
  }
};
var e8 = class {
  constructor(t16, e12) {
    this._source = t16, this._attributeStore = e12, this._sendStates = /* @__PURE__ */ new Map();
  }
  destroy() {
  }
  get enablePixelBuffering() {
    return true;
  }
  onSubscribe(t16) {
    const e12 = this.createState(t16);
    this._sendStates.set(t16.key.id, e12), this.updateChunks();
  }
  onUnsubscribe(t16) {
    this._sendStates.get(t16.key.id)?.destroy(), this._sendStates.delete(t16.key.id);
  }
  invalidate() {
    const t16 = Array.from(this._sendStates.values());
    this._sendStates.clear();
    for (const e12 of t16) e12.destroy(), this.onSubscribe(e12.subscription);
  }
  invalidateAttributeData() {
  }
  getFeatureObjectIdsForAggregate(t16) {
    throw new Error("InternalError: AggregateId lookup not supported");
  }
  getDisplayIds(t16) {
    return this.displayMap(t16, (t17) => t17, (t17) => t17);
  }
  getDisplayAndObjectIds(t16) {
    return this.displayMap(t16, (t17) => t17, (t17, e12, s17) => [t17, s17]);
  }
  afterUpdateChunks() {
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/processor/AAggregateStrategy.js
var i5 = class extends e8 {
  constructor(t16, r8, s17, o16) {
    super(t16, r8), this.spatialReference = s17, this.aggregateFields = o16, this.events = new o2(), this.featureAdapter = o4;
  }
  get aggregateQueryEngine() {
    return this._aggregateQueryEngine || (this._aggregateQueryEngine = new $({
      featureStore: this,
      fieldsIndex: this._metadata.fieldsIndex,
      geometryType: this._metadata.geometryType,
      objectIdField: this._metadata.objectIdField,
      spatialReference: this.spatialReference
    })), this._aggregateQueryEngine;
  }
  removeChunks(e12) {
  }
  forEach(e12) {
    return this.forEachAggregateWorldSpace(e12);
  }
  forEachInBounds(e12, t16) {
  }
  forEachBounds(e12, a12) {
    const s17 = i();
    for (const t16 of e12) {
      const e13 = gt(s17, t16.geometry, false, false);
      e13 && a12(e13);
    }
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSourceMessage.js
var e9 = class {
  constructor(e12, i11, t16, s17, r8) {
    this.subscription = e12, this.reader = i11, this.clear = t16, this.end = s17, this.debugInfo = r8, this.type = "append";
  }
  get id() {
    return this.subscription.tile.id;
  }
  createMessage(e12, i11, t16) {
    return {
      type: "append",
      clear: this.clear,
      id: this.id,
      append: e12,
      end: this.end,
      debugInfo: this.debugInfo,
      subscriptionVesrion: this.subscription.version,
      version: i11,
      attributeEpoch: t16
    };
  }
};
var i6 = class {
  constructor(e12, i11, t16, s17, r8) {
    this.subscription = e12, this.reader = i11, this.remove = t16, this.end = s17, this.debugInfo = r8, this.type = "update";
  }
  get id() {
    return this.subscription.tile.id;
  }
  createMessage(e12, i11, t16) {
    return {
      type: "update",
      id: this.id,
      modify: e12,
      debugInfo: this.debugInfo,
      remove: this.remove,
      version: i11,
      subscriptionVesrion: this.subscription.version,
      end: this.end,
      attributeEpoch: t16
    };
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderJSON.js
var u5 = class _u extends M2 {
  static fromFeatures(t16, r8) {
    const {
      objectIdField: s17,
      geometryType: i11
    } = r8, n17 = et([], t16, i11, false, false, s17);
    for (let e12 = 0; e12 < n17.length; e12++) n17[e12].displayId = t16[e12].displayId;
    return _u.fromOptimizedFeatures(n17, r8);
  }
  static fromFeatureSet(e12, r8) {
    const s17 = ct(e12, r8.objectIdField);
    return _u.fromOptimizedFeatureSet(s17, r8);
  }
  static fromOptimizedFeatureSet(e12, t16) {
    const r8 = _u.fromOptimizedFeatures(e12.features, t16);
    return r8._exceededTransferLimit = e12.exceededTransferLimit, r8._transform = e12.transform, r8._fieldsIndex = new Z(e12.fields), r8;
  }
  static fromOptimizedFeatures(e12, t16, r8) {
    const s17 = new _u(e12, t16);
    return s17._fieldsIndex = t16.fieldsIndex, s17._transform = r8, s17;
  }
  static empty(e12) {
    return new _u([], e12);
  }
  constructor(e12, t16) {
    super(t16), this._exceededTransferLimit = false, this._featureIndex = -1, this._fieldsIndex = null, this._geometryType = t16.geometryType, this._features = e12;
  }
  get fields() {
    return this._fieldsIndex;
  }
  get geometryType() {
    return this._geometryType;
  }
  get hasFeatures() {
    return !!this._features.length;
  }
  get hasNext() {
    return this._featureIndex + 1 < this._features.length;
  }
  get exceededTransferLimit() {
    return this._exceededTransferLimit;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get _current() {
    return this._features[this._featureIndex];
  }
  removeIds(e12) {
    const t16 = new Set(e12);
    this._features = this._features.filter((e13) => !(null != e13.objectId && t16.has(e13.objectId)));
  }
  getSize() {
    return this._features.length;
  }
  getCursor() {
    return this.copy();
  }
  getInTransform() {
    return this._transform;
  }
  getAttributeHash() {
    let e12 = "";
    for (const t16 in this._current.attributes) e12 += this._current.attributes[t16];
    return e12;
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e12) {
    this._featureIndex = e12;
  }
  getObjectId() {
    return this._current?.objectId;
  }
  getDisplayId() {
    return this._current.displayId;
  }
  setDisplayId(e12) {
    this._current.displayId = e12;
  }
  copy() {
    const e12 = new _u(this._features, this.metadata);
    return this.copyInto(e12), e12;
  }
  next() {
    for (; ++this._featureIndex < this._features.length && !this._getExists(); ) ;
    return this._featureIndex < this._features.length;
  }
  readGeometryArea() {
    return s4(this._current) ? Nt(this._current.geometry, 2) : 0;
  }
  _readX() {
    return s4(this._current) ? this._current.geometry.coords[0] : 0;
  }
  _readY() {
    return s4(this._current) ? this._current.geometry.coords[1] : 0;
  }
  _readGeometry() {
    return s4(this._current) ? this._current.geometry ?? null : null;
  }
  _readServerCentroid() {
    return this._current.centroid;
  }
  _readAttribute(e12, t16) {
    if (!this._fieldsIndex) {
      const t17 = this._current.attributes[e12];
      if (void 0 !== t17) return t17;
      const r9 = e12.toLowerCase();
      for (const e13 in this._current.attributes) if (e13.toLowerCase() === r9) return this._current.attributes[e13];
      return;
    }
    const r8 = this._fieldsIndex.get(e12);
    if (!r8) return;
    let s17 = this._current.attributes[r8.name];
    return null == s17 ? s17 : ("esriFieldTypeTimestampOffset" === this.fields.get(e12)?.type && (s17 = this.parseTimestampOffset(s17)), t16 && this.fields.isDateField(e12) ? new Date(s17) : s17);
  }
  _readAttributes() {
    return this._current.attributes;
  }
  copyInto(e12) {
    super.copyInto(e12), e12._featureIndex = this._featureIndex, e12._transform = this._transform, e12._fieldsIndex = this._fieldsIndex;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/processor/BinningStrategy.js
var m3 = class extends t7 {
  constructor(e12, t16) {
    super(e12), this.bins = /* @__PURE__ */ new Map(), this.featureCache = /* @__PURE__ */ new Map(), this.done = false, this._store = t16;
  }
  reset() {
    this.destroy(), this.done = false;
  }
  destroy() {
    const e12 = this.subscription.tile.key.level;
    for (const t16 of this.featureCache.keys()) this._store.releaseDisplayIdForObjectId(`${t16}.${e12}`);
    this.bins.clear(), this.featureCache.clear(), this.handledChunks.clear();
  }
  get tile() {
    return this.subscription.tile;
  }
  *featuresWorldSpace() {
    for (const t16 of this.featureCache.values()) {
      const s17 = t16.clone();
      s17.geometry && pt(s17.geometry, s17.geometry, false, false, this.subscription.tile.transform), yield s17;
    }
  }
};
var g3 = class _g extends i5 {
  static create(e12, t16, s17, a12, o16) {
    return __async(this, null, function* () {
      const n17 = new p({
        spatialReference: t16
      }), l9 = yield Promise.all(e12.fields.map((e13) => __async(this, null, function* () {
        return s11.create(n17, e13);
      }))), u8 = e12.featureFilter ? yield p2.create({
        geometryType: s17.metadata.geometryType,
        hasM: false,
        hasZ: false,
        timeInfo: s17.metadata.timeInfo,
        fieldsIndex: s17.metadata.fieldsIndex,
        spatialReference: t16,
        filterJSON: e12.featureFilter
      }) : null;
      return "geohash" === e12.index.type && (yield x(t16, f2.WGS84)), new _g(e12, u8, o16, l9, t16, s17, a12);
    });
  }
  constructor(e12, t16, s17, r8, i11, a12, o16) {
    super(a12, o16, i11, r8), this._schema = e12, this._featureFilter = t16, this._timeZone = s17, this._metadata = new i2({
      geometryType: "esriGeometryPolygon",
      objectIdField: "aggregateId",
      fields: e12.fields,
      globalIdField: null,
      spatialReference: a12.metadata.spatialReference,
      subtypeField: null,
      subtypes: null,
      timeInfo: null,
      timeReferenceUnknownClient: null,
      typeIdField: null,
      types: null
    });
  }
  createState(e12) {
    return new m3(e12, this._attributeStore);
  }
  applyLocalEdit(e12) {
    return __asyncGenerator(this, null, function* () {
      for (const t16 of this._sendStates.values()) {
        t16.reset();
        const e13 = new e9(t16.subscription, u5.empty(this._source.metadata), true, false, {});
        yield e13;
      }
    });
  }
  displayMap(e12, t16, s17) {
    const r8 = new Map(e12.map((e13) => [t16(e13), e13])), i11 = [];
    for (const a12 of this._sendStates.values()) for (const e13 of a12.featuresWorldSpace()) {
      const {
        objectId: t17,
        displayId: a13
      } = e13, o16 = r8.get(t17);
      if (null != o16) {
        const e14 = s17(a13, o16, t17);
        i11.push(e14), r8.delete(t17);
      }
    }
    return i11;
  }
  getDisplayFeatures(e12) {
    const s17 = new Set(e12), r8 = /* @__PURE__ */ new Set(), i11 = [];
    for (const a12 of this._sendStates.values()) for (const e13 of a12.featuresWorldSpace()) s17.has(e13.displayId) && !r8.has(e13.objectId) && (e13.geometry && i11.push(__spreadProps(__spreadValues({}, nt(e13, this._metadata.geometryType, false, false)), {
      displayId: e13.displayId
    })), r8.add(e13.objectId));
    return {
      features: [],
      aggregates: i11
    };
  }
  getFeatureObjectIdsForAggregate(e12) {
    for (const t16 of this._sendStates.values()) for (const s17 of t16.bins.values()) if (s17.id === e12) return Array.from(s17.containedObjectIds);
    return [];
  }
  updateChunks() {
    return __asyncGenerator(this, null, function* () {
      if (this._source.chunks().length) for (const e12 of this._sendStates.values()) yield* __yieldStar(this._update(e12, this._source));
    });
  }
  forEachAggregateWorldSpace(e12) {
    for (const t16 of this._sendStates.values()) for (const s17 of t16.featuresWorldSpace()) e12(s17);
  }
  _createIndexOptions(e12) {
    switch (this._schema.index.type) {
      case "geohash":
        return {
          type: "geohash",
          fields: this.aggregateFields,
          featureFilter: this._featureFilter,
          geohashLevel: this._schema.index.fixBinLevel,
          spatialReference: this.spatialReference,
          timeZone: this._timeZone,
          scale: e12.scale
        };
      case "grid": {
        const t16 = this._schema.index.fixedBinLevel, s17 = null != t16 ? e12.tileInfoView.getLODInfoAt(t16).scale : e12.scale;
        return {
          type: "grid",
          fields: this.aggregateFields,
          cellSize: this._schema.index.size,
          featureFilter: this._featureFilter,
          spatialReference: this.spatialReference,
          timeZone: this._timeZone,
          scale: s17
        };
      }
    }
  }
  _update(e12, t16) {
    return __asyncGenerator(this, null, function* () {
      const {
        handledChunks: r8,
        subscription: i11,
        bins: a12,
        featureCache: o16
      } = e12, n17 = i11.tile;
      if (e12.done) return;
      for (const s17 of t16.chunks()) {
        if (r8.has(s17.chunkId)) continue;
        r8.add(s17.chunkId);
        const t17 = s17.queryInfo;
        if ("tileId" in t17) {
          const e13 = new e4(t17.tileId);
          if (e13.level !== n17.level || e13.world !== n17.key.world) continue;
        }
        s17.getAggregateIndex(this._createIndexOptions(e12.tile)).putBounded(a12, e12.tile.extent, e12.tile.resolution);
      }
      const c10 = [], d9 = i11.tile.transform, u8 = i11.tile.key.level;
      for (const l9 of a12.values()) {
        let e13 = o16.get(l9.id);
        if (e13) e13.attributes = l9.getAttributes();
        else {
          const t17 = l9.getGeometry(this.spatialReference, d9);
          e13 = new e3(t17, l9.getAttributes(), null), t17 || (e13.centroid = l9.getGeometricCentroid(this.spatialReference, d9)), e13.objectId = l9.id, e13.displayId = this._attributeStore.createDisplayIdForObjectId(`${e13.objectId}.${u8}`), o16.set(l9.id, e13);
        }
        c10.push(e13);
      }
      this.events.emit("changed"), e12.done = !t16.updateTracking.updating;
      const h6 = u5.fromOptimizedFeatures(c10, this._metadata, d9), m9 = h6.getCursor(), g5 = e12.subscription.tile.createArcadeEvaluationOptions(this._timeZone);
      for (; m9.next(); ) this._attributeStore.setAttributeData(m9.getDisplayId(), m9, g5);
      const y8 = new i6(e12.subscription, h6, [], e12.done, {});
      yield y8;
    });
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/aggregation/AAggregateCell.js
var t8 = class {
  constructor(t16) {
    this._statistics = t16;
  }
  get statistics() {
    return this._statistics;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/aggregation/AccumulatedStatistics.js
var e10 = Math.PI / 180;
var s12 = class _s {
  static create(t16) {
    return new _s(t16.map((t17) => i7(t17)));
  }
  constructor(t16) {
    this._statistics = t16;
  }
  values() {
    return this._statistics.values();
  }
  insert(t16, e12) {
    for (const s17 of this._statistics) s17.insert(t16, e12);
  }
  merge(t16) {
    for (let e12 = 0; e12 < this._statistics.length; e12++) {
      const s17 = this._statistics[e12], i11 = t16._statistics[e12];
      if (s17.field.name !== i11.field.name) throw new Error("InternalError: Tried to merge incompatible statistics");
      s17.merge(i11);
    }
  }
  clone() {
    return new _s(this._statistics.map((t16) => t16.clone()));
  }
};
function i7(t16) {
  switch (t16.statisticType) {
    case "min":
      return new r3(t16);
    case "max":
      return new u6(t16);
    case "avg":
      return new c7(t16);
    case "avg_angle":
      return new h4(t16);
    case "sum":
    case "count":
      return new a6(t16);
    case "mode":
      return new o9(t16);
  }
}
var n10 = class {
  constructor(t16) {
    this.field = t16;
  }
  insert(e12, s17) {
    if (!this.field.computed) return;
    const i11 = this.field.computed.read(e12, s17);
    n6(i11) || this._insertValue(i11);
  }
};
var r3 = class _r extends n10 {
  constructor() {
    super(...arguments), this.type = "min", this.value = Number.MAX_VALUE;
  }
  _insertValue(t16) {
    this.value = Math.min(this.value, t16);
  }
  merge(t16) {
    this.value = Math.min(this.value, t16.value);
  }
  clone() {
    const t16 = new _r(this.field);
    return t16.value = this.value, t16;
  }
};
var u6 = class _u extends n10 {
  constructor() {
    super(...arguments), this.type = "max", this.value = Number.MIN_VALUE;
  }
  _insertValue(t16) {
    this.value = Math.max(this.value, t16);
  }
  merge(t16) {
    this.value = Math.max(this.value, t16.value);
  }
  clone() {
    const t16 = new _u(this.field);
    return t16.value = this.value, t16;
  }
};
var a6 = class _a extends n10 {
  constructor() {
    super(...arguments), this.type = "sum", this.value = 0;
  }
  _insertValue(t16) {
    this.value += t16;
  }
  merge(t16) {
    this.value += t16.value;
  }
  clone() {
    const t16 = new _a(this.field);
    return t16.value = this.value, t16;
  }
};
var c7 = class _c extends n10 {
  constructor() {
    super(...arguments), this.type = "avg", this._total = 0, this._count = 0;
  }
  get value() {
    return this._total / this._count;
  }
  _insertValue(t16) {
    this._total += t16, this._count += 1;
  }
  merge(t16) {
    this._total += t16._total, this._count += t16._count;
  }
  clone() {
    const t16 = new _c(this.field);
    return t16._total = this._total, t16._count = this._count, t16;
  }
};
var h4 = class _h extends n10 {
  constructor() {
    super(...arguments), this.type = "avg_angle", this._x = 0, this._y = 0, this._count = 0;
  }
  get value() {
    const t16 = this._x / this._count, e12 = this._y / this._count, s17 = 180 / Math.PI;
    return Math.atan2(e12, t16) * s17;
  }
  _insertValue(t16) {
    this._x = this._x + Math.cos(t16 * e10), this._y = this._y + Math.sin(t16 * e10), this._count += 1;
  }
  merge(t16) {
    this._x += t16._x, this._y += t16._y, this._count += t16._count;
  }
  clone() {
    const t16 = new _h(this.field);
    return t16._x = this._x, t16._y = this._y, t16._count = this._count, t16;
  }
};
var o9 = class _o extends n10 {
  constructor() {
    super(...arguments), this._frequencies = /* @__PURE__ */ new Map();
  }
  get value() {
    let t16, e12 = 0;
    for (const [s17, i11] of this._frequencies.entries()) i11 > e12 && (e12 = i11, t16 = s17);
    return t16;
  }
  _insertValue(t16) {
    const e12 = this._frequencies.get(t16);
    null != e12 ? this._frequencies.set(t16, e12 + 1) : this._frequencies.set(t16, 1);
  }
  merge(t16) {
    for (const [e12, s17] of t16._frequencies.entries()) {
      const t17 = this._frequencies.get(e12);
      null != t17 ? this._frequencies.set(e12, t17 + s17) : this._frequencies.set(e12, s17);
    }
  }
  clone() {
    const t16 = new _o(this.field);
    return t16._frequencies = new Map(this._frequencies), t16;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/aggregation/GridCell.js
var l2 = class _l extends t8 {
  static createId(t16, e12) {
    return `${t16}.${e12}`;
  }
  static create(t16, e12, r8, i11) {
    return new _l(t16, e12, s12.create(r8), i11);
  }
  constructor(t16, e12, r8, i11) {
    super(r8), this.gridX = t16, this.gridY = e12, this._worldUnitsPerCell = i11, this._count = 0, this._xWorldTotal = 0, this._yWorldTotal = 0, this._objectIds = /* @__PURE__ */ new Set();
  }
  get id() {
    return _l.createId(this.gridX, this.gridY);
  }
  get containedObjectIds() {
    return this._objectIds;
  }
  get count() {
    return this._count;
  }
  get firstObjectId() {
    return this._objectIds.values().next().value;
  }
  get centroidXWorld() {
    return this._xWorldTotal / this._count;
  }
  get centroidYWorld() {
    return this._yWorldTotal / this._count;
  }
  clone() {
    const t16 = new _l(this.gridX, this.gridY, this._statistics.clone(), this._worldUnitsPerCell);
    return t16._count = this._count, t16._xWorldTotal = this._xWorldTotal, t16._yWorldTotal = this._yWorldTotal, t16._firstFeatureAttributes = this._firstFeatureAttributes, t16._objectIds = new Set(this._objectIds), t16;
  }
  insert(t16, e12, r8, i11) {
    0 === this._count ? this._firstFeatureAttributes = t16.readAttributes() : this._firstFeatureAttributes = null, this._count += 1, this._xWorldTotal += r8, this._yWorldTotal += i11, this._statistics.insert(t16, e12), this._objectIds.add(t16.getObjectId());
  }
  merge(t16) {
    if (0 !== t16._count) {
      this._count += t16._count, this._firstFeatureAttributes = t16._firstFeatureAttributes, this._xWorldTotal += t16._xWorldTotal, this._yWorldTotal += t16._yWorldTotal, this._statistics.merge(t16._statistics);
      for (const e12 of t16._objectIds.values()) this._objectIds.add(e12);
    }
  }
  getCentroidX(e12) {
    return null == e12 ? this.centroidXWorld : N(e12, this.centroidXWorld);
  }
  getCentroidY(t16) {
    return null == t16 ? this.centroidYWorld : w2(t16, this.centroidYWorld);
  }
  getGeometry(t16, e12) {
    const s17 = this.gridX * this._worldUnitsPerCell, o16 = this.gridY * this._worldUnitsPerCell, l9 = new e2([4], [s17, o16, s17 + this._worldUnitsPerCell, o16, s17 + this._worldUnitsPerCell, o16 + this._worldUnitsPerCell, s17, o16 + this._worldUnitsPerCell]);
    if (null != e12) {
      const t17 = new e2();
      return at(t17, l9, false, false, "esriGeometryPolygon", e12);
    }
    return l9;
  }
  getCentroid(t16) {
    const e12 = new e2([], [this.centroidXWorld, this.centroidYWorld]);
    if (null != t16) {
      const s17 = new e2();
      return at(s17, e12, false, false, "esriGeometryPoint", t16);
    }
    return e12;
  }
  getGeometricCentroid(t16, e12) {
    const s17 = this.gridX * this._worldUnitsPerCell + 0.5 * this._worldUnitsPerCell, o16 = this.gridY * this._worldUnitsPerCell + 0.5 * this._worldUnitsPerCell, l9 = new e2([], [s17, o16]);
    if (null != e12) {
      const t17 = new e2();
      return at(t17, l9, false, false, "esriGeometryPoint", e12);
    }
    return l9;
  }
  getAttributes() {
    const t16 = {
      aggregateId: this.id
    };
    for (const e12 of this._statistics.values()) t16[e12.field.name] = e12.value;
    return null != this._firstFeatureAttributes ? __spreadValues(__spreadValues({}, t16), this._firstFeatureAttributes) : t16;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/aggregation/AAggregateSpatialIndex.js
var t9 = class {
  constructor(e12) {
    this._options = e12;
  }
  insert(e12, t16) {
    const r8 = e12.getCursor(), o16 = {
      $view: {
        scale: this._options.scale,
        timeZone: this._options.timeZone
      }
    };
    for (; r8.next(); ) this._insertFeature(r8, o16, t16);
  }
  _insertFeature(t16, r8, o16) {
    const {
      featureFilter: i11
    } = this._options;
    if (null !== i11 && !i11.check(t16)) return;
    let s17 = 0, n17 = 0;
    if ("esriGeometryPoint" === t16.geometryType) s17 = t16.readXWorldSpace(), n17 = t16.readYWorldSpace();
    else {
      if (o16) {
        const r10 = t16.readCentroidForDisplay();
        if (null == r10) return;
        const [o17, i12] = r10.coords;
        if (o17 < 0 || o17 > a2 || i12 < 0 || i12 > a2) return;
      }
      const r9 = t16.readCentroidWorldSpace();
      if (null == r9) return;
      s17 = r9.coords[0], n17 = r9.coords[1];
    }
    this._insert(t16, s17, n17, r8);
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/aggregation/GridSpatialIndex.js
var l3 = 96;
function o10(i11, s17) {
  return W(i11) * o3 * l3 / s17;
}
var n11 = class extends t9 {
  constructor(t16) {
    super(t16), this._cells = /* @__PURE__ */ new Map(), this._pixelsPerMapUnit = o10(t16.spatialReference, t16.scale);
  }
  put(t16) {
    for (const e12 of this._cells.values()) {
      const i11 = t16.get(e12.id);
      i11 ? i11.merge(e12) : t16.set(e12.id, e12.clone());
    }
  }
  putBounded(t16, e12, i11) {
    const s17 = [e12.xmin, e12.ymin, e12.xmax, e12.ymax], [l9, o16, n17, r8] = s17, c10 = Math.floor(l9 * this._pixelsPerMapUnit / this._options.cellSize), p7 = Math.floor(o16 * this._pixelsPerMapUnit / this._options.cellSize), a12 = Math.ceil(n17 * this._pixelsPerMapUnit / this._options.cellSize), h6 = Math.ceil(r8 * this._pixelsPerMapUnit / this._options.cellSize);
    for (let _5 = p7; _5 <= h6; _5++) for (let e13 = c10; e13 <= a12; e13++) {
      const i12 = `${e13}.${_5}`, s18 = this._cells.get(i12);
      if (!s18) continue;
      const l10 = t16.get(s18.id);
      l10 ? s18 && !t16.has(s18.id) && l10.merge(s18) : t16.set(s18.id, s18.clone());
    }
  }
  _insert(t16, e12, i11, s17) {
    const l9 = e12 * this._pixelsPerMapUnit, o16 = i11 * this._pixelsPerMapUnit, n17 = Math.floor(l9 / this._options.cellSize), r8 = Math.floor(o16 / this._options.cellSize);
    this._getCellOrCreate(n17, r8).insert(t16, s17, e12, i11);
  }
  _getCellOrCreate(t16, e12) {
    const i11 = l2.createId(t16, e12);
    let l9 = this._cells.get(i11);
    if (!l9) {
      const o16 = 1 * this._options.cellSize / this._pixelsPerMapUnit;
      l9 = l2.create(t16, e12, this._options.fields, o16), this._cells.set(i11, l9);
    }
    return l9;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/processor/support/WithDisplayId.js
var s13 = class {
  constructor(s17, t16) {
    this.inner = s17, this.displayId = t16;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/processor/ClusterStrategy.js
var _3 = 128;
var m4 = class extends t7 {
  constructor(e12) {
    super(e12), this.didSend = false, this.done = false;
  }
};
var y4 = class {
  constructor(e12, t16, s17, i11, r8) {
    this._level = e12, this._scale = t16, this._indexOptions = s17, this._clusterRadius = i11, this._store = r8, this._cells = /* @__PURE__ */ new Map(), this._handledChunks = /* @__PURE__ */ new Set(), this._statistics = /* @__PURE__ */ new Map(), this._clusters = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._clearClusters();
  }
  _clearClusters() {
    for (const e12 of this._clusters.values()) this._store.releaseDisplayIdForObjectId(e12.inner.id);
    this._clusters.clear();
  }
  *aggregatesWorldSpace() {
    for (const e12 of this._clusters.values()) {
      const s17 = e12.inner.getCentroid(null), i11 = new e3(s17, e12.inner.getAttributes(), null);
      i11.objectId = e12.inner.id, i11.displayId = e12.displayId, yield i11;
    }
  }
  clusters() {
    return this._clusters.values();
  }
  updateChunks(e12, t16) {
    let s17 = false;
    for (const a12 of e12) {
      const e13 = a12.queryInfo;
      if ("tileId" in e13) {
        if (new e4(e13.tileId).level !== this._level) continue;
      }
      if (!this._handledChunks.has(a12.normalizedChunkId)) {
        this._handledChunks.add(a12.normalizedChunkId), s17 = true;
        a12.getAggregateIndex(__spreadProps(__spreadValues({}, this._indexOptions), {
          scale: this._scale
        })).put(this._cells);
      }
    }
    const i11 = {
      xMin: 1 / 0,
      yMin: 1 / 0,
      xMax: -1 / 0,
      yMax: -1 / 0
    }, r8 = o10(this._indexOptions.spatialReference, this._scale), n17 = this._indexOptions.cellSize;
    for (const {
      subscription: a12
    } of t16) {
      const e13 = a12.tile.bounds, t17 = Math.floor(e13[0] * r8 / n17), s18 = Math.floor(e13[1] * r8 / n17), l9 = Math.ceil(e13[2] * r8 / n17), o16 = Math.ceil(e13[3] * r8 / n17);
      i11.xMin = Math.min(i11.xMin, t17), i11.yMin = Math.min(i11.yMin, s18), i11.xMax = Math.max(i11.xMax, l9), i11.yMax = Math.max(i11.yMax, o16);
    }
    return null != this._lastCellBounds && i11.xMin === this._lastCellBounds.xMin && i11.yMin === this._lastCellBounds.yMin && i11.yMin === this._lastCellBounds.yMin && i11.yMax === this._lastCellBounds.yMax || (s17 = true, this._lastCellBounds = i11), s17 && this._clusterCells(i11), s17;
  }
  updateStatistics(e12) {
    return __async(this, null, function* () {
      let t16 = false;
      for (const s17 of this._clusters.values()) s17.inner.count > 1 && (t16 = this._updateAggregateStatistics(this._statistics, s17.inner) || t16);
      if (t16) {
        const t17 = Array.from(this._statistics.entries()).map(([e13, t18]) => ({
          fieldName: e13,
          minValue: t18.minValue,
          maxValue: t18.maxValue
        }));
        yield e12.container.updateStatistics(this._level, t17);
      }
    });
  }
  createAggregateFeatures(e12, r8) {
    const n17 = e12.subscription, a12 = [], l9 = n17.tile.transform;
    for (const o16 of this._clusters.values()) {
      let e13 = o16.inner.getCentroidX(l9);
      const r9 = o16.inner.getCentroidY(l9), d9 = n17.tile.lod, c10 = d9.wrap ? d9.worldSize[0] : null, u8 = 1 === o16.inner.count ? o16.inner.firstObjectId : o16.inner.id, h6 = o16.displayId;
      if (null != c10) if (1 === c10) {
        const n18 = new e2([], [e13, r9]), l10 = new e3(n18, o16.inner.getAttributes(), null);
        l10.geometry.coords[0] -= a2, l10.objectId = u8, l10.displayId = h6, a12.push(l10);
        const d10 = new e2([], [e13, r9]), c11 = new e3(d10, o16.inner.getAttributes(), null);
        c11.geometry.coords[0] += a2, c11.objectId = u8, c11.displayId = h6, a12.push(c11);
      } else e13 > a2 + a2 / 2 ? e13 -= c10 * a2 : e13 < -a2 / 2 && (e13 += c10 * a2);
      if (e13 < a2 + _3 && e13 >= -_3 && r9 < a2 + _3 && r9 >= -_3) {
        const i11 = new e2([], [e13, r9]), n18 = new e3(i11, o16.inner.getAttributes(), null);
        n18.objectId = u8, n18.displayId = h6, a12.push(n18);
      }
    }
    return u5.fromOptimizedFeatures(a12, r8, n17.tile.transform);
  }
  _clusterCells(e12) {
    let t16 = Array.from(this._cells.values());
    t16 = t16.sort((e13, t17) => t17.count - e13.count);
    const s17 = [];
    for (const n17 of this._clusters.values()) s17.push(n17.inner.id);
    this._clusters.clear();
    const i11 = this._clusterRadius * (1 / o10(this._indexOptions.spatialReference, this._scale)), r8 = 1 + this._clusterRadius / this._indexOptions.cellSize, l9 = /* @__PURE__ */ new Set();
    for (const a12 of t16) {
      if (l9.has(a12.id)) continue;
      if (a12.gridX < e12.xMin || a12.gridX > e12.xMax || a12.gridY < e12.yMin || a12.gridY > e12.yMax) continue;
      const t17 = this._store.createDisplayIdForObjectId(a12.id), s18 = new s13(a12.clone(), t17);
      l9.add(a12.id), this._clusters.set(a12.id, s18);
      const o16 = a12.centroidXWorld, c10 = a12.centroidYWorld;
      for (let e13 = a12.gridY - r8; e13 <= a12.gridY + r8; e13++) for (let t18 = a12.gridX - r8; t18 <= a12.gridX + r8; t18++) {
        if (e13 === a12.gridY && t18 === a12.gridX) continue;
        const r9 = this._cells.get(l2.createId(t18, e13));
        if (!r9 || l9.has(r9.id)) continue;
        const d9 = Math.abs(r9.centroidXWorld - o16), u8 = Math.abs(r9.centroidYWorld - c10);
        d9 < i11 && u8 < i11 && (s18.inner.merge(r9), l9.add(r9.id));
      }
    }
    for (const n17 of s17) this._store.releaseDisplayIdForObjectId(n17);
  }
  _updateAggregateStatistics(e12, t16) {
    let s17 = false;
    for (const i11 of t16.statistics.values()) {
      if ("esriFieldTypeString" === i11.field.type) continue;
      const t17 = i11.value, r8 = i11.field, n17 = e12.get(r8.name);
      if (n17) {
        const {
          minValue: e13,
          maxValue: i12
        } = n17, r9 = Math.min(n17.minValue, t17), a12 = Math.max(n17.maxValue, t17);
        e13 === r9 && i12 === a12 || (n17.minValue = r9, n17.maxValue = a12, s17 = true);
      } else e12.set(r8.name, {
        minValue: t17,
        maxValue: t17
      }), s17 = true;
    }
    return s17;
  }
};
var S3 = class _S extends i5 {
  static create(e12, t16, s17, i11, n17, a12) {
    return __async(this, null, function* () {
      const l9 = new p({
        spatialReference: s17
      }), o16 = {
        type: "grid",
        fields: yield Promise.all(t16.fields.map((e13) => __async(this, null, function* () {
          return s11.create(l9, e13);
        }))),
        spatialReference: s17,
        featureFilter: t16.featureFilter ? yield p2.create({
          geometryType: i11.metadata.geometryType,
          hasM: false,
          hasZ: false,
          timeInfo: i11.metadata.timeInfo,
          fieldsIndex: i11.metadata.fieldsIndex,
          spatialReference: s17,
          filterJSON: t16.featureFilter
        }) : null,
        cellSize: t16.clusterRadius / 4,
        timeZone: a12
      };
      return new _S(e12, t16.clusterRadius, o16, t16.fields, i11, n17);
    });
  }
  constructor(e12, t16, s17, i11, r8, n17) {
    super(r8, n17, s17.spatialReference, s17.fields), this._connection = e12, this._clusterRadius = t16, this._indexOptions = s17, this._cellsPerScale = /* @__PURE__ */ new Map(), this._metadata = new i2({
      geometryType: "esriGeometryPoint",
      objectIdField: "aggregateId",
      fields: [...i11, ...this._source.metadata.fieldsIndex.fields, {
        name: "aggregateId",
        alias: "aggregateId",
        type: "esriFieldTypeOID"
      }],
      globalIdField: null,
      spatialReference: r8.metadata.spatialReference,
      subtypeField: null,
      subtypes: null,
      timeInfo: null,
      timeReferenceUnknownClient: null,
      typeIdField: null,
      types: null
    });
  }
  get enablePixelBuffering() {
    return false;
  }
  invalidate() {
    super.invalidate();
    for (const e12 of this._cellsPerScale.values()) e12.destroy();
    this._cellsPerScale.clear();
  }
  onSubscribe(e12) {
    super.onSubscribe(e12), this._requiredLevel = e12.tile.level, this._requiredScale = e12.tile.scale;
  }
  createState(e12) {
    return new m4(e12);
  }
  applyLocalEdit(e12) {
    return __asyncGenerator(this, null, function* () {
      for (const t16 of this._cellsPerScale.values()) t16.destroy();
      this._cellsPerScale.clear();
      for (const t16 of this._sendStates.values()) t16.done = false;
    });
  }
  displayMap(e12, t16, s17) {
    const i11 = new Map(e12.map((e13) => [t16(e13), e13])), r8 = [], n17 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const a12 of n17.clusters()) {
      const e13 = i11.get(a12.inner.id);
      if (null == e13) {
        if (1 === a12.inner.count) {
          const e14 = i11.get(a12.inner.firstObjectId);
          if (null != e14) {
            const t17 = s17(a12.displayId, e14, a12.inner.firstObjectId);
            r8.push(t17), i11.delete(a12.inner.firstObjectId);
          }
        }
      } else {
        const t17 = s17(a12.displayId, e13, a12.inner.id);
        r8.push(t17), i11.delete(a12.inner.id);
      }
    }
    return r8;
  }
  getDisplayFeatures(t16) {
    const s17 = new Set(t16), i11 = /* @__PURE__ */ new Set(), r8 = [], n17 = [], a12 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const l9 of a12.aggregatesWorldSpace()) if (s17.has(l9.displayId) && !i11.has(l9.displayId)) {
      const t17 = nt(l9, this._metadata.geometryType, false, false);
      if (i11.add(l9.displayId), 1 === t17.attributes.cluster_count) {
        r8.push(__spreadProps(__spreadValues({}, t17), {
          displayId: l9.displayId
        }));
        continue;
      }
      n17.push(__spreadProps(__spreadValues({}, t17), {
        displayId: l9.displayId
      }));
    }
    return {
      features: r8,
      aggregates: n17
    };
  }
  getFeatureObjectIdsForAggregate(e12) {
    const t16 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const s17 of t16.clusters()) if (s17.inner.id === e12) return Array.from(s17.inner.containedObjectIds);
    return [];
  }
  updateChunks() {
    return __asyncGenerator(this, null, function* () {
      const e12 = this._source.chunks();
      if (!e12.length) return;
      const t16 = this._getClusterState(this._requiredLevel, this._requiredScale), s17 = Array.from(this._sendStates.values()).filter((e13) => e13.subscription.tile.level === this._requiredLevel);
      if (t16.updateChunks(e12, s17) || !this._source.updateTracking.updating) for (const n17 of s17) n17.subscription.tile.level === this._requiredLevel && (n17.didSend = false, n17.done = false);
      const i11 = Array.from(this._sendStates.values()).filter((e13) => e13.done).map((e13) => e13.subscription.tile.key), r8 = new Set(i11);
      for (const n17 of this._sendStates.values()) {
        if (this._source.updateTracking.updating) {
          if (i11.some((e13) => e13.containsChild(n17.subscription.tile.key))) continue;
          if (n17.subscription.tile.key.getChildKeys().every((e13) => r8.has(e13))) continue;
        }
        n17.didSend || n17.subscription.tile.level !== this._requiredLevel || (n17.didSend = true, yield* __yieldStar(this._update(n17, t16, this._source)));
      }
      yield new __await(t16.updateStatistics(this._connection));
    });
  }
  forEachAggregateWorldSpace(e12) {
    if (null == this._requiredLevel || null == this._requiredScale) return;
    const t16 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const s17 of t16.aggregatesWorldSpace()) e12(s17);
  }
  _getClusterState(e12, t16) {
    if (null == e12 || null == t16) throw new Error("InternalError: Level and scale must be defined");
    let s17 = this._cellsPerScale.get(t16);
    return s17 || (s17 = new y4(e12, t16, this._indexOptions, this._clusterRadius, this._attributeStore), this._cellsPerScale.set(t16, s17)), s17;
  }
  _update(e12, t16, s17) {
    return __asyncGenerator(this, null, function* () {
      if (e12.done) return;
      const i11 = t16.createAggregateFeatures(e12, this._metadata);
      this.events.emit("changed"), e12.done = !s17.updateTracking.updating;
      const r8 = i11.getCursor(), n17 = e12.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.timeZone);
      for (; r8.next(); ) this._attributeStore.setAttributeData(r8.getDisplayId(), r8, n17);
      const a12 = new e9(e12.subscription, i11, true, e12.done, {});
      yield a12;
    });
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/FeatureSpatialIndex.js
var t10 = class _t {
  static fromReader(o16) {
    const e12 = [], r8 = o16.copy(), a12 = i();
    for (; r8.next(); ) {
      r8.getBounds(a12) && e12.push(r8.getIndex());
    }
    const i11 = i3(9, (n17) => (r8.setIndex(n17), {
      minX: r8.getBoundsXMin(),
      minY: r8.getBoundsYMin(),
      maxX: r8.getBoundsXMax(),
      maxY: r8.getBoundsYMax()
    }));
    return i11.load(e12), new _t(i11);
  }
  constructor(n17) {
    this._index = n17;
  }
  search(n17) {
    const s17 = {
      minX: n17[0],
      minY: n17[1],
      maxX: n17[2],
      maxY: n17[3]
    };
    return this._index.search(s17);
  }
};

// ../../../node_modules/@arcgis/core/geohash/geohashUtils.js
var m5 = new Float64Array(2);
var p4 = new Float64Array(2);
var j3 = 64;
function S4(t16, e12, f7, l9) {
  const a12 = [t16.xmin, t16.ymin, t16.xmax, t16.ymax], u8 = j.fromExtent(w.fromBounds(a12, l9)), h6 = j2(u8, l9, f2.WGS84, {
    densificationStep: e12 * j3
  });
  if (!h6) return null;
  const m9 = K(new e2(), h6, false, false), p7 = m9.coords.filter((t17, o16) => !(o16 % 2)), g5 = m9.coords.filter((t17, o16) => o16 % 2), y8 = Math.min(...p7), d9 = Math.min(...g5), x2 = Math.max(...p7), M3 = Math.max(...g5), S6 = A(y8, d9, f7, f2.WGS84), G = A(x2, M3, f7, f2.WGS84);
  return S6 && G ? {
    bounds: a12,
    geohashBounds: {
      xLL: S6[0],
      yLL: S6[1],
      xTR: G[0],
      yTR: G[1]
    },
    level: f7
  } : null;
}
function A(o16, r8, s17, i11) {
  if (i11.isWebMercator) {
    const n17 = M(o16 / s3.radius), i12 = n17 - 360 * Math.floor((n17 + 180) / 360), c10 = [0, 0];
    return Y(c10, 0, M(Math.PI / 2 - 2 * Math.atan(Math.exp(-r8 / s3.radius))), i12, s17), c10;
  }
  const f7 = j2({
    x: o16,
    y: r8
  }, i11, f2.WGS84);
  if (!f7) return null;
  const l9 = [0, 0];
  return Y(l9, 0, f7.y, f7.x, s17), l9;
}
function R(t16, o16) {
  let r8 = -90, n17 = 90, e12 = -180, s17 = 180;
  for (let i11 = 0; i11 < o16; i11++) {
    const o17 = Math.ceil((i11 + 1) / 2), c10 = Math.floor((i11 + 1) / 2), f7 = 1 - i11 % 2, l9 = 30 - (3 * o17 + 2 * c10), a12 = 30 - (2 * o17 + 3 * c10), u8 = 3 * f7 + 2 * (1 - f7), h6 = 2 * f7 + 3 * (1 - f7), m9 = 3 * f7 + 7 * (1 - f7) << a12, p7 = (7 * f7 + 3 * (1 - f7) << l9 & t16.geohashX) >> l9, g5 = (m9 & t16.geohashY) >> a12;
    for (let t17 = u8 - 1; t17 >= 0; t17--) {
      const o18 = (e12 + s17) / 2, r9 = p7 & 1 << t17 ? 1 : 0;
      e12 = (1 - r9) * e12 + r9 * o18, s17 = (1 - r9) * o18 + r9 * s17;
    }
    for (let t17 = h6 - 1; t17 >= 0; t17--) {
      const o18 = (r8 + n17) / 2, e13 = g5 & 1 << t17 ? 1 : 0;
      r8 = (1 - e13) * r8 + e13 * o18, n17 = (1 - e13) * o18 + e13 * n17;
    }
  }
  return [e12, r8, s17, n17];
}
function Y(t16, o16, r8, n17, e12) {
  e12 % 2 && (e12 += 1);
  let s17 = 0, i11 = 0, c10 = -90, f7 = 90, l9 = -180, a12 = 180;
  for (let u8 = 0; u8 < e12 / 2; u8++) {
    for (let t17 = 0; t17 < 5; t17++) {
      const o17 = (l9 + a12) / 2, r9 = n17 > o17 ? 1 : 0;
      s17 |= r9 << 29 - (t17 + 5 * u8), l9 = (1 - r9) * l9 + r9 * o17, a12 = (1 - r9) * o17 + r9 * a12;
    }
    for (let t17 = 0; t17 < 5; t17++) {
      const o17 = (c10 + f7) / 2, n18 = r8 > o17 ? 1 : 0;
      i11 |= n18 << 29 - (t17 + 5 * u8), c10 = (1 - n18) * c10 + n18 * o17, f7 = (1 - n18) * o17 + n18 * f7;
    }
  }
  t16[2 * o16] = s17, t16[2 * o16 + 1] = i11;
}

// ../../../node_modules/@arcgis/core/geohash/GeohashCell.js
var l4 = class _l extends t8 {
  static create(t16, e12, o16, s17) {
    const r8 = s12.create(t16), i11 = new Array(32);
    for (let h6 = 0; h6 < i11.length; h6++) i11[h6] = null;
    return new _l(r8, e12, o16, s17, i11);
  }
  constructor(t16, e12, o16, s17, r8) {
    super(t16), this.xNode = e12, this.yNode = o16, this.depth = s17, this.children = r8, this._objectIds = /* @__PURE__ */ new Set(), this._count = 0, this._xWorldTotal = 0, this._yWorldTotal = 0, this._xGeohashTotal = 0, this._yGeohashTotal = 0, this.next = null;
  }
  get id() {
    return `${this.xNode}.${this.yNode}`;
  }
  get containedObjectIds() {
    return this._objectIds;
  }
  get count() {
    return this._count;
  }
  clone() {
    const t16 = new _l(this._statistics.clone(), this.xNode, this.yNode, this.depth, this.children);
    return t16._count = this._count, t16._xWorldTotal = this._xWorldTotal, t16._yWorldTotal = this._yWorldTotal, t16._xGeohashTotal = this._xGeohashTotal, t16._yGeohashTotal = this._yGeohashTotal, t16.next = this.next, t16._objectIds = new Set(this._objectIds), t16;
  }
  insert(t16, e12, o16, s17, r8, i11) {
    this._count += 1, this._xWorldTotal += e12, this._yWorldTotal += o16, this._xGeohashTotal += s17, this._yGeohashTotal += r8, this._statistics.insert(t16, i11), this._objectIds.add(t16.getObjectId());
  }
  merge(t16) {
    if (0 !== t16._count) {
      this._count += t16._count, this._xWorldTotal += t16._xWorldTotal, this._yWorldTotal += t16._yWorldTotal, this._xGeohashTotal += t16._xWorldTotal, this._yGeohashTotal += t16._yWorldTotal, this._statistics.merge(t16._statistics);
      for (const e12 of t16._objectIds.values()) this._objectIds.add(e12);
    }
  }
  getCentroid(t16) {
    throw new Error("getCentroid not supported for GeohashNode");
  }
  getGeometry(t16, r8) {
    const a12 = this._getLngLatBounds(), [n17, l9, d9, c10] = a12, _5 = j2({
      rings: [[[n17, l9], [n17, c10], [d9, c10], [d9, l9], [n17, l9]]]
    }, f2.WGS84, t16), u8 = K(new e2(), _5, false, false);
    if (null != r8) {
      return at(new e2(), u8, false, false, "esriGeometryPolygon", r8, false, false);
    }
    return u8;
  }
  getGeometricCentroid(t16, o16) {
    const a12 = this._getLngLatBounds(), [n17, l9, d9, c10] = a12, _5 = j2({
      x: (n17 + d9) / 2,
      y: (l9 + c10) / 2
    }, f2.WGS84, t16), u8 = O(new e2(), _5);
    if (null != o16) {
      return at(new e2(), u8, false, false, "esriGeometryPoint", o16, false, false);
    }
    return u8;
  }
  getAttributes() {
    const t16 = {
      aggregateId: this.id
    };
    for (const e12 of this._statistics.values()) t16[e12.field.name] = e12.value;
    return t16.aggregateCount = this._count, t16;
  }
  find(t16, e12, o16, s17, r8, i11) {
    if (s17 >= o16) return this;
    const h6 = 1 - s17 % 2, a12 = 3 * h6 + 2 * (1 - h6), n17 = 2 * h6 + 3 * (1 - h6), l9 = 30 - r8 - a12, d9 = 30 - i11 - n17, c10 = ((t16 & 7 * h6 + 3 * (1 - h6) << l9) >> l9) + ((e12 & 3 * h6 + 7 * (1 - h6) << d9) >> d9) * (8 * h6 + 4 * (1 - h6)), _5 = this.children[c10];
    return null == _5 ? null : _5.find(t16, e12, o16, s17 + 1, r8 + a12, i11 + n17);
  }
  _getLngLatBounds() {
    const e12 = this.depth, o16 = Math.ceil(e12 / 2), s17 = Math.floor(e12 / 2), r8 = 30 - (3 * o16 + 2 * s17), i11 = 30 - (2 * o16 + 3 * s17), h6 = this.xNode << r8, a12 = this.yNode << i11;
    return R({
      geohashX: h6,
      geohashY: a12
    }, this.depth);
  }
};

// ../../../node_modules/@arcgis/core/geohash/GeohashTree.js
var e11 = class {
  constructor(e12) {
    this._fields = e12, this._size = 0, this._depth = 0, this._root = l4.create(this._fields, 0, 0, 0);
  }
  destroy() {
  }
  get size() {
    return this._size;
  }
  get depth() {
    return this._depth;
  }
  find(t16, e12, s17) {
    return this._root.find(t16, e12, s17, 0, 0, 0);
  }
  insert(e12, s17, i11, n17, o16, h6, r8) {
    let l9 = this._root, d9 = 0, c10 = 0, a12 = 0;
    for (; null !== l9; ) {
      if (l9.insert(e12, s17, i11, n17, o16, r8), d9 >= h6) return;
      const f7 = Math.ceil((d9 + 1) / 2), u8 = Math.floor((d9 + 1) / 2), x2 = 1 - d9 % 2, _5 = 30 - (3 * f7 + 2 * u8), p7 = 30 - (2 * f7 + 3 * u8), M3 = (n17 & 7 * x2 + 3 * (1 - x2) << _5) >> _5, m9 = (o16 & 3 * x2 + 7 * (1 - x2) << p7) >> p7, g5 = M3 + m9 * (8 * x2 + 4 * (1 - x2));
      c10 = c10 << 3 * x2 + 2 * (1 - x2) | M3, a12 = a12 << 2 * x2 + 3 * (1 - x2) | m9, null == l9.children[g5] && (l9.children[g5] = l4.create(this._fields, c10, a12, d9 + 1), this._depth = Math.max(this._depth, d9 + 1), this._size += 1), d9 += 1, l9 = l9.children[g5];
    }
  }
  putBins(t16, e12) {
    for (const s17 of this.getNodes(e12)) {
      const e13 = t16.get(s17.id);
      e13 ? e13.merge(s17) : t16.set(s17.id, s17.clone());
    }
  }
  getNodes(t16) {
    const e12 = [], {
      geohashBounds: s17,
      level: i11
    } = t16;
    let n17 = this._root;
    for (; null !== n17; ) {
      const t17 = n17.depth, o16 = n17.xNode, h6 = n17.yNode;
      if (t17 >= i11) {
        e12.push(n17), n17 = n17.next;
        continue;
      }
      const r8 = Math.ceil((t17 + 1) / 2), l9 = Math.floor((t17 + 1) / 2), d9 = 1 - t17 % 2, c10 = 30 - (3 * r8 + 2 * l9), a12 = 30 - (2 * r8 + 3 * l9), f7 = ~((1 << c10) - 1), u8 = ~((1 << a12) - 1), x2 = (s17.xLL & f7) >> c10, _5 = (s17.yLL & u8) >> a12, p7 = (s17.xTR & f7) >> c10, M3 = (s17.yTR & u8) >> a12, m9 = o16 << 3 * d9 + 2 * (1 - d9), g5 = h6 << 2 * d9 + 3 * (1 - d9), y8 = m9 + 8 * d9 + 4 * (1 - d9), z2 = g5 + 4 * d9 + 8 * (1 - d9), L2 = Math.max(m9, x2), N2 = Math.max(g5, _5), B = Math.min(y8, p7), R2 = Math.min(z2, M3);
      let T = null, j4 = null;
      for (let e13 = N2; e13 <= R2; e13++) for (let t18 = L2; t18 <= B; t18++) {
        const s18 = t18 - m9 + (e13 - g5) * (8 * d9 + 4 * (1 - d9)), i12 = n17.children[s18];
        i12 && (T || (T = i12, T.next = n17.next), j4 && (j4.next = i12), j4 = i12, i12.next = n17.next);
      }
      n17 = T || n17.next;
    }
    return e12;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/aggregation/GeohashSpatialIndex.js
var r4 = class extends t9 {
  constructor(t16) {
    super(t16), this._tree = new e11(this._options.fields);
  }
  put(e12) {
    throw new Error("Geohash tree does not support put");
  }
  putBounded(e12, s17, o16) {
    const {
      geohashLevel: r8,
      spatialReference: h6
    } = this._options, i11 = S4(s17, o16, r8, h6);
    null != i11 && this._tree.putBins(e12, i11);
  }
  _insert(e12, t16, o16, r8) {
    const {
      geohashLevel: h6,
      spatialReference: i11
    } = this._options, n17 = A(t16, o16, h6, i11);
    n17 && this._tree.insert(e12, t16, o16, n17[0], n17[1], h6, r8);
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderIndirect.js
var a7 = class _a extends M2 {
  static from(e12, r8) {
    return new _a(e12.copy(), r8);
  }
  constructor(e12, r8) {
    super(e12.metadata), this._currentIndex = -1, this._displayTranslationX = 0, this._displayTranslationY = 0, this._displayScaleX = 1, this._displayScaleY = 1, this._reader = e12, this._indices = r8, this._isPoint = "esriGeometryPoint" === e12.geometryType;
  }
  setTransformForDisplay(e12) {
    const r8 = this._reader.getInTransform();
    if (null == r8) {
      const [r9, t17] = e12.scale, [s18, a13] = e12.translate;
      return this._displayTranslationX = -s18 / r9, this._displayScaleX = 1 / r9, this._displayTranslationY = a13 / t17, this._displayScaleY = 1 / -t17, void (this._displayTransform = e12);
    }
    const [t16, s17] = r8.scale, [a12, i11] = r8.translate, [d9, n17] = e12.scale, [o16, l9] = e12.translate;
    if (this._displayScaleX = t16 / d9, this._displayTranslationX = (a12 - o16) / d9, this._displayScaleY = s17 / n17, this._displayTranslationY = (-i11 + l9) / n17, !this._isPoint && r8) throw new Error("InternalError: Relative transformations not supported for non-point features");
    this._displayTransform = e12;
  }
  getInTransform() {
    return this._reader.getInTransform();
  }
  get fields() {
    return this._reader.fields;
  }
  get hasNext() {
    return this._currentIndex + 1 < this._indices.length;
  }
  getSize() {
    return this._indices.length;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const e12 = new _a(this._reader.copy(), this._indices);
    return e12._currentIndex = this._currentIndex, e12._displayTransform = this._displayTransform, e12._displayTranslationX = this._displayTranslationX, e12._displayTranslationY = this._displayTranslationY, e12._displayScaleX = this._displayScaleX, e12._displayScaleY = this._displayScaleY, e12;
  }
  get contextTimeZone() {
    return this._reader.contextTimeZone;
  }
  set contextTimeZone(e12) {
    this._reader.contextTimeZone = e12;
  }
  _nextIndex() {
    return ++this._currentIndex < this._indices.length && (this._reader.setIndex(this._indices[this._currentIndex]), true);
  }
  next() {
    for (; this._nextIndex() && !this._reader._getExists(); ) ;
    return this._currentIndex < this._indices.length;
  }
  readXForDisplay() {
    return this._reader.readXForDisplay() * this._displayScaleX + this._displayTranslationX;
  }
  readYForDisplay() {
    return this._reader.readYForDisplay() * this._displayScaleY + this._displayTranslationY;
  }
  readGeometryForDisplay() {
    const r8 = this._reader.readGeometryForDisplay();
    if (!this._displayTransform) return r8;
    const s17 = new e2();
    return at(s17, r8, this.hasZ, this.hasM, this.geometryType, this._displayTransform), s17.deltaDecode();
  }
  readCentroidForDisplay() {
    const e12 = this._reader.readCentroidForDisplay()?.clone();
    if (e12) {
      const [r8, t16] = e12.coords;
      e12.coords[0] = r8 * this._displayScaleX + this._displayTranslationX, e12.coords[1] = t16 * this._displayScaleY + this._displayTranslationY;
    }
    return e12;
  }
  get geometryType() {
    return this._reader.geometryType;
  }
  get hasFeatures() {
    return this._reader.hasFeatures;
  }
  get exceededTransferLimit() {
    return this._reader.exceededTransferLimit;
  }
  get hasZ() {
    return this._reader.hasZ;
  }
  get hasM() {
    return this._reader.hasM;
  }
  readAttribute(e12, r8 = false) {
    return this._reader.readAttribute(e12, r8);
  }
  readAttributes() {
    return this._reader.readAttributes();
  }
  joinAttributes(e12) {
    return this._reader.joinAttributes(e12);
  }
  getBounds(e12) {
    return this._reader.getBounds(e12);
  }
  getAttributeHash() {
    return this._reader.getAttributeHash();
  }
  getObjectId() {
    return this._reader.getObjectId();
  }
  getDisplayId() {
    return this._reader.getDisplayId();
  }
  setDisplayId(e12) {
    return this._reader.setDisplayId(e12);
  }
  setIndex(e12) {
    return this._reader.setIndex(e12);
  }
  getIndex() {
    return this._reader.getIndex();
  }
  readXWorldSpace() {
    return this._reader.readXWorldSpace();
  }
  readYWorldSpace() {
    return this._reader.readYWorldSpace();
  }
  _readX() {
    return this._reader.readXForDisplay();
  }
  _readY() {
    return this._reader.readYForDisplay();
  }
  _readServerCentroid() {
    return this._reader._readServerCentroid();
  }
  readLegacyFeatureForDisplay() {
    const e12 = this.readCentroidForDisplay();
    return {
      attributes: this.readAttributes(),
      geometry: this.readLegacyGeometryForDisplay(),
      centroid: (e12 && {
        x: e12.coords[0],
        y: e12.coords[1]
      }) ?? null
    };
  }
  readLegacyGeometryForDisplay() {
    const e12 = this.readGeometryForDisplay();
    return rt(e12, this.geometryType, false, false);
  }
  readGeometryArea() {
    return this._reader.readGeometryArea();
  }
  readGeometryWorldSpace() {
    return this._reader.readGeometryWorldSpace();
  }
  _readGeometry() {
    return this._reader._readGeometry();
  }
  _readAttribute(e12, r8) {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
  _readAttributes() {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
  readArcadeFeature() {
    return this._reader.readArcadeFeature();
  }
  geometry() {
    return this._reader.geometry();
  }
  field(e12) {
    return this._reader.field(e12);
  }
  hasField(e12) {
    return this._reader.hasField(e12);
  }
  setField(e12, r8) {
    return this._reader.setField(e12, r8);
  }
  keys() {
    return this._reader.keys();
  }
  castToText(e12 = false) {
    return this._reader.castToText(e12);
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/ASourceChunk.js
var i8 = class {
  size() {
    return this.reader.getSize();
  }
  get fields() {
    return this.reader.fields;
  }
  invalidate() {
    this._aggregateIndex = null, this._aggregateIndexHash = null, this._spatialIndex = null;
  }
  queryFeaturesInBounds(e12) {
    const t16 = this._getSpatialIndex().search(e12);
    return a7.from(this.reader, t16);
  }
  getAggregateIndex(e12) {
    const r8 = JSON.stringify(e12);
    if (r8 !== this._aggregateIndexHash) {
      switch (this._aggregateIndexHash = r8, e12.type) {
        case "grid":
          this._aggregateIndex = new n11(e12);
          break;
        case "geohash":
          this._aggregateIndex = new r4(e12);
      }
      this._aggregateIndex.insert(this.reader, this.isTiled);
    }
    return this._aggregateIndex;
  }
  _getSpatialIndex() {
    return this._spatialIndex || (this._spatialIndex = t10.fromReader(this.reader)), this._spatialIndex;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/OverrideChunk.js
var r5 = class extends i8 {
  constructor(e12, t16) {
    super(), this.metadata = e12, this.removed = /* @__PURE__ */ new Set(), this.overriddenIds = /* @__PURE__ */ new Set(), this._features = [], this.chunkId = t16, this.normalizedChunkId = t16;
  }
  get reader() {
    return u5.fromOptimizedFeatures(this._features, this.metadata);
  }
  get queryInfo() {
    return {};
  }
  get first() {
    return false;
  }
  get end() {
    return false;
  }
  get isTiled() {
    return false;
  }
  applyOverrides(e12) {
    super.invalidate();
    const {
      reader: t16,
      removed: r8
    } = e12, s17 = [], d9 = /* @__PURE__ */ new Set(), o16 = t16.getCursor(), i11 = new Set(r8);
    for (this.overriddenIds.clear(); o16.next(); ) {
      const e13 = o16.readOptimizedFeatureWorldSpace(), t17 = e13.objectId;
      s17.push(e13), d9.add(t17), this.overriddenIds.add(t17), this.removed.delete(t17);
    }
    for (const n17 of this._features) {
      const e13 = n17.objectId;
      i11.has(e13) || d9.has(e13) || (s17.push(n17), this.overriddenIds.add(e13));
    }
    this._features = s17;
    for (const n17 of d9.values()) this.removed.delete(n17);
    for (const n17 of r8) this.removed.add(n17), this.overriddenIds.add(n17);
  }
  removeOverrides(e12) {
    this.invalidate();
    const t16 = e12.reader.getCursor(), r8 = /* @__PURE__ */ new Set();
    for (; t16.next(); ) {
      const e13 = t16.getObjectId();
      this.overriddenIds.has(e13) && (r8.add(e13), this.overriddenIds.delete(e13));
    }
    this._features = this._features.filter((e13) => !r8.has(e13.objectId));
  }
  getTileReader(e12) {
    if (!this._features.length) return null;
    const t16 = this.queryFeaturesInBounds(e12.bounds);
    return t16.setTransformForDisplay(e12.transform), t16;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/processor/FeatureUpdateStrategy.js
var n12 = class extends t7 {
};
var o11 = class extends e8 {
  constructor(e12, t16, s17) {
    super(e12, t16), this._timeZone = s17, this.handledChunks = /* @__PURE__ */ new Set(), this.handledChunksForIdCreation = /* @__PURE__ */ new Set(), this.handledChunksForAttributeData = /* @__PURE__ */ new Set(), this._streamLayerDeferredObjectIdsToRemove = [];
  }
  destroy() {
    super.destroy();
    for (const e12 of this._source.chunks()) this._cleanupChunkIds(e12);
  }
  invalidateAttributeData() {
    this.handledChunksForAttributeData.clear();
  }
  onSubscribe(e12) {
    super.onSubscribe(e12), this._evalOptions = e12.tile.createArcadeEvaluationOptions(this._timeZone);
  }
  createState(e12) {
    return new n12(e12);
  }
  get aggregateQueryEngine() {
    return null;
  }
  displayMap(e12, t16, s17) {
    const r8 = new Map(e12.map((e13) => [t16(e13), e13])), a12 = [];
    for (const n17 of this._source.chunks()) {
      const e13 = n17.reader.getCursor();
      for (; e13.next(); ) {
        const t17 = e13.getObjectId(), n18 = e13.getDisplayId(), o16 = r8.get(t17);
        if (null != o16) {
          const e14 = s17(n18, o16, t17);
          a12.push(e14), r8.delete(t17);
        }
      }
    }
    return a12;
  }
  getDisplayFeatures(e12) {
    const t16 = new Set(e12), s17 = /* @__PURE__ */ new Set(), r8 = [];
    for (const a12 of this._source.chunks()) {
      const e13 = a12.reader.getCursor();
      for (; e13.next(); ) {
        const a13 = e13.getObjectId(), n17 = e13.getDisplayId();
        t16.has(n17) && !s17.has(a13) && (r8.push(__spreadProps(__spreadValues({}, e13.readLegacyFeatureWorldSpace()), {
          displayId: n17
        })), s17.add(a13));
      }
    }
    return {
      features: r8,
      aggregates: []
    };
  }
  applyLocalEdit(e12) {
    return __asyncGenerator(this, null, function* () {
      const t16 = [], r8 = e12.reader.getCursor();
      for (; r8.next(); ) {
        const e13 = r8.getObjectId();
        t16.push(e13);
        const s17 = this._attributeStore.createDisplayIdForObjectId(e13);
        r8.setDisplayId(s17), this._attributeStore.setAttributeData(s17, r8, this._evalOptions);
      }
      const n17 = this.getDisplayIds(t16), o16 = this.getDisplayIds(e12.removed), d9 = new r5(this._source.metadata, "localEdit");
      d9.applyOverrides(e12), this.handledChunks.add(d9.chunkId), this.handledChunksForAttributeData.add(d9.chunkId), this.handledChunksForIdCreation.add(d9.chunkId);
      for (const a12 of this._sendStates.values()) a12.handledChunks.add(d9.chunkId), yield new i6(a12.subscription, null, n17, false, d9.queryInfo);
      for (const a12 of this._sendStates.values()) {
        const e13 = d9.getTileReader(a12.subscription.tile);
        yield new i6(a12.subscription, e13, o16, false, d9.queryInfo);
      }
      for (const s17 of e12.removed) this._attributeStore.releaseDisplayIdForObjectId(s17);
    });
  }
  updateChunks() {
    return __asyncGenerator(this, null, function* () {
      if (this._source.chunks().length) {
        yield new __await(this._updateAttributeData());
        for (const e12 of this._sendStates.values()) yield* __yieldStar(this._update(e12));
      }
    });
  }
  removeChunks(e12) {
    for (const t16 of e12) this.handledChunks.delete(t16.chunkId), this.handledChunksForAttributeData.delete(t16.chunkId), this._cleanupChunkIds(t16);
  }
  afterUpdateChunks() {
    for (const e12 of this._streamLayerDeferredObjectIdsToRemove) this._attributeStore.releaseDisplayIdForObjectId(e12);
    this._streamLayerDeferredObjectIdsToRemove = [];
  }
  _cleanupChunkIds(e12) {
    if (this.handledChunksForIdCreation.has(e12.chunkId)) {
      const t16 = e12.reader.getCursor();
      for (; t16.next(); ) {
        const e13 = t16.getObjectId();
        this._source.isStream ? this._streamLayerDeferredObjectIdsToRemove.push(e13) : this._attributeStore.releaseDisplayIdForObjectId(e13);
      }
      this.handledChunksForIdCreation.delete(e12.chunkId);
    }
  }
  _updateAttributeData() {
    return __async(this, null, function* () {
      for (const e12 of this._source.chunks()) {
        const {
          chunkId: t16,
          reader: s17
        } = e12;
        if (!this.handledChunksForIdCreation.has(t16)) {
          this.handledChunksForIdCreation.add(t16);
          const e13 = s17.getCursor();
          for (; e13.next(); ) {
            const t17 = this._attributeStore.createDisplayIdForObjectId(e13.getObjectId());
            e13.setDisplayId(t17);
          }
        }
      }
      for (const e12 of this._source.chunks()) if (!this.handledChunksForAttributeData.has(e12.chunkId)) {
        this.handledChunksForAttributeData.add(e12.chunkId);
        const t16 = e12.reader.getCursor();
        for (; t16.next(); ) {
          const e13 = t16.getDisplayId();
          this._attributeStore.setAttributeData(e13, t16, this._evalOptions);
        }
      }
    });
  }
  *_update(e12) {
    const {
      subscription: t16,
      handledChunks: s17
    } = e12;
    for (const a12 of this._source.chunks()) {
      const {
        chunkId: n17
      } = a12;
      if (s17.has(n17)) continue;
      s17.add(n17);
      const o16 = a12.getTileReader(t16.tile);
      o16 && (yield new e9(e12.subscription, o16, false, a12.end, a12.queryInfo));
    }
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/Processor.js
var f4 = class {
  constructor(e12, t16) {
    this._connection = e12, this._source = t16, this._version = 1, this._registry = new W2(), this._proxy = new s7({
      fetch: (e13, t17) => this._connection.layerView.fetch(e13, t17),
      fetchDictionary: (e13, t17) => this._connection.layerView.fetchDictionary(e13, t17)
    }), this._attributeStore = new b3({
      isLocal: false,
      update: (e13) => O2(this._connection.container.updateAttributeView(e13))
    });
  }
  destroy() {
    this._proxy.destroy(), this._strategy?.destroy(), this._attributeStore.destroy();
  }
  get aggregateQueryEngine() {
    return this._strategy?.aggregateQueryEngine;
  }
  getDisplayFeatures(e12) {
    return this._strategy ? this._strategy.getDisplayFeatures(e12) : {
      features: [],
      aggregates: []
    };
  }
  getFeatureObjectIdsForAggregate(e12) {
    return this._strategy ? this._strategy.getFeatureObjectIdsForAggregate(e12) : [];
  }
  onSubscribe(e12) {
    this._strategy?.onSubscribe(e12);
  }
  onUnsubscribe(e12) {
    this._strategy?.onUnsubscribe(e12);
  }
  update(e12, s17, r8, a12, n17) {
    return __async(this, null, function* () {
      const h6 = e12.processor, u8 = u(this._schema?.storage, h6.storage), g5 = u(this._schema?.mesh.properties, h6.mesh.properties), d9 = u(this._schema?.mesh.factory, h6.mesh.factory), y8 = u(this._schema?.mesh.strategy, h6.mesh.strategy), _5 = g5 || d9 || y8;
      if (!(u8 || _5) && !a12) return;
      has("esri-2d-update-debug") && console.debug(`Version[${this._version}] SymbolProcessor.update`, {
        changes: d3(this._schema, h6),
        schema: h6
      }), this._schema = h6;
      const l9 = f2.fromJSON(this._source.service.outSpatialReference), f7 = new p({
        fields: this._source.metadata.fieldsIndex,
        spatialReference: l9
      });
      if (yield this._attributeStore.update(h6.storage, f7, this._source.metadata, l9, s17), this._strategy?.invalidateAttributeData(), !a12 && !_5) return;
      (y8 || g5) && (yield this._updateStrategy(h6.mesh.strategy, l9, n17, h6.mesh.properties.timeZone)), this._updateSortKey(f7, "sortKey" in h6.mesh.properties ? h6.mesh.properties.sortKey : null);
      const b4 = new s10(f7, this._proxy, r8, this._registry);
      return (d9 || "dictionary" === h6.mesh.factory.symbology.type) && (this._factory = yield s9.create(b4, h6.mesh.factory)), this._invalidate(), this._version = s17, this._connection.container.updateRenderState(this._version);
    });
  }
  applyLocalEdit(e12) {
    return __async(this, null, function* () {
      if (!this._strategy) return;
      const t16 = this._strategy.applyLocalEdit(e12);
      try {
        for (var iter = __forAwait(t16), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const r8 = temp.value;
          try {
            yield this._process(r8);
          } catch (s17) {
          }
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
    });
  }
  updateChunks() {
    return __async(this, null, function* () {
      yield this._doUpdateChunks(), this._strategy?.afterUpdateChunks();
    });
  }
  removeChunks(e12) {
    return __async(this, null, function* () {
      this._strategy?.removeChunks(e12), this._attributeStore.incrementDisplayIdGeneration();
    });
  }
  updateHighlight({
    highlights: e12
  }) {
    if (!this._strategy) return void this._attributeStore.setHighlight(e12.map(({
      objectId: e13,
      highlightFlags: t17
    }) => ({
      objectId: e13,
      highlightFlags: t17,
      displayId: -1
    })), e12);
    const t16 = this._strategy.displayMap(e12, ({
      objectId: e13
    }) => e13, (e13, {
      highlightFlags: t17
    }, s17) => ({
      objectId: s17,
      displayId: e13,
      highlightFlags: t17
    }));
    this._attributeStore.setHighlight(t16, e12);
  }
  _doUpdateChunks() {
    return __async(this, null, function* () {
      if (!this._strategy) return;
      const e12 = this._strategy.updateChunks(), t16 = [], r8 = /* @__PURE__ */ new Map();
      try {
        for (var iter = __forAwait(e12), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
          const a12 = temp.value;
          let e13 = r8.get(a12.id);
          null == e13 && (e13 = new e7({
            concurrency: 16,
            process: (e14) => this._process(e14)
          }), r8.set(a12.id, e13));
          const i11 = e13.push(a12).catch((e14) => f(e14));
          t16.push(i11);
        }
      } catch (temp) {
        error = [temp];
      } finally {
        try {
          more && (temp = iter.return) && (yield temp.call(iter));
        } finally {
          if (error)
            throw error[0];
        }
      }
      try {
        yield Promise.all(t16);
      } catch (i11) {
      }
      has("esri-2d-update-debug") && console.log("SendUpdates"), this._attributeStore.sendUpdates(), has("esri-2d-update-debug") && console.log("SendUpdates.await");
    });
  }
  _updateStrategy(e12, t16, s17, r8) {
    return __async(this, null, function* () {
      switch (this._strategy?.destroy(), e12.type) {
        case "feature":
          this._strategy = new o11(this._source, this._attributeStore, r8);
          break;
        case "binning":
          this._strategy = yield g3.create(e12, t16, this._source, this._attributeStore, r8);
          break;
        case "cluster":
          this._strategy = yield S3.create(this._connection, e12, t16, this._source, this._attributeStore, r8);
      }
      for (const i11 of s17) this._strategy.onSubscribe(i11);
    });
  }
  _updateSortKey(t16, s17) {
    return __async(this, null, function* () {
      if (this._sortInfo = u2(this._sortInfo?.computed), null != s17) {
        const e12 = s17.byRenderer ? null : yield t16.createComputedField(s17);
        this._sortInfo = __spreadProps(__spreadValues({}, s17), {
          computed: e12
        });
      }
    });
  }
  _invalidate() {
    this._strategy && this._strategy.invalidate();
  }
  _process(e12) {
    return __async(this, null, function* () {
      const t16 = e12.subscription;
      if (has("esri-2d-update-debug")) {
        const s18 = t16.tile;
        console.debug(`Version[${this._version}] Tile[${s18.key.id}, end=${e12.end}] Processor._process`);
      }
      yield this._fetchResources(e12), s2(t16.signal);
      const s17 = yield this._write(e12, t16.tile.createArcadeEvaluationOptions(this._schema?.mesh.properties.timeZone)), i11 = t16.tile.tileInfoView.tileInfo.isWrappable, {
        message: a12,
        transferList: o16
      } = s17.serialize(i11), n17 = {
        objectIdMap: null,
        inner: e12.createMessage(a12, this._version, this._attributeStore.epoch)
      };
      if (this._schema?.mesh.properties.returnMeshObjectId) {
        n17.objectIdMap = {};
        const t17 = e12.reader?.getCursor();
        if (t17) for (; t17.next(); ) n17.objectIdMap[t17.getDisplayId()] = t17.getObjectId();
      }
      if (s2(t16.signal), yield this._connection.container.onMessage(n17, {
        signal: t16.signal,
        transferList: o16
      }), this._attributeStore.sendUpdates(), has("esri-2d-update-debug")) {
        const s18 = t16.tile;
        console.debug(`Version[${this._version}] Tile[${s18.key.id}, end=${e12.end}] Processor._process.await`);
      }
    });
  }
  _fetchResources(e12) {
    return __async(this, null, function* () {
      yield this._fetchMatcherResources(e12), yield this._fetchWriterResources(e12);
    });
  }
  _fetchMatcherResources(e12) {
    return __async(this, null, function* () {
      if (e12.reader) return this._factory.enqueueMatcherRequests(this._proxy, e12.reader);
    });
  }
  _fetchWriterResources(e12) {
    return __async(this, null, function* () {
      if (!e12.reader) return;
      const t16 = e12.reader.getCursor(), s17 = e12.subscription.tile.createArcadeEvaluationOptions(this._schema.mesh.properties.timeZone);
      for (; t16.next(); ) this._factory.enqueueWriterRequests(this._proxy, t16, s17);
      yield this._proxy.fetchEnqueuedResources();
    });
  }
  _write(e12, t16) {
    return __async(this, null, function* () {
      const s17 = e12.subscription.tile, r8 = e12.reader?.getCursor(), i11 = r8?.getSize() ?? 0, a12 = s17.tileInfoView.tileInfo.isWrappable, o16 = new g2(s17.key, this._strategy.enablePixelBuffering, a12, i11);
      if (!r8) return o16;
      const c10 = s17.createArcadeEvaluationOptions(this._schema.mesh.properties.timeZone);
      for (; r8.next(); ) {
        const e13 = this._getSortKeyValue(r8, t16);
        o16.entityStart(r8.getDisplayId(), e13), this._factory.write(o16, this._proxy, r8, c10, s17.level), o16.entityEnd();
      }
      return o16;
    });
  }
  _getSortKeyValue(e12, t16) {
    if (!this._sortInfo) return 0;
    const {
      computed: s17,
      order: r8,
      byRenderer: i11
    } = this._sortInfo, a12 = i11 ? this._factory.getSortKey(e12, t16) : s17?.read(e12, t16);
    return null == a12 || isNaN(a12) ? 0 : a12 * ("asc" === r8 ? -1 : 1);
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/FeatureStoreStatistics.js
var t11 = class _t {
  static from(e12) {
    let n17 = 0, r8 = 0, o16 = 0;
    return e12.forEach((t16) => {
      const e13 = t16._readGeometry();
      e13 && (r8 += e13.isPoint ? 1 : e13.lengths.reduce((t17, e14) => t17 + e14, 0), o16 += e13.isPoint ? 1 : e13.lengths.length, n17 += 1);
    }), new _t(n17, r8, o16);
  }
  constructor(t16, e12, n17) {
    this.featureCount = t16, this.vertexCount = e12, this.ringCount = n17;
  }
  toJSON() {
    return {
      featureCount: this.featureCount,
      ringCount: this.featureCount,
      vertexCount: this.featureCount
    };
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSourceQueryInfo.js
var o12 = 4;
function s14(t16, i11, o16) {
  const s17 = t16.orderByFields ?? o16.objectIdField + " ASC", n17 = t16.source, u8 = {
    returnCentroid: !(null !== n17 && "object" == typeof n17 && "path" in n17 && g(n17.path)) && "esriGeometryPolygon" === o16.geometryType,
    returnGeometry: true,
    timeReferenceUnknownClient: o16.timeReferenceUnknownClient ?? void 0,
    outSpatialReference: f2.fromJSON(t16.outSpatialReference),
    orderByFields: [s17],
    where: i11.mutable.dataFilter.definitionExpression ?? "1=1",
    outFields: i11.mutable.availableFields
  };
  if ("feature" === i11.type) {
    const {
      gdbVersion: t17,
      historicMoment: r8,
      timeExtent: a12
    } = i11.mutable.dataFilter;
    return __spreadProps(__spreadValues({}, u8), {
      gdbVersion: t17,
      historicMoment: r8 ? new Date(r8) : null,
      timeExtent: a12 ? c2.fromJSON(a12) : null,
      outFields: i11.mutable.availableFields
    });
  }
  return u8;
}
var n13 = class _n {
  static fromSchema(e12, t16, r8) {
    const a12 = "feature" === t16.type ? t16.mutable.dataFilter.queryScaleRanges : [];
    return new _n(s14(e12, t16, r8), a12, r8.subtypeField, t16.mutable.dataFilter.customParameters, r8.geometryType, e12.queryMetadata);
  }
  constructor(e12, t16, r8, a12, i11, o16) {
    this._queryParams = e12, this._queryScaleRanges = t16, this._subtypeField = r8, this._customParameters = a12, this._geometryType = i11, this._queryMetadata = o16;
  }
  get pageSize() {
    if (null == this._queryMetadata) throw new Error("InternalError: Service does not support paged queries");
    const e12 = this._queryMetadata.supportsMaxRecordCountFactor ? o12 : null, t16 = (this._queryMetadata.maxRecordCount ?? 8e3) * (e12 ?? 1);
    return Math.min(8e3, t16);
  }
  updateHistoricMoment(e12) {
    this._queryParams.historicMoment = e12;
  }
  updateFields(e12) {
    this._queryParams.outFields = e12;
  }
  createPatchFieldsQuery(e12, t16) {
    if (!t16.getSize()) return null;
    const r8 = e12.clone();
    if ("*" === this._queryParams.outFields[0]) {
      if ("*" === (r8.outFields ?? [])[0]) return null;
      r8.outFields = this._queryParams.outFields;
    } else {
      const e13 = new Set(this._queryParams.outFields), a12 = [];
      for (const r9 of e13) t16.hasField(r9) || a12.push(r9);
      if (0 === a12.length) return null;
      r8.outFields = a12;
    }
    return r8.returnGeometry = false, r8.returnCentroid = false, r8.quantizationParameters = null, r8.cacheHint = true, {
      inner: r8,
      customParameters: this._customParameters
    };
  }
  createQuery(e12 = {}) {
    if (!this._queryParams) throw new Error("InternalError: queryInfo should be defined");
    return {
      inner: new b(__spreadValues(__spreadValues({}, this._queryParams), e12)),
      customParameters: this._customParameters
    };
  }
  createTileQuery(e12, r8) {
    if (null == this._queryMetadata) throw new Error("InternalError: Service does not support tile queries");
    const a12 = this.createQuery(r8), i11 = a12.inner;
    if (this._queryScaleRanges.length) {
      const r9 = this._queryScaleRanges.filter((t16) => (!t16.minScale || t16.minScale >= e12.maxScale) && (!t16.maxScale || t16.maxScale <= e12.minScale)).map((e13) => e13.subtypeCode);
      if (r9.length) {
        const e13 = `${this._subtypeField} IN (${r9})`;
        i11.where = n3(i11.where, e13);
      }
    }
    if (i11.quantizationParameters = r8.quantizationParameters ?? e12.getQuantizationParameters(), i11.resultType = "tile", i11.geometry = e12.extent, this._queryMetadata.supportsQuantization ? "esriGeometryPolyline" === this._geometryType && (i11.maxAllowableOffset = e12.resolution * has("feature-polyline-generalization-factor")) : "esriGeometryPolyline" !== this._geometryType && "esriGeometryPolygon" !== this._geometryType || (i11.maxAllowableOffset = e12.resolution, "esriGeometryPolyline" === this._geometryType && (i11.maxAllowableOffset *= has("feature-polyline-generalization-factor"))), i11.defaultSpatialReferenceEnabled = this._queryMetadata.supportsDefaultSpatialReference, i11.compactGeometryEnabled = this._queryMetadata.supportsCompactGeometry, this._queryMetadata.supportsMaxRecordCountFactor && (i11.maxRecordCountFactor = o12), has("esri-tiles-debug")) {
      const t16 = e12.id.replaceAll("/", ".");
      a12.customParameters = a12.customParameters ? __spreadProps(__spreadValues({}, a12.customParameters), {
        tileId: t16
      }) : {
        tileId: t16
      };
    }
    return a12;
  }
  createPagedTileQuery(e12, t16) {
    const r8 = this.pageSize;
    return this.createTileQuery(e12, {
      start: r8 * t16,
      num: r8,
      returnExceededLimitFeatures: true
    });
  }
  createPagedQuery(e12) {
    const t16 = this.pageSize;
    return this.createQuery({
      start: t16 * e12,
      num: t16,
      returnExceededLimitFeatures: true,
      maxRecordCountFactor: o12
    });
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/StreamMessenger.js
var a8 = 2500;
var o13 = class extends S {
  constructor(e12) {
    super(), this._connection = e12, this._enabledEventTypes = /* @__PURE__ */ new Set(), this._updateInfo = {
      websocket: 0,
      client: 0
    }, this._lastTime = performance.now(), this._queuedCommands = [], this.addHandles([d2(() => this._strategy?.connectionStatus ?? "disconnected", (e13) => {
      this._layerView.setProperty({
        propertyName: "pipelineConnectionStatus",
        value: e13
      });
    }, {
      initial: true
    }), d2(() => this._strategy?.errorString || null, (e13) => this._layerView.setProperty({
      propertyName: "pipelineErrorString",
      value: e13
    }), {
      initial: true
    })]);
  }
  destroy() {
    this._strategy = null, this.removeAllHandles();
  }
  get _layerView() {
    return this._connection.layerView;
  }
  set strategy(e12) {
    null == this._strategy && this._resetUpdateInfo(performance.now());
    const t16 = "event-handles";
    this.removeHandles(t16), null != e12 && (this.addHandles([e12.events.on("data-received", (e13) => this._onFeature(e13)), e12.events.on("message-received", (e13) => this._onWebSocketMessage(e13)), e12.events.on("features-updated", (e13) => this._onUpdate(e13)), e12.events.on("tick", () => this._onTick())], t16), this._queuedCommands.forEach((t17) => t17(e12)), this._queuedCommands = []), this._strategy = e12;
  }
  updateCustomParameters(e12) {
    null != e12 && this._callOrEnqueue((t16) => t16.updateCustomParameters(e12));
  }
  sendMessageToSocket(e12) {
    this._callOrEnqueue((t16) => t16.sendMessageToSocket(e12));
  }
  sendMessageToClient(e12) {
    this._callOrEnqueue((t16) => t16.sendMessageToClient(e12));
  }
  enableEvent(e12, t16) {
    t16 ? this._enabledEventTypes.add(e12) : this._enabledEventTypes.delete(e12);
  }
  disconnect() {
    this._strategy?.disconnect();
  }
  connect() {
    this._strategy?.connect();
  }
  clear() {
    this._strategy?.clear();
  }
  _onWebSocketMessage(e12) {
    this._enabledEventTypes.has("message-received") && this._layerView.emitEvent({
      name: "message-received",
      event: e12
    });
  }
  _onFeature(e12) {
    this._updateInfo.websocket++, this._enabledEventTypes.has("data-received") && this._layerView.emitEvent({
      name: "data-received",
      event: {
        attributes: e12.attributes,
        centroid: e12.centroid,
        geometry: e12.geometry
      }
    });
  }
  _onUpdate(e12) {
    this._updateInfo.client += e12;
  }
  _onTick() {
    const e12 = performance.now(), t16 = e12 - this._lastTime;
    if (t16 > a8) {
      const s17 = Math.round(this._updateInfo.client / (t16 / 1e3)), n17 = Math.round(this._updateInfo.websocket / (t16 / 1e3));
      this._resetUpdateInfo(e12), this._layerView.emitEvent({
        name: "update-rate",
        event: {
          client: s17,
          websocket: n17
        }
      });
    }
  }
  _resetUpdateInfo(e12) {
    this._lastTime = e12, this._updateInfo.client = 0, this._updateInfo.websocket = 0;
  }
  _callOrEnqueue(e12) {
    null != this._strategy ? e12(this._strategy) : this._queuedCommands.push(e12);
  }
};
e([y()], o13.prototype, "_strategy", void 0), o13 = e([a("esri.views.2d.layers.features.sources.StreamMessenger")], o13);

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ALoadStrategy.js
var r6 = class {
  constructor(r8) {
    this._store = r8, this._controller = new AbortController();
  }
  destroy() {
    this._controller.abort();
  }
  get _options() {
    return {
      signal: this._controller.signal
    };
  }
  unsafeSetQueryHistoricMoment(r8) {
    throw new Error("InternalError: LoadStrategy does not support query info");
  }
  queryOverride(r8) {
    return __async(this, null, function* () {
      throw new Error("InternalError: LoadStrategy does not support fetching");
    });
  }
  queryByObjectId(r8) {
    return __async(this, null, function* () {
      throw new Error("InternalError: LoadStrategy does not support fetching");
    });
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBFHeader.js
var n14 = 268435455;
var o14 = class {
  constructor() {
    this.hasFeatures = false, this.exceededTransferLimit = false, this.fieldCount = 0, this.featureCount = 0, this.objectIdFieldIndex = 0, this.vertexCount = 0, this.offsets = {
      attributes: new Array(),
      geometry: new Array()
    }, this.centroid = new Array();
  }
};
function a9(a12, i11, c10 = false) {
  const f7 = 1, d9 = 3, u8 = 9, g5 = 12, l9 = 13, p7 = 15, h6 = a12.asUnsafe(), b4 = h6.pos(), w3 = new o14();
  let m9 = 0, y8 = 0;
  const k = 1, x2 = 2, I2 = 4, L2 = 3;
  let A2 = null, F = null, C = null, S6 = false;
  const j4 = [];
  for (; h6.next(); ) switch (h6.tag()) {
    case f7:
      A2 = h6.getString();
      break;
    case d9:
      F = h6.getString();
      break;
    case g5:
      C = h6.processMessage(h);
      break;
    case u8:
      if (w3.exceededTransferLimit = h6.getBool(), w3.exceededTransferLimit) {
        w3.offsets.geometry = c10 ? new Float64Array(8e3) : new Int32Array(8e3), w3.centroid = c10 ? new Float64Array(16e3) : new Int32Array(16e3);
        for (let e12 = 0; e12 < w3.centroid.length; e12++) w3.centroid[e12] = n14;
      }
      break;
    case l9: {
      const e12 = h6.processMessage(b2);
      e12.index = m9++, j4.push(e12);
      break;
    }
    case p7: {
      const e12 = h6.getLength(), t16 = h6.pos() + e12;
      if (!w3.exceededTransferLimit) {
        const e13 = w3.offsets.geometry, t17 = w3.centroid;
        e13.push(0), t17.push(n14), t17.push(n14);
      }
      !S6 && w3.exceededTransferLimit && (S6 = true, w3.offsets.attributes = c10 ? new Float64Array(8e3 * m9) : new Uint32Array(8e3 * m9));
      let s17 = y8 * m9;
      for (; h6.pos() < t16 && h6.next(); ) switch (h6.tag()) {
        case k: {
          if (S6) w3.offsets.attributes[s17++] = h6.pos();
          else {
            w3.offsets.attributes.push(h6.pos());
          }
          const e13 = h6.getLength();
          h6.skipLen(e13);
          break;
        }
        case x2:
          if (i11) {
            const e13 = h6.getLength(), t17 = h6.pos() + e13;
            for (; h6.pos() < t17 && h6.next(); ) switch (h6.tag()) {
              case L2: {
                h6.getUInt32();
                const e14 = h6.getSInt64(), t18 = h6.getSInt64();
                w3.centroid[2 * y8] = e14, w3.centroid[2 * y8 + 1] = t18;
                break;
              }
              default:
                h6.skip();
            }
          } else {
            w3.offsets.geometry[y8] = h6.pos();
            const e13 = h6.getLength();
            w3.vertexCount += e13, h6.skipLen(e13);
          }
          break;
        case I2: {
          const e13 = h6.getLength(), t17 = h6.pos() + e13;
          for (; h6.pos() < t17 && h6.next(); ) switch (h6.tag()) {
            case L2: {
              h6.getUInt32();
              const e14 = h6.getSInt64(), t18 = h6.getSInt64();
              w3.centroid[2 * y8] = e14, w3.centroid[2 * y8 + 1] = t18;
              break;
            }
            default:
              h6.skip();
          }
          break;
        }
        default:
          h6.skip();
      }
      y8++, w3.hasFeatures = true;
      break;
    }
    default:
      h6.skip();
  }
  const U2 = A2 || F;
  if (!U2) throw new s("FeatureSet has no objectId or globalId field name");
  return w3.fields = new Z(j4), w3.featureCount = y8, w3.fieldCount = m9, w3.objectIdFieldIndex = w3.fields.get(U2)?.index, w3.transform = C, w3.displayIds = new Uint32Array(w3.featureCount), w3.groupIds = new Uint16Array(w3.featureCount), h6.move(b4), w3;
}

// ../../../node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBF.js
var o15 = true;
var d7 = 268435455;
var u7 = 128;
var c8 = 128e3;
var g4 = {
  small: {
    delta: new Int32Array(u7),
    decoded: new Int32Array(u7)
  },
  large: {
    delta: new Int32Array(c8),
    decoded: new Int32Array(c8)
  }
};
function _4(e12) {
  return e12 <= g4.small.delta.length ? g4.small : (e12 <= g4.large.delta.length || (g4.large.delta = new Int32Array(Math.round(1.25 * e12)), g4.large.decoded = new Int32Array(Math.round(1.25 * e12))), g4.large);
}
function f5(r8) {
  try {
    const e12 = 2, t16 = new n4(new Uint8Array(r8), new DataView(r8));
    for (; t16.next(); ) {
      if (t16.tag() === e12) return l5(t16.getMessage());
      t16.skip();
    }
  } catch (n17) {
    const r9 = new s("query:parsing-pbf", "Error while parsing FeatureSet PBF payload", {
      error: n17
    });
    n.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF").error(r9);
  }
  return null;
}
function l5(e12) {
  const t16 = 1;
  for (; e12.next(); ) {
    if (e12.tag() === t16) return e12.getMessage();
    e12.skip();
  }
  return null;
}
function I(e12) {
  const t16 = 1, r8 = 2, s17 = 3, n17 = 4, a12 = 5, i11 = 6, h6 = 7, o16 = 8, d9 = 9, u8 = e12.getLength(), c10 = e12.pos() + u8;
  for (; e12.pos() < c10 && e12.next(); ) switch (e12.tag()) {
    case t16:
      return e12.getString();
    case r8:
      return e12.getFloat();
    case s17:
      return e12.getDouble();
    case n17:
      return e12.getSInt32();
    case a12:
      return e12.getUInt32();
    case i11:
      return e12.getInt64();
    case h6:
      return e12.getUInt64();
    case o16:
      return e12.getSInt64();
    case d9:
      return e12.getBool();
    default:
      return e12.skip(), null;
  }
  return null;
}
function p5(e12, t16, r8, s17, n17, a12) {
  return 0.5 * Math.abs(e12 * s17 + r8 * a12 + n17 * t16 - e12 * a12 - r8 * t16 - n17 * s17);
}
function y5(e12, t16, r8, s17) {
  return 0 === e12 * s17 - r8 * t16 && e12 * r8 + t16 * s17 > 0;
}
var m6 = class _m extends M2 {
  static fromBuffer(e12, t16, r8 = false) {
    const s17 = t16.geometryType, n17 = f5(e12), a12 = a9(n17, "esriGeometryPoint" === s17, r8);
    return new _m(n17, a12, t16);
  }
  constructor(e12, t16, r8) {
    super(r8), this._hasNext = false, this._isPoints = false, this._featureIndex = -1, this._featureOffset = 0, this._cache = {
      area: 0,
      unquantGeometry: void 0,
      geometry: void 0,
      centroid: void 0,
      legacyFeature: void 0,
      optFeature: void 0
    }, this._parseCaches = new Array(), this._geometryType = r8.geometryType, this._reader = e12, this._header = t16, this._hasNext = t16.hasFeatures, this._isPoints = "esriGeometryPoint" === r8.geometryType;
  }
  get _size() {
    return this._header.featureCount;
  }
  get fields() {
    return this._header.fields;
  }
  get geometryType() {
    return this._geometryType;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get hasFeatures() {
    return this._header.hasFeatures;
  }
  get hasNext() {
    return this._hasNext;
  }
  get exceededTransferLimit() {
    return this._header.exceededTransferLimit;
  }
  getSize() {
    return this._size;
  }
  getInTransform() {
    return this._header.transform;
  }
  getCursor() {
    return this.copy();
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e12) {
    this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0, this._featureIndex = e12;
  }
  getAttributeHash() {
    let e12 = "";
    for (const t16 of this._header.fields.fields) e12 += this._readAttributeAtIndex(t16.index) + ".";
    return e12;
  }
  getObjectId() {
    return this._readAttributeAtIndex(this._header.objectIdFieldIndex);
  }
  getDisplayId() {
    return this._header.displayIds[this._featureIndex];
  }
  setDisplayId(e12) {
    this._header.displayIds[this._featureIndex] = e12;
  }
  readGeometryArea() {
    return this._cache.area || this._readGeometry(true), this._cache.area;
  }
  copy() {
    const e12 = this._reader.clone(), t16 = new _m(e12, this._header, this.metadata);
    return this.copyInto(t16), t16;
  }
  next() {
    for (this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0; ++this._featureIndex < this._size && !this._getExists(); ) ;
    return this._featureIndex < this._size;
  }
  _readX() {
    return this._header.centroid[2 * this._featureIndex];
  }
  _readY() {
    return this._header.centroid[2 * this._featureIndex + 1];
  }
  _readServerCentroid() {
    const e12 = this._header.centroid[2 * this._featureIndex], t16 = this._header.centroid[2 * this._featureIndex + 1];
    return e12 === d7 ? null : new e2([], [e12, t16]);
  }
  _readGeometry(e12 = false) {
    if (void 0 === this._cache.geometry) {
      let r8 = null;
      if (this._isPoints) {
        if (this._header.centroid[2 * this._featureIndex] === d7) return null;
        const e13 = this._header.centroid[2 * this._featureIndex], t16 = this._header.centroid[2 * this._featureIndex + 1];
        r8 = new e2([], [e13, t16]);
      } else {
        const s17 = this._header.offsets.geometry[this._featureIndex], n17 = this._reader;
        if (0 === s17) return null;
        n17.move(s17);
        try {
          r8 = e12 ? this._parseGeometryForDisplay(n17) : this._parseGeometry(n17);
        } catch (t16) {
          return null;
        }
      }
      return 0 === r8?.coords.length && (r8 = null), this._cache.geometry = r8, r8;
    }
    return this._cache.geometry;
  }
  _readAttribute(e12, t16) {
    const r8 = this._header.fields.get(e12);
    if (null == r8) return;
    let s17 = this._readAttributeAtIndex(r8.index);
    "esriFieldTypeTimestampOffset" === this.fields.get(e12)?.type && (s17 = this.parseTimestampOffset(s17));
    const n17 = this._header.fields.isDateField(r8.name);
    return t16 ? null == s17 ? s17 : n17 ? new Date(s17) : s17 : s17;
  }
  _readAttributes() {
    const e12 = {};
    for (const t16 of this._header.fields.fields) e12[t16.name] = this._readAttributeAtIndex(t16.index);
    return e12;
  }
  copyInto(e12) {
    super.copyInto(e12), e12._featureIndex = this._featureIndex, e12._featureOffset = this._featureOffset, e12._hasNext = this._hasNext, e12._parseCaches = this._parseCaches;
  }
  _readAttributeAtIndex(e12) {
    let t16 = this._parseCaches[e12];
    if (t16 || (t16 = new a3(this.getSize()), this._parseCaches[e12] = t16), t16.has(this._featureIndex)) return t16.get(this._featureIndex);
    const r8 = this._header.offsets.attributes[this._featureIndex * this._header.fieldCount + e12], s17 = this._reader;
    s17.move(r8);
    const n17 = I(s17);
    return t16.set(this._featureIndex, n17), n17;
  }
  _readGeometryDeltaDecoded(e12 = false) {
    if (void 0 === this._cache.unquantGeometry) {
      const t16 = this._readGeometry(e12);
      if (!t16) return this._cache.unquantGeometry = void 0, null;
      if (!this.getInTransform()) return this._cache.unquantGeometry = t16, t16;
      const r8 = _4(t16.coords.length).decoded, s17 = t16.clone(r8), n17 = s17.coords;
      let a12 = 0;
      for (const e13 of s17.lengths) {
        for (let t17 = 1; t17 < e13; t17++) {
          const e14 = 2 * (a12 + t17), r9 = 2 * (a12 + t17 - 1);
          n17[e14] += n17[r9], n17[e14 + 1] += n17[r9 + 1];
        }
        a12 += e13;
      }
      return this._cache.unquantGeometry = s17, s17;
    }
    return this._cache.unquantGeometry;
  }
  _parseGeometry(e12) {
    const t16 = 2, r8 = 3, s17 = e12.asUnsafe(), a12 = s17.getLength(), i11 = s17.pos() + a12, h6 = [], o16 = [];
    for (; s17.pos() < i11 && s17.next(); ) switch (s17.tag()) {
      case t16: {
        const e13 = s17.getUInt32(), t17 = s17.pos() + e13;
        for (; s17.pos() < t17; ) o16.push(s17.getUInt32());
        break;
      }
      case r8: {
        const e13 = s17.getUInt32(), t17 = s17.pos() + e13;
        for (h6.push(s17.getSInt64()), h6.push(s17.getSInt64()), this.hasZ && s17.getSInt64(), this.hasM && s17.getSInt64(); s17.pos() < t17; ) h6.push(s17.getSInt64()), h6.push(s17.getSInt64()), this.hasZ && s17.getSInt64(), this.hasM && s17.getSInt64();
        break;
      }
      default:
        s17.skip();
    }
    return new e2(o16, h6);
  }
  _parseGeometryForDisplay(e12) {
    const t16 = 2, s17 = 3, a12 = e12.asUnsafe(), i11 = a12.getLength(), h6 = a12.pos() + i11, d9 = [], u8 = [];
    let c10 = 0, g5 = 0, f7 = null, l9 = 0;
    const I2 = "esriGeometryPolygon" === this.geometryType;
    for (; a12.pos() < h6 && a12.next(); ) switch (a12.tag()) {
      case t16: {
        const e13 = a12.getUInt32(), t17 = a12.pos() + e13;
        for (; a12.pos() < t17; ) {
          const e14 = a12.getUInt32();
          d9.push(e14), c10 += e14;
        }
        f7 = _4(2 * c10).delta;
        break;
      }
      case s17: {
        a12.getUInt32();
        const e13 = 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
        n2(f7);
        for (const t17 of d9) if (g5 + e13 * t17 > f7.length) for (let e14 = 0; e14 < t17; e14++) a12.getSInt32(), a12.getSInt32(), this.hasZ && a12.getSInt32(), this.hasM && a12.getSInt32();
        else if (I2 && o15) {
          const e14 = this.getAreaSimplificationThreshold(t17, this._header.vertexCount);
          let r8 = 2, s18 = 1;
          const n17 = false;
          let i12 = a12.getSInt32(), h7 = a12.getSInt32();
          f7[g5++] = i12, f7[g5++] = h7, this.hasZ && a12.getSInt32(), this.hasM && a12.getSInt32();
          let o16 = a12.getSInt32(), d10 = a12.getSInt32();
          for (this.hasZ && a12.getSInt32(), this.hasM && a12.getSInt32(); r8 < t17; ) {
            let t18 = a12.getSInt32(), n18 = a12.getSInt32();
            this.hasZ && a12.getSInt32(), this.hasM && a12.getSInt32();
            const u9 = i12 + o16, c11 = h7 + d10;
            p5(i12, h7, u9, c11, u9 + t18, c11 + n18) >= e14 ? (l9 += -0.5 * (u9 - i12) * (c11 + h7), s18 > 1 && y5(f7[g5 - 2], f7[g5 - 1], o16, d10) ? (f7[g5 - 2] += o16, f7[g5 - 1] += d10) : (f7[g5++] = o16, f7[g5++] = d10, s18++), i12 = u9, h7 = c11) : (t18 += o16, n18 += d10), o16 = t18, d10 = n18, r8++;
          }
          s18 < 3 || n17 ? g5 -= 2 * s18 : (l9 += -0.5 * (i12 + o16 - i12) * (h7 + d10 + h7), y5(f7[g5 - 2], f7[g5 - 1], o16, d10) ? (f7[g5 - 2] += o16, f7[g5 - 1] += d10, u8.push(s18)) : (f7[g5++] = o16, f7[g5++] = d10, u8.push(++s18)));
        } else {
          let e14 = 0, r8 = a12.getSInt32(), s18 = a12.getSInt32();
          this.hasZ && a12.getSInt32(), this.hasM && a12.getSInt32(), f7[g5++] = r8, f7[g5++] = s18, e14 += 1;
          for (let n17 = 1; n17 < t17; n17++) {
            const t18 = a12.getSInt32(), i12 = a12.getSInt32(), h7 = r8 + t18, o16 = s18 + i12;
            l9 += -0.5 * (h7 - r8) * (o16 + s18), this.hasZ && a12.getSInt32(), this.hasM && a12.getSInt32(), n17 > 2 && y5(f7[g5 - 2], f7[g5 - 1], t18, i12) ? (f7[g5 - 2] += t18, f7[g5 - 1] += i12) : (f7[g5++] = t18, f7[g5++] = i12, e14 += 1), r8 = h7, s18 = o16;
          }
          u8.push(e14);
        }
        break;
      }
      default:
        a12.skip();
    }
    return this._cache.area = l9, u8.length ? new e2(u8, f7) : null != f7 ? this._createQuantizedExtrudedGeometry(f7[0], f7[1]) : null;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/support/queryAdapters.js
var c9 = class {
  constructor(t16, e12) {
    this.service = t16, this._metadata = e12;
  }
  destroy() {
  }
};
function m7(t16, e12) {
  switch (t16.type) {
    case "memory":
      return new l6(t16, e12);
    case "ogc":
      return new y6(t16, e12);
    case "feature-service":
      return t16.queryMetadata.supportsFormatPBF && has("featurelayer-pbf") ? new d8(t16, e12) : new f6(t16, e12);
  }
}
function p6(e12) {
  return __async(this, null, function* () {
    const r8 = new c4();
    return yield r8.open(e12, {}), r8;
  });
}
var l6 = class extends c9 {
  constructor(t16, e12) {
    super(t16, e12), this._portsOpen = p6(t16.source).then((t17) => this.client = t17);
  }
  destroy() {
    this.client.close(), this.client = null;
  }
  executeQuery(t16, e12) {
    return __async(this, null, function* () {
      yield this._portsOpen;
      const r8 = yield this.client.invoke("queryFeatures", t16.toJSON(), e12);
      return u5.fromFeatureSet(r8, this._metadata);
    });
  }
};
var d8 = class extends c9 {
  executeQuery(t16, e12) {
    return __async(this, null, function* () {
      const {
        data: r8
      } = yield d4(this.service.source, t16, e12), a12 = !t16.quantizationParameters;
      return m6.fromBuffer(r8, this._metadata, a12);
    });
  }
};
var f6 = class extends c9 {
  executeQuery(t16, s17) {
    return __async(this, null, function* () {
      const {
        source: i11,
        queryMetadata: u8
      } = this.service;
      if (null != t16.quantizationParameters && !u8.supportsQuantization) {
        const u9 = t16.clone(), c11 = s5(u9.quantizationParameters);
        u9.quantizationParameters = null;
        const {
          data: m9
        } = yield c3(i11, u9, this._metadata.spatialReference, s17), p7 = ct(m9, this._metadata.objectIdField);
        return ft(c11, p7), u5.fromOptimizedFeatureSet(p7, this._metadata);
      }
      const {
        data: c10
      } = yield c3(i11, t16, this._metadata.spatialReference, s17);
      return "esriGeometryPoint" === this._metadata.geometryType && (c10.features = c10.features?.filter((t17) => {
        if (null != t17.geometry) {
          const e12 = t17.geometry;
          return Number.isFinite(e12.x) && Number.isFinite(e12.y);
        }
        return true;
      })), u5.fromFeatureSet(c10, this._metadata);
    });
  }
};
var y6 = class extends c9 {
  executeQuery(t16, r8) {
    return __async(this, null, function* () {
      if (t16.quantizationParameters && !this.service.queryMetadata.supportsQuantization) {
        const i12 = t16.clone(), o16 = s5(i12.quantizationParameters);
        i12.quantizationParameters = null;
        const u8 = yield $2(this.service.source, t16, r8);
        return ft(o16, u8), u5.fromOptimizedFeatureSet(u8, this._metadata);
      }
      const i11 = yield $2(this.service.source, t16, r8);
      return u5.fromOptimizedFeatureSet(i11, this._metadata);
    });
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/AFetchLoadStrategy.js
var i9 = class extends r6 {
  constructor(e12, t16, r8, n17, i11) {
    super(r8), this._serviceInfo = e12, this._queryInfo = t16, this._metadata = n17, this._connection = i11, this._queue = new _({
      concurrency: 16,
      process: (e13) => __async(this, null, function* () {
        const t17 = {
          signal: e13.options?.signal,
          query: e13.query.customParameters
        };
        return this._adapter.executeQuery(e13.query.inner, t17);
      })
    }), this._adapter = m7(e12, n17);
  }
  unsafeSetQueryHistoricMoment(e12) {
    this._queryInfo.updateHistoricMoment(e12);
  }
  updateFields(r8) {
    return __async(this, null, function* () {
      this._queryInfo.updateFields(r8);
      const s17 = Array.from(this._store.chunks()).map((e12) => __async(this, null, function* () {
        const r9 = b.fromJSON(e12.queryInfo.queryJSON);
        if (r9) try {
          return yield this._tryUpdateFields(e12.reader, r9), null;
        } catch (s18) {
          return s18;
        }
      })), n17 = (yield Promise.all(s17)).filter((e12) => e12);
      if (n17.length) throw new s("featurelayer-query", "Encountered errors when downloading fields", {
        errors: n17
      });
    });
  }
  queryByObjectId(e12) {
    return __async(this, null, function* () {
      if (0 === e12.length) return u5.empty(this._metadata);
      const t16 = this._queryInfo.createQuery({
        objectIds: e12
      });
      return this._fetch(t16);
    });
  }
  _fetch(e12, t16) {
    return __async(this, null, function* () {
      const r8 = yield this._enqueue(e12, t16);
      return yield this._tryUpdateFields(r8, e12.inner), r8;
    });
  }
  _tryUpdateFields(e12, t16) {
    return __async(this, null, function* () {
      const r8 = this._queryInfo.createPatchFieldsQuery(t16, e12);
      if (!r8) return;
      const s17 = yield this._enqueue(r8, this._options);
      e12.joinAttributes(s17);
    });
  }
  _enqueue(e12, t16) {
    return __async(this, null, function* () {
      return this._connection.onEvent({
        type: "fetchStart"
      }), this._queue.push({
        query: e12,
        options: t16
      }).finally(() => {
        this._connection.onEvent({
          type: "fetchEnd",
          done: 0 === this._queue.length
        });
      });
    });
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ATileLoadStrategy.js
var s15 = class extends i9 {
  constructor() {
    super(...arguments), this._chunksById = /* @__PURE__ */ new Map();
  }
  unload(e12) {
    this._removeChunks(e12.tile);
  }
  _addChunk(e12) {
    const s17 = e12.tile.id;
    this._chunksById.has(s17) || this._chunksById.set(s17, []);
    const t16 = e12.size();
    (t16 || e12.first || e12.end) && (has("esri-2d-update-debug") && console.debug(`Chunk[${e12.chunkId}] ATileLoadStrategy.addChunk [count=${t16}]`), this._chunksById.get(s17).push(e12), this._store.insert(e12));
  }
  _removeChunks(e12) {
    const s17 = this._chunksById.get(e12.key.id) ?? [];
    for (const t16 of s17) has("esri-2d-update-debug") && console.debug(`Tile[${e12.key.id}] Chunk[${t16.chunkId}] ATileLoadStrategy.removeChunk`), this._store.remove(t16);
    this._chunksById.delete(e12.key.id);
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/DrillDownTileSourceChunk.js
var i10 = class extends i8 {
  constructor(e12, i11, t16, r8, s17, h6) {
    super(), this._reader = e12, this._queryJSON = i11, this._tile = t16, this._sourceTile = r8, this._sourceTileDepth = s17, this._end = h6, this.chunkId = `${this._tile.key.id}.${this._sourceTile?.key.id}${this._end ? "e" : ""}`, this.normalizedChunkId = `${this._tile.key.normalizedId}.${this._sourceTile?.key.normalizedId}${this._end ? "e" : ""}`;
  }
  get queryInfo() {
    return {
      type: "drill-down-tile",
      chunkId: this.chunkId,
      tileId: this._tile.key.id,
      queryJSON: this._queryJSON,
      sourceTileDepth: this._sourceTileDepth,
      sourceTileId: this._sourceTile?.key.id,
      size: this.size(),
      end: this.end
    };
  }
  get first() {
    return 0 === this._sourceTileDepth;
  }
  get reader() {
    return this._reader;
  }
  get end() {
    return this._end;
  }
  get tile() {
    return this._tile;
  }
  get isTiled() {
    return true;
  }
  getTileReader(e12) {
    return this._tile.key.id === e12.key.id ? this.reader : null;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/DrillDownTileLoadStrategy.js
var l7 = class {
  constructor(e12, o16) {
    this.subscription = e12, this._tileIdToResult = /* @__PURE__ */ new Map(), this._controller = new AbortController(), this._handles = o([m(e12.signal, () => this._controller.abort()), m(o16, () => this._controller.abort())]);
  }
  destroy() {
    this._controller.abort(), this._handles.remove();
  }
  get(t16) {
    return this._tileIdToResult.get(t16);
  }
  set(t16, e12) {
    this._tileIdToResult.set(t16, e12);
  }
  get options() {
    return {
      signal: this._controller.signal
    };
  }
};
var a10 = class extends s15 {
  constructor() {
    super(...arguments), this._loadStates = /* @__PURE__ */ new Map();
  }
  destroy() {
    super.destroy();
    for (const t16 of this._loadStates.values()) t16.destroy();
    this._loadStates.clear();
  }
  get about() {
    return {
      willQueryAllFeatures: false,
      willQueryFullResolutionGeometry: false
    };
  }
  load(t16) {
    return __async(this, null, function* () {
      this._loadStates.has(t16.key.id) || this._loadStates.set(t16.key.id, new l7(t16, this._options));
      const s17 = this._loadStates.get(t16.key.id);
      let o16;
      try {
        try {
          for (var iter = __forAwait(this._fetchChunkInfos(s17, t16.tile, 0)), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
            const o17 = temp.value;
            const {
              queryJSON: t17,
              reader: i11,
              sourceTile: l9,
              sourceTileDepth: a13,
              tile: n17
            } = o17, h6 = new i10(i11, t17, n17, l9, a13, false);
            s2(s17.options), this._addChunk(h6);
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield temp.call(iter));
          } finally {
            if (error)
              throw error[0];
          }
        }
      } catch (n17) {
        o16 = n17;
      }
      const a12 = new i10(u5.empty(this._metadata), null, t16.tile, null, -1, true);
      if (this._addChunk(a12), o16) throw o16;
    });
  }
  unload(t16) {
    super.unload(t16), this._loadStates.get(t16.key.id)?.destroy(), this._loadStates.delete(t16.key.id);
  }
  _fetchChunkInfos(t16, e12, s17) {
    return __asyncGenerator(this, null, function* () {
      let o16 = t16.get(e12.id);
      const r8 = !!o16;
      if (o16 || (o16 = yield new __await(this._fetchChunkInfo(t16, e12, s17)), t16.set(e12.id, o16)), o16.reader.exceededTransferLimit && s17 < has("featurelayer-query-max-depth")) for (const i11 of e12.createChildTiles()) yield* __yieldStar(this._fetchChunkInfos(t16, i11, s17 + 1));
      else r8 || (yield o16);
    });
  }
  _fetchChunkInfo(t16, e12, s17) {
    return __async(this, null, function* () {
      const o16 = t16.subscription.tile.getQuantizationParameters(), r8 = this._queryInfo.createTileQuery(e12, {
        returnExceededLimitFeatures: false,
        quantizationParameters: o16
      });
      return {
        reader: yield this._fetch(r8, t16.options),
        queryJSON: r8.inner.toJSON(),
        tile: t16.subscription.tile,
        sourceTile: e12,
        sourceTileDepth: s17
      };
    });
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/PagedTileSourceChunk.js
var t12 = class extends i8 {
  constructor(e12, t16, i11, r8, s17) {
    super(), this._reader = e12, this._queryJSON = t16, this._tile = i11, this._page = r8, this._end = s17, this.chunkId = `${this._tile.key.id}.${this._page}${this.end ? "e" : ""}`, this.normalizedChunkId = `${this._tile.key.normalizedId}.${this._page}${this.end ? "e" : ""}`;
  }
  get queryInfo() {
    return {
      type: "paged-tile",
      chunkId: this.chunkId,
      tileId: this._tile.key.id,
      queryJSON: this._queryJSON,
      page: this._page,
      size: this.size(),
      end: this.end
    };
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return 0 === this._page;
  }
  get end() {
    return this._end;
  }
  get page() {
    return this._page;
  }
  get tile() {
    return this._tile;
  }
  get isTiled() {
    return true;
  }
  getTileReader(e12) {
    return this._tile.key.id === e12.key.id ? this.reader : null;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/PagedTileLoadStrategy.js
var n15 = class {
  constructor(e12, s17) {
    this.subscription = e12, this._pages = /* @__PURE__ */ new Set(), this._controller = new AbortController(), this._done = false, this._handles = o([m(e12.signal, () => this._controller.abort()), m(s17, () => this._controller.abort())]);
  }
  destroy() {
    this._controller.abort(), this._handles.remove();
  }
  get pageStart() {
    let t16 = -1;
    for (const e12 of this._pages.values()) t16 = Math.max(t16, e12);
    return t16 + 1;
  }
  get done() {
    return this._done;
  }
  get options() {
    return {
      signal: this._controller.signal
    };
  }
  add(t16, e12) {
    this._pages.add(t16), this._done = this._done || e12;
  }
};
var l8 = class extends s15 {
  constructor() {
    super(...arguments), this._loadStates = /* @__PURE__ */ new Map();
  }
  destroy() {
    super.destroy();
    for (const t16 of this._loadStates.values()) t16.destroy();
    this._loadStates.clear();
  }
  get about() {
    return {
      willQueryAllFeatures: false,
      willQueryFullResolutionGeometry: false
    };
  }
  load(t16) {
    return __async(this, null, function* () {
      this._loadStates.has(t16.key.id) || this._loadStates.set(t16.key.id, new n15(t16, this._options));
      const s17 = this._loadStates.get(t16.key.id);
      let o16;
      try {
        yield this._fetchPages(s17);
      } catch (l9) {
        o16 = l9;
      }
      const r8 = new t12(u5.empty(this._metadata), null, t16.tile, -1, true);
      if (c(s17.options) || this._addChunk(r8), o16) throw o16;
    });
  }
  unload(t16) {
    super.unload(t16), this._loadStates.get(t16.key.id)?.destroy(), this._loadStates.delete(t16.key.id);
  }
  _fetchPages(t16) {
    return __async(this, null, function* () {
      const e12 = 4, o16 = 20;
      let r8 = 0, a12 = t16.pageStart, i11 = 1;
      for (; r8 < o16 && !t16.done; ) {
        const o17 = [];
        for (let e13 = 0; e13 < i11; e13++) o17.push(this._fetchChunk(t16, a12++));
        const n17 = yield Promise.all(o17);
        for (const e13 of n17) (0 !== e13.size() || e13.first) && (t16.add(e13.page, !e13.reader.exceededTransferLimit), s2(t16.options), this._addChunk(e13));
        r8++, i11 = Math.min(i11 + 1, e12);
      }
    });
  }
  _fetchChunk(t16, e12) {
    return __async(this, null, function* () {
      const s17 = t16.subscription.tile, o16 = this._queryInfo.createPagedTileQuery(s17, e12), r8 = yield this._fetch(o16, t16.options);
      return new t12(r8, o16.inner.toJSON(), s17, e12, false);
    });
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/FeatureSnapshotSourceChunk.js
var t13 = class extends i8 {
  constructor(e12, t16, r8, s17) {
    super(), this._reader = e12, this._queryJSON = t16, this._page = r8, this._end = s17, this.chunkId = `${this._page}${this.end ? "e" : ""}`, this.normalizedChunkId = this.chunkId;
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return 0 === this._page;
  }
  get end() {
    return this._end;
  }
  get queryInfo() {
    return {
      type: "snapshot",
      chunkId: this.chunkId,
      queryJSON: this._queryJSON,
      page: this._page,
      size: this.size(),
      end: this.end
    };
  }
  get isTiled() {
    return false;
  }
  getTileReader(e12) {
    const t16 = this.queryFeaturesInBounds(e12.bounds);
    return t16.setTransformForDisplay(e12.transform), t16;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/SnapshotLoadStrategy.js
var a11 = class extends i9 {
  constructor(t16, e12, o16, s17, n17, a12) {
    super(t16, e12, o16, n17, a12), this._random = new t(1e3), this._featureCount = s17;
  }
  get about() {
    return {
      willQueryAllFeatures: true,
      willQueryFullResolutionGeometry: true
    };
  }
  load(t16) {
    return null == this._promise && (this._promise = this._downloadPages(this._featureCount)), this._promise;
  }
  unload(t16) {
  }
  _downloadPages(e12) {
    return __async(this, null, function* () {
      const r8 = Math.ceil(e12 / this._queryInfo.pageSize), o16 = Array.from({
        length: r8
      }, (t16, e13) => e13).sort((t16, e13) => this._random.getInt() - this._random.getInt()), a12 = yield Promise.all(o16.map((t16) => this._downloadPage(t16))), i11 = new t13(u5.empty(this._metadata), null, -1, true);
      this._store.insert(i11);
      const u8 = a12.filter((t16) => t16);
      if (u8.length) throw new s("featurelayer-query", "Encountered errors when downloading data", {
        errors: u8
      });
    });
  }
  _downloadPage(t16) {
    return __async(this, null, function* () {
      try {
        const r8 = this._queryInfo.createPagedQuery(t16), o16 = yield this._fetch(r8, this._options), n17 = new t13(o16, r8.inner.toJSON(), t16, false);
        return s2(this._options), this._store.insert(n17), null;
      } catch (r8) {
        return r8;
      }
    });
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/StreamConnectionState.js
var s16 = class extends S {
  constructor(r8) {
    super(r8);
  }
  get connectionStatus() {
    return this.connection?.connectionStatus;
  }
  get errorString() {
    return this.connection?.errorString;
  }
};
e([y()], s16.prototype, "connection", void 0), e([y()], s16.prototype, "connectionStatus", null), e([y()], s16.prototype, "errorString", null), s16 = e([a("esri.views.2d.layers.features.sources.StreamConnectionState")], s16);

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/StreamFeatureStore.js
var t14 = class {
  constructor(e12, t16) {
    this._metadata = e12, this._onUpdate = t16, this._objectIdToFeature = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._objectIdToFeature.size;
  }
  get reader() {
    return u5.fromFeatures([...this._objectIdToFeature.values()], this._metadata);
  }
  add(e12) {
    this._objectIdToFeature.set(e12.objectId, e12);
  }
  forEach(e12) {
    this._objectIdToFeature.forEach(e12);
  }
  removeById(e12) {
    const t16 = this._objectIdToFeature.get(e12);
    return t16 ? (this._objectIdToFeature.delete(e12), t16) : null;
  }
  clear() {
    this._objectIdToFeature = /* @__PURE__ */ new Map();
  }
  update(e12, t16) {
    this._onUpdate(e12?.length ?? 0);
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/StreamSourceChunk.js
var r7 = class extends i8 {
  constructor(e12) {
    super(), this._reader = e12, this.chunkId = "stream-chunk", this.normalizedChunkId = "stream-chunk";
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return true;
  }
  get end() {
    return true;
  }
  get queryInfo() {
    return {
      type: "stream",
      chunkId: this.chunkId,
      size: this.size(),
      end: this.end
    };
  }
  get isTiled() {
    return false;
  }
  getTileReader(e12) {
    const r8 = this.queryFeaturesInBounds(e12.bounds);
    return r8.setTransformForDisplay(e12.transform), r8;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/StreamLoadStrategy.js
var h5 = class extends r6 {
  constructor(t16, s17, o16, a12, c10) {
    super(o16), this._service = t16, this._dataFilter = s17, this._streamOptions = a12, this._metadata = c10, this._connectionState = new s16(), this._forceRefresh = false, this.events = new o2();
    const {
      objectIdField: h6,
      timeInfo: m9
    } = this._metadata, {
      purgeOptions: d9
    } = s17;
    this._stagingStore = new t14(this._metadata, (e12) => this.events.emit("features-updated", e12)), this._manager = new o6(this._stagingStore, h6, m9, d9), this.connect();
  }
  destroy() {
    super.destroy(), this.disconnect();
  }
  get about() {
    return {
      willQueryAllFeatures: false,
      willQueryFullResolutionGeometry: false
    };
  }
  get connectionStatus() {
    return this._connectionState.connectionStatus;
  }
  get errorString() {
    return this._connectionState?.errorString;
  }
  refresh() {
    return __async(this, null, function* () {
      const e12 = null != this._chunk;
      this._manager.checkForUpdates() || !e12 || this._forceRefresh ? (this._chunk && this._store.remove(this._chunk), this._forceRefresh = false, this._chunk = new r7(this._stagingStore.reader), this._store.insert(this._chunk), this.events.emit("tick")) : this.events.emit("tick");
    });
  }
  updateFields(e12) {
    return __async(this, null, function* () {
      throw new Error("Updating available fields not supported for StreamLayer");
    });
  }
  load(e12) {
    return __async(this, null, function* () {
    });
  }
  unload(e12) {
  }
  disconnect() {
    this._connection = u2(this._connection), this._connectionState.connection = null, this._handlesGroup?.remove();
  }
  connect() {
    if (null != this._connection) return;
    const {
      geometryType: e12,
      spatialReference: s17
    } = this._metadata, {
      maxReconnectionAttempts: n17,
      maxReconnectionInterval: i11,
      geometryDefinition: r8,
      definitionExpression: a12,
      customParameters: c10
    } = this._dataFilter;
    this._connection = r2(this._service.source, s17, this._streamOptions.outSR, e12, a12, r8, n17, i11, c10), this._handlesGroup = o([this._connection.on("data-received", (e13) => this._onFeature(e13)), this._connection.on("message-received", (e13) => this._onWebSocketMessage(e13))]), this._connectionState.connection = this._connection;
  }
  clear() {
    this._manager.checkForUpdates(), this._stagingStore.clear(), this._forceRefresh = true;
  }
  updateCustomParameters(e12) {
    this._connection?.updateCustomParameters(e12);
  }
  sendMessageToSocket(e12) {
    this._connection?.sendMessageToSocket(e12);
  }
  sendMessageToClient(e12) {
    this._connection?.sendMessageToClient(e12);
  }
  _onWebSocketMessage(e12) {
    if ("type" in e12) switch (e12.type) {
      case "delete":
        if (e12.objectIds) for (const t16 of e12.objectIds) this._manager.removeById(t16);
        if (e12.trackIds) for (const t16 of e12.trackIds) this._manager.removeByTrackId(t16);
        break;
      case "clear":
        this.clear();
    }
    this.events.emit("message-received", e12);
  }
  _onFeature(e12) {
    try {
      this._manager.add(e12), this.events.emit("data-received", e12);
    } catch (t16) {
    }
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/SourceChunkStore.js
var n16 = class {
  constructor(s17) {
    this._onChange = s17, this._chunks = /* @__PURE__ */ new Map(), this._chunksToRemove = [], this.events = new o2(), this.featureAdapter = new t3();
  }
  destroy() {
    this.clear();
  }
  clear() {
    for (const e12 of this._chunks.values()) this._chunksToRemove.push(e12);
    this._chunks.clear(), null != this._localEditChunk && this._chunksToRemove.push(this._localEditChunk), this._localEditChunk = null;
  }
  *chunks() {
    this._localEditChunk && (yield this._localEditChunk), this._localOverridesChunk && (yield this._localOverridesChunk), yield* __yieldStar(this._chunks.values());
  }
  insert(e12) {
    has("esri-2d-update-debug") && console.debug(`Chunk[${e12.chunkId}] SourceChunkStore.insert`), this._localOverridesChunk?.overriddenIds.size && (e12.reader.removeIds(this._localOverridesChunk.overriddenIds), e12.invalidate()), this._localEditChunk?.overriddenIds.size && this._localEditChunk.removeOverrides(e12), this._chunks.set(e12.chunkId, e12), this.events.emit("changed"), this._onChange();
  }
  remove(e12) {
    has("esri-2d-update-debug") && console.debug(`Chunk[${e12.chunkId}] SourceChunkStore.remove`), this._chunks.delete(e12.chunkId), this._chunksToRemove.push(e12);
  }
  cleanupRemovedChunks() {
    const e12 = this._chunksToRemove;
    return this._chunksToRemove = [], e12;
  }
  applyLocalOverrides(e12, s17) {
    null == this._localOverridesChunk && (this._localOverridesChunk = new r5(s17, "localOverride")), this._localOverridesChunk.applyOverrides(e12);
    for (const o16 of this._chunks.values()) o16.reader.removeIds(this._localOverridesChunk.overriddenIds), o16.invalidate();
  }
  applyLocalEdit(e12, s17) {
    null == this._localEditChunk && (this._localEditChunk = new r5(s17, "localEdit")), this._localEditChunk.applyOverrides(e12);
    for (const o16 of this._chunks.values()) o16.reader.removeIds(this._localEditChunk.overriddenIds), o16.invalidate();
  }
  forEach(e12) {
    const s17 = /* @__PURE__ */ new Set();
    for (const o16 of this.chunks()) {
      const t16 = o16.reader.getCursor();
      for (; t16.next(); ) {
        const o17 = t16.getObjectId();
        s17.has(o17) || (e12(t16.copy()), s17.add(o17));
      }
    }
  }
  forEachUnsafe(e12) {
    const s17 = /* @__PURE__ */ new Set();
    for (const o16 of this.chunks()) {
      const t16 = o16.reader.getCursor();
      for (; t16.next(); ) {
        const o17 = t16.getObjectId();
        s17.has(o17) || (e12(t16), s17.add(o17));
      }
    }
  }
  forEachInBounds(e12, s17) {
    const o16 = /* @__PURE__ */ new Set();
    for (const t16 of this.chunks()) {
      const n17 = t16.queryFeaturesInBounds(e12);
      for (; n17.next(); ) {
        const e13 = n17.getObjectId();
        o16.has(e13) || (s17(n17.copy()), o16.add(e13));
      }
    }
  }
  forEachBounds(e12, o16) {
    const t16 = i();
    for (const s17 of e12) {
      s17.getBounds(t16) && o16(t16);
    }
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSource.js
var S5 = class {
  constructor(e12, t16, s17, r8, a12) {
    this.service = e12, this._aggregateAdapter = t16, this._subscriptions = s17, this._onChange = r8, this._connection = a12, this._updateTracking = new d5({
      debugName: "FeatureSource"
    }), this._didInvalidateData = false, this._store = new n16(this._onChange), this._metadata = new i2(e12.metadata);
  }
  destroy() {
    this._strategy?.destroy(), this._store.destroy(), this._streamMessenger?.destroy(), "memory" === this.service.type && this.service.source.map((e12) => e12.close());
  }
  get metadata() {
    if (!this._metadata) throw new Error("InternalError: Metadata not defined. Was update called?");
    return this._metadata;
  }
  get store() {
    return this._store;
  }
  get streamMessenger() {
    return null == this._streamMessenger && this._initStreamMessenger(), this._streamMessenger;
  }
  get statistics() {
    return t11.from(this._store);
  }
  get updateTracking() {
    return this._updateTracking;
  }
  get queryEngine() {
    if (!this._queryEngine) {
      if (!this._schema) return null;
      const {
        dataFilter: e12
      } = this._schema.mutable, t16 = this._schema.mutable.availableFields, s17 = this._metadata;
      this._queryEngine = new $({
        featureStore: this._store,
        fieldsIndex: s17.fieldsIndex,
        geometryType: s17.geometryType,
        objectIdField: s17.objectIdField,
        hasM: false,
        hasZ: false,
        spatialReference: this.service.outSpatialReference,
        cacheSpatialQueries: true,
        aggregateAdapter: this._aggregateAdapter,
        timeInfo: s17.timeInfo,
        definitionExpression: e12.definitionExpression,
        availableFields: t16
      });
    }
    return this._queryEngine;
  }
  get isStream() {
    return "stream" === this._schema.type;
  }
  chunks() {
    return Array.from(this._store.chunks());
  }
  cleanupRemovedChunks() {
    return this._store.cleanupRemovedChunks();
  }
  onSubscribe(e12) {
    this._connection.onEvent({
      type: "subscribe",
      tile: e12.tile.id
    });
    const t16 = this._strategy?.load(e12);
    t16 && (t16.then(() => this._connection.onEvent({
      type: "loaded",
      tile: e12.tile.id
    })).catch((t17) => this._connection.onEvent({
      type: "error",
      tile: e12.tile.id,
      error: t17
    })), this._updateTracking.addPromise(t16));
  }
  onResume(e12) {
    this._updateTracking.addPromise(d(this._strategy?.load(e12)));
  }
  onUnsubscribe(e12) {
    this._connection.onEvent({
      type: "unsubscribe",
      tile: e12.tile.id
    }), this._strategy?.unload(e12);
  }
  getLocalEdit(e12) {
    return this._updateTracking.addPromise(this._getGetLocalEdit(e12));
  }
  applyLocalEdit(e12) {
    this._didInvalidateData = true, this._store.applyLocalEdit(e12, this.metadata);
  }
  update(e12, t16) {
    return __async(this, null, function* () {
      const s17 = e12.source, o16 = d3(this._schema?.mutable, s17.mutable);
      if (!o16) return false;
      if (has("esri-2d-update-debug") && console.debug(`Version[${t16}] FeatureSource.update`, {
        changes: o16
      }), this._schema = s17, this._queryEngine?.destroy(), this._queryEngine = null, "feature-service" === this.service.type && null != this.service.queryMetadata.lastEditDate && (this._lastEditDate = this.service.queryMetadata.lastEditDate), null == this._streamMessenger && "stream" === this._schema.type && this._initStreamMessenger(), y2(o16, "sourceRefreshVersion") && this._strategy?.refresh) return yield this._strategy.refresh(), true;
      if ("feature" === s17.type && y2(o16, "availableFields")) {
        if ((yield this._queryLastEditDateChanged()) || this._didInvalidateData) this._didInvalidateData = false, yield this._updateStrategy(t16);
        else {
          this._connection.onEvent({
            type: "updateFieldsStart"
          });
          try {
            yield this._strategy.updateFields(s17.mutable.availableFields), this._connection.onEvent({
              type: "updateFieldsEnd"
            });
          } catch (n17) {
            this._connection.onEvent({
              type: "updateFieldsError",
              error: n17
            });
          }
        }
        return false;
      }
      return !(!s6(o16, "dataFilter") && !s6(o16, "sourceRefreshVersion")) && (yield this._updateStrategy(t16), true);
    });
  }
  _initStreamMessenger() {
    null == this._streamMessenger && (this._streamMessenger = new o13(this._connection));
  }
  _getGetLocalEdit(e12) {
    return __async(this, null, function* () {
      if (e12.historicMoment && "feature" === this._schema.type && (this._schema.mutable.dataFilter.historicMoment = e12.historicMoment, this._strategy.unsafeSetQueryHistoricMoment(new Date(e12.historicMoment))), "edit-by-feature" === e12.type) {
        const t17 = [...e12.added, ...e12.updated].map((e13) => e3.fromJSON(e13, this.metadata.objectIdField));
        return {
          reader: u5.fromOptimizedFeatures(t17, this.metadata),
          removed: this._resolveIdentifiers(e12.removed)
        };
      }
      const t16 = this._resolveIdentifiers(e12.removed);
      if (!e12.updated.length && !e12.added.length) return {
        reader: u5.empty(this.metadata),
        removed: t16
      };
      const s17 = this._resolveIdentifiers([...e12.added, ...e12.updated]);
      return {
        reader: yield this._strategy.queryByObjectId(s17),
        removed: t16
      };
    });
  }
  _resolveIdentifiers(e12) {
    const t16 = [], s17 = [];
    for (const r8 of e12) null != r8.objectId && -1 !== r8.objectId ? s17.push(r8.objectId) : t16.push(r8.globalId);
    if (t16.length) {
      const e13 = new Set(t16), r8 = this.metadata.globalIdField;
      if (null == r8) throw new Error("InternalError: Recieved an edit with globalIds, but not supported by the service");
      this._store.forEachUnsafe((t17) => {
        const a12 = t17.readAttribute(r8);
        e13.has(a12) && s17.push(t17.getObjectId());
      });
    }
    return s17;
  }
  _queryLastEditDateChanged() {
    return __async(this, null, function* () {
      if (null == this._lastEditDate) return false;
      const t16 = this.service.source, s17 = __spreadProps(__spreadValues({}, t16.query), {
        f: "json"
      }), r8 = (yield U(t16.path, {
        query: s17,
        responseType: "json"
      })).data.editingInfo.lastEditDate;
      return r8 !== this._lastEditDate && (this._lastEditDate = r8, true);
    });
  }
  _createStrategy() {
    return __async(this, null, function* () {
      const e12 = "isSourceHosted" in this.service && this.service.isSourceHosted, t16 = Array.isArray(this.service.source), s17 = this.service.source && "collection" in this.service.source, r8 = e12 || t16 || s17;
      if ("stream" === this._schema.type) {
        const e13 = new h5(this.service, this._schema.mutable.dataFilter, this._store, {
          outSR: this.service.outSpatialReference
        }, this.metadata);
        return this._streamMessenger.strategy = e13, e13;
      }
      const a12 = this.service, i11 = n13.fromSchema(a12, this._schema, this._metadata), o16 = yield this._supportSnapshotMode(a12, i11);
      return o16 ? new a11(a12, i11, this._store, o16.featureCount, this.metadata, this._connection) : r8 ? new l8(a12, i11, this._store, this.metadata, this._connection) : new a10(a12, i11, this._store, this.metadata, this._connection);
    });
  }
  _updateStrategy(e12) {
    return __async(this, null, function* () {
      const t16 = yield this._createStrategy();
      this._connection.onEvent({
        type: "updateStrategyStart",
        about: t16.about
      });
      const r8 = !!this._strategy;
      this._store.clear(), this._strategy?.destroy(), this._strategy = t16, has("esri-2d-update-debug") && console.debug(`Version[${e12}] FeatureSource.updateStrategy`, {
        strategy: t16
      });
      const a12 = Array.from(this._subscriptions.values());
      if (!a12.length) return void this._connection.onEvent({
        type: "updateStrategyEnd"
      });
      const i11 = Promise.all(a12.map((e13) => this._strategy.load(e13).then(() => this._connection.onEvent({
        type: "loaded",
        tile: e13.tile.id
      })).catch((t17) => this._connection.onEvent({
        type: "error",
        tile: e13.tile.id,
        error: t17
      }))));
      this._updateTracking.addPromise(i11);
      try {
        r8 && (yield i11);
      } catch (o16) {
        f(o16);
      }
      this._connection.onEvent({
        type: "updateStrategyEnd"
      }), has("esri-2d-update-debug") && console.debug(`Version[${e12}] FeatureSource.updateStrategyEnd`, {
        strategy: t16
      });
    });
  }
  _supportSnapshotMode(e12, t16) {
    return __async(this, null, function* () {
      const {
        queryMetadata: s17
      } = e12, r8 = s17.snapshotInfo;
      if (!r8 || !r8.supportsSnapshotMinThreshold || !r8.snapshotCountThresholds) return null;
      const a12 = e12.source, i11 = t16.createQuery();
      i11.inner.orderByFields = [], i11.inner.returnGeometry = false;
      const o16 = (yield S2(a12, i11.inner, {
        query: i11.customParameters
      })).data.count, {
        min: n17,
        max: h6
      } = r8.snapshotCountThresholds;
      return o16 <= n17 || r8.supportsSnapshotMaxThreshold && o16 < h6 ? {
        featureCount: o16
      } : null;
    });
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureTileSubscription.js
var t15 = class {
  constructor(t16, r8) {
    this.tile = t16, this.version = r8, this._abortController = new AbortController();
  }
  get key() {
    return this.tile.key;
  }
  get signal() {
    return this._abortController.signal;
  }
  abort() {
    this._abortController.abort();
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/features/FeaturePipelineWorker.js
var m8 = class {
  constructor(e12) {
    this.inner = e12, this.resolver = L();
  }
};
var y7 = class {
  constructor() {
    this._aggregateAdapter = {
      getFeatureObjectIds: (e12) => this._processor.getFeatureObjectIdsForAggregate(e12)
    }, this._subscriptions = /* @__PURE__ */ new Map(), this._updateRequested = false, this._updateSubscriptionRequests = [], this._updateHighlightRequests = [];
  }
  destroy() {
    this._subscriptions.clear(), this._processor.destroy(), this._source.destroy(), this._handles.remove(), this._updateLocalEditsRequest = null, this._tileInfoView = null;
  }
  onAttach(e12) {
    has("esri-2d-update-debug") && console.debug("Pipeline.onAttach");
    const s17 = this._connection, i11 = z.fromJSON(e12.tileInfoJSON);
    this._tileInfoView = new h2(i11), this._source = new S5(e12.service, this._aggregateAdapter, this._subscriptions, () => this._requestUpdate(), s17), this._processor = new f4(s17, this._source), this._handles = o([d2(() => this._source.updateTracking.updating, () => {
      this._requestUpdate(), d(this._connection.layerView.setUpdating({
        data: this._source.updateTracking.updating,
        pipeline: true
      }));
    })]);
  }
  onDetach() {
    has("esri-2d-update-debug") && console.debug("Pipeline.onDetach"), this.destroy();
  }
  set remoteClient(e12) {
    this._connection = new t4(e12);
  }
  get features() {
    const t16 = this._source?.queryEngine;
    if (!t16) throw new s("no-queryEngine", "No query engine defined");
    return t16;
  }
  get aggregates() {
    const t16 = this._processor?.aggregateQueryEngine;
    if (!t16) throw new s("no-queryEngine", "No aggregate query engine defined");
    return t16;
  }
  get processor() {
    return this._processor;
  }
  get streamMessenger() {
    return this._source.streamMessenger;
  }
  getDisplayFeatures(e12) {
    return this._processor.getDisplayFeatures(e12);
  }
  updateSchema(e12, t16) {
    return __async(this, null, function* () {
      return has("esri-2d-update-debug") && this._updateSchemaRequest && console.error("InternalError: Schema already updating"), this._updateSchemaRequest = new m8({
        schema: e12,
        version: t16
      }), this._requestUpdate(), this._updateSchemaRequest.resolver.promise;
    });
  }
  updateSubscriptions(e12) {
    const t16 = new m8(e12);
    return this._updateSubscriptionRequests.push(t16), this._requestUpdate(), t16.resolver.promise;
  }
  updateHighlight(e12) {
    const t16 = new m8(e12);
    return this._updateHighlightRequests.push(t16), this._requestUpdate(), t16.resolver.promise;
  }
  onEdits(t16) {
    return __async(this, null, function* () {
      if (null != this._updateLocalEditsRequest) throw new s("InternalError - Already processing an edit");
      this._updateLocalEditsRequest = new m8(t16);
      const s17 = this._updateLocalEditsRequest.resolver.promise;
      return this._requestUpdate(), s17;
    });
  }
  queryStatistics() {
    return this._source.statistics.toJSON();
  }
  queryVisibleFeatures(e12, t16) {
    return __async(this, null, function* () {
      return this.features.executeQuery(e12, t16);
    });
  }
  queryHeatmapStatistics(e12) {
    return __async(this, null, function* () {
      const t16 = Math.round(u3(e12.radius));
      let s17 = Number.POSITIVE_INFINITY, i11 = Number.NEGATIVE_INFINITY;
      const r8 = "string" == typeof e12.fieldOffset, o16 = e12.fieldOffset ?? 0, n17 = Array.from(this._subscriptions.values()), u8 = this._source.chunks(), d9 = t16 ** 2, c10 = 3 / (Math.PI * d9), p7 = 2 * t16, h6 = Math.ceil(a2 / p7);
      for (const a12 of n17) {
        const t17 = a12.tile, n18 = new Float64Array(h6 * h6);
        for (const s18 of u8) {
          const i12 = s18.getTileReader(t17);
          if (!i12) continue;
          const u9 = i12.getCursor();
          for (; u9.next(); ) {
            let t18 = 1;
            if (null != e12.field) {
              const s20 = u9.readAttribute(e12.field);
              t18 = r8 ? -1 * +s20 : +s20 + o16;
            }
            const s19 = u9.readXForDisplay() / p7, i13 = u9.readYForDisplay() / p7, a13 = Math.floor(s19), l9 = Math.floor(i13);
            if (a13 < 0 || l9 < 0 || a13 >= h6 || l9 >= h6) continue;
            const g5 = ((0.5 + a13 - s19) * p7) ** 2 + ((0.5 + l9 - i13) * p7) ** 2;
            if (g5 > d9) continue;
            const _5 = t18 * (c10 * (1 - g5 / d9) ** 2);
            n18[l9 + a13 * h6] += _5;
          }
        }
        for (let e13 = 0; e13 < n18.length; e13++) s17 = Math.min(s17, n18[e13]), i11 = Math.max(i11, n18[e13]);
      }
      return {
        max: i11,
        min: s17
      };
    });
  }
  getSampleFeatures(e12) {
    return __async(this, null, function* () {
      const t16 = this._source.chunks();
      if (t16.reduce((e13, t17) => e13 + t17.size(), 0) <= e12.minFeatureCount) {
        if (!this._source.updateTracking.updating) {
          const e13 = [];
          return this._source.store.forEachUnsafe((t17) => e13.push(t17.readLegacyFeatureWorldSpace())), e13;
        }
        return null;
      }
      const s17 = /* @__PURE__ */ new Set(), i11 = [], r8 = t16.map((e13) => e13.reader.getCursor()), o16 = new t(), u8 = 3 * e12.sampleSize;
      for (let n17 = 0; n17 < u8 && i11.length < e12.sampleSize; n17++) {
        const e13 = r8[o16.getIntRange(0, t16.length - 1)];
        if (0 === e13.getSize()) continue;
        const n18 = o16.getIntRange(0, e13.getSize() - 1);
        e13.setIndex(n18);
        const u9 = e13.getObjectId();
        s17.has(u9) || (s17.add(u9), i11.push(e13.readLegacyFeatureWorldSpace()));
      }
      return i11.length >= e12.sampleSize ? i11 : null;
    });
  }
  _requestUpdate() {
    this._updateRequested || (this._updateRequested = true, t2(() => this._scheduleNextUpdate()));
  }
  _scheduleNextUpdate() {
    this._updateRequested && (this._ongoingUpdate || (this._ongoingUpdate = O2(this._doUpdate()).finally(() => {
      this._ongoingUpdate = null, this._scheduleNextUpdate();
    }), this._updateRequested = false));
  }
  _subscribe(e12) {
    const t16 = e12.tileId;
    if (this._subscriptions.has(t16)) return;
    has("esri-2d-update-debug") && console.debug(`Tile[${t16}] Pipeline.subscribe`);
    const s17 = new n7(this._tileInfoView, t16), i11 = new t15(s17, e12.version);
    this._subscriptions.set(t16, i11), this._source.onSubscribe(i11), this._processor.onSubscribe(i11);
  }
  _unsubscribe(e12) {
    const t16 = this._subscriptions.get(e12);
    t16 && (has("esri-2d-update-debug") && console.debug(`Tile[${e12}] Pipeline.unsubscribe`), t16.abort(), this._source.onUnsubscribe(t16), this._processor.onUnsubscribe(t16), this._subscriptions.delete(t16.key.id));
  }
  _doUpdate() {
    return __async(this, null, function* () {
      if (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateStart"), yield this._connection.layerView.setUpdating({
        data: this._source.updateTracking.updating,
        pipeline: true
      }), this._updateSubscriptionRequests.length) {
        const e13 = this._updateSubscriptionRequests;
        this._updateSubscriptionRequests = [];
        for (const t17 of e13) this._doUpdateSubscriptions(t17.inner), t17.resolver.resolve();
      }
      const e12 = this._updateSchemaRequest;
      if (this._updateSchemaRequest = null, null != e12) {
        const {
          schema: t17,
          version: s18
        } = e12.inner;
        yield this._doUpdateSchema(t17, s18);
      }
      const t16 = this._updateLocalEditsRequest;
      if (this._updateLocalEditsRequest = null, null != t16) {
        has("esri-2d-update-debug") && console.debug("Pipeline.applyEditOverride", t16.inner);
        const e13 = yield this._source.getLocalEdit(t16.inner);
        yield this._processor.applyLocalEdit(e13), this._source.applyLocalEdit(e13), has("esri-2d-update-debug") && console.debug("Pipeline.endEditOverride", t16.inner);
      }
      if (this._updateHighlightRequests.length) {
        const e13 = this._updateHighlightRequests;
        this._updateHighlightRequests = [];
        for (const t17 of e13) this._processor.updateHighlight(t17.inner), t17.resolver.resolve();
      }
      const s17 = this._source.cleanupRemovedChunks();
      this._processor.removeChunks(s17);
      try {
        this._subscriptions.size && (has("esri-2d-update-debug") && console.debug("Pipeline.updateChunksStart"), yield this._processor.updateChunks(), has("esri-2d-update-debug") && console.debug("Pipeline.updateChunksEnd"));
      } catch (r8) {
        f(r8);
      }
      null != t16 && t16.resolver.resolve(), null != e12 && e12.resolver.resolve(), this._updateRequested ? (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateEnd [updateRequested=true]"), yield this._connection.layerView.setUpdating({
        data: this._source.updateTracking.updating,
        pipeline: true
      })) : (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateEnd [updateRequested=false, After flush]"), yield this._connection.layerView.setUpdating({
        data: this._source.updateTracking.updating,
        pipeline: this._updateRequested
      }));
    });
  }
  _doUpdateSchema(e12, t16) {
    return __async(this, null, function* () {
      has("esri-2d-update-debug") && console.debug(`Version[${t16}] Pipeline.updateStart`, {
        schema: e12
      });
      const s17 = {
        tileInfo: this._tileInfoView?.tileInfo
      }, i11 = yield this._source.update(e12, t16), r8 = Array.from(this._subscriptions.values());
      yield this._processor.update(e12, t16, s17, i11, r8), has("esri-2d-update-debug") && console.debug(`Version[${t16}] Pipeline.updateEnd`);
    });
  }
  _doUpdateSubscriptions(e12) {
    has("esri-2d-update-debug") && console.debug("Pipeline.updateSubscriptions", e12);
    for (const t16 of e12.subscribe) this._subscribe(t16);
    for (const t16 of e12.unsubscribe) this._unsubscribe(t16);
  }
};
export {
  y7 as default
};
//# sourceMappingURL=FeaturePipelineWorker-E2QEFBDG.js.map
