{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/chunks/LineCallout.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { set as e } from \"../core/libs/gl-matrix-2/math/vec2.js\";\nimport { create as i } from \"../core/libs/gl-matrix-2/factories/vec2f64.js\";\nimport { ZEROS as r } from \"../core/libs/gl-matrix-2/factories/vec4f64.js\";\nimport { SliceDraw as o } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { AlignPixel as n } from \"../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl.js\";\nimport { HUD as t } from \"../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js\";\nimport { HUDVisibility as a } from \"../views/3d/webgl-engine/core/shaderLibrary/hud/HUDVisibility.glsl.js\";\nimport { multipassGeometryTest as l } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl.js\";\nimport { addScreenSizePerspectiveAlignment as d } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js\";\nimport { Float2PassUniform as s } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float4PassUniform as c } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as p } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as g } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as f } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { VertexAttribute as v } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nfunction S(i) {\n  const r = new f(),\n    {\n      vertex: S,\n      fragment: h\n    } = r;\n  return S.include(n), r.include(t, i), r.include(o, i), r.attributes.add(v.UV0, \"vec2\"), S.uniforms.add(new c(\"viewport\", (e, i) => i.camera.fullViewport), new p(\"lineSize\", (e, i) => e.size > 0 ? Math.max(1, e.size) * i.camera.pixelRatio : 0), new s(\"pixelToNDC\", (i, r) => e(b, 2 / r.camera.fullViewport[2], 2 / r.camera.fullViewport[3])), new p(\"borderSize\", (e, i) => null != e.borderColor ? i.camera.pixelRatio : 0), new s(\"screenOffset\", (i, r) => e(b, i.horizontalScreenOffset * r.camera.pixelRatio, 0))), r.varyings.add(\"coverageSampling\", \"vec4\"), r.varyings.add(\"lineSizes\", \"vec2\"), i.multipassEnabled && r.varyings.add(\"depth\", \"float\"), i.occlusionTestEnabled && r.include(a), i.hasScreenSizePerspective && d(S), S.code.add(g`\n    void main(void) {\n      ProjectHUDAux projectAux;\n      vec4 endPoint = projectPositionHUD(projectAux);\n\n      vec3 vpos = projectAux.posModel;\n      if (rejectBySlice(vpos)) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n    ${i.occlusionTestEnabled ? g`\n      if (!testHUDVisibility(endPoint)) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }` : \"\"}\n\n    ${i.hasScreenSizePerspective ? g`\n      vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n      vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);\n        ` : g`vec2 screenOffsetScaled = screenOffset;`}\n      // Add view dependent polygon offset to get exact same original starting point. This is mostly used to get the\n      // correct depth value\n      vec3 posView = (view * vec4(position, 1.0)).xyz;\n      ${i.multipassEnabled ? \"depth = posView.z;\" : \"\"}\n\n      applyHUDViewDependentPolygonOffset(centerOffsetAndDistance.w, projectAux.absCosAngle, posView);\n      vec4 startPoint = proj * vec4(posView, 1.0);\n      // Apply screen offset to both start and end point\n      vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n      startPoint.xy += screenOffsetNorm * startPoint.w;\n      endPoint.xy += screenOffsetNorm * endPoint.w;\n      // Align start and end to pixel origin\n      vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n      vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n    ${i.depthHudEnabled ? i.depthHudAlignStartEnabled ? g`endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);` : g`startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);` : \"\"}\n      vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\n      // The direction of the line in screen space\n      vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n      vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n    ${i.hasScreenSizePerspective ? g`\n      float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n      float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);\n        ` : g`\n      float lineSizeScaled = lineSize;\n      float borderSizeScaled = borderSize;\n        `}\n      float halfPixelSize = lineSizeScaled * 0.5;\n\n      // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size\n      float padding = 1.0 + borderSizeScaled;\n      vec2 ndcOffset = (-halfPixelSize - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n\n      // Offset x/y from the center of the line in screen space\n      projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n\n      // Compute a coverage varying which we can use in the fragment shader to determine\n      // how much a pixel is actually covered by the line (i.e. to anti alias the line).\n      // This works by computing two coordinates that can be linearly interpolated and then\n      // subtracted to find out how far away from the line edge we are.\n      float edgeDirection = (uv0.x * 2.0 - 1.0);\n\n      float halfBorderSize = 0.5 * borderSizeScaled;\n      float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n      float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n\n      float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n\n      coverageSampling = vec4(\n        // Edge coordinate\n        outerEdgeCoverageSampler,\n\n        // Border edge coordinate\n        outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n\n        // Line offset\n        halfPixelSize - 0.5,\n\n        // Border offset\n        halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n      );\n\n      lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n\n      gl_Position = projectedPosition;\n    }\n  `), h.uniforms.add(new c(\"uColor\", e => m(e.color)), new c(\"borderColor\", e => m(e.borderColor))), i.multipassEnabled && (h.include(l, i), h.uniforms.add(new s(\"inverseViewport\", (e, i) => i.inverseViewport))), h.code.add(g`\n    void main() {\n      ${i.multipassEnabled ? \"if( geometryDepthTest(gl_FragCoord.xy * inverseViewport, depth) ){ discard; }\" : \"\"}\n\n      // Mix between line and border coverage offsets depending on whether we need\n      // a border (based on the sidedness).\n      vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n\n      // Mix between border and line color based on the line coverage (conceptually the line blends on top of the\n      // border background).\n      //\n      // Anti-alias by blending final result using the full (including optional border) coverage and the color alpha\n      float borderAlpha = uColor.a * borderColor.a * coverage.y;\n      float colorAlpha = uColor.a * coverage.x;\n\n      float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n\n    ${i.depthHudEnabled ? g`\n      if (finalAlpha < 0.01) {\n        discard;\n      }\n      ` : g`\n      vec3 finalRgb = mix(borderColor.rgb * borderAlpha, uColor.rgb, colorAlpha);\n      fragColor = vec4(finalRgb, finalAlpha);\n      `}\n  }\n  `), r;\n}\nfunction m(e) {\n  return null != e ? e : r;\n}\nconst b = i(),\n  h = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    build: S\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { h as L, S as b };"],
  "mappings": "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",
  "names": ["r", "o", "S", "h", "e", "i"]
}
