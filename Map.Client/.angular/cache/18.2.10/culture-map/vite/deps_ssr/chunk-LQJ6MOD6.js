import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  m as m6
} from "./chunk-IYAKOGH7.js";
import {
  H,
  N,
  a as a2,
  a3 as a4,
  e as e9,
  i as i5,
  i2 as i6,
  l as l3,
  m as m5,
  n as n7,
  o as o5,
  p as p4,
  r as r7,
  r3 as r9,
  r4 as r10,
  s as s11,
  s2 as s12,
  t2 as t6,
  t3 as t7,
  t4 as t8,
  t5 as t9,
  u as u5,
  u2 as u6,
  y as y2
} from "./chunk-AUSHQO5O.js";
import {
  o as o7,
  r as r6
} from "./chunk-WQIJCG2D.js";
import {
  e as e8
} from "./chunk-JRL65HQ7.js";
import {
  e as e7
} from "./chunk-ZYO2ZGSV.js";
import {
  a as a3,
  c as c2,
  r as r8,
  s as s10
} from "./chunk-TM56WRQ7.js";
import {
  _ as _2,
  d as d3,
  t2 as t5
} from "./chunk-62PN4TEW.js";
import {
  Gt,
  H as H2,
  Y,
  Z,
  _ as _3,
  at,
  ft,
  gt,
  ht,
  jt,
  kt,
  lt,
  mt,
  ot,
  pt,
  tt,
  ut,
  wt,
  xt,
  yt
} from "./chunk-KZBRH42J.js";
import {
  m as m3
} from "./chunk-AENXIHUM.js";
import {
  e as e5
} from "./chunk-H5GZAILH.js";
import {
  m as m4
} from "./chunk-A47NS37R.js";
import {
  e as e6
} from "./chunk-7PJ3GUSK.js";
import {
  o as o6
} from "./chunk-P6I54QB7.js";
import {
  r as r5,
  t as t4
} from "./chunk-ZU246SKZ.js";
import {
  n as n6
} from "./chunk-33J3D7DK.js";
import {
  h as h4,
  s as s8
} from "./chunk-I6EZE7ZH.js";
import {
  i as i4
} from "./chunk-V4U3XK2O.js";
import {
  p as p3
} from "./chunk-RAYFUCRQ.js";
import {
  n as n5
} from "./chunk-WS7U2AGS.js";
import {
  f as f4,
  i as i3,
  s as s9,
  u as u4
} from "./chunk-U4NXHH3L.js";
import {
  e as e4
} from "./chunk-J7FRIDYV.js";
import {
  t as t3
} from "./chunk-2LHHRVKS.js";
import {
  S as S2,
  e as e3,
  m,
  o as o4,
  r as r4
} from "./chunk-B76NC7GX.js";
import {
  P as P2
} from "./chunk-T5C2TZNO.js";
import {
  m as m2
} from "./chunk-OOK3QTWF.js";
import {
  n as n4
} from "./chunk-BZHHBBFX.js";
import {
  M as M2,
  h as h3,
  i as i2,
  o as o3,
  r as r3
} from "./chunk-A2FDYA6M.js";
import {
  d as d2
} from "./chunk-NVOJILW6.js";
import {
  l as l2
} from "./chunk-KLK34CGP.js";
import {
  B,
  K
} from "./chunk-LM3JDV4W.js";
import {
  p as p2,
  z
} from "./chunk-KAHESDP5.js";
import {
  i
} from "./chunk-ASCK5HJ5.js";
import {
  c
} from "./chunk-VYTPFEL2.js";
import {
  j
} from "./chunk-MRPCXIVS.js";
import {
  s as s6
} from "./chunk-YTKVV2Y3.js";
import {
  M,
  s as s7,
  u as u3
} from "./chunk-GCVQXAS4.js";
import {
  f as f2,
  t as t2,
  w as w2
} from "./chunk-RNF7VOCU.js";
import {
  _,
  e as e2
} from "./chunk-TIRJMGGG.js";
import {
  s as s4
} from "./chunk-66YQWHHE.js";
import {
  f as f3,
  h as h2
} from "./chunk-2OZSYJDX.js";
import {
  u as u2
} from "./chunk-MHPE4SZA.js";
import {
  G,
  r as r2,
  s2 as s5
} from "./chunk-6SSA7P3A.js";
import {
  f
} from "./chunk-4AZPIP7K.js";
import {
  A as A2,
  C,
  P,
  d,
  p,
  w
} from "./chunk-LZSLQ24Q.js";
import {
  V
} from "./chunk-U3RHUXYK.js";
import {
  o as o2
} from "./chunk-JAMSDYD6.js";
import {
  e
} from "./chunk-NUICEVIH.js";
import {
  A,
  S,
  r,
  t2 as t
} from "./chunk-NXK752PZ.js";
import {
  y
} from "./chunk-UVNLCXWD.js";
import {
  n as n2
} from "./chunk-PNUA7JOS.js";
import {
  a3 as a,
  g2 as g,
  n as n3,
  s3
} from "./chunk-UDMPWVPF.js";
import {
  h,
  o,
  s as s2
} from "./chunk-AIZ3T7E3.js";
import {
  l,
  u
} from "./chunk-6WGE3IUL.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-6JFGZTLU.js";
import {
  O,
  has
} from "./chunk-2ZJE6ZFX.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-XBPEBUD5.js";

// ../../../node_modules/@arcgis/core/core/libs/gl-matrix-2/types/vec2.js
function n8(n13) {
  return n13 instanceof Float32Array && n13.length >= 2;
}
function r11(n13) {
  return Array.isArray(n13) && n13.length >= 2;
}
function t10(t15) {
  return n8(t15) || r11(t15);
}

// ../../../node_modules/@arcgis/core/views/2d/ViewState.js
var C2;
var L = [0, 0];
var O2 = C2 = class extends f {
  constructor(t15) {
    super(t15), this._viewpoint2D = {
      center: n4(),
      rotation: 0,
      scale: 0,
      spatialReference: void 0
    }, this.center = [0, 0], this.extent = new w2(), this.id = 0, this.inverseTransform = e5(), this.resolution = 0, this.rotation = 0, this.scale = 0, this.transform = e5(), this.transformNoRotation = e5(), this.displayMat3 = e6(), this.displayViewMat3 = e6(), this.viewMat3 = e6(), this.viewMat2d = n5(), this.worldScreenWidth = 0, this.size = [0, 0];
  }
  set pixelRatio(t15) {
    this._set("pixelRatio", t15), this._update();
  }
  set size(t15) {
    this._set("size", t15), this._update();
  }
  set viewpoint(t15) {
    if (t15) {
      const i10 = this._viewpoint2D, e16 = t15.targetGeometry;
      i10.center[0] = e16.x, i10.center[1] = e16.y, i10.rotation = t15.rotation, i10.scale = t15.scale, i10.spatialReference = e16.spatialReference;
    }
    this._update();
  }
  copy(t15) {
    const i10 = this.size, e16 = this.viewpoint;
    return e16 && i10 ? (this.viewpoint = Z(e16, t15.viewpoint), this._set("size", r4(i10, t15.size))) : (this.viewpoint = t15.viewpoint.clone(), this._set("size", [t15.size[0], t15.size[1]])), this._set("pixelRatio", t15.pixelRatio), this;
  }
  clone() {
    return new C2({
      size: this.size,
      viewpoint: this.viewpoint.clone(),
      pixelRatio: this.pixelRatio
    });
  }
  toMap(t15, i10, e16) {
    return t10(i10) ? S2(t15, i10, this.inverseTransform) : (L[0] = i10, L[1] = e16, S2(t15, L, this.inverseTransform));
  }
  toScreen(t15, i10, e16) {
    return t10(i10) ? S2(t15, i10, this.transform) : (L[0] = i10, L[1] = e16, S2(t15, L, this.transform));
  }
  toScreenNoRotation(t15, i10, e16) {
    return t10(i10) ? S2(t15, i10, this.transformNoRotation) : (L[0] = i10, L[1] = e16, S2(t15, L, this.transformNoRotation));
  }
  wrapMapCoordinate(t15, i10) {
    r4(t15, i10);
    const [e16] = i10, [s16] = this.center, {
      extent: o12,
      spatialReference: r14
    } = this;
    let {
      xmin: a13,
      xmax: n13
    } = o12;
    if (r14.isWrappable) {
      const t16 = mt(r14) / 2;
      a13 = Math.max(a13, s16 - t16), n13 = Math.min(n13, s16 + t16);
    }
    return (e16 < a13 || e16 > n13) && (t15[0] = P2(e16, s16, r14)), t15;
  }
  getScreenTransform(t15, i10) {
    const {
      center: e16
    } = this._viewpoint2D, s16 = this._get("pixelRatio") || 1, o12 = this._get("size");
    return ut(t15, e16, o12, i10, 0, s16), t15;
  }
  _update() {
    const {
      center: t15,
      spatialReference: e16,
      scale: s16,
      rotation: o12
    } = this._viewpoint2D, c8 = this._get("pixelRatio") || 1, h7 = this._get("size"), x2 = new m3({
      targetGeometry: new _(t15[0], t15[1], e16),
      scale: s16,
      rotation: o12
    });
    if (this._set("viewpoint", x2), !h7 || !e16 || !s16) return;
    this.resolution = ot(x2), this.rotation = o12, this.scale = s16, this.spatialReference = e16, r4(this.center, t15);
    const j3 = 0 !== h7[0] ? 2 / h7[0] : 0, y5 = 0 !== h7[1] ? -2 / h7[1] : 0;
    r3(this.displayMat3, j3, 0, 0, 0, y5, 0, -1, 1, 1);
    const R = o3(this.viewMat3), _5 = t3(h7[0] / 2, h7[1] / 2), z4 = t3(-h7[0] / 2, -h7[1] / 2), b = u2(o12);
    M2(R, R, _5), h3(R, R, b), M2(R, R, z4), i2(this.displayViewMat3, this.displayMat3, R);
    const M3 = f4(this.viewMat2d, _5);
    return s9(M3, M3, b), i3(M3, M3, z4), _3(this.extent, x2, h7), lt(this.transform, x2, h7, c8), u4(this.inverseTransform, this.transform), ft(this.transformNoRotation, x2, h7, c8), this.worldScreenWidth = yt(this.spatialReference, this.resolution), this._set("id", this.id + 1), this;
  }
};
e([y({
  readOnly: true
})], O2.prototype, "id", void 0), e([y({
  value: 1,
  json: {
    write: true
  }
})], O2.prototype, "pixelRatio", null), e([y({
  json: {
    write: true
  }
})], O2.prototype, "size", null), e([y()], O2.prototype, "spatialReference", void 0), e([y({
  type: m3,
  json: {
    write: true
  }
})], O2.prototype, "viewpoint", null), O2 = C2 = e([a("esri.views.2d.ViewState")], O2);
var U = O2;

// ../../../node_modules/@arcgis/core/views/2d/PaddedViewState.js
var h5;
var m7;
var g2 = h5 = class extends S {
  constructor() {
    super(...arguments), this.left = 0, this.top = 0, this.right = 0, this.bottom = 0;
  }
  clone() {
    return new h5({
      left: this.left,
      top: this.top,
      right: this.right,
      bottom: this.bottom
    });
  }
};
e([y()], g2.prototype, "left", void 0), e([y()], g2.prototype, "top", void 0), e([y()], g2.prototype, "right", void 0), e([y()], g2.prototype, "bottom", void 0), g2 = h5 = e([a("esri.views.2d.PaddedViewState.Padding")], g2);
var f5 = m7 = class extends U {
  constructor(...t15) {
    super(...t15), this.paddedViewState = new U(), this._updateContent = (() => {
      const t16 = n4();
      return () => {
        const e16 = this._get("size"), i10 = this._get("padding");
        if (!e16 || !i10) return;
        const o12 = this.paddedViewState;
        o4(t16, i10.left + i10.right, i10.top + i10.bottom), e3(t16, e16, t16), r4(o12.size, t16);
        const s16 = o12.viewpoint;
        s16 && (this.viewpoint = s16);
      };
    })(), this.addHandles(d(() => [this.size, this.padding], () => this._updateContent(), C)), this.padding = new g2(), this.size = [0, 0];
  }
  set padding(t15) {
    this._set("padding", t15 || new g2());
  }
  set viewpoint(t15) {
    if (t15) {
      this.paddedViewState.viewpoint = t15;
      const e16 = this._viewpoint2D;
      if (this._get("padding")) {
        const i10 = t15.clone();
        gt(i10, t15, this._get("size"), this._get("padding"));
        const o12 = i10.targetGeometry;
        e16.center[0] = o12.x, e16.center[1] = o12.y, e16.rotation = i10.rotation, e16.scale = i10.scale, e16.spatialReference = o12.spatialReference;
      } else {
        const i10 = t15.targetGeometry;
        e16.center[0] = i10.x, e16.center[1] = i10.y, e16.rotation = t15.rotation, e16.scale = t15.scale, e16.spatialReference = i10.spatialReference;
      }
      this._update();
    }
  }
  clone() {
    return new m7({
      padding: this.padding.clone(),
      size: this.size.slice(),
      viewpoint: this.paddedViewState.viewpoint.clone(),
      pixelRatio: this.pixelRatio
    });
  }
};
e([y()], f5.prototype, "paddedViewState", void 0), e([y({
  type: g2
})], f5.prototype, "padding", null), e([y()], f5.prototype, "viewpoint", null), f5 = m7 = e([a("esri.views.2d.PaddedViewState")], f5);
var w3 = f5;

// ../../../node_modules/@arcgis/core/views/2d/pointToPoint/Camera.js
var a5 = class {
  constructor(e16) {
    this._view = e16, this.viewpoint = new m3({
      targetGeometry: new _(),
      scale: 0,
      rotation: 0
    });
  }
  get view() {
    return this._view;
  }
  get size() {
    const [t15, e16] = this._view.size;
    return Math.sqrt(t15 * t15 + e16 * e16);
  }
  get scale() {
    return this.viewpoint.scale;
  }
  get rotation() {
    return this.viewpoint.rotation;
  }
  get center() {
    return this.viewpoint.targetGeometry;
  }
  get scaleToResolutionFactor() {
    return at(this.center.spatialReference);
  }
  pixelsPerPanAtZoom(t15) {
    return 1 / (t15 * this.scaleToResolutionFactor);
  }
  zoomAtPixelsPerPan(t15) {
    return 1 / (t15 * this.scaleToResolutionFactor);
  }
  pixelsPerRotateAtZoom(t15) {
    return this.size / 2;
  }
  compareTo(t15, o12) {
    o12.pan = e2(this.center, t15.center);
    let r14 = Math.abs(t15.rotation - this.rotation);
    r14 = r14 >= 180 ? 360 - r14 : r14, o12.rotate = h2(r14), o12.sourceZoom = this.scale, o12.targetZoom = t15.scale;
  }
  interpolate(t15, e16, i10) {
    const {
      pan: r14,
      rotate: s16,
      zoom: n13,
      zoomOffset: a13
    } = i10, {
      center: c8
    } = this;
    c8.spatialReference = t15.center.spatialReference, c8.x = f3(t15.center.x, e16.center.x, r14), c8.y = f3(t15.center.y, e16.center.y, r14), this.viewpoint.scale = f3(t15.scale, e16.scale + a13, n13);
    let p9 = t15.rotation;
    const l8 = e16.rotation;
    Math.abs(l8 - p9) >= 180 && (p9 += 360 * (p9 < l8 ? 1 : -1)), this.viewpoint.rotation = f3(p9, l8, s16);
  }
  copyFrom(t15) {
    Z(this.viewpoint, t15.viewpoint), this._view = t15.view;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/AnimationManager.js
var v = 2e3;
var j2 = 64;
var y3 = class {
  constructor(t15) {
    this._view = t15, this._animation = new p4(() => new a5(this._view)), this._current = new a5(this._view);
  }
  get _source() {
    return this._animation.definition.source;
  }
  get _target() {
    return this._animation.definition.target;
  }
  get duration() {
    return this._animation.time;
  }
  get animation() {
    return this._animation;
  }
  update(t15, i10, e16 = {}) {
    Z(this._current.viewpoint, t15), Z(this._source.viewpoint, t15), Z(this._target.viewpoint, i10), this._animation.update(this._source, this._target, e16);
  }
  applyRatio(t15, i10) {
    this._animation.cameraAt(i10, this._current), Z(t15, this._current.viewpoint);
  }
};
var T = class extends S {
  constructor(t15) {
    super(t15), this._animation = null, this._destinationViewState = new w3(), this.updateFunction = null, this.easing = t4.ease, this.viewpoint = new m3({
      targetGeometry: new _(),
      scale: 0,
      rotation: 0
    }), this._updateTask = A({
      postRender: this._postRender.bind(this)
    }), this._updateTask.pause(), this._transition = new y3(t15.view);
  }
  destroy() {
    this._updateTask = l(this._updateTask);
  }
  get animation() {
    return this._animation;
  }
  set animation(t15) {
    this._animation = t15, this.view.animation = t15;
  }
  animate(t15, i10, e16) {
    this.stop();
    const n13 = this.viewpoint;
    Z(n13, i10);
    const o12 = ("string" == typeof e16?.easing ? r5(e16.easing) : e16?.easing) || this.easing, s16 = t15.target;
    this._transition.update(this.viewpoint, s16, {
      apex: {
        maximumDistance: Math.min(Math.min(i10.scale, s16.scale) * j2, this.view.constraints.effectiveMinScale),
        desiredSlope: 5e-8
      },
      duration: e16?.duration,
      maxDuration: "auto" === e16?.animationMode ? n2(1 / 0) : e16?.maxDuration ?? r7.maxDuration,
      speedFactor: e16?.speedFactor,
      easing: "function" == typeof o12 ? (t16) => o12(t16) : void 0
    }), "auto" === e16?.animationMode && (this._destinationViewState.copy(this.view.state), this._destinationViewState.viewpoint = s16, x(this._transition.animation, e16, this.view.state, this._destinationViewState) || this._transition.update(this.viewpoint, s16, {
      duration: n2(0)
    }));
    const r14 = () => {
      this.animation === t15 && this._updateTask && ("finished" === t15.state && (this._transition.applyRatio(this.viewpoint, 1), this.view.state && (this.view.state.viewpoint = this.viewpoint.clone())), this.animation = null, this.updateFunction = null);
    };
    return t15.when(r14, r14), this._startTime = performance.now(), this._updateTask.resume(), this.animation = t15, t15;
  }
  animateContinuous(t15, i10) {
    this.stop(), this.updateFunction = i10, this.viewpoint = t15;
    const e16 = new a2({
      target: t15.clone()
    }), n13 = () => {
      this.animation === e16 && this._updateTask && (this.animation = null, this.updateFunction = null);
    };
    return e16.when(n13, n13), this._startTime = performance.now(), this._updateTask.resume(), this.animation = e16, e16;
  }
  stop() {
    this.animation && (this.animation.stop(), this.animation = null, this.updateFunction = null);
  }
  _postRender(t15) {
    const i10 = this.animation;
    if (i10 && i10.state !== a2.State.STOPPED) {
      if (this.updateFunction) this.updateFunction(this.viewpoint, t15.deltaTime), this.animation?.update(this.viewpoint);
      else {
        const t16 = performance.now() - this._startTime, i11 = this._transition.duration, e16 = i11 > 0 ? t16 / i11 : 1, n13 = e16 >= 1;
        this._transition.applyRatio(this.viewpoint, e16), n13 && this.animation?.finish();
      }
      this.view.state && (this.view.state.viewpoint = this.viewpoint.clone());
    } else this._updateTask.pause();
  }
};
function x(t15, i10, e16, n13) {
  if (null != i10?.duration) return true;
  const {
    time: o12,
    isLinear: a13
  } = t15, r14 = i10?.speedFactor || 1, h7 = i10?.maxDuration ?? r7.maxDuration / r14;
  if (has("esri-goto-debug") && (console.log("speed factor:", r14), console.log("adjusted duration:		", o12), console.log("adjusted max duration:	", h7), console.log("is linear:", a13)), o12 > h7) return has("esri-goto-debug") && console.warn(`failed "auto" heuristic: animations must be shorter than ${h7 / 1e3}s`), false;
  if (a13) {
    const t16 = 1.5, i11 = n4(), a14 = c(...n13.toScreen(i11, ...e16.center)), p9 = c(...e16.toScreen(i11, ...n13.center)), u9 = null != p9 && p9.x > -(t16 - 0.5) * e16.size[0] && p9.x < (t16 + 0.5) * e16.size[0] && p9.y > -(t16 - 0.5) * e16.size[1] && p9.y < (t16 + 0.5) * e16.size[1], c8 = null != a14 && a14.x > -(t16 - 0.5) * n13.size[0] && a14.x < (t16 + 0.5) * n13.size[0] && a14.y > -(t16 - 0.5) * n13.size[1] && a14.y < (t16 + 0.5) * n13.size[1];
    if (has("esri-goto-debug") && (console.log(`dest is within ${t16} screens at start view:`, u9), console.log(`start is within ${t16} screens at dest view:`, c8)), o12 > v / r14 && !u9 && !c8) return has("esri-goto-debug") && console.warn(`failed "auto" heuristic: linear animations must be...
  - shorter than ${v / 1e3 / r14}s, or
  - shorter than ${h7 / 1e3}s and the destination is close enough to the starting screen, or
  - shorter than ${h7 / 1e3}s and the start point is close enough to the destination screen`), false;
  }
  return true;
}
e([y()], T.prototype, "easing", void 0), e([y()], T.prototype, "view", void 0), e([y()], T.prototype, "viewpoint", void 0), T = e([a("esri.views.2d.AnimationManager")], T);
var S3 = T;

// ../../../node_modules/@arcgis/core/views/2d/FrameTask.js
var s13 = class {
  constructor(t15) {
    this.view = t15, this._stationaryHandle = null, this._frameTaskHandle = null, this._updateParameters = null, this._updateRequested = false, this.stationary = true, this.animationInProgress = false, this.prepare = () => {
      this._updateParameters && (this._updateParameters.state = this.view.state, this._updateParameters.stationary = this.view.stationary, this._updateParameters.pixelRatio = window.devicePixelRatio, this._updateParameters.renderingOptions = this.view.renderingOptions, this._updateParameters.targetState.copy(this.view.state), this.view.animation && !("then" in this.view.animation.target) && (this._updateParameters.targetState.viewpoint = this.view.animation.target));
    }, this.update = () => {
      if (this._updateRequested = false, this.view?.destroyed) return;
      const {
        allLayerViews: t16,
        graphicsView: e16,
        labelManager: a13,
        state: {
          id: s16
        }
      } = this.view;
      t16.forEach(this._updateLayerView, this), null != a13 && (a13.lastUpdateId !== s16 && (a13.viewChange(), a13.lastUpdateId = s16), a13.updateRequested && a13.processUpdate(this._updateParameters)), null != e16 && (e16.lastUpdateId !== s16 && (e16.viewChange(), e16.lastUpdateId = s16), e16.updateRequested && e16.processUpdate(this._updateParameters)), this.view.graphicsTileStore.setViewState(this._updateParameters.state), this.animationInProgress || this._updateRequested || this._frameTaskHandle?.pause();
    };
  }
  destroy() {
    this.stop();
  }
  start() {
    if (this._frameTaskHandle) return;
    const s16 = this.view;
    this.stationary = s16.stationary, this._updateParameters = {
      state: s16.state,
      targetState: new w3(),
      pixelRatio: window.devicePixelRatio,
      stationary: this.stationary,
      renderingOptions: s16.renderingOptions
    }, this._stationaryHandle = d(() => s16.stationary, (t15) => {
      this.stationary = t15, this.requestFrame();
    }), this._frameTaskHandle = A(this), this.requestUpdate();
  }
  stop() {
    this._frameTaskHandle && (this._updateRequested = false, this._stationaryHandle?.remove(), this._frameTaskHandle.remove(), this._updateParameters = this._stationaryHandle = this._frameTaskHandle = null, this.stationary = true, this.animationInProgress = false);
  }
  requestUpdate() {
    this._updateRequested || (this._updateRequested = true, this.requestFrame());
  }
  requestFrame() {
    this._frameTaskHandle && this._frameTaskHandle.resume();
  }
  _updateLayerView(t15) {
    if (!t15.attached) return void this.requestUpdate();
    const e16 = this.view.state, a13 = t15.lastUpdateId;
    null != a13 && (this.stationary || t15.moving) || (t15.moving = true), a13 !== e16.id && t15.viewChange(), this.stationary && t15.moving && (t15.moving = false, t15.moveEnd()), t15.lastUpdateId = e16.id, t15.updateRequested && t15.processUpdate(this._updateParameters), "layerViews" in t15 && t15.layerViews?.forEach(this._updateLayerView, this);
  }
};

// ../../../node_modules/@arcgis/core/views/2d/GoToManager.js
var h6 = class extends S {
  constructor(t15) {
    super(t15), this._gotoTask = null;
  }
  destroy() {
    this._gotoTask = null;
  }
  goTo(t15, e16) {
    return __async(this, null, function* () {
      if (!t15) return void n.getLogger(this).error("#goTo()", "target cannot be null or undefined");
      const i10 = new a2();
      this.view.animation = i10, yield w(() => this.view.ready, e16);
      const s16 = __spreadProps(__spreadValues({}, e16), {
        animate: e16?.animate ?? !o6(),
        animationMode: e16?.animationMode ?? "auto"
      }), {
        extent: a13,
        spatialReference: c8,
        size: m10,
        viewpoint: h7,
        constraints: g3,
        padding: w4,
        allLayerViews: d8
      } = this.view, u9 = Y(t15, {
        extent: a13,
        spatialReference: c8,
        size: m10,
        viewpoint: h7,
        constraints: g3,
        padding: w4,
        allLayerViews: d8,
        pickClosestTarget: e16?.pickClosestTarget ?? true
      });
      return i10?.update(u9), this._gotoTask = {}, s16.animate ? this._gotoAnimated(u9, s16) : this._gotoImmediate(u9, s16);
    });
  }
  _gotoImmediate(t15, o12) {
    const e16 = this._gotoTask, r14 = this.view.animation, a13 = t15.then((t16) => {
      if (s2(o12), e16 !== this._gotoTask) throw new s("view:goto-interrupted", "Goto was interrupted");
      this.view.viewpoint = r14.target = t16, r14.finish();
    });
    return this._cancellableGoTo(e16, r14, a13, o12);
  }
  _gotoAnimated(t15, o12) {
    const e16 = this._gotoTask, r14 = this.view.animation;
    if (!r14) return Promise.resolve();
    const a13 = t15.then((t16) => {
      if (s2(o12), e16 !== this._gotoTask) throw new s("view:goto-interrupted", "Goto was interrupted");
      return r14.update(t16), this.view.animationManager.animate(r14, this.view.viewpoint, o12), r14.when().then(() => {
      }, () => {
      });
    });
    return this._cancellableGoTo(e16, r14, a13, o12);
  }
  _cancellableGoTo(t15, o12, e16, i10) {
    const r14 = () => t15 === this._gotoTask;
    return h(e16, i10).finally(() => {
      r14() && (o12.done || o12.stop());
    });
  }
};
e([y({
  constructOnly: true
})], h6.prototype, "view", void 0), h6 = e([a("esri.views.2d.GoToManager")], h6);

// ../../../node_modules/@arcgis/core/views/2d/layerViewModuleImportUtils.js
function r12() {
  return Promise.all([import("./webglDeps-T4RH63NP.js"), import("./mapViewDeps-APWLEI4H.js")]);
}
var a6 = () => r12().then(() => import("./TileLayerView2D-2RRGQTFY.js"));
var t11 = () => r12().then(() => import("./FeatureLayerView2D-OSURE7XX.js"));
var i7 = {
  "base-dynamic": () => r12().then(() => import("./BaseDynamicLayerView2D-VYDK2OIO.js")),
  "base-tile": a6,
  "bing-maps": a6,
  catalog: () => r12().then(() => import("./CatalogLayerView2D-QTP3TFZV.js")),
  "catalog-dynamic-group": () => r12().then(() => import("./CatalogDynamicGroupLayerView2D-K6UYZAN2.js")),
  "catalog-footprint": () => r12().then(() => import("./CatalogFootprintLayerView2D-FD3OUB3W.js")),
  csv: t11,
  "geo-rss": () => r12().then(() => import("./GeoRSSLayerView2D-TYGUO52Z.js")),
  feature: t11,
  geojson: t11,
  graphics: () => r12().then(() => import("./GraphicsLayerView2D-GXRPK2MV.js")),
  group: () => r12().then(() => import("./GroupLayerView2D-DGRO3RKI.js")),
  imagery: () => r12().then(() => import("./ImageryLayerView2D-C72K3RWP.js")),
  "imagery-tile": () => r12().then(() => import("./ImageryTileLayerView2D-SYHB2A3D.js")),
  kml: () => r12().then(() => import("./KMLLayerView2D-C3TZFFH5.js")),
  "knowledge-graph": () => r12().then(() => import("./KnowledgeGraphLayerView2D-QXKXBDSX.js")),
  "link-chart": () => r12().then(() => import("./KnowledgeGraphLayerView2D-QXKXBDSX.js")),
  "knowledge-graph-sublayer": t11,
  "map-image": () => r12().then(() => import("./MapImageLayerView2D-RPXFIQQM.js")),
  "map-notes": () => r12().then(() => import("./MapNotesLayerView2D-KDPI2IPA.js")),
  media: () => r12().then(() => import("./MediaLayerView2D-XT6WVDO6.js")),
  "ogc-feature": () => r12().then(() => import("./OGCFeatureLayerView2D-I7BZVYUZ.js")),
  "open-street-map": a6,
  "oriented-imagery": t11,
  route: () => r12().then(() => import("./RouteLayerView2D-2KZ5X5T2.js")),
  stream: () => r12().then(() => import("./StreamLayerView2D-UXKDX262.js")),
  "subtype-group": () => r12().then(() => import("./SubtypeGroupLayerView2D-IEULHMBW.js")),
  tile: a6,
  "vector-tile": () => r12().then(() => import("./VectorTileLayerView2D-H2V5DM4Y.js")),
  video: () => r12().then(() => import("./VideoLayerView2D-LOT4XJXF.js")),
  wcs: () => r12().then(() => import("./ImageryTileLayerView2D-SYHB2A3D.js")),
  "web-tile": a6,
  wfs: t11,
  wms: () => r12().then(() => import("./WMSLayerView2D-GSJYIV3M.js")),
  wmts: () => r12().then(() => import("./WMTSLayerView2D-TOXFWNLA.js")),
  "line-of-sight": null,
  "base-elevation": null,
  "building-scene": null,
  dimension: null,
  elevation: null,
  "integrated-mesh": null,
  "integrated-mesh-3dtiles": null,
  "point-cloud": null,
  voxel: null,
  scene: null,
  unknown: null,
  unsupported: null
};
function s14(r14) {
  const a13 = r14.declaredClass ? r14.declaredClass.slice(r14.declaredClass.lastIndexOf(".") + 1) : "Unknown", t15 = a13.replaceAll(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  return new s(`${t15}:view-not-supported`, `${a13} is not supported in 2D`);
}
var l4 = {
  hasLayerViewModule: (e16) => null != i7[e16.type],
  importLayerView: (e16) => {
    const r14 = i7[e16.type];
    if (null == r14) throw s14(e16);
    return r14(e16);
  }
};

// ../../../node_modules/@arcgis/core/geometry/support/near.js
function n9(n13, m10) {
  const {
    spatialReference: r14
  } = m10, i10 = [m10.x, m10.y];
  let s16 = Number.POSITIVE_INFINITY, x2 = 0, a13 = 0;
  const c8 = [0, 0], f7 = "extent" === n13.type ? [[[n13.xmin, n13.ymin], [n13.xmin, n13.ymax], [n13.xmax, n13.ymax], [n13.xmax, n13.ymin], [n13.xmin, n13.ymin]]] : n13.rings;
  for (const o12 of f7) for (let n14 = 0; n14 < o12.length - 1; n14++) {
    s6(c8, i10, o12, n14);
    const m11 = m(i10, c8);
    m11 < s16 && (s16 = m11, x2 = c8[0], a13 = c8[1]);
  }
  return {
    coordinate: new _({
      x: x2,
      y: a13,
      spatialReference: r14
    }),
    distance: s16
  };
}

// ../../../node_modules/@arcgis/core/views/2d/constraints/GeometryConstraint.js
var l5;
var p5 = l5 = class extends i(S) {
  constructor(e16) {
    super(e16), this.geometry = null, this.spatialReference = null;
  }
  get normalizedGeometry() {
    if (null == this.geometry || !this.spatialReference) return null;
    if (!this.spatialReference.equals(this.geometry.spatialReference)) try {
      return K(this.geometry, this.spatialReference);
    } catch (e16) {
      return n.getLogger(this).error("#constraints.geometry", "could not project the geometry to the view's spatial reference", {
        geometry: this.geometry,
        spatialReference: this.spatialReference,
        error: e16
      }), null;
    }
    return this.geometry;
  }
  constrain(e16, r14) {
    if (null == this.normalizedGeometry) return e16;
    const t15 = e16.targetGeometry;
    if ("extent" === this.normalizedGeometry.type ? t2(this.normalizedGeometry, t15) : f2(this.normalizedGeometry, t15)) return e16;
    const {
      coordinate: o12
    } = n9(this.normalizedGeometry, t15);
    return o12 ? (e16.targetGeometry = o12, e16) : e16;
  }
  clone() {
    return new l5({
      geometry: this.geometry?.clone(),
      spatialReference: this.spatialReference?.clone()
    });
  }
};
e([y({
  constructOnly: true
})], p5.prototype, "geometry", void 0), e([y({
  readOnly: true
})], p5.prototype, "normalizedGeometry", null), e([y({
  constructOnly: true
})], p5.prototype, "spatialReference", void 0), p5 = l5 = e([a("esri.views.2d.constraints.GeometryConstraint")], p5);

// ../../../node_modules/@arcgis/core/views/2d/constraints/RotationConstraint.js
var a7;
var n10 = a7 = class extends i(S) {
  constructor() {
    super(...arguments), this.enabled = true, this.rotationEnabled = true;
  }
  constrain(o12, t15) {
    return this.enabled && t15 ? (this.rotationEnabled || (o12.rotation = t15.rotation), o12) : o12;
  }
  clone() {
    return new a7({
      enabled: this.enabled,
      rotationEnabled: this.rotationEnabled
    });
  }
};
e([y()], n10.prototype, "enabled", void 0), e([y()], n10.prototype, "rotationEnabled", void 0), n10 = a7 = e([a("esri.views.2d.constraints.RotationConstraint")], n10);
var i8 = n10;

// ../../../node_modules/@arcgis/core/views/2d/constraints/ZoomConstraint.js
var a8;
var c3 = a8 = class extends i(S) {
  constructor(e16) {
    super(e16), this._lodByScale = {}, this._scales = [], this.effectiveLODs = null, this.effectiveMinZoom = -1, this.effectiveMaxZoom = -1, this.effectiveMinScale = 0, this.effectiveMaxScale = 0, this.lods = null, this.minZoom = -1, this.maxZoom = -1, this.minScale = 0, this.maxScale = 0, this.snapToZoom = true;
  }
  initialize() {
    let e16, {
      lods: t15,
      minScale: o12,
      maxScale: s16,
      minZoom: i10,
      maxZoom: a13
    } = this, c8 = -1, l8 = -1, r14 = false, n13 = false;
    if (0 !== o12 && 0 !== s16 && o12 < s16 && ([o12, s16] = [s16, o12]), !t15?.length) return this._set("effectiveMinScale", o12), void this._set("effectiveMaxScale", s16);
    t15 = t15.map((e17) => e17.clone()), t15.sort((e17, t16) => t16.scale - e17.scale), t15.forEach((e17, t16) => e17.level = t16);
    for (const f7 of t15) !r14 && o12 > 0 && o12 >= f7.scale && (c8 = f7.level, r14 = true), !n13 && s16 > 0 && s16 >= f7.scale && (l8 = e16 ? e16.level : -1, n13 = true), e16 = f7;
    -1 === i10 && (i10 = 0 === o12 ? 0 : c8), -1 === a13 && (a13 = 0 === s16 ? t15.length - 1 : l8), i10 = Math.max(i10, 0), i10 = Math.min(i10, t15.length - 1), a13 = Math.max(a13, 0), a13 = Math.min(a13, t15.length - 1), i10 > a13 && ([i10, a13] = [a13, i10]), o12 = t15[i10].scale, s16 = t15[a13].scale, t15.splice(0, i10), t15.splice(a13 - i10 + 1, t15.length), t15.forEach((e17, t16) => {
      this._lodByScale[e17.scale] = e17, this._scales[t16] = e17.scale;
    }), this._set("effectiveLODs", t15), this._set("effectiveMinZoom", i10), this._set("effectiveMaxZoom", a13), this._set("effectiveMinScale", o12), this._set("effectiveMaxScale", s16);
  }
  constrain(e16, t15) {
    if (t15 && e16.scale === t15.scale) return e16;
    const o12 = this.effectiveMinScale, s16 = this.effectiveMaxScale, i10 = e16.targetGeometry, a13 = t15 && t15.targetGeometry, c8 = 0 !== s16 && e16.scale < s16, l8 = 0 !== o12 && e16.scale > o12;
    if (c8 || l8) {
      const c9 = l8 ? o12 : s16;
      if (t15 && a13) {
        const o13 = (c9 - t15.scale) / (e16.scale - t15.scale);
        i10.x = a13.x + (i10.x - a13.x) * o13, i10.y = a13.y + (i10.y - a13.y) * o13;
      }
      e16.scale = c9;
    }
    return this.snapToZoom && this.effectiveLODs && (e16.scale = this._getClosestScale(e16.scale)), e16;
  }
  fit(e16) {
    if (!this.effectiveLODs || !this.snapToZoom) return this.constrain(e16, null);
    const t15 = this.scaleToZoom(e16.scale), o12 = Math.abs(t15 - Math.floor(t15));
    return e16.scale = this.zoomToScale(o12 > 0.99 ? Math.round(t15) : Math.floor(t15)), e16;
  }
  zoomToScale(e16) {
    if (!this.effectiveLODs) return 0;
    e16 -= this.effectiveMinZoom, e16 = Math.max(0, e16);
    const t15 = this._scales;
    if (e16 <= 0) return t15[0];
    if (e16 >= t15.length) return t15[t15.length - 1];
    const o12 = Math.floor(e16), s16 = Math.ceil(e16);
    return t15[o12] + (e16 - o12) * (t15[s16] - t15[o12]);
  }
  scaleToZoom(e16) {
    if (!this.effectiveLODs) return -1;
    const t15 = this._scales;
    let o12, s16;
    if (e16 >= t15[0]) return this.effectiveMinZoom;
    if (e16 <= t15[t15.length - 1]) return this.effectiveMaxZoom;
    for (let i10 = 0; i10 < t15.length - 1; i10++) {
      if (o12 = t15[i10], s16 = t15[i10 + 1], s16 === e16) {
        return i10 + this.effectiveMinZoom + 1;
      }
      if (o12 > e16 && s16 < e16) {
        return i10 + this.effectiveMinZoom + 1 - (e16 - s16) / (o12 - s16);
      }
    }
    return -1;
  }
  snapToClosestScale(e16) {
    if (!this.effectiveLODs) return e16;
    const t15 = this.scaleToZoom(e16);
    return this.zoomToScale(Math.round(t15));
  }
  snapToNextScale(e16, t15 = 0.5) {
    if (!this.effectiveLODs) return e16 * t15;
    const o12 = Math.round(this.scaleToZoom(e16));
    return this.zoomToScale(o12 + 1);
  }
  snapToPreviousScale(e16, t15 = 2) {
    if (!this.effectiveLODs) return e16 * t15;
    const o12 = Math.round(this.scaleToZoom(e16));
    return this.zoomToScale(o12 - 1);
  }
  clone() {
    return new a8({
      lods: this.lods,
      minZoom: this.minZoom,
      maxZoom: this.maxZoom,
      minScale: this.minScale,
      maxScale: this.maxScale
    });
  }
  _getClosestScale(e16) {
    return this._lodByScale[e16] || (e16 = this._scales.reduce((t15, o12) => Math.abs(o12 - e16) <= Math.abs(t15 - e16) ? o12 : t15, this._scales[0])), this._lodByScale[e16].scale;
  }
};
e([y({
  readOnly: true
})], c3.prototype, "effectiveLODs", void 0), e([y({
  readOnly: true
})], c3.prototype, "effectiveMinZoom", void 0), e([y({
  readOnly: true
})], c3.prototype, "effectiveMaxZoom", void 0), e([y({
  readOnly: true
})], c3.prototype, "effectiveMinScale", void 0), e([y({
  readOnly: true
})], c3.prototype, "effectiveMaxScale", void 0), e([y()], c3.prototype, "lods", void 0), e([y()], c3.prototype, "minZoom", void 0), e([y()], c3.prototype, "maxZoom", void 0), e([y()], c3.prototype, "minScale", void 0), e([y()], c3.prototype, "maxScale", void 0), e([y()], c3.prototype, "snapToZoom", void 0), c3 = a8 = e([a("esri.views.2d.constraints.ZoomConstraint")], c3);
var l6 = c3;

// ../../../node_modules/@arcgis/core/views/2d/MapViewConstraints.js
var p6 = {
  base: null,
  key: "type",
  typeMap: {
    extent: w2,
    polygon: j
  }
};
var y4 = class extends S {
  constructor(o12) {
    super(o12), this.lods = null, this.minScale = 0, this.maxScale = 0, this.minZoom = -1, this.maxZoom = -1, this.rotationEnabled = true, this.snapToZoom = true, this.customConstraints = new V();
  }
  destroy() {
    this.view = null;
  }
  get effectiveLODs() {
    return this._zoom.effectiveLODs;
  }
  get effectiveMinScale() {
    return this._zoom.effectiveMinScale;
  }
  get effectiveMaxScale() {
    return this._zoom.effectiveMaxScale;
  }
  get effectiveMinZoom() {
    return this._zoom.effectiveMinZoom;
  }
  get effectiveMaxZoom() {
    return this._zoom.effectiveMaxZoom;
  }
  set geometry(o12) {
    o12 ? this._set("geometry", o12) : this._set("geometry", null);
  }
  get version() {
    return `${this._zoom?.uid}/${this._rotation?.uid}/${this._geometry?.uid}`;
  }
  get _geometry() {
    const o12 = this._get("_geometry");
    return o12 && this.geometry === o12.geometry && this.view?.constraintsInfo.spatialReference === o12.spatialReference ? o12 : new p5({
      geometry: this.geometry,
      spatialReference: this.view?.constraintsInfo.spatialReference
    });
  }
  get _rotation() {
    return new i8({
      rotationEnabled: this.rotationEnabled
    });
  }
  get _zoom() {
    const o12 = this._get("_zoom"), t15 = this.lods || this.view?.constraintsInfo.lods, e16 = this.minZoom, r14 = this.maxZoom, s16 = this.minScale, i10 = this.maxScale, n13 = this.snapToZoom;
    return o12 && o12.lods === t15 && o12.minZoom === e16 && o12.maxZoom === r14 && o12.minScale === s16 && o12.maxScale === i10 && o12.snapToZoom === n13 ? o12 : new l6({
      lods: t15,
      minZoom: e16,
      maxZoom: r14,
      minScale: s16,
      maxScale: i10,
      snapToZoom: n13
    });
  }
  canZoomInTo(o12) {
    const t15 = this.effectiveMaxScale;
    return 0 === t15 || o12 >= t15;
  }
  canZoomOutTo(o12) {
    const t15 = this.effectiveMinScale;
    return 0 === t15 || o12 <= t15;
  }
  constrain(o12, t15) {
    return this._zoom.constrain(o12, t15), this._rotation.constrain(o12, t15), this._geometry.constrain(o12, t15), this.customConstraints.forEach((e16) => e16.constrain(o12, t15)), o12;
  }
  constrainByGeometry(o12) {
    return this._geometry.constrain(o12), this.customConstraints.forEach((t15) => t15.applyPanConstraint?.(o12)), o12;
  }
  fit(o12) {
    return this._zoom.fit(o12);
  }
  zoomToScale(o12) {
    return this._zoom.zoomToScale(o12);
  }
  scaleToZoom(o12) {
    return this._zoom.scaleToZoom(o12);
  }
  snapScale(o12) {
    return this._zoom.snapToClosestScale(o12);
  }
  snapToNextScale(o12) {
    return this._zoom.snapToNextScale(o12);
  }
  snapToPreviousScale(o12) {
    return this._zoom.snapToPreviousScale(o12);
  }
};
e([y({
  readOnly: true
})], y4.prototype, "effectiveLODs", null), e([y({
  readOnly: true
})], y4.prototype, "effectiveMinScale", null), e([y({
  readOnly: true
})], y4.prototype, "effectiveMaxScale", null), e([y({
  readOnly: true
})], y4.prototype, "effectiveMinZoom", null), e([y({
  readOnly: true
})], y4.prototype, "effectiveMaxZoom", null), e([y({
  types: p6,
  value: null
})], y4.prototype, "geometry", null), e([y({
  type: [p2]
})], y4.prototype, "lods", void 0), e([y()], y4.prototype, "minScale", void 0), e([y()], y4.prototype, "maxScale", void 0), e([y()], y4.prototype, "minZoom", void 0), e([y()], y4.prototype, "maxZoom", void 0), e([y()], y4.prototype, "rotationEnabled", void 0), e([y()], y4.prototype, "snapToZoom", void 0), e([y({
  type: V
})], y4.prototype, "customConstraints", void 0), e([y()], y4.prototype, "view", void 0), e([y({
  readOnly: true
})], y4.prototype, "version", null), e([y({
  type: p5,
  readOnly: true
})], y4.prototype, "_geometry", null), e([y({
  type: i8
})], y4.prototype, "_rotation", null), e([y({
  readOnly: true,
  type: l6
})], y4.prototype, "_zoom", null), y4 = e([a("esri.views.2d.MapViewConstraints")], y4);
var f6 = y4;

// ../../../node_modules/@arcgis/core/views/2d/ViewStateManager.js
var z2 = class extends S {
  constructor(t15) {
    super(t15), this.constraints = null, this.ready = false, this.resizeAlign = "center", this.addHandles([d(() => this.constraints?.version, (t16) => {
      this.constraints && t16 && this.ready && (this.state.viewpoint = this.constraints.fit(this.state.paddedViewState.viewpoint));
    }, C)]);
  }
  get center() {
    if (!this.ready) return this._get("center");
    const {
      center: t15,
      spatialReference: e16
    } = this.state.paddedViewState;
    return this.state.commitProperty("id"), new _({
      x: t15[0],
      y: t15[1],
      spatialReference: e16
    });
  }
  set center(t15) {
    if (null == t15) return;
    if (!this.ready) return void this._set("center", t15);
    let e16;
    try {
      e16 = this._project(t15, this.state.spatialReference);
    } catch (o12) {
      return void n.getLogger(this).error(new s("mapview:invalid-center", "could not project the value in the view's spatial reference", {
        input: t15,
        error: o12
      }));
    }
    const i10 = this.viewpoint;
    xt(i10, i10, e16), this.viewpoint = i10;
  }
  get extent() {
    return this.ready ? (this.state.commitProperty("id"), this.state.paddedViewState.extent.clone()) : this._get("extent");
  }
  set extent(t15) {
    if (null == t15) return;
    if (!t15.width || !t15.height) return void n.getLogger(this).error(new s("mapview:invalid-extent", "invalid extent size"));
    if (!this.ready) return this._set("extent", t15), this._set("center", void 0), this._set("viewpoint", void 0), this._set("scale", void 0), void this._set("zoom", void 0);
    let e16;
    try {
      e16 = this._project(t15, this.state.spatialReference);
    } catch (o12) {
      return void n.getLogger(this).error(new s("mapview:invalid-extent", "could not project the value in the view's spatial reference", {
        error: o12
      }));
    }
    const i10 = this.viewpoint;
    tt(i10, i10, e16, this.state.size, {
      constraints: this.constraints
    }), this.viewpoint = i10;
  }
  get padding() {
    return this.ready ? this.state.padding : this._get("padding");
  }
  set padding(t15) {
    this.ready ? (this.state.padding = t15, this._set("padding", this.state.padding)) : this._set("padding", t15);
  }
  get resolution() {
    return this.ready ? (this.state.commitProperty("id"), this.state.resolution) : 0;
  }
  get rotation() {
    return this.ready ? (this.state.commitProperty("id"), this.state.rotation) : this._get("rotation");
  }
  set rotation(t15) {
    if (isNaN(t15)) return;
    if (!this.ready) return void this._set("rotation", t15);
    const e16 = this.viewpoint;
    wt(e16, e16, t15), this.viewpoint = e16;
  }
  get scale() {
    return this.ready ? (this.state.commitProperty("id"), this.state.scale) : this._get("scale");
  }
  set scale(t15) {
    if (!t15 || isNaN(t15)) return;
    if (!this.ready) {
      this._set("scale", t15), this._set("zoom", void 0);
      const e17 = this._get("extent");
      return void (e17 && (this._set("extent", void 0), this._set("center", e17.center)));
    }
    const e16 = this.viewpoint;
    jt(e16, e16, t15), this.viewpoint = e16;
  }
  get viewpoint() {
    if (!this.ready) return this._get("viewpoint");
    return this.state.paddedViewState.viewpoint.clone();
  }
  set viewpoint(t15) {
    if (null == t15) return;
    if (!this.ready) return this._set("viewpoint", t15), this._set("extent", void 0), this._set("center", void 0), this._set("zoom", void 0), void this._set("scale", void 0);
    let i10, o12;
    try {
      i10 = this._project(t15, this.state.spatialReference), !t15.scale || isNaN(t15.scale) ? o12 = new s("mapview:invalid-viewpoint", `invalid scale value of ${t15.scale}`) : null == t15.targetGeometry && (o12 = new s("mapview:invalid-viewpoint", "geometry not defined"));
    } catch (a13) {
      o12 = new s("mapview:invalid-viewpoint", "could not project the value in the view's spatial reference", {
        error: a13
      });
    }
    if (o12) return void n.getLogger(this).error(o12);
    this._scaleBeforeChangingSpatialReference = null;
    const n13 = new m3({
      targetGeometry: new _(),
      scale: 0,
      rotation: 0
    });
    Z(n13, i10), this.constraints?.constrain(n13, this.state.paddedViewState.viewpoint), this.state.viewpoint = n13, this._set("viewpoint", n13);
  }
  get zoom() {
    return this.ready ? this.constraints?.scaleToZoom(this.scale) ?? -1 : this._get("zoom");
  }
  set zoom(t15) {
    if (!(t15 >= 0)) return;
    if (!this.ready) {
      this._set("zoom", t15), this._set("scale", void 0);
      const e17 = this._get("extent");
      return void (e17 && (this._set("extent", void 0), this._set("center", e17.center)));
    }
    const e16 = this.constraints?.zoomToScale(t15) ?? 0;
    if (!e16) return void this._set("zoom", -1);
    const i10 = this.viewpoint;
    jt(i10, i10, e16), this.viewpoint = i10, this._set("zoom", this.constraints?.scaleToZoom(this.scale) ?? -1);
  }
  getUserStartupOptions(t15) {
    if (!t15[0] && !t15[1]) return {
      center: void 0,
      rotation: void 0,
      scale: void 0
    };
    const {
      padding: e16,
      constraints: i10
    } = this, s16 = this._get("center"), r14 = this._get("extent"), o12 = this._get("scale"), n13 = this._get("rotation"), a13 = this._get("viewpoint"), c8 = this._get("zoom"), p9 = null != c8 && null != i10 && i10.zoomToScale(c8) || void 0;
    let h7, l8, d8;
    const v2 = a13?.rotation, m10 = a13?.targetGeometry;
    "extent" === m10?.type ? h7 = m10 : "point" === m10?.type && (l8 = m10, d8 = a13?.scale);
    const g3 = r14 ?? h7;
    return {
      center: s16 ?? l8 ?? g3?.center,
      rotation: n13 ?? v2,
      scale: (o12 ?? p9 ?? d8 ?? (g3 && H2(g3, [t15[0] - e16.left - e16.right, t15[1] - e16.top - e16.bottom]))) || void 0
    };
  }
  startup(t15, e16, i10, s16) {
    const o12 = t15.targetGeometry;
    try {
      this._project(t15, i10);
    } catch (n13) {
      n.getLogger(this).warn(new s3("mapview:startup-projection-error", "projection of initial viewpoint to the view's spatial reference, defaulting to the initial viewpoint.", {
        center: o12.toJSON(),
        spatialReference: i10,
        error: n13
      })), t15.targetGeometry = s16 || new _({
        x: 0,
        y: 0,
        spatialReference: i10
      });
    }
    this.constraints?.fit(t15), this._set("state", new w3({
      padding: this.padding,
      size: e16,
      viewpoint: t15
    })), this._set("ready", true);
  }
  teardown() {
    this._set("ready", false);
    const {
      center: [t15, e16],
      spatialReference: i10,
      rotation: s16,
      scale: r14
    } = this.state.paddedViewState, o12 = new _({
      x: t15,
      y: e16,
      spatialReference: i10
    });
    this._set("viewpoint", null), this._set("extent", null), this._set("center", o12), this._set("zoom", -1), this._set("rotation", s16), this._set("scale", r14), this._set("state", null);
  }
  changeSpatialReference(t15) {
    const i10 = this.state.paddedViewState.clone();
    if (null == this._scaleBeforeChangingSpatialReference) this._scaleBeforeChangingSpatialReference = i10.scale;
    else {
      const t16 = i10.viewpoint.clone();
      t16.scale = this._scaleBeforeChangingSpatialReference, i10.viewpoint = t16;
    }
    const s16 = i10.clone(), [o12, n13] = i10.center;
    let a13 = null;
    try {
      a13 = this._project(new _({
        x: o12,
        y: n13,
        spatialReference: i10.spatialReference
      }), t15);
    } catch (h7) {
      r2() || n.getLogger(this).warn(new s3("mapview:spatial-reference-change", "could not project the view's center to the new spatial reference", {
        center: a13?.toJSON(),
        spatialReference: t15,
        error: h7
      }));
    }
    a13 || (a13 = new _({
      x: 0,
      y: 0,
      spatialReference: t15
    }));
    const p9 = xt(new m3({
      targetGeometry: new _(),
      scale: 0,
      rotation: 0
    }), i10.viewpoint, a13);
    s16.viewpoint = p9;
    try {
      const e16 = 20, r14 = [i10.size[0] / 2, i10.size[1] / 2], o13 = [r14[0] + e16, r14[1]], n14 = i10.toMap([0, 0], o13), {
        x: a14,
        y: c8
      } = this._project(new _({
        x: n14[0],
        y: n14[1],
        spatialReference: i10.spatialReference
      }), t15);
      n14[0] = a14, n14[1] = c8, s16.toScreen(n14, n14);
      const h7 = pt(r14, n14, o13), l8 = Math.hypot(n14[0] - r14[0], n14[1] - r14[1]) / e16;
      !Number.isFinite(l8) || Math.abs(l8) > 4 ? (p9.rotation = 0, p9.targetGeometry = new _({
        x: 0,
        y: 0,
        spatialReference: t15
      })) : (p9.scale *= l8, p9.scale > has("mapview-srswitch-adjust-rotation-scale-threshold") ? p9.rotation = 0 : p9.rotation += Number.isFinite(h7) ? h7 : 0);
    } catch {
    }
    this._get("constraints")?.constrain(p9, void 0), this._get("state").viewpoint = p9;
  }
  resize(t15, e16) {
    if (!this.ready) return;
    const i10 = this.state;
    let s16 = this.state.paddedViewState.viewpoint;
    const r14 = this.state.paddedViewState.size.concat();
    i10.size = [t15, e16], ht(s16, s16, r14, this.state.paddedViewState.size, this.resizeAlign), s16 = this.constraints?.constrain(s16, void 0) ?? s16, this.state.viewpoint = s16;
  }
  toMap(t15) {
    if (!this.ready) return null;
    const e16 = [0, 0], [i10, s16] = this.state.toMap(e16, [t15.x, t15.y]), r14 = this.state.spatialReference;
    return new _({
      x: i10,
      y: s16,
      spatialReference: r14
    });
  }
  toScreen(t15, e16) {
    if (!this.ready) return null;
    const i10 = this._project(t15, this.state.spatialReference), s16 = [i10.x, i10.y];
    return false === e16?.pickClosestTarget || this.state.paddedViewState.wrapMapCoordinate(s16, s16), this.state.toScreen(s16, s16), c(s16[0], s16[1]);
  }
  _project(t15, e16) {
    const i10 = t15?.targetGeometry || t15;
    if (!e16) return t15;
    if (!i10) return null;
    if (e16.imageCoordinateSystem || i10.spatialReference?.imageCoordinateSystem) return t15;
    if (G(e16, i10.spatialReference)) return t15;
    const r14 = K(i10, e16);
    if (!r14) throw new s("mapview:projection-not-possible", "projecting input geometry to target spatial reference returned a null value", {
      geometry: i10,
      spatialReference: e16
    });
    return V2(t15) ? (t15.targetGeometry = r14, t15) : r14;
  }
};
function V2(t15) {
  return "esri.Viewpoint" === t15?.declaredClass;
}
e([y({
  type: _
})], z2.prototype, "center", null), e([y()], z2.prototype, "constraints", void 0), e([y({
  type: w2
})], z2.prototype, "extent", null), e([y({
  value: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  cast: (t15) => __spreadValues({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, t15)
})], z2.prototype, "padding", null), e([y()], z2.prototype, "ready", void 0), e([y()], z2.prototype, "resizeAlign", void 0), e([y({
  readOnly: true
})], z2.prototype, "resolution", null), e([y({
  type: Number
})], z2.prototype, "rotation", null), e([y({
  type: Number
})], z2.prototype, "scale", null), e([y({
  readOnly: true
})], z2.prototype, "state", void 0), e([y({
  type: m3
})], z2.prototype, "viewpoint", null), e([y()], z2.prototype, "zoom", null), z2 = e([a("esri.views.2d.ViewStateManager")], z2);

// ../../../node_modules/@arcgis/core/views/2d/input/handlers/DoubleClickZoom.js
var a9 = class extends t5 {
  constructor(t15, i10) {
    super(true), this._view = t15, this.registerIncoming("double-click", i10, (t16) => this._handleDoubleClick(t16, i10));
  }
  _handleDoubleClick(t15, a13) {
    t6(t15.data, "primary") && (t15.stopPropagation(), a13 ? this._view.mapViewNavigation.zoomOut([t15.data.x, t15.data.y]) : this._view.mapViewNavigation.zoomIn([t15.data.x, t15.data.y]));
  }
};

// ../../../node_modules/@arcgis/core/views/2d/input/handlers/DoubleTapDragZoom.js
var e10 = class extends t5 {
  constructor(t15, e16, a13) {
    super(true), this.view = t15, this.pointerType = e16, this.registerIncoming("double-tap-drag", a13, (t16) => this._handleDoubleTapDrag(t16));
  }
  _handleDoubleTapDrag(t15) {
    const {
      data: e16
    } = t15, {
      pointerType: a13
    } = e16;
    if (a13 !== this.pointerType) return;
    t15.stopPropagation();
    const {
      action: s16,
      delta: i10
    } = e16, {
      view: r14
    } = this, {
      mapViewNavigation: n13
    } = r14;
    switch (s16) {
      case "begin": {
        const {
          scale: t16
        } = r14;
        this._startScale = t16, this._currentScale = t16, this._previousDelta = i10, n13.begin();
        break;
      }
      case "update": {
        if (this._previousDelta.y === i10.y) return;
        this._previousDelta = i10;
        const t16 = 1.015 ** i10.y, e17 = this._startScale * t16, a14 = e17 / this._currentScale;
        n13.setViewpointImmediate(a14), this._currentScale = e17;
        break;
      }
      case "end": {
        const {
          constraints: t16
        } = r14, {
          effectiveLODs: e17,
          snapToZoom: a14
        } = t16;
        if (!a14 || !e17) return void n13.end();
        const s17 = t16.snapScale(this._currentScale), o12 = (i10.y > 0 ? Math.max(s17, t16.snapToPreviousScale(this._startScale)) : Math.min(s17, t16.snapToNextScale(this._startScale))) / this._currentScale;
        n13.zoom(o12).then(() => {
          n13.end();
        });
        break;
      }
    }
  }
};

// ../../../node_modules/@arcgis/core/views/2d/input/handlers/DragPan.js
var n11 = class extends t5 {
  constructor(t15, i10, a13) {
    super(true), this.view = t15, this.pointerAction = i10, this.registerIncoming("drag", a13, (t16) => this._handleDrag(t16)), this.registerIncoming("pointer-down", () => this.stopMomentumNavigation());
  }
  onInstall(i10) {
    super.onInstall(i10), this._dragEventSeparator = new t7({
      start: (t15, i11) => {
        this.view.mapViewNavigation.pan.begin(this.view, i11.data), i11.stopPropagation();
      },
      update: (t15, i11) => {
        this.view.mapViewNavigation.pan.update(this.view, i11.data), i11.stopPropagation();
      },
      end: (t15, i11) => {
        this.view.mapViewNavigation.pan.end(this.view, i11.data), i11.stopPropagation();
      },
      condition: (t15, i11) => 1 === t15 && t6(i11.data, this.pointerAction)
    });
  }
  _handleDrag(t15) {
    const i10 = this.view.mapViewNavigation;
    i10.pinch.zoomMomentum || i10.pinch.rotateMomentum ? this.stopMomentumNavigation() : this._dragEventSeparator.handle(t15);
  }
  stopMomentumNavigation() {
    this.view.mapViewNavigation.pan.stopMomentumNavigation();
  }
};

// ../../../node_modules/@arcgis/core/views/2d/input/handlers/DragRotate.js
var o8 = class extends t5 {
  constructor(a13, o12, r14) {
    super(true), this._view = a13, this.pointerAction = o12;
    const e16 = this._view.mapViewNavigation;
    this._dragEventSeparator = new t7({
      start: (t15, a14) => {
        e16.rotate.begin(this._view, a14.data), a14.stopPropagation();
      },
      update: (t15, a14) => {
        e16.rotate.update(this._view, a14.data), a14.stopPropagation();
      },
      end: (t15, a14) => {
        e16.rotate.end(), a14.stopPropagation();
      },
      condition: (t15, a14) => 1 === t15 && t6(a14.data, this.pointerAction)
    }), this.registerIncoming("drag", r14, (t15) => this._dragEventSeparator.handle(t15));
  }
};

// ../../../node_modules/@arcgis/core/views/2d/input/handlers/GamepadNavigation.js
var d4 = class extends t5 {
  constructor(i10) {
    super(true), this._view = i10, this._frameTask = null, this._watchHandles = new r(), this._currentDevice = null, this._transformation = {
      translation: [0, 0, 0],
      heading: 0,
      tilt: 0,
      zoom: 0
    }, this._handle = this.registerIncoming("gamepad", (t15) => this._handleGamePadEvent(t15)), this._handle.pause();
  }
  onInstall(t15) {
    super.onInstall(t15), this._watchHandles.add([d(() => this._view.navigation.gamepad?.enabled, (t16) => {
      t16 ? (this._handle.resume(), this._frameTask || (this._frameTask = A({
        update: (t17) => this._frameUpdate(t17.deltaTime)
      }))) : (this._handle.pause(), this._frameTask && (this._frameTask.remove(), this._frameTask = null));
    }, P)]);
  }
  onUninstall() {
    this._watchHandles.removeAll(), this._frameTask && (this._frameTask.remove(), this._frameTask = null), super.onUninstall();
  }
  _handleGamePadEvent(t15) {
    const i10 = this._view.navigation.gamepad.device;
    i10 && t15.data.device !== i10 || this._currentDevice && this._currentDevice !== t15.data.device || ("end" === t15.data.action ? (this._currentDevice = null, a4(this._transformation)) : (this._currentDevice = t15.data.device, i5(t15.data, this._view.navigation.gamepad, this._transformation)));
  }
  _frameUpdate(t15) {
    const i10 = this._transformation;
    if (s11(i10)) return;
    const e16 = this._view.viewpoint.clone(), a13 = this._view.navigation.gamepad.velocityFactor, r14 = _4 * a13 * t15;
    kt(e16, e16, [i10.translation[0] * r14, -i10.translation[1] * r14]);
    const o12 = 1 + i10.translation[2] * c4 * t15, h7 = this._view.constraints.rotationEnabled ? -i10.heading * m8 * t15 : 0, d8 = this._view.size, v2 = [d8[0] / 2, d8[1]];
    Gt(e16, e16, o12, h7, v2, d8);
    const p9 = this._view.constraints.constrain(e16, this._view.viewpoint);
    this._view.viewpoint = p9;
  }
};
var m8 = 0.06;
var _4 = 0.7;
var c4 = 6e-4;

// ../../../node_modules/@arcgis/core/views/2d/input/handlers/KeyPan.js
var e11 = class extends t5 {
  constructor(i10, e16, s16) {
    super(true), this.view = i10, this.keys = e16, this._isSticky = false, this._pressedKeys = /* @__PURE__ */ new Set(), this._timeout = void 0, this._currentDirection = void 0, this._stickyKeyDuration = 200, this._handleKey = (i11) => {
      const t15 = this._keyMap[i11.data.key];
      if (i11.modifiers.has("Meta") || i11.modifiers.has("Control")) return void this._stopMovement();
      if (null == t15) return;
      i11.stopPropagation(), i11.preventDefault();
      const e17 = "key-down" === i11.type;
      if (this._pressedKeys[e17 ? "add" : "delete"](t15), e17) {
        if (this._direction === t15) return;
        this._direction = t15, this._isSticky = false, this._setTimeout(() => {
          this._isSticky && this._handlePopKey();
        });
      } else {
        const i12 = void 0 === this._timeout, t16 = this._pressedKeys.size > 0;
        i12 || t16 ? this._handlePopKey() : this._isSticky = true;
      }
    }, this._handlePopKey = () => {
      this._direction = Array.from(this._pressedKeys).pop(), null == this._direction && this._stopMovement();
    }, this._stopMovement = () => {
      this._isSticky = false, this._direction = void 0, this._pressedKeys.clear(), this._setTimeout(void 0);
    }, this._keyMap = {
      [e16.left]: "left",
      [e16.right]: "right",
      [e16.up]: "up",
      [e16.down]: "down"
    }, this.registerIncoming("key-down", s16, this._handleKey), this.registerIncoming("key-up", s16, this._handleKey), this.registerIncoming("blur", s16, this._stopMovement), this._visibilityHandle = i6((i11) => i11 ? null : this._stopMovement());
  }
  onUninstall() {
    this._stopMovement(), this._visibilityHandle?.remove();
  }
  get _direction() {
    return this._currentDirection;
  }
  set _direction(i10) {
    const t15 = null != this._currentDirection;
    if (null != i10) {
      if (t15 || this.view.mapViewNavigation.begin(), this._currentDirection !== i10) switch (i10) {
        case "left":
          this.view.mapViewNavigation.continuousPanLeft();
          break;
        case "right":
          this.view.mapViewNavigation.continuousPanRight();
          break;
        case "up":
          this.view.mapViewNavigation.continuousPanUp();
          break;
        case "down":
          this.view.mapViewNavigation.continuousPanDown();
      }
    } else t15 && this.view.mapViewNavigation.stop();
    this._currentDirection = i10;
  }
  _setTimeout(i10) {
    clearTimeout(this._timeout), this._timeout = void 0 === i10 ? void 0 : setTimeout(() => {
      this._timeout = void 0, i10();
    }, this._stickyKeyDuration);
  }
};

// ../../../node_modules/@arcgis/core/views/2d/input/handlers/KeyRotate.js
var t12 = class extends t5 {
  constructor(e16, t15, s16) {
    super(true), this.view = e16, this.keys = t15, this._pressed = false, this._keyToDirection = {
      [t15.clockwiseOption1]: "clockwise",
      [t15.clockwiseOption2]: "clockwise",
      [t15.counterClockwiseOption1]: "counterClockwise",
      [t15.counterClockwiseOption2]: "counterClockwise",
      [t15.resetOption1]: "reset",
      [t15.resetOption2]: "reset"
    }, this.registerIncoming("key-down", s16, (e17) => this._handleKeyDown(e17)), this.registerIncoming("key-up", s16, (e17) => this._handleKeyUp(e17)), this.registerIncoming("blur", s16, () => this._handleStop()), this._visibilityHandle = i6((e17) => e17 ? null : this._handleStop());
  }
  onUninstall() {
    this._visibilityHandle?.remove(), this._handleStop();
  }
  _handleKeyDown(e16) {
    e16.data.repeat || this._handleKey(e16, true);
  }
  _handleKeyUp(e16) {
    this._handleKey(e16, false);
  }
  _handleStop() {
    this._pressed && (this._pressed = false, this.view.mapViewNavigation.stop());
  }
  _handleKey(e16, i10) {
    const t15 = e16.modifiers;
    if (t15.size > 0 && !t15.has("Shift") || !this.view.constraints.rotationEnabled) return;
    const s16 = this._keyToDirection[e16.data.key];
    if (this._pressed = null != s16, this._pressed) {
      if (e16.preventDefault(), i10) switch (this.view.mapViewNavigation.begin(), s16) {
        case "clockwise":
          this.view.mapViewNavigation.continuousRotateClockwise();
          break;
        case "counterClockwise":
          this.view.mapViewNavigation.continuousRotateCounterclockwise();
          break;
        case "reset":
          this.view.mapViewNavigation.resetRotation();
      }
      else this._pressed = false, this.view.mapViewNavigation.stop();
      e16.stopPropagation();
    }
  }
};

// ../../../node_modules/@arcgis/core/views/2d/input/handlers/KeyZoom.js
var t13;
!function(o12) {
  o12[o12.IN = 0] = "IN", o12[o12.OUT = 1] = "OUT";
}(t13 || (t13 = {}));
var e12 = class extends t5 {
  constructor(o12, e16, i10) {
    super(true), this.view = o12, this.keys = e16, this._keysToZoomAction = {}, this.registerIncoming("key-down", i10, (o13) => this._handleKeyDown(o13)), e16.zoomIn.forEach((o13) => this._keysToZoomAction[o13] = t13.IN), e16.zoomOut.forEach((o13) => this._keysToZoomAction[o13] = t13.OUT);
  }
  _handleKeyDown(o12) {
    this._handleKey(o12);
  }
  _handleKey(o12) {
    const e16 = o12.modifiers;
    if (e16.size > 0 && !e16.has("Shift")) return;
    const {
      key: i10
    } = o12.data;
    if (!(i10 in this._keysToZoomAction)) return;
    const n13 = this._keysToZoomAction[i10], {
      mapViewNavigation: s16
    } = this.view;
    let r14 = null;
    switch (n13) {
      case t13.IN:
        r14 = s16.zoomIn();
        break;
      case t13.OUT:
        r14 = s16.zoomOut();
        break;
      default:
        return;
    }
    s16.begin(), r14.then(() => s16.end()), o12.stopPropagation();
  }
};

// ../../../node_modules/@arcgis/core/views/2d/input/handlers/MouseWheelZoom.js
var t14 = 0.6;
var o9 = class extends t5 {
  constructor(e16, t15) {
    super(true), this._view = e16, this._canZoom = true, this.registerIncoming("mouse-wheel", t15, (e17) => this._handleMouseWheel(e17));
  }
  _handleMouseWheel(e16) {
    if (!this._view.navigation.mouseWheelZoomEnabled) return;
    if (e16.preventDefault(), e16.stopPropagation(), !this._canZoom) return;
    const o12 = this._view.mapViewNavigation, {
      x: n13,
      y: i10,
      deltaY: s16
    } = e16.data, a13 = 1 / t14 ** (1 / 60 * s16), h7 = o12.zoom(a13, [n13, i10]);
    h7 && (this._canZoom = false, h7.catch(() => {
    }).then(() => {
      this._canZoom = true, o12.end();
    }));
  }
};

// ../../../node_modules/@arcgis/core/views/2d/input/handlers/PinchAction.js
var a10 = class extends t5 {
  constructor(i10) {
    super(true), this.view = i10, this.registerIncoming("drag", (t15) => this._handleDrag(t15)), this.registerIncoming("pointer-down", () => this._stopMomentumNavigation());
    const a13 = this.view.mapViewNavigation;
    this._dragEventSeparator = new t7({
      start: (t15, i11) => {
        a13.pinch.begin(this.view, i11.data), i11.stopPropagation();
      },
      update: (t15, i11) => {
        a13.pinch.update(this.view, i11.data), i11.stopPropagation();
      },
      end: (t15, i11) => {
        a13.pinch.end(this.view), i11.stopPropagation();
      },
      condition: (t15) => t15 >= 2
    });
  }
  _handleDrag(t15) {
    this._dragEventSeparator.handle(t15);
  }
  _stopMomentumNavigation() {
    this.view.mapViewNavigation.pinch.stopMomentumNavigation();
  }
};

// ../../../node_modules/@arcgis/core/views/input/recognizers/DoubleTapDrag.js
var p7 = class extends t5 {
  constructor(e16 = t8.maximumDoubleClickDelay, i10 = t8.maximumDoubleClickDistance, r14 = t8.maximumDoubleTouchDelay, s16 = t8.maximumDoubleTouchDistance, u9 = o) {
    super(false), this._maximumDoubleClickDelay = e16, this._maximumDoubleClickDistance = i10, this._maximumDoubleTouchDelay = r14, this._maximumDoubleTouchDistance = s16, this._clock = u9, this._doubleTapDragReady = false, this._doubleTapDragActive = false, this._dragStartCenter = c(0, 0), this._pointerState = /* @__PURE__ */ new Map(), this._doubleTapDrag = this.registerOutgoing("double-tap-drag"), this._dragEventSeparator = new t7({
      start: (t15, e17) => this._dragStart(t15, e17),
      update: (t15, e17) => this._dragUpdate(e17),
      end: (t15, e17) => this._dragEnd(e17)
    }), this.registerIncoming("drag", (t15) => this._dragEventSeparator.handle(t15)), this.registerIncoming("pointer-down", (t15) => this._handlePointerDown(t15)), this.registerIncoming("pointer-up", () => this._handlePointerUp());
  }
  onUninstall() {
    this._pointerState.forEach((t15) => {
      t15.doubleTapTimeout = l(t15.doubleTapTimeout);
    });
  }
  get hasPendingInputs() {
    return n3(this._pointerState, (t15) => null != t15.doubleTapTimeout);
  }
  _clearPointerDown(t15) {
    const e16 = this._pointerState.get(t15);
    e16 && (e16.doubleTapTimeout = l(e16.doubleTapTimeout), this._pointerState.delete(t15), this.refreshHasPendingInputs());
  }
  _dragStart(t15, e16) {
    if (!this._doubleTapDragReady || 1 !== t15) return;
    this._doubleTapDragReady = false, this._doubleTapDragActive = true;
    const {
      data: i10,
      modifiers: a13
    } = e16, {
      center: r14
    } = i10;
    this._dragStartCenter = r14;
    const n13 = d5("begin", c(0, 0), i10);
    this._doubleTapDrag.emit(n13, void 0, a13), e16.stopPropagation();
  }
  _dragUpdate(t15) {
    if (!this._doubleTapDragActive) return;
    const {
      data: e16,
      modifiers: i10
    } = t15, {
      center: a13
    } = e16, r14 = d5("update", c(a13.x - this._dragStartCenter.x, a13.y - this._dragStartCenter.y), e16);
    this._doubleTapDrag.emit(r14, void 0, i10), t15.stopPropagation();
  }
  _dragEnd(t15) {
    if (!this._doubleTapDragActive) return;
    const {
      data: e16,
      modifiers: i10
    } = t15, {
      center: a13
    } = e16, r14 = d5("end", c(a13.x - this._dragStartCenter.x, a13.y - this._dragStartCenter.y), e16);
    this._doubleTapDrag.emit(r14, void 0, i10), this._doubleTapDragActive = false, t15.stopPropagation();
  }
  _handlePointerDown(t15) {
    const {
      data: e16
    } = t15, i10 = u5(e16), o12 = this._pointerState.get(i10), {
      pointerType: a13
    } = e16.native;
    if (o12) {
      const r14 = "touch" === a13 ? this._maximumDoubleTouchDistance : this._maximumDoubleClickDistance;
      this._clearPointerDown(i10), n7(o12.event.data, e16) > r14 ? this._storePointerDown(t15) : this._doubleTapDragReady = true;
    } else this._storePointerDown(t15);
  }
  _handlePointerUp() {
    this._doubleTapDragReady = false;
  }
  _storePointerDown(t15) {
    const {
      data: e16
    } = t15, {
      pointerType: i10
    } = e16.native, o12 = u5(e16), a13 = "touch" === i10 ? this._maximumDoubleTouchDelay : this._maximumDoubleClickDelay, r14 = this._clock.setTimeout(() => this._clearPointerDown(o12), a13);
    this._pointerState.set(o12, {
      event: t15,
      doubleTapTimeout: r14
    }), this.refreshHasPendingInputs();
  }
};
function d5(t15, e16, i10) {
  const {
    button: o12,
    buttons: a13,
    pointer: r14,
    pointers: n13,
    pointerType: s16,
    timestamp: u9
  } = i10;
  return {
    action: t15,
    delta: e16,
    button: o12,
    buttons: a13,
    pointer: r14,
    pointers: n13,
    pointerType: s16,
    timestamp: u9
  };
}

// ../../../node_modules/@arcgis/core/views/2d/input/MapViewInputManager.js
var T2 = {
  counter: "Control",
  pan: {
    left: "ArrowLeft",
    right: "ArrowRight",
    up: "ArrowUp",
    down: "ArrowDown"
  },
  zoom: {
    zoomIn: ["=", "+"],
    zoomOut: ["-", "_"]
  },
  rotate: {
    clockwiseOption1: "a",
    clockwiseOption2: "A",
    counterClockwiseOption1: "d",
    counterClockwiseOption2: "D",
    resetOption1: "n",
    resetOption2: "N"
  }
};
var z3 = class extends S {
  initialize() {
    const e16 = () => this.view?.ready;
    this.addHandles([p(() => !e16(), () => this._disconnect()), p(e16, () => this._connect())]);
  }
  destroy() {
    this._disconnect();
  }
  get latestPointerType() {
    return this._inputManager?.latestPointerType;
  }
  get latestPointerLocation() {
    return this._inputManager?.latestPointerLocation;
  }
  get multiTouchActive() {
    return this._inputManager?.multiTouchActive ?? false;
  }
  isModifierKeyDown(e16) {
    return this._inputManager?.isModifierKeyDown(e16) ?? false;
  }
  _disconnect() {
    this.view.viewEvents.disconnect(), this._inputManager = u(this._inputManager);
  }
  _connect() {
    const e16 = this.view.surface, t15 = new l3(e16, this.view.input), o12 = [new m5(), new r9(), new r10(), new s12(this.view.navigation), new p7()], i10 = new d3({
      eventSource: t15,
      recognizers: o12
    });
    i10.installHandlers("prevent-context-menu", [new e9()], _2.INTERNAL), i10.installHandlers("navigation", [new a10(this.view), new d4(this.view), new o9(this.view), new a9(this.view), new a9(this.view, [T2.counter]), new n11(this.view, "primary"), new e11(this.view, T2.pan), new e12(this.view, T2.zoom), new t12(this.view, T2.rotate), new o8(this.view, "secondary"), new e10(this.view, "touch")], _2.INTERNAL), this.view.viewEvents.connect(i10), this._source = t15, this._inputManager = i10, d(() => this.view?.navigation?.browserTouchPanEnabled, (e17) => {
      this._source && (this._source.browserTouchPanningEnabled = !e17);
    }, P);
  }
  get test() {
  }
};
e([y()], z3.prototype, "view", void 0), e([y()], z3.prototype, "latestPointerType", null), e([y()], z3.prototype, "latestPointerLocation", null), e([y()], z3.prototype, "multiTouchActive", null), z3 = e([a("esri.views.2d.input.MapViewInputManager")], z3);
var k = z3;

// ../../../node_modules/@arcgis/core/views/2d/layers/features/support/TileStore.js
var d6 = {
  added: [],
  removed: []
};
var a11 = /* @__PURE__ */ new Set();
var c5 = new e4(0, 0, 0, 0);
function m9(e16, t15) {
  const s16 = s5(t15);
  if (!s16) return null;
  const [i10, r14] = s16.valid;
  return e16[2] > r14 ? [u3([e16[0], e16[1], r14, e16[3]]), u3([i10, e16[1], i10 + e16[2] - r14, e16[3]])] : e16[0] < i10 ? [u3([i10, e16[1], e16[2], e16[3]]), u3([r14 - (i10 - e16[0]), e16[1], r14, e16[3]])] : null;
}
var u7 = class extends o2 {
  constructor(e16) {
    super(), this._tiles = /* @__PURE__ */ new Map(), this._index = i4(9, has("esri-csp-restrictions") ? (e17) => ({
      minX: e17.bounds[0],
      minY: e17.bounds[1],
      maxX: e17.bounds[2],
      maxY: e17.bounds[3]
    }) : [".bounds[0]", ".bounds[1]", ".bounds[2]", ".bounds[3]"]), this.tiles = [], this.tileScheme = e16;
  }
  destroy() {
    this.clear();
  }
  clear() {
    this.tiles.length = 0, this._tiles.clear(), this._index.clear();
  }
  has(e16) {
    return this._tiles.has(e16);
  }
  get(e16) {
    return this._tiles.get(e16);
  }
  getIntersectingTiles(e16) {
    if (!e16 || 0 === M(e16) || 0 === s7(e16)) return [];
    const t15 = m9(e16, this.tileScheme.spatialReference);
    return null != t15 ? [.../* @__PURE__ */ new Set([...this.boundsIntersections(t15[0]), ...this.boundsIntersections(t15[1])])] : this.boundsIntersections(e16);
  }
  boundsIntersections(e16) {
    return this._index.search({
      minX: e16[0],
      minY: e16[1],
      maxX: e16[2],
      maxY: e16[3]
    });
  }
  updateTiles(e16) {
    const t15 = {
      added: [],
      removed: []
    };
    for (const s16 of e16.added) if (!this.has(s16)) {
      const e17 = new n6(this.tileScheme, s16);
      this._tiles.set(s16, e17), this._index.insert(e17), t15.added.push(e17);
    }
    for (const s16 of e16.removed) if (this.has(s16)) {
      const e17 = this.get(s16);
      this._tiles.delete(s16), this._index.remove(e17), t15.removed.push(e17);
    }
    this.tiles.length = 0, this._tiles.forEach((e17) => this.tiles.push(e17)), (t15.added.length || t15.removed.length) && this.emit("update", t15);
  }
  setViewState(e16) {
    const t15 = this.tileScheme.getTileCoverage(e16, 0);
    if (!t15) return;
    const {
      spans: s16,
      lodInfo: i10
    } = t15, {
      level: o12
    } = i10;
    if (s16.length > 0) for (const {
      row: n13,
      colFrom: l8,
      colTo: h7
    } of s16) for (let e17 = l8; e17 <= h7; e17++) {
      const t16 = c5.set(o12, n13, i10.normalizeCol(e17), i10.getWorldForColumn(e17)).id;
      if (a11.add(t16), !this.has(t16)) {
        const e18 = new n6(this.tileScheme, t16);
        this._tiles.set(t16, e18), this._index.insert(e18), this.tiles.push(e18), d6.added.push(e18);
      }
    }
    for (let n13 = this.tiles.length - 1; n13 >= 0; n13--) {
      const e17 = this.tiles[n13];
      a11.has(e17.id) || (this._tiles.delete(e17.id), this.tiles.splice(n13, 1), this._index.remove(e17), d6.removed.push(e17));
    }
    (d6.added.length || d6.removed.length) && this.emit("update", d6), s8.pool.release(t15), a11.clear(), d6.added.length = 0, d6.removed.length = 0;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/support/hitTestUtils.js
function s15(e16, i10, s16) {
  return __async(this, null, function* () {
    const f7 = o7(i10) ? r6(e16, i10) : i10;
    if (!e16.ready || isNaN(f7.x) || isNaN(f7.y)) return {
      screenPoint: f7,
      results: []
    };
    let d8 = /* @__PURE__ */ new Set();
    const y5 = /* @__PURE__ */ new Set();
    let u9 = false, h7 = null, g3 = null;
    s16?.include ? o10(s16.include, n12(e16, (e17) => {
      d8.add(e17), p8(e17, (e18) => y5.add(e18));
    }, (e17, r14) => {
      y5.add(e17), d8.add(r14);
    }, (e17) => {
      h7 || (h7 = /* @__PURE__ */ new Set()), h7.add(e17);
    }, (e17) => d8.add(e17), () => u9 = true)) : (u9 = true, d8 = new Set(e16.allLayerViews), d8.forEach((e17) => {
      p8(e17, (e18) => y5.add(e18));
    })), s16?.exclude && o10(s16.exclude, n12(e16, (e17) => {
      d8.delete(e17), p8(e17, (e18) => y5.delete(e18));
    }, (e17) => y5.delete(e17), (e17) => {
      g3 || (g3 = /* @__PURE__ */ new Set()), g3.add(e17);
    }));
    const m10 = e16.toMap(f7), w4 = e16.allLayerViews.filter((r14) => !r14.suspended && d8.has(r14) && r14.clips.every((r15) => m4(e16, r15, f7, m10))).reverse();
    let V3 = [...u9 ? e16.graphicsView.hitTest(m10).map((e17) => ({
      type: "graphic",
      graphic: e17,
      layer: null,
      mapPoint: m10
    })) : [], ...yield Promise.all(w4.map((e17) => e17.hitTest(m10, f7)).toArray())].filter(O).flat().filter(O);
    return V3 = V3.filter((e17) => "graphic" !== e17.type || "subtype-group" !== e17.layer?.type || y5.has(e17.graphic.layer)), h7 && (V3 = V3.filter((e17) => !("graphic" in e17) || !e17.graphic || h7?.has(c6(e17.graphic)))), g3 && (V3 = V3.filter((e17) => !("graphic" in e17) || !e17.graphic || !g3?.has(c6(e17.graphic)))), {
      screenPoint: f7,
      results: V3
    };
  });
}
function n12(r14, i10, t15, a13, l8, s16) {
  return (n13) => {
    if (n13 instanceof d2) {
      if (n13.layer === r14) s16?.();
      else {
        const e16 = r14.allLayerViews.find((e17) => e17.layer === n13.layer);
        e16 && l8?.(e16);
      }
      a13(c6(n13));
    } else if ("layer" in n13 && "element" in n13) ;
    else if ("subtype-sublayer" === n13.type) {
      const e16 = r14.allLayerViews.find((e17) => e17.layer === n13.parent);
      e16 && t15(n13, e16);
    } else {
      const e16 = r14.allLayerViews.find((e17) => e17.layer === n13);
      e16 && i10(e16);
    }
  };
}
function o10(e16, r14) {
  if (e16) if (t(e16)) {
    for (const t15 of e16) if (t(t15)) for (const e17 of t15) r14(e17);
    else r14(t15);
  } else r14(e16);
}
function c6(e16) {
  const r14 = e16.getObjectId();
  return r14 ? `${e16.layer?.uid ?? e16.sourceLayer?.uid ?? "MapView"}/${r14}` : `"MapView/${e16.uid}`;
}
function p8({
  layer: e16
}, r14) {
  "subtype-group" === e16?.type && e16.sublayers.forEach((e17) => {
    r14(e17);
  });
}

// ../../../node_modules/@arcgis/core/views/2d/support/screenshotUtils.js
var e13 = {
  flipY: true,
  premultipliedAlpha: true
};
function o11(h7, n13) {
  return __async(this, null, function* () {
    const o12 = yield a12(h7, n13), {
      format: r14,
      quality: l8
    } = c2(n13?.format, n13?.quality);
    return a3(o12, {
      format: r14,
      quality: l8,
      rotation: 0,
      disableDecorations: false
    }, e13);
  });
}
function r13(t15, i10) {
  return __async(this, null, function* () {
    const n13 = yield a12(t15, i10);
    return r8(n13, e13);
  });
}
function a12(t15, i10) {
  const h7 = d7(i10 || {}, u8(t15.stage, t15.size), t15.size, t15.padding), n13 = l7(i10, t15.allLayerViews);
  return t15.stage.takeScreenshot(h7, n13, t15.backgroundColor, i10?.rotation);
}
function l7(t15 = {}, i10) {
  if (!t15.layers) return;
  const h7 = [];
  return t15.layers.forEach((t16) => {
    const n13 = i10.find((i11) => i11.layer.id === t16.id);
    n13?.container && h7.push(n13.container);
  }), h7;
}
function u8(t15, i10) {
  return Math.min(4, s10(i10, Math.min(4096, t15.context.parameters.maxTextureSize)));
}
function d7(t15, i10, h7, n13) {
  t15.ignorePadding && (n13 = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  });
  let e16 = null;
  null != t15.width && null != t15.height ? e16 = [t15.width, t15.height] : null == t15.width && null != t15.height ? e16 = [t15.height, t15.height] : null != t15.width && null == t15.height ? e16 = [t15.width, t15.width] : null == t15.width && null == t15.height && (e16 = null);
  const o12 = h7[0] - (n13.left + n13.right), r14 = h7[1] - (n13.top + n13.bottom);
  let a13, l8, u9 = t15.area || {
    x: 0,
    y: 0,
    width: o12,
    height: r14
  };
  if (e16) {
    const t16 = o12 / r14, i11 = e16[0] / e16[1];
    if (i11 > t16) {
      const t17 = u9.width / i11;
      u9 = {
        x: u9.x,
        y: Math.round(u9.y + (u9.height - t17) / 2),
        width: u9.width,
        height: Math.round(t17)
      };
    } else {
      const t17 = u9.height * i11;
      u9 = {
        x: Math.round(u9.x + (u9.width - t17) / 2),
        y: u9.y,
        width: Math.round(t17),
        height: u9.height
      };
    }
  } else e16 = [u9.width, u9.height];
  return e16[0] > u9.width ? (a13 = Math.min(e16[0] / u9.width, i10), l8 = e16[0] / u9.width / a13) : (a13 = 1, l8 = e16[0] / u9.width), {
    cropArea: {
      x: Math.round((u9.x + n13.left) * a13),
      y: Math.round((u9.y + n13.top) * a13),
      width: Math.round(u9.width * a13),
      height: Math.round(u9.height * a13)
    },
    outputScale: l8,
    resolutionScale: a13
  };
}

// ../../../node_modules/@arcgis/core/views/2d/support/StationaryManager.js
var e14 = 160;
var i9 = class extends S {
  constructor() {
    super(...arguments), this._timer = void 0;
  }
  get stationary() {
    return !this._timer;
  }
  flip() {
    this._timestamp = performance.now(), null == this._timer && (this._timer = setInterval(() => {
      performance.now() - this._timestamp >= e14 && this.clear();
    }, e14));
  }
  clear() {
    this._timer && (clearInterval(this._timer), this._timer = void 0);
  }
};
e([y()], i9.prototype, "_timer", void 0), e([y()], i9.prototype, "stationary", null), i9 = e([a("esri.views.2d.support.StationaryManager")], i9);

// ../../../node_modules/@arcgis/core/views/ui/2d/DefaultUI2D.js
var e15 = class extends u6 {
  constructor(o12) {
    super(o12), this.components = ["attribution", "zoom"];
  }
};
e([y()], e15.prototype, "components", void 0), e15 = e([a("esri.views.ui.2d.DefaultUI2D")], e15);
var c7 = e15;

// ../../../node_modules/@arcgis/core/views/MapView.js
var $;
var W;
var H3;
var B2;
var Z2;
var J;
function K2() {
  return __async(this, null, function* () {
    const [, {
      GraphicsView2D: e16,
      GraphicContainer: t15,
      LabelManager: i10,
      MapViewNavigation: r14,
      MagnifierView2D: s16,
      Stage: a13
    }] = yield Promise.all([import("./webglDeps-T4RH63NP.js"), import("./mapViewDeps-APWLEI4H.js")]);
    W = e16, H3 = t15, B2 = i10, Z2 = r14, J = s16, $ = a13;
  });
}
var Q = class extends o5(y2(H(N))) {
  constructor(e16) {
    super(e16), this._magnifierView = null, this.stage = null, this._resolveWhenReady = [], this.rootLayerViews = new l2({
      getCollections: () => [this.basemapView?.baseLayerViews, this.layerViews, this.basemapView?.referenceLayerViews],
      getChildrenFunction: () => null
    }), this.featuresTilingScheme = null, this.fullOpacity = 1, this.goToManager = new h6({
      view: this
    }), this.graphicsView = null, this.stateManager = new z2({
      constraints: new f6({
        view: this
      })
    }), this.stationaryManager = new i9(), this.labelManager = null, this.mapViewNavigation = null, this.renderingOptions = {
      samplingMode: "dynamic",
      edgeLabelsVisible: true,
      labelsAnimationTime: 125,
      labelCollisionsEnabled: true
    }, this.supersampleScreenshotsEnabled = true, this.supportsGround = false, this.frameTask = new s13(this), this.floors = new V(), this.highlightOptions = new p3(), this.inputManager = new k({
      view: this
    }), this.map = null, this.spatialReferenceLocked = false, this.timeline = new e7(), this.type = "2d", this.ui = new c7(), this.test = {
      takeScreenshot: (e17) => __async(this, null, function* () {
        return r13(this._getScreenshotView(e17), e17);
      })
    }, this.padding = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, this.addHandles([d(() => this.viewpoint, () => this.stationaryManager.flip(), C), this.on("resize", (e17) => this.stateManager.resize(e17.width, e17.height))]), m2();
  }
  destroy() {
    this.layerViewManager.clear(), this._set("preconditionsReady", false), this.frameTask = u(this.frameTask), this.goToManager.destroy(), this.rootLayerViews.destroy(), this.inputManager.destroy(), this._set("inputManager", null);
  }
  get graphicsTileStore() {
    return new u7(this.featuresTilingScheme);
  }
  get constraintsInfo() {
    const e16 = this.defaultsFromMap?.tileInfo, t15 = this.spatialReference;
    return {
      lods: e16?.spatialReference?.equals(t15) ? e16.lods : null,
      spatialReference: t15
    };
  }
  get state() {
    return this.stateManager.state;
  }
  get initialExtentRequired() {
    if (!this.stateManager) return false;
    const {
      scale: e16,
      constraints: t15,
      center: i10,
      viewpoint: r14,
      extent: s16
    } = this;
    let a13 = this.zoom;
    return !(this.map && "initialViewProperties" in this.map && this.map.initialViewProperties?.viewpoint) && !s16 && (t15?.effectiveLODs || (a13 = -1), (!i10 || 0 === e16 && -1 === a13) && (null == r14?.targetGeometry || "extent" !== r14.targetGeometry.type && !r14.scale));
  }
  get _defaultsFromMapSettings() {
    return {
      required: {
        tileInfo: true,
        heightModelInfo: false,
        extent: false
      },
      requiresExtentInSpatialReference: this.spatialReferenceLocked
    };
  }
  get typeSpecificPreconditionsReady() {
    const e16 = this._getDefaultViewpoint();
    if (!e16) return false;
    const t15 = e16.targetGeometry, i10 = this.spatialReference;
    return B(t15.spatialReference, i10);
  }
  set animation(e16) {
    const t15 = this._get("animation");
    if (e16 === t15) return;
    if (t15 && t15.stop(), e16 !== this.animationManager.animation && this.animationManager.stop(), !e16 || e16.isFulfilled()) return this._set("animation", null), void (this.frameTask.animationInProgress = false);
    this._set("animation", e16), this.frameTask.animationInProgress = true;
    const i10 = () => {
      this.destroyed || (e16 === this._get("animation") && (this._set("animation", null), this.frameTask?.requestFrame()), this.frameTask.animationInProgress = false);
    };
    e16.when(i10, i10);
  }
  get background() {
    return e8(this.map) ? this.map.initialViewProperties.background : null;
  }
  set background(e16) {
    this._override("background", e16);
  }
  get center() {
    return this.stateManager?.center ?? null;
  }
  set center(e16) {
    this.stateManager.center = e16;
  }
  get constraints() {
    return this.stateManager?.constraints;
  }
  set constraints(e16) {
    e16.view = this;
    const t15 = this.stateManager.constraints;
    this.stateManager.constraints = e16, t15?.destroy();
  }
  get extent() {
    return this.stateManager?.extent ?? null;
  }
  set extent(e16) {
    this.stateManager.extent = e16;
  }
  get padding() {
    return this.stateManager?.padding;
  }
  set padding(e16) {
    this.stateManager && (this.stateManager.padding = e16);
  }
  get rendering() {
    return this.stage?.renderRequested ?? false;
  }
  get resizeAlign() {
    return this.stateManager.resizeAlign;
  }
  set resizeAlign(e16) {
    this.stateManager.resizeAlign = e16;
  }
  get resolution() {
    return this.stateManager.resolution ?? 0;
  }
  get rotation() {
    return this.stateManager.rotation ?? 0;
  }
  set rotation(e16) {
    const {
      rotationEnabled: t15
    } = this.constraints;
    this.constraints.rotationEnabled = true, this.stateManager.rotation = e16, this.constraints.rotationEnabled = t15;
  }
  get scale() {
    return this.stateManager?.scale ?? 0;
  }
  set scale(e16) {
    this.stateManager && (this.stateManager.scale = e16);
  }
  get stationary() {
    return !this.animation && !this.navigating && !this.resizing && this.stationaryManager.stationary;
  }
  get tileInfo() {
    return this.featuresTilingScheme?.tileInfo;
  }
  get updating() {
    const e16 = !(!this.magnifier.visible || null === this.magnifier.position || !this._magnifierView?.updatingHandles.updating), t15 = !this.destroyed && (!this.layerViewManager || !this.labelManager || !this.graphicsView || true === this.layerViewManager.updating || true === this.labelManager.updating || true === this.graphicsView.updating || this.allLayerViews.some((e17) => !e17.destroyed && !("layerViews" in e17) && true === e17.updating) || e16);
    if (has("esri-2d-log-updating")) {
      const i10 = this.allLayerViews.reduce((e17, t16) => __spreadProps(__spreadValues({}, e17), {
        [`${t16.layer.id}(${t16.layer.type})`]: !t16.destroyed && !("layerViews" in t16) && t16.updating
      }), {});
      console.log(`Updating MapView: ${t15}
-> Null LayerViewManager: ${!this.layerViewManager}
-> Null LabelManager: ${!this.labelManager}
-> Null GraphicsView: ${!this.graphicsView}
-> layerViewManager.updating: ${this.layerViewManager?.updating}
-> labelManager.updating: ${this.labelManager?.updating}
-> graphicsView.updating: ${this.graphicsView?.updating}
-> allLayerViews: ${JSON.stringify(i10)}
-> updatingMagnifier: ${e16}
`);
    }
    return t15;
  }
  get viewpoint() {
    return this.stateManager.viewpoint ?? null;
  }
  set viewpoint(e16) {
    this.stateManager.viewpoint = e16, this.frameTask.requestFrame();
  }
  get zoom() {
    return this.stateManager.zoom ?? -1;
  }
  set zoom(e16) {
    this.stateManager.zoom = e16;
  }
  get navigating() {
    return this.mapViewNavigation?.interacting ?? false;
  }
  goTo(e16, t15) {
    return this.goToManager.goTo(e16, t15);
  }
  hitTest(e16, t15) {
    return __async(this, null, function* () {
      return s15(this, e16, t15);
    });
  }
  takeScreenshot(e16) {
    return __async(this, null, function* () {
      return o11(this._getScreenshotView(e16), e16);
    });
  }
  toMap(e16) {
    if (!this.ready) return null;
    const t15 = o7(e16) ? r6(this, e16) : e16;
    return this.stateManager.toMap(t15);
  }
  toScreen(e16, t15) {
    return this.stateManager.toScreen(e16, t15);
  }
  on(e16, t15, i10, r14) {
    const s16 = this.inputManager && this.viewEvents.on(e16, t15, i10, r14);
    return s16 || super.on(e16, t15);
  }
  hasEventListener(e16) {
    return super.hasEventListener(e16) || this.viewEvents.hasHandler(e16);
  }
  whenLayerView(e16) {
    return super.whenLayerView(e16);
  }
  graphicChanged(e16) {
    if (this.graphicsView) {
      this.graphicsView.graphicUpdateHandler(e16);
    }
  }
  whenReady() {
    return new Promise((e16) => {
      this.ready ? e16(this) : this._resolveWhenReady.push(e16);
    });
  }
  forceDOMReadyCycle() {
    this.forceReadyCycle();
  }
  getDefaultSpatialReference() {
    return this.map && "initialViewProperties" in this.map && this.map?.initialViewProperties?.spatialReference || this.defaultsFromMap?.spatialReference || null;
  }
  getDefaultTimeZone() {
    return e8(this.map) ? this.map.initialViewProperties.timeZone : null;
  }
  hasLayerViewModule(e16) {
    return l4.hasLayerViewModule(e16);
  }
  importLayerView(e16) {
    return l4.importLayerView(e16);
  }
  pixelSizeAt() {
    return this.ready ? this.resolution : (n.getLogger(this).error("#pixelSizeAt()", "Map view cannot be used before it is ready"), null);
  }
  popupHitTest(e16) {
    return __async(this, null, function* () {
      const t15 = this.toMap(e16), i10 = yield this.hitTest(e16), r14 = this.allLayerViews.toArray().reverse(), s16 = new globalThis.Map(r14.map((e17) => [e17.layer.uid, e17])), a13 = [];
      let n13 = 0, o12 = 0;
      for (; n13 < i10.results.length || o12 < r14.length; ) {
        const e17 = i10.results.at(n13);
        if (e17 && "graphic" !== e17.type) {
          ++n13;
          continue;
        }
        const p9 = s16.get((e17?.layer ?? e17?.graphic.layer)?.uid);
        if ((!e17 || p9) && o12 < r14.length && r14.at(o12) !== p9) {
          const e18 = r14.at(o12);
          "fetchPopupFeaturesAtLocation" in e18 && a13.push({
            mapPoint: t15,
            layerView: e18
          }), ++o12;
        } else e17 && (a13.push({
          graphic: e17.graphic,
          layerView: p9
        }), ++n13);
      }
      return {
        hits: a13,
        location: t15
      };
    });
  }
  requestUpdate() {
    this.ready && this.frameTask.requestUpdate();
  }
  validate() {
    return __async(this, null, function* () {
      let e16 = t9(this.type);
      if (has("safari") && has("safari") < 9 && (e16 = new s("mapview:browser-not-supported", "This browser is not supported by MapView (Safari < 9)", {
        type: "safari",
        requiredVersion: 9,
        detectedVersion: has("safari")
      })), null != e16) throw n.getLogger(this).warn("#validate()", e16.message), e16;
    });
  }
  loadAsyncDependencies() {
    return K2();
  }
  _getDefaultViewpoint() {
    const {
      constraints: e16,
      initialExtent: i10,
      map: r14,
      padding: s16,
      size: a13
    } = this;
    if (!e16) return null;
    const n13 = r14 && "initialViewProperties" in r14 ? r14.initialViewProperties : void 0, o12 = this.stateManager.getUserStartupOptions(this.size), p9 = n13?.viewpoint, l8 = p9?.targetGeometry?.extent ?? i10, h7 = l8?.center, g3 = p9?.rotation ?? 0, d8 = p9?.scale || l8 && H2(l8, [a13[0] - s16.left - s16.right, a13[1] - s16.top - s16.bottom]), u9 = o12.center ?? h7, c8 = o12.rotation ?? g3, m10 = o12.scale ?? d8;
    return u9 && m10 ? new m3({
      targetGeometry: u9,
      scale: m10,
      rotation: c8
    }) : null;
  }
  _startup() {
    this.timeline.begin("MapView Startup");
    const e16 = this._getDefaultViewpoint();
    this.stateManager.startup(e16, this.size, this.spatialReference, this.defaultsFromMap.extent?.center), this.graphics.owner = this;
    const t15 = new $(this.surface, {
      canvas: this.renderCanvas,
      contextOptions: {
        disabledExtensions: this.deactivatedWebGLExtensions,
        debugWebGLExtensions: this.debugWebGLExtensions
      },
      renderingOptions: this.renderingOptions,
      timeline: this.timeline
    });
    this.stage = t15, this._magnifierView = new J(), this._magnifierView.magnifier = this.magnifier;
    const i10 = new B2({
      view: this
    });
    this._set("labelManager", i10);
    const r14 = new S3({
      view: this
    });
    this._set("animationManager", r14);
    const s16 = new Z2({
      view: this,
      animationManager: r14
    });
    this._set("mapViewNavigation", s16), this._setupSpatialReferenceDependentProperties(), this.addHandles([this.rootLayerViews.on("change", () => this._updateStageChildren()), t15.on("webgl-error", (e17) => this.fatalError = e17.error), d(() => this.stationary, (e17) => t15.stationary = e17, A2), d(() => this.background, (e17) => {
      t15.backgroundColor = e17?.color, this._magnifierView.backgroundColor = e17?.color;
    }, A2), d(() => this.magnifier, (e17) => this._magnifierView.magnifier = e17, A2), d(() => this.renderingOptions, (e17) => t15.renderingOptions = e17, A2), d(() => this.highlightOptions, (e17) => t15.highlightOptions = e17, A2), d(() => this.state.id, () => t15.state = this.state, A2)], "map-view"), this._updateStageChildren();
    const a13 = this._resolveWhenReady;
    this._resolveWhenReady = [], a13.forEach((e17) => e17(this)), this.timeline.end("MapView Startup"), this.frameTask.start(), this._set("ready", true);
  }
  _teardown() {
    this._destroySpatialReferenceDependentProperties(), this.removeHandles("map-view"), this.mapViewNavigation.destroy(), this._set("mapViewNavigation", null), this.animation = null, this.animationManager.destroy(), this._set("animationManager", null), this.layerViewManager.clear(), this.labelManager.destroy(), this._magnifierView.destroy(), this.stage.destroy(), this.stage = null, this._set("graphicsView", null), this._magnifierView = null, this._set("labelManager", null), this._set("mapViewNavigation", null), this.graphics.owner = null, this.frameTask.stop(), this.stationaryManager.clear(), this._set("ready", false), this.stateManager.teardown();
  }
  _updateStageChildren() {
    this.stage.removeAllChildren(), this.rootLayerViews.forEach((e17) => {
      this.stage.addChild(e17.container);
    });
    const e16 = this.graphicsView;
    this.stage.addChild(e16.container), this.stage.addChild(this._magnifierView);
  }
  _setupSpatialReferenceDependentProperties() {
    const e16 = new h4(z.create({
      spatialReference: this.spatialReference,
      size: 512,
      numLODs: 36
    }));
    this._set("featuresTilingScheme", e16);
    const t15 = new W({
      view: this,
      graphics: this.graphics,
      requestUpdateCallback: () => this.requestUpdate(),
      container: new H3(e16)
    });
    this._set("graphicsView", t15);
  }
  _destroySpatialReferenceDependentProperties() {
    const e16 = this.graphicsView;
    this._set("graphicsView", null), e16.destroy(), this._set("featuresTilingScheme", null);
  }
  _getScreenshotView(e16) {
    const {
      allLayerViews: t15,
      padding: i10,
      size: r14,
      stage: s16
    } = this;
    return {
      allLayerViews: t15,
      backgroundColor: e16?.ignoreBackground ? null : this.background?.color,
      padding: i10,
      size: r14,
      stage: s16
    };
  }
  _spatialReferenceChanged(e16) {
    if (this.ready) {
      this.frameTask.stop();
      for (const e17 of this.allLayerViews) e17.processDetach();
      this._destroySpatialReferenceDependentProperties(), this.stateManager.changeSpatialReference(e16), this.stage.state = this.state, this._setupSpatialReferenceDependentProperties();
      for (const e17 of this.allLayerViews) e17.processAttach();
      this.frameTask.requestFrame(), this.frameTask.start(), this._updateStageChildren();
    }
  }
};
Q.type = "2d", e([y({
  readOnly: true
})], Q.prototype, "animationManager", void 0), e([y({
  constructOnly: true
})], Q.prototype, "deactivatedWebGLExtensions", void 0), e([y({
  constructOnly: true
})], Q.prototype, "debugWebGLExtensions", void 0), e([y({
  readOnly: true
})], Q.prototype, "featuresTilingScheme", void 0), e([y({
  readOnly: true
})], Q.prototype, "fullOpacity", void 0), e([y()], Q.prototype, "goToManager", void 0), e([y({
  readOnly: true
})], Q.prototype, "graphicsTileStore", null), e([y()], Q.prototype, "graphicsView", void 0), e([y()], Q.prototype, "stateManager", void 0), e([y()], Q.prototype, "constraintsInfo", null), e([y({
  readOnly: true
})], Q.prototype, "state", null), e([y()], Q.prototype, "initialExtentRequired", null), e([y()], Q.prototype, "labelManager", void 0), e([y({
  readOnly: true
})], Q.prototype, "mapViewNavigation", void 0), e([y({
  constructOnly: true
})], Q.prototype, "renderCanvas", void 0), e([y()], Q.prototype, "renderingOptions", void 0), e([y({
  constructOnly: true
})], Q.prototype, "supersampleScreenshotsEnabled", void 0), e([y({
  readOnly: true
})], Q.prototype, "supportsGround", void 0), e([y()], Q.prototype, "_defaultsFromMapSettings", null), e([y({
  readOnly: true
})], Q.prototype, "typeSpecificPreconditionsReady", null), e([y()], Q.prototype, "animation", null), e([y({
  type: m6
})], Q.prototype, "background", null), e([y()], Q.prototype, "center", null), e([y({
  type: f6
})], Q.prototype, "constraints", null), e([y()], Q.prototype, "extent", null), e([y()], Q.prototype, "floors", void 0), e([y({
  type: p3
})], Q.prototype, "highlightOptions", void 0), e([y({
  readOnly: true
})], Q.prototype, "inputManager", void 0), e([y()], Q.prototype, "map", void 0), e([y()], Q.prototype, "padding", null), e([y({
  readOnly: true
})], Q.prototype, "rendering", null), e([y()], Q.prototype, "resizeAlign", null), e([y({
  readOnly: true
})], Q.prototype, "resolution", null), e([y()], Q.prototype, "rotation", null), e([y()], Q.prototype, "scale", null), e([y({
  constructOnly: true
})], Q.prototype, "spatialReferenceLocked", void 0), e([y()], Q.prototype, "stationary", null), e([y({
  readOnly: true
})], Q.prototype, "tileInfo", null), e([y({
  type: e7,
  readOnly: true
})], Q.prototype, "timeline", void 0), e([y({
  readOnly: true
})], Q.prototype, "type", void 0), e([y({
  readOnly: true
})], Q.prototype, "updating", null), e([y()], Q.prototype, "viewpoint", null), e([y()], Q.prototype, "zoom", null), e([y({
  readOnly: true
})], Q.prototype, "navigating", null), e([y(), s4((e16) => e16 instanceof u6 ? e16 : g(c7, e16))], Q.prototype, "ui", void 0), Q = e([a("esri.views.MapView")], Q);
var X = Q;

export {
  X
};
//# sourceMappingURL=chunk-LQJ6MOD6.js.map
