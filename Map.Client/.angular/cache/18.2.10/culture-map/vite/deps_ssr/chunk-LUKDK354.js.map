{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/layers/graphics/sources/support/sourceUtils.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { parseDate as t } from \"../../../../core/date.js\";\nimport { isValid as n } from \"../../../../geometry/support/spatialReferenceUtils.js\";\nimport { validateFieldValue as e, validationErrorToString as r, isNumericField as i, isStringField as o, isDateField as s, sanitizeNullFieldValue as l } from \"../../../support/fieldUtils.js\";\nclass u {\n  constructor() {\n    this.code = null, this.description = null;\n  }\n}\nclass c {\n  constructor(t) {\n    this.error = new u(), this.globalId = null, this.objectId = null, this.success = !1, this.uniqueId = null, this.error.description = t;\n  }\n}\nfunction f(t) {\n  return new c(t);\n}\nclass a {\n  constructor(t) {\n    this.globalId = null, this.success = !0, this.objectId = this.uniqueId = t;\n  }\n}\nfunction d(t) {\n  return new a(t);\n}\nconst m = new Set();\nfunction p(t, n, i, o = !1) {\n  m.clear();\n  for (const s in i) {\n    const l = t.get(s);\n    if (!l) continue;\n    const u = g(l, i[s]);\n    if (m.add(l.name), l && (o || l.editable)) {\n      const t = e(l, u);\n      if (t) return f(r(t, l, u));\n      n[l.name] = u;\n    }\n  }\n  for (const e of t?.requiredFields ?? []) if (!m.has(e.name)) return f(`missing required field \"${e.name}\"`);\n  return null;\n}\nfunction g(n, e) {\n  let r = e;\n  return i(n) && \"string\" == typeof e ? r = parseFloat(e) : o(n) && null != e && \"string\" != typeof e ? r = String(e) : s(n) && \"string\" == typeof e && (r = t(e)), l(r);\n}\nlet h;\nfunction y(t, e) {\n  if (!t || !n(e)) return t;\n  if (\"rings\" in t || \"paths\" in t) {\n    if (null == h) throw new TypeError(\"geometry engine not loaded\");\n    return h.simplify(e, t);\n  }\n  return t;\n}\nasync function w() {\n  return null == h && (h = await import(\"../../../../geometry/geometryEngineJSON.js\")), h;\n}\nasync function j(t, e) {\n  !n(t) || \"esriGeometryPolygon\" !== e && \"esriGeometryPolyline\" !== e || (await w());\n}\nexport { f as createFeatureEditErrorResult, d as createFeatureEditSuccessResult, j as loadGeometryEngineForSimplify, p as mixAttributes, y as simplify };"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAOA,IAAM,IAAN,MAAQ;AAAA,EACN,cAAc;AACZ,SAAK,OAAO,MAAM,KAAK,cAAc;AAAA,EACvC;AACF;AACA,IAAM,IAAN,MAAQ;AAAA,EACN,YAAY,GAAG;AACb,SAAK,QAAQ,IAAI,EAAE,GAAG,KAAK,WAAW,MAAM,KAAK,WAAW,MAAM,KAAK,UAAU,OAAI,KAAK,WAAW,MAAM,KAAK,MAAM,cAAc;AAAA,EACtI;AACF;AACA,SAAS,EAAE,GAAG;AACZ,SAAO,IAAI,EAAE,CAAC;AAChB;AACA,IAAM,IAAN,MAAQ;AAAA,EACN,YAAY,GAAG;AACb,SAAK,WAAW,MAAM,KAAK,UAAU,MAAI,KAAK,WAAW,KAAK,WAAW;AAAA,EAC3E;AACF;AACA,SAAS,EAAE,GAAG;AACZ,SAAO,IAAI,EAAE,CAAC;AAChB;AACA,IAAM,IAAI,oBAAI,IAAI;AAClB,SAAS,EAAE,GAAGA,IAAG,GAAG,IAAI,OAAI;AAC1B,IAAE,MAAM;AACR,aAAW,KAAK,GAAG;AACjB,UAAM,IAAI,EAAE,IAAI,CAAC;AACjB,QAAI,CAAC,EAAG;AACR,UAAMC,KAAI,EAAE,GAAG,EAAE,CAAC,CAAC;AACnB,QAAI,EAAE,IAAI,EAAE,IAAI,GAAG,MAAM,KAAK,EAAE,WAAW;AACzC,YAAMC,KAAI,GAAE,GAAGD,EAAC;AAChB,UAAIC,GAAG,QAAO,EAAE,GAAEA,IAAG,GAAGD,EAAC,CAAC;AAC1B,MAAAD,GAAE,EAAE,IAAI,IAAIC;AAAA,IACd;AAAA,EACF;AACA,aAAW,KAAK,GAAG,kBAAkB,CAAC,EAAG,KAAI,CAAC,EAAE,IAAI,EAAE,IAAI,EAAG,QAAO,EAAE,2BAA2B,EAAE,IAAI,GAAG;AAC1G,SAAO;AACT;AACA,SAAS,EAAED,IAAG,GAAG;AACf,MAAI,IAAI;AACR,SAAO,GAAEA,EAAC,KAAK,YAAY,OAAO,IAAI,IAAI,WAAW,CAAC,IAAI,GAAEA,EAAC,KAAK,QAAQ,KAAK,YAAY,OAAO,IAAI,IAAI,OAAO,CAAC,IAAI,GAAEA,EAAC,KAAK,YAAY,OAAO,MAAM,IAAI,EAAE,CAAC,IAAI,GAAE,CAAC;AACvK;AACA,IAAI;AACJ,SAAS,EAAE,GAAG,GAAG;AACf,MAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAG,QAAO;AACxB,MAAI,WAAW,KAAK,WAAW,GAAG;AAChC,QAAI,QAAQ,EAAG,OAAM,IAAI,UAAU,4BAA4B;AAC/D,WAAO,EAAE,SAAS,GAAG,CAAC;AAAA,EACxB;AACA,SAAO;AACT;AACA,SAAe,IAAI;AAAA;AACjB,WAAO,QAAQ,MAAM,IAAI,MAAM,OAAO,kCAA4C,IAAI;AAAA,EACxF;AAAA;AACA,SAAe,EAAE,GAAG,GAAG;AAAA;AACrB,KAAC,EAAE,CAAC,KAAK,0BAA0B,KAAK,2BAA2B,MAAM,MAAM,EAAE;AAAA,EACnF;AAAA;",
  "names": ["n", "u", "t"]
}
