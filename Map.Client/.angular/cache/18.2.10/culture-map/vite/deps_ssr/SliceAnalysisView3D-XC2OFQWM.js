import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  Ai,
  Ci,
  H as H2,
  I,
  Li,
  Mi,
  Ri,
  Vi,
  _i,
  ai,
  c as c4,
  ci,
  e as e2,
  ei,
  g as g2,
  gi,
  ji,
  li,
  mi,
  pi,
  ri,
  si,
  t as t6,
  ui,
  v as v2,
  xi
} from "./chunk-DADJKEQ4.js";
import {
  h as h2
} from "./chunk-IFQJT5WB.js";
import {
  M,
  f as f3,
  h as h3,
  j,
  m as m3,
  p as p3,
  r as r2,
  t as t7
} from "./chunk-JJGFAKU4.js";
import "./chunk-VYV5FW7C.js";
import "./chunk-7JFTMCGE.js";
import {
  t as t4
} from "./chunk-AAOWJTVD.js";
import {
  l as l2,
  n as n5
} from "./chunk-CROYEIB5.js";
import {
  O as O2
} from "./chunk-SPTEUQ5I.js";
import {
  a as a2,
  v
} from "./chunk-LUQDD4XX.js";
import {
  o as o3
} from "./chunk-2FVMT5KX.js";
import {
  s as s2
} from "./chunk-AOVKCTSO.js";
import {
  t as t5
} from "./chunk-DVWZMNZY.js";
import {
  w2 as w
} from "./chunk-73EW5OP6.js";
import {
  p as p2
} from "./chunk-J5J3QXIV.js";
import {
  m as m2
} from "./chunk-NCXTRC7L.js";
import "./chunk-FJ65I6KE.js";
import "./chunk-F2LQGEBE.js";
import "./chunk-7RXQQ22H.js";
import "./chunk-VC76DE2W.js";
import "./chunk-XUM2DDAI.js";
import "./chunk-SF5T5ZX3.js";
import "./chunk-OPYMVWCV.js";
import {
  h
} from "./chunk-IRKNVCIL.js";
import "./chunk-ATL6GPJC.js";
import "./chunk-IPGNBAEV.js";
import "./chunk-N7TLJ6LV.js";
import "./chunk-VTFYXQEG.js";
import "./chunk-INUNNFZT.js";
import "./chunk-NF2MOJH5.js";
import "./chunk-2NPPOPEZ.js";
import "./chunk-JP4VYCP3.js";
import "./chunk-K6JW77RY.js";
import {
  H,
  W,
  Z,
  ds
} from "./chunk-377KSYNB.js";
import "./chunk-PSH57UZT.js";
import "./chunk-VFAQK3MV.js";
import "./chunk-IQWWKVQ4.js";
import "./chunk-LEBOC3ZD.js";
import "./chunk-FSYMZVRK.js";
import "./chunk-T4DTOVU4.js";
import "./chunk-TDVWRWD6.js";
import "./chunk-TO2KOAJE.js";
import "./chunk-DTMLHZFB.js";
import {
  n as n4
} from "./chunk-WQIJCG2D.js";
import "./chunk-WOWVQEU2.js";
import "./chunk-4X2M4YSF.js";
import "./chunk-D5RCKR5Z.js";
import "./chunk-N4FQBAT2.js";
import "./chunk-K7U66W6G.js";
import "./chunk-WQMUOLHB.js";
import "./chunk-LVERV6OU.js";
import "./chunk-3FFTEL3W.js";
import "./chunk-4WON4QDF.js";
import "./chunk-45GTM6LF.js";
import "./chunk-XUZTWNKD.js";
import "./chunk-Q5PBA64J.js";
import "./chunk-TIAWSZQK.js";
import "./chunk-KWHFMZEB.js";
import "./chunk-FBMJVQWQ.js";
import "./chunk-WUTM5T74.js";
import "./chunk-RV5QLAWU.js";
import "./chunk-22UDIQGJ.js";
import "./chunk-XFLPRRYT.js";
import "./chunk-Z5ZLX3BE.js";
import "./chunk-23Q4INNG.js";
import "./chunk-LZSSTWLW.js";
import "./chunk-ALQIX2AS.js";
import "./chunk-D3VQCVGJ.js";
import "./chunk-6YHZYHJS.js";
import "./chunk-TSTMST4X.js";
import "./chunk-I47GCEJP.js";
import "./chunk-LA4GCRJY.js";
import "./chunk-ZTMARHUQ.js";
import "./chunk-P5MJSFMN.js";
import "./chunk-HMPRRFR4.js";
import "./chunk-UE7ZYRIH.js";
import "./chunk-W24M6HII.js";
import "./chunk-FWGI52X4.js";
import "./chunk-E5RXQH35.js";
import "./chunk-62ZEBDPC.js";
import "./chunk-ZFMS3XGM.js";
import "./chunk-QWQJOAVR.js";
import "./chunk-YLQMUXQA.js";
import "./chunk-4U7LUZFD.js";
import "./chunk-T257OY4U.js";
import "./chunk-BMO2W6EC.js";
import "./chunk-QA265FYQ.js";
import "./chunk-HUOFTIIK.js";
import "./chunk-ZDFN6OZC.js";
import "./chunk-KSOKDIBG.js";
import "./chunk-3NWWTJOW.js";
import "./chunk-TRF6JO5N.js";
import "./chunk-ZHVMMFTW.js";
import "./chunk-HKAONIBH.js";
import "./chunk-EPIUUGS2.js";
import "./chunk-TMXHZTIG.js";
import "./chunk-FIQ7DCCC.js";
import "./chunk-SNHVHW2N.js";
import "./chunk-QATJRB5Q.js";
import "./chunk-7Z4UWMRU.js";
import "./chunk-YEB36ZCF.js";
import "./chunk-LQUVB46M.js";
import "./chunk-GHPF24X4.js";
import "./chunk-UC4DX4SE.js";
import "./chunk-44O4APOL.js";
import "./chunk-LCPLUSDH.js";
import "./chunk-KYLW5XXS.js";
import "./chunk-B63XAMYJ.js";
import "./chunk-THUD7LGO.js";
import "./chunk-YSJVVDDH.js";
import "./chunk-DLWZ3HVT.js";
import "./chunk-B76NC7GX.js";
import {
  A as A3
} from "./chunk-5O46LCZR.js";
import "./chunk-QMJ2OQSU.js";
import "./chunk-VENH3UKS.js";
import "./chunk-AS4KZK4Y.js";
import "./chunk-IZJSB4V4.js";
import "./chunk-ZSJNH2BT.js";
import "./chunk-FJ3AI2QH.js";
import "./chunk-XUSZNRTW.js";
import "./chunk-W26QF64E.js";
import "./chunk-D3XX7CQS.js";
import "./chunk-D5ZVYTUT.js";
import "./chunk-MY2HOJQI.js";
import "./chunk-CAYYEMNX.js";
import "./chunk-6NY22YWY.js";
import "./chunk-JBJJW35I.js";
import "./chunk-PXTZCDRW.js";
import "./chunk-GVEKX2VV.js";
import "./chunk-MM5HQGRH.js";
import "./chunk-JA5GJ7PX.js";
import "./chunk-Q6OCJ3NG.js";
import "./chunk-DD6UQHSS.js";
import "./chunk-FALQTRQL.js";
import "./chunk-GGTDLTZW.js";
import "./chunk-2W7YKBRA.js";
import "./chunk-GLFGRGCP.js";
import "./chunk-WQZJGTGX.js";
import "./chunk-VFQA3B5S.js";
import "./chunk-NOH3NLJ5.js";
import "./chunk-LX5BT6XP.js";
import "./chunk-PLGJMWC5.js";
import "./chunk-UGFQYEND.js";
import "./chunk-XC5RDNAY.js";
import "./chunk-KXVPQVTB.js";
import "./chunk-ARN5GJBK.js";
import "./chunk-MPLS4PY6.js";
import "./chunk-AGBPYPP3.js";
import "./chunk-IKBXTTSU.js";
import "./chunk-VMZV7772.js";
import "./chunk-3FR2T2I2.js";
import "./chunk-LOZRWPGI.js";
import "./chunk-GZ64OOAB.js";
import "./chunk-WR2NVDOI.js";
import "./chunk-EPLJRYUV.js";
import "./chunk-VYRCS5VR.js";
import "./chunk-OOK3QTWF.js";
import "./chunk-VFYCIIDC.js";
import "./chunk-PQUZDC3L.js";
import "./chunk-UUQ5O7GK.js";
import "./chunk-6XY35LS7.js";
import "./chunk-T42EJVJR.js";
import "./chunk-D3QK4EV3.js";
import "./chunk-JTDKNK44.js";
import "./chunk-RR7OQLEK.js";
import "./chunk-ZWAQV54Z.js";
import "./chunk-5PXOWPHT.js";
import "./chunk-OGKROLZ3.js";
import "./chunk-BHG37GSO.js";
import "./chunk-QI5HKZYN.js";
import "./chunk-RIZOHDTP.js";
import "./chunk-ZFES27RA.js";
import "./chunk-XP2AJZUL.js";
import "./chunk-CZA7RDJP.js";
import "./chunk-FYE6XHDR.js";
import "./chunk-NCMX3DAD.js";
import "./chunk-BCNABTAE.js";
import "./chunk-3PPEJ4QJ.js";
import "./chunk-ZEOLGKXL.js";
import "./chunk-HITI6WDM.js";
import "./chunk-IS4RJOPJ.js";
import "./chunk-XK3CKE5Q.js";
import "./chunk-AMH7CZMY.js";
import "./chunk-EAVSYZXD.js";
import "./chunk-7GHUVMBI.js";
import "./chunk-Q5JLNMWZ.js";
import "./chunk-AABDXAD3.js";
import "./chunk-LGS63R4F.js";
import "./chunk-L6FG3WIC.js";
import {
  m
} from "./chunk-6ZLH7XBS.js";
import "./chunk-44ZUWZXU.js";
import "./chunk-NAG6YX7T.js";
import "./chunk-WFNAKG2H.js";
import "./chunk-EKHRAAS6.js";
import "./chunk-IEB4ZCRH.js";
import "./chunk-7QOUHKW5.js";
import "./chunk-NHYYZMJR.js";
import "./chunk-U4EMQMDC.js";
import "./chunk-WVSTX2NW.js";
import "./chunk-MKFGPBQ3.js";
import "./chunk-AVCKPV77.js";
import "./chunk-MNBTLVRM.js";
import "./chunk-GNCXYHNE.js";
import "./chunk-CSK4VZQ7.js";
import {
  E,
  F,
  S as S2,
  V,
  c as c3,
  f as f2,
  t as t3
} from "./chunk-2TNGEJGS.js";
import "./chunk-OYGNGIHQ.js";
import "./chunk-GSG4T2KM.js";
import "./chunk-D7C26LZP.js";
import "./chunk-BZHHBBFX.js";
import "./chunk-GK5M6FUR.js";
import "./chunk-MRP3FBLV.js";
import "./chunk-Y7SJWJAL.js";
import "./chunk-A2FDYA6M.js";
import "./chunk-YGAXDKHF.js";
import "./chunk-4TOSJLKR.js";
import "./chunk-EXPZNTF3.js";
import "./chunk-ORYC4PVJ.js";
import "./chunk-DXIKKLD7.js";
import "./chunk-VQNXE43R.js";
import "./chunk-VZ37C3ID.js";
import "./chunk-5R3HARKC.js";
import "./chunk-BKSTWG4S.js";
import "./chunk-FSG7HOZQ.js";
import "./chunk-Q5TIVVER.js";
import "./chunk-ZPMUEGLK.js";
import "./chunk-GNFDYYU3.js";
import "./chunk-X36BR2QB.js";
import "./chunk-RGG3YJQA.js";
import "./chunk-GBJYL7OX.js";
import "./chunk-GHKVDSKU.js";
import "./chunk-NVOJILW6.js";
import "./chunk-KYPTWEOO.js";
import "./chunk-WVFB3H4O.js";
import {
  n as n3
} from "./chunk-C7BQE556.js";
import "./chunk-ZREJ3Y2F.js";
import "./chunk-IR6CVPPC.js";
import "./chunk-BBUQOCRA.js";
import "./chunk-YBUJLIWZ.js";
import "./chunk-DL2B6IFJ.js";
import "./chunk-VOOO6FU5.js";
import "./chunk-IUPJR3FF.js";
import "./chunk-TGZW6QWO.js";
import "./chunk-OYIDHTXG.js";
import "./chunk-KUBMHTYA.js";
import "./chunk-E5NWFBZG.js";
import "./chunk-FP37456K.js";
import {
  _,
  t as t2
} from "./chunk-VSQZQLTQ.js";
import "./chunk-K43CZ3M5.js";
import "./chunk-6EIBUVMG.js";
import "./chunk-XCCMILGI.js";
import "./chunk-JDVVCQU6.js";
import "./chunk-NBJSAHZT.js";
import "./chunk-BD24XM4D.js";
import "./chunk-NXXQ35YM.js";
import "./chunk-3BXPVUY5.js";
import "./chunk-LM3JDV4W.js";
import "./chunk-34V2CLL5.js";
import "./chunk-CXNERL22.js";
import "./chunk-7V4JSBFA.js";
import "./chunk-REIMIECM.js";
import "./chunk-EO2EW5KR.js";
import "./chunk-JEFPXTYT.js";
import "./chunk-MVS2BECH.js";
import "./chunk-UZ7IOCF3.js";
import "./chunk-OS542PQQ.js";
import "./chunk-3B5GODXR.js";
import "./chunk-NKXXHQDD.js";
import "./chunk-7TBQUMV3.js";
import {
  f
} from "./chunk-TPLUZX3A.js";
import "./chunk-BGLJ2FAH.js";
import "./chunk-2EJFYNM7.js";
import "./chunk-DC5LRNPY.js";
import "./chunk-ASCK5HJ5.js";
import "./chunk-5X5U7R6O.js";
import "./chunk-XNLAOXPY.js";
import "./chunk-ZT7V2AVD.js";
import "./chunk-C2OXE4NQ.js";
import {
  c as c2,
  d as d3,
  p
} from "./chunk-KOI252FF.js";
import "./chunk-I2TVVMQ6.js";
import "./chunk-5EGQYY2H.js";
import "./chunk-JKPUNUQA.js";
import "./chunk-SR7PRON4.js";
import "./chunk-HGHPYGKP.js";
import "./chunk-4DSGTDZJ.js";
import {
  c,
  d as d2
} from "./chunk-VYTPFEL2.js";
import "./chunk-RLGDH6IY.js";
import "./chunk-MRPCXIVS.js";
import "./chunk-YTKVV2Y3.js";
import "./chunk-GCVQXAS4.js";
import "./chunk-UFQD6AL4.js";
import "./chunk-EGBDRLCX.js";
import "./chunk-THZPD5CT.js";
import "./chunk-OBCA6CWH.js";
import "./chunk-2JI245BP.js";
import "./chunk-ZEZ3LI2L.js";
import "./chunk-N34BRXVM.js";
import "./chunk-KETDH2J4.js";
import "./chunk-7QV7DHWN.js";
import "./chunk-4L4Y34YK.js";
import "./chunk-BXONKQKI.js";
import "./chunk-2HDBQXAR.js";
import "./chunk-RNF7VOCU.js";
import "./chunk-TIRJMGGG.js";
import "./chunk-ZDRQSPB6.js";
import "./chunk-DCXDXGAR.js";
import "./chunk-BCCDYCTQ.js";
import "./chunk-AYL3HQHD.js";
import "./chunk-66YQWHHE.js";
import "./chunk-QGBMZIP4.js";
import "./chunk-AOEBZVTA.js";
import "./chunk-2OZSYJDX.js";
import {
  O,
  P,
  g,
  o as o2,
  r,
  s,
  u as u2,
  z
} from "./chunk-MZM4INJV.js";
import {
  n as n2,
  t
} from "./chunk-J4GMQHGL.js";
import "./chunk-MHPE4SZA.js";
import "./chunk-6SSA7P3A.js";
import "./chunk-FQBTLEUI.js";
import "./chunk-GS7Y3YOG.js";
import "./chunk-Y2HYKTTT.js";
import "./chunk-XLEC46FY.js";
import "./chunk-4AZPIP7K.js";
import "./chunk-G73HQZEL.js";
import {
  A as A2,
  C,
  d
} from "./chunk-LZSLQ24Q.js";
import "./chunk-U3RHUXYK.js";
import "./chunk-7DBI6LQG.js";
import "./chunk-AUUN7RFQ.js";
import "./chunk-JAMSDYD6.js";
import "./chunk-PH6NPTP7.js";
import {
  e
} from "./chunk-NUICEVIH.js";
import {
  A,
  S
} from "./chunk-NXK752PZ.js";
import {
  y
} from "./chunk-UVNLCXWD.js";
import "./chunk-PNUA7JOS.js";
import "./chunk-OR2FKGUM.js";
import {
  a3 as a
} from "./chunk-UDMPWVPF.js";
import "./chunk-XJNKCEWL.js";
import {
  o
} from "./chunk-AIZ3T7E3.js";
import "./chunk-6UEMNP3E.js";
import {
  l,
  u
} from "./chunk-6WGE3IUL.js";
import "./chunk-MLYB2YW4.js";
import {
  n2 as n
} from "./chunk-6JFGZTLU.js";
import "./chunk-2ZJE6ZFX.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-XBPEBUD5.js";

// ../../../node_modules/@arcgis/core/views/3d/terrain/isTerrainSurfaceLayer.js
function a3(a4) {
  switch (a4.type) {
    case "building-scene":
    case "catalog":
    case "catalog-dynamic-group":
    case "catalog-footprint":
    case "csv":
    case "dimension":
    case "feature":
    case "geo-rss":
    case "geojson":
    case "graphics":
    case "group":
    case "integrated-mesh":
    case "integrated-mesh-3dtiles":
    case "kml":
    case "knowledge-graph":
    case "link-chart":
    case "knowledge-graph-sublayer":
    case "line-of-sight":
    case "map-notes":
    case "ogc-feature":
    case "oriented-imagery":
    case "point-cloud":
    case "route":
    case "scene":
    case "stream":
    case "voxel":
    case "subtype-group":
    case "unknown":
    case "unsupported":
    case "wfs":
    case null:
      return false;
    case "base-dynamic":
    case "base-elevation":
    case "base-tile":
    case "bing-maps":
    case "elevation":
    case "imagery":
    case "imagery-tile":
    case "map-image":
    case "media":
    case "open-street-map":
    case "tile":
    case "vector-tile":
    case "video":
    case "wcs":
    case "web-tile":
    case "wms":
    case "wmts":
      return true;
    default:
      return n3(a4.type), false;
  }
}

// ../../../node_modules/@arcgis/core/views/3d/analysis/Slice/SliceController.js
var v3 = class extends S {
  constructor(e3) {
    super(e3), this._internalChange = false, this._currentSlicePlane = null;
  }
  initialize() {
    this.addHandles(this.analysis.excludedLayers.on("before-add", (e3) => {
      const i = e3.item;
      null != i && (i instanceof f || i instanceof A3) ? i instanceof f && a3(i) ? (n.getLogger(this).error("excludedLayers", `Layer '${i.title}, id:${i.id}' of type '${i.type}' can not be individually excluded from slicing. Use 'excludeGroundSurface' instead.`), e3.preventDefault()) : this.analysis.excludedLayers.includes(i) && e3.preventDefault() : (n.getLogger(this).error("excludedLayers", "Invalid layer type, layer must derive from Layer or BuildingComponentSublayer"), e3.preventDefault());
    })), V2(this.view, this), this.addHandles([d(() => this.analysisViewData.plane, () => {
      this._internalChange || this._updateSlicePlaneFromBoundedPlane(), this._updateLayerViews();
    }, {
      sync: true
    }), d(() => this.analysis.excludeGroundSurface, () => this._updateLayerViews(), {
      sync: true
    }), this.analysis.excludedLayers.on("change", () => this._updateLayerViews()), d(() => [this.analysisViewData.active, this.analysisViewData.visible], () => {
      this._updateActiveController(), this._updateViewSlicePlane();
    }, {
      sync: true
    }), d(() => this._allLayerAndSubLayerViews, () => this._updateLayerViews())]), this.addHandles([d(() => this.analysis.shape, () => {
      this._internalChange || (this._updateBoundedPlaneFromSlicePlane(), this._updateViewSlicePlane());
    }, {
      sync: true
    })], "analysis"), this._updateActiveController(), this._updateBoundedPlaneFromSlicePlane(), this._updateViewSlicePlane();
  }
  destroy() {
    this.analysisViewData.active && (this.analysisViewData.active = false, this.view.slicePlane = null, this._updateActiveController(), this._updateViewSlicePlane()), L(this.view, this), this.set("view", null);
  }
  get _allLayerAndSubLayerViews() {
    const e3 = this.view.allLayerViews.items;
    return e3.concat(e3.filter(xi).flatMap(({
      sublayerViews: e4
    }) => e4.items));
  }
  _updateBoundedPlaneFromSlicePlane() {
    const e3 = this.analysis.shape, i = this._currentSlicePlane;
    if (null == i && null == e3 || null != i && null != e3 && e3.equals(i)) return;
    let a4 = null, l3 = null;
    if (null != e3?.position) {
      const i2 = e3.position.spatialReference, s3 = Li(e3, this.view);
      null == s3 && t5(this.analysis, i2, n.getLogger(this)), a4 = Vi(s3, this.view, {
        tiltEnabled: this.analysis.tiltEnabled
      }, W()), null != a4 && (l3 = {
        heading: e3.heading,
        tilt: e3.tilt,
        position: e3.position,
        width: e3.width,
        height: e3.height
      });
    }
    this._currentSlicePlane = l3, this._internalChange = true, this.analysisViewData.plane = a4, this._internalChange = false;
  }
  _updateSlicePlaneFromBoundedPlane() {
    const e3 = this.analysisViewData.plane, a4 = Ri(e3, this.view, this.view.spatialReference, new h2());
    let t8 = null;
    null != a4 && (t8 = {
      heading: a4.heading,
      tilt: a4.tilt,
      position: a4.position,
      width: a4.width,
      height: a4.height
    }), this._currentSlicePlane = t8, this._internalChange = true, this.analysis.shape = a4, this._internalChange = false, this._updateViewSlicePlane();
  }
  _updateActiveController() {
    if (m4) return;
    const e3 = _2(this.view);
    if (!e3) return;
    if (this.analysisViewData.active) null != e3.activeController && e3.activeController !== this ? (m4 = true, e3.activeController.analysisViewData.active = false, m4 = false) : null != e3.activeController && e3.activeController, this._updateLayerViews(), e3.activeController = this;
    else {
      if (null != e3.activeController && e3.activeController !== this) return;
      null != e3.activeController && e3.activeController === this && (e3.activeController = null, this._updateLayerViews());
    }
  }
  _updateViewSlicePlane() {
    g3(this.view);
  }
  _updateLayerViews() {
    const e3 = null != this.analysisViewData.plane && this.analysisViewData.visible && this.analysisViewData.active, i = [], a4 = (e4) => {
      "layers" in e4 ? e4.layers.forEach(a4) : i.push(e4);
    };
    this.analysis.excludedLayers.forEach(a4), this.view.allLayerViews.forEach((a5) => {
      a5.destroyed || ("slicePlaneEnabled" in a5 && (a5.slicePlaneEnabled = e3 && !i.includes(a5.layer)), "sublayerViews" in a5 && a5.sublayerViews.forEach((a6) => {
        a6.slicePlaneEnabled = e3 && !i.includes(a6.sublayer);
      }));
    }), null != this.view.basemapTerrain && (this.view.basemapTerrain.slicePlaneEnabled = e3 && !this.analysis.excludeGroundSurface);
  }
};
e([y()], v3.prototype, "view", void 0), e([y()], v3.prototype, "analysis", void 0), e([y()], v3.prototype, "analysisViewData", void 0), e([y()], v3.prototype, "_allLayerAndSubLayerViews", null), v3 = e([a("esri.views.3d.analysis.Slice.SliceController")], v3);
var f4 = /* @__PURE__ */ new Map();
var m4 = false;
function g3(e3) {
  const i = _2(e3), a4 = i?.activeController;
  null != a4?.analysisViewData.plane && a4.analysisViewData.visible ? e3.slicePlane = a4.analysisViewData.plane : e3.slicePlane = null;
}
function V2(e3, i) {
  f4.has(e3) || f4.set(e3, {
    all: [],
    activeController: null
  }), f4.get(e3)?.all.push(i);
}
function _2(e3) {
  return f4.get(e3);
}
function L(e3, i) {
  if (!f4.has(e3)) throw new Error("view expected in global slice register");
  const a4 = f4.get(e3), t8 = a4?.all.lastIndexOf(i) ?? -1;
  if (!a4 || -1 === t8) throw new Error("controller expected in global slice register");
  a4.all.splice(t8, 1), 0 === a4.all.length && f4.delete(e3);
}

// ../../../node_modules/@arcgis/core/views/3d/analysis/Slice/SliceTool.js
var Vt;
var bt = Vt = class extends o3 {
  constructor(t8) {
    super(t8), this._clock = o, this._previewPlaneOpacity = 1, this.removeIncompleteOnCancel = false, this._layersMode = "none", this.shiftManipulator = null, this.rotateHeadingManipulator = null, this.rotateTiltManipulator = null, this.resizeManipulators = null, this._frameTask = null, this._pointerMoveTimerMs = m3, this._prevPointerMoveTimeout = null, this._previewPlaneGridVisualElement = null, this._previewPlaneOutlineVisualElement = null, this._startPlane = W(), this._previewPlane = null, this._activeKeyModifiers = {}, this._lastCursorPosition = c(), this._resizeHandles = [{
      direction: [1, 0]
    }, {
      direction: [1, 1]
    }, {
      direction: [0, 1]
    }, {
      direction: [-1, 1]
    }, {
      direction: [-1, 0]
    }, {
      direction: [-1, -1]
    }, {
      direction: [0, -1]
    }, {
      direction: [1, -1]
    }], this._intersector = t4(t8.view.state.viewingMode);
  }
  initialize() {
    if (null == this.analysis) throw new Error("SliceTool requires valid analysis, but null was provided.");
    const t8 = (t9) => {
      this._updateManipulatorsInteractive(t9), t9.grabbing || (null != this.analysisViewData.plane && Z(this.analysisViewData.plane, this._startPlane), this.inputState = null);
    }, e3 = new I(this.view, H2.CENTER_ON_ARROW);
    this.shiftManipulator = e3, this.manipulators.add(e3), this.addHandles([this._createShiftDragPipeline(e3), e3.events.on("grab-changed", (i2) => {
      this._onShiftGrab(i2), t8(e3);
    })]);
    const i = !this.view._stage?.renderView.renderingContext.driverTest.svgPremultipliesAlpha.result, a4 = new g2(this.view, (t9, e4) => l2(this.view.textures, {
      accentColor: t9,
      contrastColor: e4,
      preMultiplyAlpha: i
    }));
    this.rotateHeadingManipulator = a4, this.manipulators.add(a4), this.addHandles([this._createRotateHeadingDragPipeline(a4), a4.events.on("grab-changed", (e4) => {
      this._onRotateHeadingGrab(e4), t8(a4);
    })]);
    const s3 = new g2(this.view, (t9, e4) => n5(this.view.textures, {
      accentColor: t9,
      contrastColor: e4,
      preMultiplyAlpha: i
    }));
    this.rotateTiltManipulator = s3, this.manipulators.add(s3), this.addHandles([this._createRotateTiltDragPipeline(s3), s3.events.on("grab-changed", (e4) => {
      this._onRotateTiltGrab(e4), t8(s3);
    })]), this.resizeManipulators = this._resizeHandles.map((e4, i2) => {
      const a5 = new v2(this.view, e4);
      return this.addHandles([this._createResizeDragPipeline(a5), a5.events.on("grab-changed", (e5) => {
        this._onResizeGrab(e5, i2), t8(a5);
      })]), a5;
    }), this.manipulators.addMany(this.resizeManipulators), this._previewPlaneGridVisualElement = ji(this.view), this._previewPlaneOutlineVisualElement = Ai(this.view), this._previewPlaneOutlineVisualElement.width = M, this.addHandles(d(() => [this.analysisViewData.plane, this.analysis.tiltEnabled], () => this._updateManipulators(), C));
    const o4 = d(() => this.state, (t9) => {
      "sliced" === t9 && this.finishToolCreation();
    }, A2);
    this.addHandles([o4, d(() => this.view.state.camera, () => this._onCameraChange())]);
  }
  destroy() {
    this._removeFrameTask(), this._clearPointerMoveTimeout(), this._previewPlaneOutlineVisualElement = u(this._previewPlaneOutlineVisualElement), this._previewPlaneGridVisualElement = u(this._previewPlaneGridVisualElement);
  }
  get state() {
    const t8 = !!this.analysisViewData.plane, e3 = !!this.inputState;
    return t8 ? t8 && e3 ? "slicing" : t8 && !e3 ? "sliced" : "ready" : "ready";
  }
  get cursor() {
    return this._isPlacingSlicePlane || "exclude" === this.layersMode ? "crosshair" : null != this._creatingPointerId ? "grabbing" : null;
  }
  set analysis(t8) {
    if (null == t8) throw new Error("SliceTool requires valid analysis, but null was provided.");
    this.removeHandles("analysis"), this._set("analysis", t8);
  }
  get layersMode() {
    return this._layersMode;
  }
  get inputState() {
    return this._get("inputState");
  }
  set inputState(t8) {
    this._set("inputState", t8), this.analysisViewData.showGrid = null != t8 && "resize" === t8.type, this._updateMaterials();
  }
  get _isPlacingSlicePlane() {
    return !this.inputState && !this.analysisViewData.plane && this.active;
  }
  get _creatingPointerId() {
    return null != this.inputState && "shift" === this.inputState.type ? this.inputState.creatingPointerId : null;
  }
  enterExcludeLayerMode() {
    null != this.analysisViewData.plane && (this._layersMode = "exclude", this.active || (this.view.activeTool = this));
  }
  exitExcludeLayerMode() {
    null != this.analysisViewData.plane && (this._layersMode = "none", this.active && (this.view.activeTool = null));
  }
  onDeactivate() {
    this._updatePreviewPlane(null);
  }
  onShow() {
    this._updateVisibility(true);
  }
  onHide() {
    this._updateVisibility(false);
  }
  _updateVisibility(t8) {
    this._updateManipulators(), t8 || this._clearPointerMoveTimeout();
  }
  onInputEvent(t8) {
    switch (t8.type) {
      case "pointer-drag":
        if (!kt(t8)) return;
        this._isPlacingSlicePlane ? this._onClickPlacePlane(t8) && t8.stopPropagation() : this._onPointerDrag(t8) && t8.stopPropagation();
        break;
      case "pointer-move":
        this._onPointerMove(t8);
        break;
      case "pointer-up":
        this._onPointerUp(t8) && t8.stopPropagation();
        break;
      case "immediate-click":
        if (!kt(t8)) return;
        this._onClickPlacePlane(t8) && t8.stopPropagation();
        break;
      case "click":
        if (!kt(t8)) return;
        this._onClickExcludeLayer(t8) && t8.stopPropagation();
        break;
      case "drag":
        this.inputState && t8.stopPropagation();
        break;
      case "key-down":
        this._onKeyDown(t8) && t8.stopPropagation();
        break;
      case "key-up":
        this._onKeyUp(t8) && t8.stopPropagation();
    }
  }
  onEditableChange() {
    this.analysisViewData.editable = this.internallyEditable;
  }
  _onPointerDrag(t8) {
    const e3 = this.inputState;
    if (t8.pointerId === this._creatingPointerId && null != e3 && "shift" === e3.type) {
      const i = n4(t8);
      return this.shiftManipulator.events.emit("drag", {
        action: e3.hasBeenDragged ? "update" : "start",
        pointerType: t8.pointerType,
        start: i,
        screenPoint: i
      }), e3.hasBeenDragged = true, true;
    }
    return false;
  }
  _onPointerMove(t8) {
    this._lastCursorPosition.x = t8.x, this._lastCursorPosition.y = t8.y, this._resetPointerMoveTimeout(), "touch" !== t8.pointerType && this._updatePreviewPlane(n4(t8), this._activeKeyModifiers);
  }
  _onCameraChange() {
    this._updatePreviewPlane(this._lastCursorPosition, this._activeKeyModifiers), this._updateManipulators();
  }
  _onPointerUp(t8) {
    if (t8.pointerId === this._creatingPointerId && null != this.analysisViewData.plane) {
      const e3 = n4(t8);
      return this.shiftManipulator.events.emit("drag", {
        action: "end",
        start: e3,
        screenPoint: e3
      }), Z(this.analysisViewData.plane, this._startPlane), this.inputState = null, true;
    }
    return false;
  }
  _onClickPlacePlane(t8) {
    if ("exclude" === this.layersMode) return false;
    if (this._isPlacingSlicePlane) {
      const i = n4(t8), a4 = W();
      if (this._pickPlane(i, false, this._activeKeyModifiers, a4)) {
        if ("pointer-drag" === t8.type) {
          const e3 = m2(this.view.state.camera, i, xt);
          this.inputState = Et(e3, t8.pointerId, a4.origin, a4);
        }
        return Z(a4, this._startPlane), this.analysis.shape = Ri(a4, this.view, this.view.spatialReference, new h2()), true;
      }
    }
    return false;
  }
  _onClickExcludeLayer(t8) {
    return !("exclude" !== this.layersMode || !this.created) && (this.view.hitTest(n4(t8)).then((t9) => {
      if (t9.results.length) {
        const e3 = t9.results[0], i = "graphic" === e3?.type && e3.graphic;
        if (i) {
          const t10 = i.sourceLayer || i.layer;
          t10 && this.analysis.excludedLayers.push(t10);
        }
      } else t9.ground.layer ? this.analysis.excludedLayers.push(t9.ground.layer) : this.analysis.excludeGroundSurface = true;
    }), this.exitExcludeLayerMode(), true);
  }
  _onKeyDown(t8) {
    return (t8.key === r2 || t8.key === t7) && (this._activeKeyModifiers[t8.key] = true, null != this._previewPlane && this._updatePreviewPlane(this._lastCursorPosition, this._activeKeyModifiers), true);
  }
  _onKeyUp(t8) {
    return !(t8.key !== r2 && t8.key !== t7 || !this._activeKeyModifiers[t8.key]) && (delete this._activeKeyModifiers[t8.key], null != this._previewPlane && this._updatePreviewPlane(this._lastCursorPosition, this._activeKeyModifiers), true);
  }
  _onShiftGrab(t8) {
    if ("start" !== t8.action || null == this.analysisViewData.plane || !t8.screenPoint) return;
    const e3 = m2(this.view.state.camera, t8.screenPoint, xt);
    Z(this.analysisViewData.plane, this._startPlane), this.inputState = Et(e3, null, this.shiftManipulator.renderLocation, this.analysisViewData.plane);
  }
  _createShiftDragPipeline(t8) {
    return p2(t8, (t9, e3, i) => {
      const a4 = this.inputState;
      if (null == a4 || "shift" !== a4.type) return;
      const s3 = null != this.analysisViewData.plane ? Z(this.analysisViewData.plane, W()) : null;
      e3.next(O2(this.view, a4.shiftPlane)).next(this._shiftDragAdjustSensitivity(a4)).next(this._shiftDragUpdatePlane(a4)), i.next(() => {
        null != s3 && this._updateBoundedPlane(s3);
      });
    });
  }
  _shiftDragAdjustSensitivity(t8) {
    return (e3) => {
      if (null == this.analysisViewData.plane) return null;
      const i = 1e-3, a4 = Math.min((1 - Math.abs(P(ds(this.analysisViewData.plane), e3.ray.direction) / s(e3.ray.direction))) / i, 1), s3 = -V(this._startPlane.plane, e3.renderEnd), n6 = -V(this._startPlane.plane, t8.startPoint);
      return t8.depth = t8.depth * (1 - a4) + s3 * a4 - n6, e3;
    };
  }
  _shiftDragUpdatePlane(t8) {
    return () => {
      if (null == this.analysisViewData.plane) return;
      const e3 = r(c3.get(), this._startPlane.origin), i = r(c3.get(), ds(this._startPlane));
      g(i, i, -t8.depth), u2(i, i, e3);
      const a4 = H(i, this.analysisViewData.plane.basis1, this.analysisViewData.plane.basis2, W());
      this._updateBoundedPlane(a4);
    };
  }
  _onRotateHeadingGrab(t8) {
    if ("start" !== t8.action || null == this.analysisViewData.plane || !t8.screenPoint) return;
    const e3 = li(this.analysisViewData.plane, this.view.renderCoordsHelper, _i.HEADING, E()), i = m2(this.view.state.camera, t8.screenPoint, xt), a4 = n2();
    S2(e3, i, a4) && (Z(this.analysisViewData.plane, this._startPlane), this.inputState = {
      type: "rotate",
      rotatePlane: e3,
      startPoint: a4
    });
  }
  _createRotateHeadingDragPipeline(t8) {
    return p2(t8, (t9, e3, i) => {
      const a4 = this.inputState;
      if (null == a4 || "rotate" !== a4.type) return;
      const s3 = null != this.analysisViewData.plane ? Z(this.analysisViewData.plane, W()) : null;
      e3.next(O2(this.view, a4.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(a4)).next(this._rotateDragUpdatePlaneFromRotate()), i.next(() => {
        null != s3 && this._updateBoundedPlane(s3);
      });
    });
  }
  _onRotateTiltGrab(t8) {
    if ("start" !== t8.action || null == this.analysisViewData.plane || !t8.screenPoint) return;
    const e3 = li(this.analysisViewData.plane, this.view.renderCoordsHelper, _i.TILT, E()), i = m2(this.view.state.camera, t8.screenPoint, xt), a4 = n2();
    S2(e3, i, a4) && (Z(this.analysisViewData.plane, this._startPlane), this.inputState = {
      type: "rotate",
      rotatePlane: e3,
      startPoint: a4
    });
  }
  _createRotateTiltDragPipeline(t8) {
    return p2(t8, (t9, e3, i) => {
      const a4 = this.inputState;
      if (null == a4 || "rotate" !== a4.type) return;
      const s3 = null != this.analysisViewData.plane ? Z(this.analysisViewData.plane, W()) : null;
      e3.next(O2(this.view, a4.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(a4)).next(this._rotateDragUpdatePlaneFromRotate()), i.next(() => {
        null != s3 && this._updateBoundedPlane(s3);
      });
    });
  }
  _rotateDragRenderPlaneToRotate(t8) {
    return (e3) => {
      if (null == this.analysisViewData.plane) return null;
      const i = F(t8.rotatePlane), a4 = w(t8.startPoint, e3.renderEnd, this.analysisViewData.plane.origin, i);
      return __spreadProps(__spreadValues({}, e3), {
        rotateAxis: i,
        rotateAngle: a4
      });
    };
  }
  _rotateDragUpdatePlaneFromRotate() {
    return (t8) => {
      if (null == this.analysisViewData.plane) return;
      const e3 = p(f2.get(), t8.rotateAngle, t8.rotateAxis);
      if (null == e3) return;
      const i = O(c3.get(), this._startPlane.basis1, e3), a4 = O(c3.get(), this._startPlane.basis2, e3), s3 = H(this.analysisViewData.plane.origin, i, a4, W());
      this._updateBoundedPlane(s3);
    };
  }
  _onResizeGrab(t8, e3) {
    if ("start" !== t8.action || null == this.analysisViewData.plane || !t8.screenPoint) return;
    const i = m2(this.view.state.camera, t8.screenPoint, xt), a4 = c3.get();
    S2(this.analysisViewData.plane.plane, i, a4) && (Z(this.analysisViewData.plane, this._startPlane), this.inputState = {
      type: "resize",
      activeHandleIdx: e3,
      startPoint: t(a4)
    });
  }
  _createResizeDragPipeline(t8) {
    return p2(t8, (t9, e3, i) => {
      const a4 = this.inputState;
      if (null == a4 || "resize" !== a4.type || null == this.analysisViewData.plane) return;
      const s3 = Z(this.analysisViewData.plane, W());
      e3.next(O2(this.view, this.analysisViewData.plane.plane)).next(this._resizeDragUpdatePlane(a4)), i.next(() => {
        this._updateBoundedPlane(s3);
      });
    });
  }
  _resizeDragUpdatePlane(t8) {
    return (e3) => {
      if (null == this.analysisViewData.plane) return;
      const i = this._resizeHandles[t8.activeHandleIdx], a4 = ri(i, t8.startPoint, e3.renderEnd, this.view.state.camera, this._startPlane, Z(this.analysisViewData.plane));
      this._updateBoundedPlane(a4);
    };
  }
  _updateBoundedPlane(t8) {
    const e3 = this.analysisViewData;
    if (null == e3) throw new Error("valid internal object expected");
    e3.plane = t8;
  }
  _updatePreviewPlane(t8, e3 = {}) {
    let i = this._previewPlane;
    if (this._previewPlane = null, null == t8) return this._removeFrameTask(), void this._updateManipulators();
    if (!this.analysisViewData.plane && this.active) {
      const a4 = null != i ? i : W();
      if (i = null != i ? Z(i, St) : null, this._pickPlane(t8, true, e3, a4)) {
        const t9 = f3;
        let e4 = false;
        null != i && (e4 = P(F(i.plane), F(a4.plane)) < t9 || P(z(c3.get(), i.basis1), z(c3.get(), a4.basis1)) < t9), e4 && (this._previewPlaneOpacity = 0), this._previewPlane = a4;
      }
    }
    null != this._previewPlane && null == this._frameTask && 0 === this._previewPlaneOpacity ? this._frameTask = A({
      update: ({
        deltaTime: t9
      }) => {
        this._previewPlaneOpacity = Math.min(this._previewPlaneOpacity + t9 / (1e3 * p3), 1), this._updateManipulators(), 1 === this._previewPlaneOpacity && this._removeFrameTask();
      }
    }) : null == this._previewPlane && null != this._frameTask ? this._removeFrameTask() : null != this._previewPlane && this._updateManipulators();
  }
  _removeFrameTask() {
    this._frameTask = l(this._frameTask);
  }
  _pickMinResult(t8) {
    const e3 = d2(t8, t3.get());
    return this.view.sceneIntersectionHelper.intersectToolIntersectorScreen(e3, this._intersector), this._intersector.results.min;
  }
  _pickPlane(t8, e3, i, a4) {
    const s3 = this._pickMinResult(t8), n6 = c3.get();
    if (!s3.getIntersectionPoint(n6)) return false;
    const r3 = s3.getTransformedNormal(c3.get()), l3 = this.view.state.camera;
    P(r3, l3.viewForward) > 0 && g(r3, r3, -1);
    const o4 = si(n6, l3), h5 = (e3 ? 1 : -1) * o4 * h3, p4 = g(c3.get(), r3, h5);
    u2(p4, p4, n6);
    const u3 = this.analysis.tiltEnabled ? Mi.TILTED : Mi.HORIZONTAL_OR_VERTICAL, c6 = i[r2] ? Mi.VERTICAL : i[t7] ? Mi.HORIZONTAL : u3;
    return ei(p4, r3, o4, o4, l3, c6, this.view.renderCoordsHelper, a4), true;
  }
  _clearPointerMoveTimeout() {
    this._prevPointerMoveTimeout = l(this._prevPointerMoveTimeout);
  }
  _resetPointerMoveTimeout() {
    this._clearPointerMoveTimeout(), this.shiftManipulator.state |= Ci, this.rotateHeadingManipulator.state |= Ci, this.rotateTiltManipulator.state |= Ci, this._prevPointerMoveTimeout = this._clock.setTimeout(() => {
      this.shiftManipulator.state &= ~Ci, this.rotateHeadingManipulator.state &= ~Ci, this.rotateTiltManipulator.state &= ~Ci;
    }, this._pointerMoveTimerMs);
  }
  _updateManipulators() {
    if (Vt.disableEngineLayers) return;
    let t8, e3 = false;
    if (null != this.analysisViewData.plane) t8 = this.analysisViewData.plane, e3 = false;
    else {
      if (null == this._previewPlane) return this.shiftManipulator.available = false, this.rotateHeadingManipulator.available = false, this.rotateTiltManipulator.available = false, this.resizeManipulators.forEach((t9) => t9.available = false), this._previewPlaneOutlineVisualElement.visible = false, void (this._previewPlaneGridVisualElement.visible = false);
      t8 = this._previewPlane, e3 = true;
    }
    const i = ci(t8, f2.get());
    e3 ? (this.shiftManipulator.available = false, this.rotateHeadingManipulator.available = false, this.rotateTiltManipulator.available = false, this.resizeManipulators.forEach((t9) => t9.available = false), this._previewPlaneOutlineVisualElement.attached = true, this._previewPlaneGridVisualElement.attached = true, this._previewPlaneOutlineVisualElement.visible = true, this._previewPlaneGridVisualElement.visible = true) : (this.shiftManipulator.available = true, this.rotateHeadingManipulator.available = true, this.rotateTiltManipulator.available = this.analysis.tiltEnabled, this.resizeManipulators.forEach((t9) => t9.available = true), ui(this.shiftManipulator, i, t8, this.view.state.camera), mi(this.rotateHeadingManipulator, i, t8, this.view.renderCoordsHelper), pi(this.rotateTiltManipulator, i, t8), this.resizeManipulators.forEach((e4, a5) => gi(e4, this._resizeHandles[a5], i, t8)), this._previewPlaneOutlineVisualElement.visible = false, this._previewPlaneGridVisualElement.visible = false);
    const a4 = o2(c3.get(), s(t8.basis1), s(t8.basis2), 1), s3 = d3(f2.get(), a4), n6 = c2(s3, i, s3);
    this._previewPlaneOutlineVisualElement.transform = n6, this._previewPlaneGridVisualElement.transform = n6, this._updateMaterials();
  }
  _updateMaterials() {
    const t8 = e2(this.view.effectiveTheme);
    t8[3] *= this._previewPlaneOpacity;
    const e3 = t2(t6);
    e3[3] *= this._previewPlaneOpacity, this._previewPlaneOutlineVisualElement.color = t8, this._previewPlaneGridVisualElement.backgroundColor = e3, this._previewPlaneGridVisualElement.gridColor = _;
  }
  _updateManipulatorsInteractive(t8) {
    if (!t8.grabbing) return this.shiftManipulator.interactive = true, this.rotateHeadingManipulator.interactive = true, this.rotateTiltManipulator.interactive = true, void this.resizeManipulators.forEach((t9) => {
      t9.interactive = true;
    });
    this.shiftManipulator.interactive = this.shiftManipulator === t8, this.rotateHeadingManipulator.interactive = this.rotateHeadingManipulator === t8, this.rotateTiltManipulator.interactive = this.rotateTiltManipulator === t8, this.resizeManipulators.forEach((e3) => {
      e3.interactive = e3 === t8;
    });
  }
  testData() {
    return {
      plane: this.analysisViewData.plane,
      setPointerMoveTimerMs: (t8) => {
        this._pointerMoveTimerMs = t8;
      }
    };
  }
};
bt.disableEngineLayers = false, e([y()], bt.prototype, "_clock", void 0), e([y({
  constructOnly: true
})], bt.prototype, "view", void 0), e([y()], bt.prototype, "analysisViewData", void 0), e([y({
  readOnly: true
})], bt.prototype, "state", null), e([y({
  readOnly: true
})], bt.prototype, "cursor", null), e([y()], bt.prototype, "analysis", null), e([y()], bt.prototype, "removeIncompleteOnCancel", void 0), e([y()], bt.prototype, "_layersMode", void 0), e([y()], bt.prototype, "layersMode", null), e([y({
  value: null
})], bt.prototype, "inputState", null), e([y()], bt.prototype, "_isPlacingSlicePlane", null), e([y()], bt.prototype, "_creatingPointerId", null), bt = Vt = e([a("esri.views.3d.analysis.Slice.SliceTool")], bt);
var Tt = bt;
function Et(t8, e3, i, a4) {
  const s3 = ai(i, ds(a4), t8.direction, E()), n6 = n2();
  return S2(s3, t8, n6) ? {
    type: "shift",
    creatingPointerId: e3,
    hasBeenDragged: false,
    shiftPlane: s3,
    depth: 0,
    startPoint: n6
  } : null;
}
function kt(t8) {
  return "mouse" !== t8.pointerType || 0 === t8.button;
}
var St = W();
var xt = m();

// ../../../node_modules/@arcgis/core/views/3d/analysis/Slice/SliceVisualization.js
var b = class extends S {
  constructor(i) {
    super(i), this._gridVisualElement = null, this._outlineVisualElement = null, this.showGrid = false, this.preview = true;
  }
  initialize() {
    const i = this.analysisViewData;
    if (null == i) throw new Error("expected internal object to be valid");
    this._gridVisualElement = ji(this.view), this._outlineVisualElement = Ai(this.view), this.addHandles([d(() => {
      const e3 = null != i.plane && this.analysisViewData.visible, {
        active: t8
      } = this.analysisViewData, {
        preview: s3,
        showGrid: o4,
        view: r3
      } = this, {
        effectiveTheme: l3
      } = r3;
      return {
        visible: e3,
        active: t8,
        preview: s3,
        showGrid: o4,
        gridColor: c4(l3),
        outlineColor: e2(l3)
      };
    }, (i2) => this._updateMaterials(i2), A2), d(() => i.plane, (i2) => this._updatePlane(i2), A2)], "internal");
  }
  destroy() {
    this._gridVisualElement = u(this._gridVisualElement), this._outlineVisualElement = u(this._outlineVisualElement), this.set("view", null);
  }
  _updatePlane(i) {
    if (null == i) return;
    this._gridVisualElement.attached = true, this._outlineVisualElement.attached = true;
    const e3 = o2(c3.get(), s(i.basis1), s(i.basis2), 1), t8 = d3(f2.get(), e3), s3 = ci(i, f2.get()), o4 = c2(t8, s3, t8);
    this._outlineVisualElement.transform = o4, this._gridVisualElement.transform = o4;
  }
  _updateMaterials({
    visible: i,
    active: e3,
    preview: t8,
    showGrid: s3,
    gridColor: o4,
    outlineColor: r3
  }) {
    this._outlineVisualElement.color = r3, this._outlineVisualElement.width = t8 ? M : j, this._outlineVisualElement.stipplePattern = e3 ? null : h(5), this._gridVisualElement.backgroundColor = t6, this._gridVisualElement.gridColor = s3 ? o4 : _, this._gridVisualElement.visible = i, this._outlineVisualElement.visible = i;
  }
};
e([y()], b.prototype, "view", void 0), e([y()], b.prototype, "analysis", void 0), e([y()], b.prototype, "analysisViewData", void 0), e([y()], b.prototype, "showGrid", void 0), e([y()], b.prototype, "preview", void 0), b = e([a("esri.views.3d.analysis.Slice.SliceVisualization")], b);

// ../../../node_modules/@arcgis/core/views/3d/analysis/SliceAnalysisView3D.js
var h4 = class extends s2(S) {
  constructor(s3) {
    super(s3), this.type = "slice-view-3d", this.analysis = null, this.tool = null, this.analysisVisualization = null, this.analysisController = null, this.plane = null, this.active = true;
  }
  initialize() {
    this.analysisVisualization = new b({
      view: this.view,
      analysis: this.analysis,
      analysisViewData: this
    }), this.analysisController = new v3({
      view: this.view,
      analysis: this.analysis,
      analysisViewData: this
    }), this.addHandles(a2(this, Tt));
  }
  destroy() {
    v(this), this.analysisVisualization = u(this.analysisVisualization), this.analysisController = u(this.analysisController);
  }
  get showGrid() {
    return this.analysisVisualization?.showGrid ?? false;
  }
  set showGrid(s3) {
    this.analysisVisualization && (this.analysisVisualization.showGrid = s3);
  }
  get editable() {
    return !this.analysisVisualization.preview;
  }
  set editable(s3) {
    this.analysisVisualization.preview = !s3;
  }
  get testData() {
  }
};
e([y({
  readOnly: true
})], h4.prototype, "type", void 0), e([y({
  constructOnly: true,
  nonNullable: true
})], h4.prototype, "analysis", void 0), e([y()], h4.prototype, "tool", void 0), e([y()], h4.prototype, "plane", void 0), e([y()], h4.prototype, "active", void 0), e([y()], h4.prototype, "showGrid", null), e([y()], h4.prototype, "editable", null), h4 = e([a("esri.views.3d.analysis.SliceAnalysisView3D")], h4);
var c5 = h4;
export {
  c5 as default
};
//# sourceMappingURL=SliceAnalysisView3D-XC2OFQWM.js.map
