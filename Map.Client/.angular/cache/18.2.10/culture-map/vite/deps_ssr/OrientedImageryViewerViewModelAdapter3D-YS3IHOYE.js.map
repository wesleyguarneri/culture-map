{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/widgets/OrientedImageryViewer/adapters/OrientedImageryViewerViewModelAdapter3D.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport \"../../../geometry.js\";\nimport e from \"../../../Graphic.js\";\nimport { isSome as t } from \"../../../core/arrayUtils.js\";\nimport { throwIfAborted as i, waitTick as r } from \"../../../core/promiseUtils.js\";\nimport { ensureType as o } from \"../../../core/accessorSupport/ensureType.js\";\nimport a from \"../../../geometry/Mesh.js\";\nimport { projectWithZConversion as s } from \"../../../geometry/projection.js\";\nimport { MeshVertexAttributes as n } from \"../../../geometry/support/MeshVertexAttributes.js\";\nimport { projectVertices as l, updateFrustum as c, createCoveragePolygon as m } from \"../../../layers/orientedImagery/core/coverageUtils.js\";\nimport { transformPoints as p } from \"../../../layers/orientedImagery/transformations/imageToGroundUtils.js\";\nimport { activeFrustumSymbol as u, additionalFrustumSymbol as f } from \"../symbols.js\";\nimport g from \"../../../geometry/Point.js\";\nclass w {\n  constructor(g) {\n    this.viewModel = g, this.createFootprints = async r => {\n      const {\n          coverageFrustums: o,\n          currentBestFeature: c,\n          isAdditionalCoverageVisible: m,\n          view: p\n        } = this.viewModel,\n        g = o.filter(t);\n      for (const t of g) {\n        let o = t.clone();\n        if (!p.spatialReference.equals(o.spatialReference)) {\n          const {\n            components: e,\n            spatialReference: t,\n            origin: c,\n            vertexAttributes: m,\n            vertexSpace: u\n          } = o;\n          if (\"local\" === u.type) {\n            const e = await s(c, p.spatialReference, r);\n            i(r), o.centerAt(e);\n          } else {\n            const s = m.position,\n              c = Float64Array.from(await l([...s], t.clone(), p.spatialReference.clone(), r));\n            i(r), o = new a({\n              vertexAttributes: new n({\n                position: c\n              }),\n              components: e,\n              spatialReference: p.spatialReference.clone()\n            });\n          }\n        }\n        t.imageID === c.attributes.objectId ? this.viewModel.bestFeatureFootprint = new e({\n          attributes: {\n            imageID: t.imageID\n          },\n          geometry: o,\n          symbol: u.clone(),\n          visible: !1\n        }) : this.viewModel.additionalFootprints.push(new e({\n          attributes: {\n            imageID: t.imageID\n          },\n          geometry: o,\n          symbol: f.clone(),\n          visible: m\n        }));\n      }\n    }, this.updateFootprint = async (r, n) => {\n      const {\n          currentBestFeature: l,\n          imagePointsInView: m,\n          activeViewer: f,\n          footprintExtent: g,\n          view: w\n        } = this.viewModel,\n        y = o(a, this.viewModel.getCurrentBestFeaturePolygon().geometry),\n        h = f?.imageSize;\n      if (!(l && y && m && h && g)) return;\n      const {\n          cameraHeight: v,\n          location: b,\n          cameraPitch: F,\n          horizontalFieldOfView: R,\n          verticalFieldOfView: j,\n          cameraRoll: M,\n          imageRotation: V\n        } = l.attributes,\n        I = b.toArray(),\n        {\n          vertexAttributes: {\n            position: A\n          },\n          spatialReference: P\n        } = y,\n        x = await d(A, P, b.spatialReference),\n        z = await p(r, {\n          feature: l,\n          imageProperties: {\n            width: h[0],\n            height: h[1]\n          },\n          options: n,\n          footprintExtent: g\n        });\n      i(n);\n      let C = z.filter(t);\n      if (!C.length) return;\n      C[0].spatialReference.equals(b.spatialReference) || (C = await Promise.all(C.map(async e => {\n        const t = await s(e, b.spatialReference, n);\n        return i(n), t;\n      })));\n      const O = await c(m.slice(0, 4).map(({\n        x: e,\n        y: t\n      }) => [e, t]), C.slice(0, 4).map(e => e.toArray()), {\n        cameraHeight: v,\n        cameraLocation: I,\n        cameraPitch: F,\n        frustumVertices: x,\n        horizontalFieldOfView: R,\n        imageHeight: h[1],\n        imageWidth: h[0],\n        inSRS: {\n          wkid: b.spatialReference.wkid\n        },\n        outSRS: {\n          wkid: w.spatialReference.wkid\n        },\n        verticalFieldOfView: j,\n        cameraRoll: M ?? 0,\n        imageRotation: V ?? 0,\n        options: n\n      });\n      this.viewModel.updateCurrentCoveragePolygon(new e({\n        attributes: {\n          imageID: l.attributes.objectId\n        },\n        geometry: O,\n        symbol: u.clone(),\n        visible: this.viewModel.currentCoverageVisible\n      }));\n    }, this.updateFootprintPanorama = async (t, i) => {\n      await r(i);\n      const {\n          horizontalFieldOfView: o,\n          pitch: a,\n          verticalFieldOfView: s,\n          yaw: n\n        } = t,\n        l = this.viewModel.currentBestFeature?.clone();\n      if (!l) return;\n      const {\n        attributes: c\n      } = l;\n      c.orientedImageryType = null, c.cameraHeading = (n + c.cameraHeading) % 360, c.cameraPitch = a, c.horizontalFieldOfView = o, c.verticalFieldOfView = s, c.cameraRoll = 0;\n      const {\n        frustum: p\n      } = m(c);\n      p && this.viewModel.updateCurrentCoveragePolygon(new e({\n        attributes: {\n          imageID: c.objectId\n        },\n        geometry: p,\n        symbol: u.clone(),\n        visible: this.viewModel.currentCoverageVisible\n      }));\n    };\n  }\n  updateGroundElevation(e, t) {\n    const {\n        geometry: i\n      } = this.viewModel.currentBestFeature,\n      r = t.queryElevation(i);\n    e.forEach(e => {\n      const {\n        geometry: t\n      } = e;\n      switch (t?.type) {\n        case \"mesh\":\n          {\n            const {\n                vertexAttributes: {\n                  position: e\n                }\n              } = t,\n              i = Math.floor(e.length / 3);\n            for (let t = 0; t < i; t += 1) e[3 * t + 2] += r?.z ?? 0;\n            break;\n          }\n        case \"point\":\n          t.z = (t.z ?? 0) + (r?.z ?? 0);\n      }\n    });\n  }\n}\nasync function d(e, t, i, r) {\n  return Float64Array.from((await Promise.all(e.reduce((e, t, i) => {\n    const r = Math.floor(i / 3);\n    return e[r] = e[r] ?? [], e[r].push(t), e;\n  }, new Array()).map(async e => (await s(new g(e, t), i, r)).toArray()))).flat());\n}\nexport { w as default };"],
  "mappings": "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",
  "names": ["g", "o", "t", "c", "m", "u", "e", "s", "l", "w", "b", "M", "I", "d", "O", "i", "r"]
}
