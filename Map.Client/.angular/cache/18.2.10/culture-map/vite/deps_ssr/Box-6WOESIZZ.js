import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  h as h4
} from "./chunk-SMONMTHO.js";
import {
  U
} from "./chunk-PW6RRNPT.js";
import {
  a as a3,
  i as i3,
  m as m3,
  s as s2
} from "./chunk-4VYDNFW7.js";
import {
  h as h3
} from "./chunk-YJ3POSXJ.js";
import {
  e as e3
} from "./chunk-BUA2HOYZ.js";
import {
  i as i2,
  o as o2,
  s
} from "./chunk-TT3OASJY.js";
import {
  i
} from "./chunk-YE26MSDV.js";
import {
  h as h2
} from "./chunk-7B3BAV5J.js";
import "./chunk-L2VTN5PI.js";
import {
  l
} from "./chunk-R3ALLGC4.js";
import "./chunk-HIZXJ32N.js";
import "./chunk-JGJES5EN.js";
import "./chunk-7J24PH7A.js";
import {
  m as m2
} from "./chunk-PVR7HFZS.js";
import "./chunk-2I3RVFNX.js";
import "./chunk-MH54QISY.js";
import "./chunk-JEWURWPQ.js";
import "./chunk-DUZT23UA.js";
import "./chunk-ZEZCWQFR.js";
import "./chunk-6NBMJUQX.js";
import "./chunk-IVVINOEJ.js";
import "./chunk-DUSY4H5O.js";
import "./chunk-WQIJCG2D.js";
import "./chunk-BZGBXDFF.js";
import "./chunk-LUORW76W.js";
import "./chunk-62PN4TEW.js";
import "./chunk-OPXEKSUB.js";
import "./chunk-P6I54QB7.js";
import "./chunk-NDXKLAFE.js";
import "./chunk-WYPPXVX7.js";
import {
  h
} from "./chunk-T2SCEBLQ.js";
import "./chunk-XP4RC2MQ.js";
import "./chunk-MXW2KGHZ.js";
import "./chunk-O7RCHW3H.js";
import "./chunk-HKAONIBH.js";
import "./chunk-B76NC7GX.js";
import "./chunk-EFLOBCAZ.js";
import "./chunk-QRWQ6QBB.js";
import "./chunk-ZSJNH2BT.js";
import "./chunk-ZFES27RA.js";
import "./chunk-XP2AJZUL.js";
import "./chunk-NHYYZMJR.js";
import "./chunk-BZHHBBFX.js";
import "./chunk-GK5M6FUR.js";
import "./chunk-Y7SJWJAL.js";
import "./chunk-X36BR2QB.js";
import "./chunk-RGG3YJQA.js";
import {
  d as d3
} from "./chunk-NVOJILW6.js";
import "./chunk-KYPTWEOO.js";
import "./chunk-WVFB3H4O.js";
import "./chunk-ZREJ3Y2F.js";
import "./chunk-IR6CVPPC.js";
import "./chunk-BBUQOCRA.js";
import "./chunk-YBUJLIWZ.js";
import "./chunk-DL2B6IFJ.js";
import "./chunk-VOOO6FU5.js";
import {
  S
} from "./chunk-IUPJR3FF.js";
import {
  y as y2
} from "./chunk-TGZW6QWO.js";
import {
  d as d2
} from "./chunk-OYIDHTXG.js";
import "./chunk-KUBMHTYA.js";
import "./chunk-42ZAWY2C.js";
import "./chunk-TVHVZK5G.js";
import "./chunk-P2MUOE6G.js";
import "./chunk-6EIBUVMG.js";
import "./chunk-S4XQLN73.js";
import "./chunk-YCXNHEGB.js";
import "./chunk-CSATD3VX.js";
import "./chunk-NXXQ35YM.js";
import "./chunk-LM3JDV4W.js";
import "./chunk-34V2CLL5.js";
import "./chunk-7V4JSBFA.js";
import "./chunk-EO2EW5KR.js";
import "./chunk-JEFPXTYT.js";
import "./chunk-MVS2BECH.js";
import "./chunk-UZ7IOCF3.js";
import "./chunk-TPLUZX3A.js";
import "./chunk-BGLJ2FAH.js";
import "./chunk-2EJFYNM7.js";
import "./chunk-DC5LRNPY.js";
import "./chunk-ASCK5HJ5.js";
import "./chunk-5X5U7R6O.js";
import "./chunk-XNLAOXPY.js";
import "./chunk-ZT7V2AVD.js";
import "./chunk-C2OXE4NQ.js";
import "./chunk-KOI252FF.js";
import "./chunk-I2TVVMQ6.js";
import "./chunk-5EGQYY2H.js";
import "./chunk-JKPUNUQA.js";
import "./chunk-SR7PRON4.js";
import "./chunk-HGHPYGKP.js";
import "./chunk-4DSGTDZJ.js";
import "./chunk-VYTPFEL2.js";
import "./chunk-RLGDH6IY.js";
import {
  j,
  m2 as m,
  u as u2,
  x
} from "./chunk-MRPCXIVS.js";
import {
  a as a2,
  e as e2
} from "./chunk-YTKVV2Y3.js";
import {
  u as u3
} from "./chunk-GCVQXAS4.js";
import "./chunk-UFQD6AL4.js";
import "./chunk-HEG4CVDM.js";
import "./chunk-UVQYXHKM.js";
import "./chunk-M5N6UHWJ.js";
import "./chunk-EBCBYN6Y.js";
import "./chunk-ODFKYX74.js";
import "./chunk-EGBDRLCX.js";
import "./chunk-THZPD5CT.js";
import "./chunk-OBCA6CWH.js";
import "./chunk-2JI245BP.js";
import "./chunk-N34BRXVM.js";
import "./chunk-KETDH2J4.js";
import "./chunk-7QV7DHWN.js";
import "./chunk-4L4Y34YK.js";
import "./chunk-BXONKQKI.js";
import "./chunk-2HDBQXAR.js";
import "./chunk-RNF7VOCU.js";
import {
  _
} from "./chunk-TIRJMGGG.js";
import "./chunk-ZDRQSPB6.js";
import "./chunk-DCXDXGAR.js";
import "./chunk-BCCDYCTQ.js";
import "./chunk-AYL3HQHD.js";
import "./chunk-66YQWHHE.js";
import "./chunk-QGBMZIP4.js";
import "./chunk-AOEBZVTA.js";
import "./chunk-2OZSYJDX.js";
import "./chunk-MZM4INJV.js";
import "./chunk-J4GMQHGL.js";
import "./chunk-MHPE4SZA.js";
import "./chunk-6SSA7P3A.js";
import "./chunk-FQBTLEUI.js";
import "./chunk-GS7Y3YOG.js";
import "./chunk-Y2HYKTTT.js";
import "./chunk-XLEC46FY.js";
import "./chunk-4AZPIP7K.js";
import "./chunk-JSKTDZU2.js";
import "./chunk-G73HQZEL.js";
import {
  A,
  P,
  d,
  p
} from "./chunk-LZSLQ24Q.js";
import "./chunk-U3RHUXYK.js";
import "./chunk-7DBI6LQG.js";
import "./chunk-AUUN7RFQ.js";
import {
  o
} from "./chunk-JAMSDYD6.js";
import "./chunk-PH6NPTP7.js";
import {
  e
} from "./chunk-NUICEVIH.js";
import "./chunk-NXK752PZ.js";
import {
  y
} from "./chunk-UVNLCXWD.js";
import "./chunk-PNUA7JOS.js";
import "./chunk-OR2FKGUM.js";
import {
  a3 as a
} from "./chunk-UDMPWVPF.js";
import "./chunk-XJNKCEWL.js";
import "./chunk-AIZ3T7E3.js";
import "./chunk-6UEMNP3E.js";
import {
  u
} from "./chunk-6WGE3IUL.js";
import "./chunk-MLYB2YW4.js";
import "./chunk-6JFGZTLU.js";
import "./chunk-2ZJE6ZFX.js";
import "./chunk-L4CMR4WM.js";
import "./chunk-7JIACICA.js";
import "./chunk-IE4UBD3F.js";
import "./chunk-IAO6HACY.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-XBPEBUD5.js";

// ../../../node_modules/@arcgis/core/geometry/support/rotate.js
function o3(n, e4, t, s3) {
  const i4 = [];
  for (const o4 of n) {
    const n2 = o4.slice(0);
    i4.push(n2);
    const r2 = e4 * (o4[0] - s3.x) - t * (o4[1] - s3.y) + s3.x, a4 = t * (o4[0] - s3.x) + e4 * (o4[1] - s3.y) + s3.y;
    n2[0] = r2, n2[1] = a4;
  }
  return i4;
}
function r(r2, a4, c) {
  const {
    hasM: m4,
    hasZ: x2,
    spatialReference: f
  } = r2, p2 = a4 * Math.PI / 180, l2 = Math.cos(p2), h5 = Math.sin(p2);
  if ("xmin" in r2 && (c = c ?? r2.center, r2 = new j({
    spatialReference: f,
    rings: [[[r2.xmin, r2.ymin], [r2.xmin, r2.ymax], [r2.xmax, r2.ymax], [r2.xmax, r2.ymin], [r2.xmin, r2.ymin]]]
  })), "paths" in r2) {
    c = c ?? r2.extent.center;
    const n = [];
    for (const e4 of r2.paths) n.push(o3(e4, l2, h5, c));
    return new m({
      hasM: m4,
      hasZ: x2,
      spatialReference: f,
      paths: n
    });
  }
  if ("rings" in r2) {
    c = c ?? r2.extent.center;
    const t = [];
    for (const e4 of r2.rings) {
      const s3 = a2(e4), i4 = o3(e4, l2, h5, c);
      a2(i4) !== s3 && i4.reverse(), t.push(i4);
    }
    return new j({
      hasM: m4,
      hasZ: x2,
      spatialReference: f,
      rings: t
    });
  }
  if ("x" in r2) {
    c = c ?? r2;
    const n = new _({
      x: l2 * (r2.x - c.x) - h5 * (r2.y - c.y) + c.x,
      y: h5 * (r2.x - c.x) + l2 * (r2.y - c.y) + c.y,
      spatialReference: f
    });
    return null != r2.z && (n.z = r2.z), null != r2.m && (n.m = r2.m), n;
  }
  return "points" in r2 ? (c = c ?? r2.extent.center, new u2({
    hasM: m4,
    hasZ: x2,
    points: o3(r2.points, l2, h5, c),
    spatialReference: f
  })) : null;
}

// ../../../node_modules/@arcgis/core/views/draw/support/Box.js
var z = class {
  constructor(t, e4, i4, s3) {
    this.graphics = t, this.mover = e4, this.dx = i4, this.dy = s3, this.type = "move-start";
  }
};
var B = class {
  constructor(t, e4, i4, s3) {
    this.graphics = t, this.mover = e4, this.dx = i4, this.dy = s3, this.type = "move";
  }
};
var Y = class {
  constructor(t, e4, i4, s3) {
    this.graphics = t, this.mover = e4, this.dx = i4, this.dy = s3, this.type = "move-stop";
  }
};
var N = class {
  constructor(t, e4, i4) {
    this.graphics = t, this.mover = e4, this.angle = i4, this.type = "rotate-start";
  }
};
var U2 = class {
  constructor(t, e4, i4) {
    this.graphics = t, this.mover = e4, this.angle = i4, this.type = "rotate";
  }
};
var A2 = class {
  constructor(t, e4, i4) {
    this.graphics = t, this.mover = e4, this.angle = i4, this.type = "rotate-stop";
  }
};
var P2 = class {
  constructor(t, e4, i4, s3) {
    this.graphics = t, this.mover = e4, this.xScale = i4, this.yScale = s3, this.type = "scale-start";
  }
};
var X = class {
  constructor(t, e4, i4, s3) {
    this.graphics = t, this.mover = e4, this.xScale = i4, this.yScale = s3, this.type = "scale";
  }
};
var F = class {
  constructor(t, e4, i4, s3) {
    this.graphics = t, this.mover = e4, this.xScale = i4, this.yScale = s3, this.type = "scale-stop";
  }
};
var D = h4.transformGraphics;
var V = {
  centerIndicator: new y2({
    style: "cross",
    size: D.center.size,
    color: D.center.color
  }),
  fill: {
    default: new S({
      color: D.fill.color,
      outline: {
        color: D.fill.outlineColor,
        join: "round",
        width: 1
      }
    }),
    active: new S({
      color: D.fill.stagedColor,
      outline: {
        color: D.fill.outlineColor,
        join: "round",
        style: "dash",
        width: 1
      }
    })
  },
  handles: {
    default: new y2({
      style: "square",
      size: D.vertex.size,
      color: D.vertex.color,
      outline: {
        color: D.vertex.outlineColor,
        width: 1
      }
    }),
    hover: new y2({
      style: "square",
      size: D.vertex.hoverSize,
      color: D.vertex.hoverColor,
      outline: {
        color: D.vertex.hoverOutlineColor,
        width: 1
      }
    })
  },
  rotator: {
    default: new y2({
      style: "circle",
      size: D.vertex.size,
      color: D.vertex.color,
      outline: {
        color: D.vertex.outlineColor,
        width: 1
      }
    }),
    hover: new y2({
      style: "circle",
      size: D.vertex.hoverSize,
      color: D.vertex.hoverColor,
      outline: {
        color: D.vertex.hoverOutlineColor,
        width: 1
      }
    })
  },
  rotatorLine: new d2({
    color: D.line.color,
    width: 1
  })
};
var q = class extends o.EventedAccessor {
  constructor(t) {
    super(t), this._activeHandleGraphic = null, this._graphicAttributes = {
      esriSketchTool: "box"
    }, this._mover = null, this._centerGraphic = null, this._backgroundGraphic = null, this._vertexGraphics = [], this._rotateHandleGraphic = null, this._rotateGraphicOffset = 20, this._angleOfRotation = 0, this._rotateLineGraphic = null, this._startInfo = null, this._totalDx = 0, this._totalDy = 0, this._xScale = 1, this._yScale = 1, this.tooltip = null, this.type = "box", this.callbacks = {
      onMoveStart() {
      },
      onMove() {
      },
      onMoveStop() {
      },
      onScaleStart() {
      },
      onScale() {
      },
      onScaleStop() {
      },
      onRotateStart() {
      },
      onRotate() {
      },
      onRotateStop() {
      },
      onGraphicClick() {
      }
    }, this.enableMovement = true, this.enableRotation = true, this.enableScaling = true, this.graphics = [], this.highlightsEnabled = true, this.layer = null, this.preserveAspectRatio = false, this.showCenterGraphic = true, this.symbols = V, this.sketchOptions = new l(), this.view = null, this._getBounds = (() => {
      const t2 = u3();
      return (e4, i4) => {
        e4[0] = Number.POSITIVE_INFINITY, e4[1] = Number.POSITIVE_INFINITY, e4[2] = Number.NEGATIVE_INFINITY, e4[3] = Number.NEGATIVE_INFINITY;
        for (const s3 of i4) {
          if (!s3) continue;
          let i5, o4, r2, a4;
          if ("point" === s3.type) i5 = r2 = s3.x, o4 = a4 = s3.y;
          else if ("multipoint" === s3.type) {
            const e5 = e2(s3);
            [i5, o4, r2, a4] = x(t2, [e5]);
          } else if ("extent" === s3.type) [i5, o4, r2, a4] = [s3.xmin, s3.ymin, s3.xmax, s3.ymax];
          else {
            const e5 = e2(s3);
            [i5, o4, r2, a4] = x(t2, e5);
          }
          e4[0] = Math.min(i5, e4[0]), e4[1] = Math.min(o4, e4[1]), e4[2] = Math.max(r2, e4[2]), e4[3] = Math.max(a4, e4[3]);
        }
        return e4;
      };
    })();
  }
  initialize() {
    const t = this.view;
    this._highlightHelper = new h3({
      view: t
    }), this._setup(), this.addHandles([p(() => t?.ready, () => {
      const {
        layer: t2,
        view: e4
      } = this;
      e3(e4, t2);
    }, {
      once: true,
      initial: true
    }), d(() => this.preserveAspectRatio, () => {
      this._activeHandleGraphic && (this._scaleGraphic(this._activeHandleGraphic), this._updateGraphics(), this._updateTooltip(this._activeHandleGraphic));
    }), d(() => t?.scale, () => {
      this._updateRotateGraphic(), this._updateRotateLineGraphic();
    }), d(() => this.graphics, () => this.refresh()), d(() => this.layer, (t2, e4) => {
      e4 && this._resetGraphics(e4), this.refresh();
    }), d(() => this.highlightsEnabled, () => {
      this._highlightHelper?.removeAll(), this._setUpHighlights();
    }), d(() => this.sketchOptions.tooltips.effectiveEnabled, (t2) => {
      this.tooltip = t2 ? new h2({
        view: this.view
      }) : u(this.tooltip);
    }, A), d(() => this.view.effectiveTheme.accentColor, () => this._updateSymbolsForTheme(), P), this.on("move-start", (t2) => this.callbacks?.onMoveStart?.(t2)), this.on("move", (t2) => this.callbacks?.onMove?.(t2)), this.on("move-stop", (t2) => this.callbacks?.onMoveStop?.(t2)), this.on("rotate-start", (t2) => this.callbacks?.onRotateStart?.(t2)), this.on("rotate", (t2) => this.callbacks?.onRotate?.(t2)), this.on("rotate-stop", (t2) => this.callbacks?.onRotateStop?.(t2)), this.on("scale-start", (t2) => this.callbacks?.onScaleStart?.(t2)), this.on("scale", (t2) => this.callbacks?.onScale?.(t2)), this.on("scale-stop", (t2) => this.callbacks?.onScaleStop?.(t2))]);
  }
  destroy() {
    this._reset(), this.tooltip = u(this.tooltip);
  }
  get state() {
    const t = this.view?.ready ?? false, e4 = this.graphics.length && this.layer;
    return t && e4 ? "active" : t ? "ready" : "disabled";
  }
  isUIGraphic(t) {
    return this._vertexGraphics.includes(t) || t === this._backgroundGraphic || t === this._centerGraphic || t === this._rotateHandleGraphic || t === this._rotateLineGraphic;
  }
  move(t, e4) {
    if (this._mover && this.graphics.length) {
      for (const i4 of this.graphics) {
        const s3 = i4.geometry, o4 = i3(s3, t, e4, this.view);
        i4.geometry = o4;
      }
      this.refresh(), this.emit("move-stop", new Y(this.graphics, null, t, e4));
    }
  }
  scale(t, e4) {
    if (this._mover && this.graphics.length) {
      for (const i4 of this.graphics) {
        const s3 = i4.geometry, o4 = s2(s3, t, e4);
        i4.geometry = o4;
      }
      this.refresh(), this.emit("scale-stop", new F(this.graphics, null, t, e4));
    }
  }
  rotate(t, e4) {
    if (this._mover && this.graphics.length) {
      if (!e4) {
        const t2 = this._vertexGraphics[1].geometry.x, i4 = this._vertexGraphics[3].geometry.y;
        e4 = new _(t2, i4, this.view.spatialReference);
      }
      for (const i4 of this.graphics) {
        const s3 = i4.geometry, o4 = r(s3, t, e4);
        i4.geometry = o4;
      }
      this.refresh(), this.emit("rotate-stop", new A2(this.graphics, null, t));
    }
  }
  refresh() {
    this._reset(), this._setup();
  }
  reset() {
    this.graphics = [];
  }
  _setup() {
    "active" === this.state && (this._setUpHighlights(), this._setupGraphics(), this._setupMover(), this._updateGraphics());
  }
  _reset() {
    this._highlightHelper?.removeAll(), this._resetGraphicStateVars(), this._resetGraphics(), this._updateTooltip(), this._mover && this._mover.destroy(), this._mover = null, this.view.cursor = "default";
  }
  _resetGraphicStateVars() {
    this._startInfo = null, this._activeHandleGraphic = null, this._totalDx = 0, this._totalDy = 0, this._xScale = 1, this._yScale = 1, this._angleOfRotation = 0;
  }
  _resetGraphics(t) {
    (t = t || this.layer) && (t.removeMany(this._vertexGraphics), t.remove(this._backgroundGraphic), t.remove(this._centerGraphic), t.remove(this._rotateHandleGraphic), t.remove(this._rotateLineGraphic)), this._vertexGraphics.forEach((t2) => !t2.destroyed && t2.destroy()), !this._backgroundGraphic.destroyed && this._backgroundGraphic.destroy(), !this._centerGraphic.destroyed && this._centerGraphic.destroy(), !this._rotateHandleGraphic.destroyed && this._rotateHandleGraphic.destroy(), !this._rotateLineGraphic.destroyed && this._rotateLineGraphic.destroy(), this._vertexGraphics = [], this._backgroundGraphic = null, this._centerGraphic = null, this._rotateHandleGraphic = null, this._rotateLineGraphic = null;
  }
  _setupMover() {
    let t = [];
    this.enableScaling && (t = t.concat(this._vertexGraphics)), this.enableMovement && (t = t.concat(this.graphics, this._backgroundGraphic)), this.enableRotation && t.push(this._rotateHandleGraphic), this.showCenterGraphic && t.push(this._centerGraphic), this._mover = new U({
      enableMoveAllGraphics: false,
      highlightsEnabled: false,
      indicatorsEnabled: false,
      view: this.view,
      graphics: t,
      callbacks: {
        onGraphicClick: (t2) => this._onGraphicClickCallback(t2),
        onGraphicMoveStart: (t2) => this._onGraphicMoveStartCallback(t2),
        onGraphicMove: (t2) => this._onGraphicMoveCallback(t2),
        onGraphicMoveStop: (t2) => this._onGraphicMoveStopCallback(t2),
        onGraphicPointerOver: (t2) => this._onGraphicPointerOverCallback(t2),
        onGraphicPointerOut: (t2) => this._onGraphicPointerOutCallback(t2)
      }
    });
  }
  _getStartInfo(t) {
    const [e4, i4, s3, o4] = this._getBoxBounds(u3()), r2 = Math.abs(s3 - e4), a4 = Math.abs(o4 - i4), h5 = (s3 + e4) / 2, c = (o4 + i4) / 2, {
      x: n,
      y: l2
    } = t.geometry;
    return {
      width: r2,
      height: a4,
      centerX: h5,
      centerY: c,
      startX: n,
      startY: l2,
      graphicInfos: this._getGraphicInfos(),
      box: this._backgroundGraphic.geometry,
      rotate: this._rotateHandleGraphic.geometry
    };
  }
  _getGraphicInfos() {
    return this.graphics.map((t) => this._getGraphicInfo(t));
  }
  _getGraphicInfo(t) {
    const e4 = t.geometry, [i4, s3, o4, r2] = this._getBounds(u3(), [e4]);
    return {
      width: Math.abs(o4 - i4),
      height: Math.abs(r2 - s3),
      centerX: (o4 + i4) / 2,
      centerY: (r2 + s3) / 2,
      geometry: e4
    };
  }
  _onGraphicClickCallback(t) {
    t.viewEvent.stopPropagation(), this.emit("graphic-click", t), this.callbacks.onGraphicClick && this.callbacks.onGraphicClick(t);
  }
  _onGraphicMoveStartCallback(t) {
    const {
      _angleOfRotation: e4,
      _xScale: i4,
      _yScale: s3,
      _backgroundGraphic: o4,
      _vertexGraphics: r2,
      _rotateHandleGraphic: a4,
      symbols: h5
    } = this, c = t.graphic;
    this._resetGraphicStateVars(), this._hideGraphicsBeforeUpdate(), o4.symbol = h5.fill.active, this._startInfo = this._getStartInfo(c), this._updateTooltip(c, t.viewEvent), c === a4 ? (this.view.cursor = "grabbing", this.emit("rotate-start", new N(this.graphics, c, e4))) : r2.includes(c) ? (this._activeHandleGraphic = c, this.emit("scale-start", new P2(this.graphics, c, i4, s3))) : this.emit("move-start", new z(this.graphics, c, t.dx, t.dy));
  }
  _onGraphicMoveCallback(t) {
    const e4 = t.graphic;
    if (this._startInfo) if (this._vertexGraphics.includes(e4)) this._scaleGraphic(e4), this._updateTooltip(e4, t.viewEvent), this.emit("scale", new X(this.graphics, e4, this._xScale, this._yScale));
    else if (e4 === this._rotateHandleGraphic) this._rotateGraphic(e4), this._updateTooltip(e4, t.viewEvent), this.emit("rotate", new U2(this.graphics, e4, this._angleOfRotation));
    else {
      const {
        dx: i4,
        dy: s3
      } = t;
      this._totalDx += i4, this._totalDy += s3, this._moveGraphic(e4, i4, s3), this._updateTooltip(e4, t.viewEvent), this.emit("move", new B(this.graphics, e4, i4, s3));
    }
  }
  _onGraphicMoveStopCallback(t) {
    const e4 = t.graphic;
    if (!this._startInfo) return void this.refresh();
    const {
      _angleOfRotation: i4,
      _totalDx: s3,
      _totalDy: o4,
      _xScale: r2,
      _yScale: a4,
      _vertexGraphics: h5,
      _rotateHandleGraphic: c
    } = this;
    this.refresh(), e4 === c ? (this.view.cursor = "pointer", this.emit("rotate-stop", new A2(this.graphics, e4, i4))) : h5.includes(e4) ? this.emit("scale-stop", new F(this.graphics, e4, r2, a4)) : this.emit("move-stop", new Y(this.graphics, e4, s3, o4));
  }
  _onGraphicPointerOverCallback(t) {
    const {
      _backgroundGraphic: e4,
      _vertexGraphics: i4,
      graphics: s3,
      _rotateHandleGraphic: o4,
      symbols: r2,
      view: a4
    } = this, h5 = t.graphic;
    if (this._hoveredGraphic = h5, h5 === o4) return o4.symbol = r2.rotator.hover, a4.cursor = "pointer", void this._updateTooltip(h5);
    if (s3.includes(h5) || h5 === e4) return void (a4.cursor = "move");
    if (!i4.includes(h5)) return void (a4.cursor = "pointer");
    this._updateTooltip(h5), t.graphic.symbol = r2.handles.hover;
    const c = a4.rotation;
    let n, l2 = t.index;
    switch (l2 < 8 && (c >= 0 && c < 45 ? l2 %= 8 : l2 = c >= 45 && c < 90 ? (l2 + 1) % 8 : c >= 90 && c < 135 ? (l2 + 2) % 8 : c >= 135 && c < 180 ? (l2 + 3) % 8 : c >= 180 && c < 225 ? (l2 + 4) % 8 : c >= 225 && c < 270 ? (l2 + 5) % 8 : c >= 270 && c < 315 ? (l2 + 6) % 8 : (l2 + 7) % 8), l2) {
      case 0:
      case 4:
        n = "nwse-resize";
        break;
      case 1:
      case 5:
        n = "ns-resize";
        break;
      case 2:
      case 6:
        n = "nesw-resize";
        break;
      case 3:
      case 7:
        n = "ew-resize";
        break;
      default:
        n = "pointer";
    }
    a4.cursor = n;
  }
  _onGraphicPointerOutCallback(t) {
    const {
      _vertexGraphics: e4,
      _rotateHandleGraphic: i4,
      symbols: s3,
      view: o4
    } = this;
    this._hoveredGraphic = null, t.graphic === i4 ? i4.symbol = s3.rotator.default : e4.includes(t.graphic) && (t.graphic.symbol = s3.handles.default), o4.cursor = "default", this._updateTooltip();
  }
  _scaleGraphic(t) {
    const {
      _startInfo: e4,
      _vertexGraphics: i4,
      preserveAspectRatio: s3,
      view: o4
    } = this, {
      centerX: r2,
      centerY: a4,
      graphicInfos: h5,
      height: c,
      startX: n,
      startY: l2,
      width: p2
    } = e4, {
      resolution: _2,
      transform: d4
    } = o4.state, m4 = i4.indexOf(t);
    1 !== m4 && 5 !== m4 || this._updateX(t, r2), 3 !== m4 && 7 !== m4 || this._updateY(t, a4);
    const {
      x: u4,
      y: g
    } = t.geometry, y3 = d4[0] * u4 + d4[2] * g + d4[4], G = d4[1] * u4 + d4[3] * g + d4[5], w = h5?.map((t2) => t2.geometry) ?? [], x2 = w.every((t2) => "point" === t2.type);
    if ((0 === p2 || 0 === c) && x2) {
      const t2 = J((u4 - n) / _2), i5 = J((l2 - g) / _2);
      for (let e5 = 0; e5 < w.length; e5++) this.graphics[e5].geometry = i3(w[e5], t2, i5, o4, true);
      return this._centerGraphic.geometry = new _(u4, g, o4.spatialReference), void (this._backgroundGraphic.geometry = i3(e4.box, t2, i5, o4, true));
    }
    if (s3) {
      const t2 = J(d4[0] * r2 + d4[2] * a4 + d4[4], 2), e5 = J(d4[1] * r2 + d4[3] * a4 + d4[5], 2), i5 = J(d4[0] * n + d4[2] * l2 + d4[4], 2), s4 = J(d4[1] * n + d4[3] * l2 + d4[5], 2);
      let o5 = a3(t2, e5, i5, s4, y3, G);
      0 !== o5 && Math.abs(o5) !== 1 / 0 || (o5 = 1), this._xScale = this._yScale = o5;
      for (const h6 of w) {
        const t3 = w.indexOf(h6);
        this.graphics[t3].geometry = s2(h6, this._xScale, this._yScale, [r2, a4]);
      }
      this._updateBackgroundGraphic();
    } else {
      let t2 = u4 - n, i5 = l2 - g;
      if (1 === m4 || 5 === m4 ? t2 = 0 : 3 !== m4 && 7 !== m4 || (i5 = 0), 0 === t2 && 0 === i5) return;
      const s4 = r2 + t2 / 2, h6 = a4 + i5 / 2;
      let d5 = (p2 + (n > r2 ? t2 : -1 * t2)) / p2, y4 = (c + (l2 < a4 ? i5 : -1 * i5)) / c;
      1 !== m4 && 5 !== m4 && 0 !== d5 && Math.abs(d5) !== 1 / 0 || (d5 = 1), 3 !== m4 && 7 !== m4 && 0 !== y4 && Math.abs(y4) !== 1 / 0 || (y4 = 1), this._xScale = d5, this._yScale = y4;
      const G2 = (s4 - r2) / _2, b = (h6 - a4) / _2, x3 = s2(e4.box, this._xScale, this._yScale);
      this._backgroundGraphic.geometry = i3(x3, G2, b, o4, true);
      const {
        centerX: S2,
        centerY: k
      } = this._getGraphicInfo(this._backgroundGraphic), R = (S2 - r2) / _2, M = -1 * (k - a4) / _2;
      for (const e5 of w) {
        const t3 = w.indexOf(e5), i6 = s2(e5, this._xScale, this._yScale, [r2, a4]);
        this.graphics[t3].geometry = i3(i6, R, M, o4, true);
      }
      this._centerGraphic.geometry = new _(S2, k, o4.spatialReference);
    }
  }
  _rotateGraphic(t) {
    const {
      centerX: e4,
      centerY: i4,
      startX: s3,
      startY: o4,
      box: r2,
      rotate: a4
    } = this._startInfo, h5 = this.view.spatialReference, c = new _(s3, o4, h5), n = new _(e4, i4, h5), l2 = t.geometry;
    this._angleOfRotation = m3(c, l2, n);
    const p2 = this._startInfo.graphicInfos?.map((t2) => t2.geometry) ?? [];
    for (const _2 of p2) {
      const t2 = p2.indexOf(_2), e5 = r(_2, this._angleOfRotation, n);
      this.graphics[t2].geometry = e5;
    }
    this._backgroundGraphic.geometry = r(r2, this._angleOfRotation, n), this._rotateHandleGraphic.geometry = r(a4, this._angleOfRotation, n);
  }
  _moveGraphic(t, e4, i4) {
    if (this.graphics.includes(t)) {
      const s3 = this._backgroundGraphic.geometry;
      this._backgroundGraphic.geometry = i3(s3, e4, i4, this.view);
      for (const o4 of this.graphics) o4 !== t && (o4.geometry = i3(o4.geometry, e4, i4, this.view));
    } else if (t === this._centerGraphic) {
      const t2 = this._backgroundGraphic.geometry;
      this._backgroundGraphic.geometry = i3(t2, e4, i4, this.view);
    }
    if (t === this._backgroundGraphic || t === this._centerGraphic) for (const s3 of this.graphics) s3.geometry = i3(s3.geometry, e4, i4, this.view);
  }
  _setUpHighlights() {
    this.highlightsEnabled && this.graphics.length && this._highlightHelper?.add(this.graphics);
  }
  _setupGraphics() {
    const {
      _graphicAttributes: t,
      symbols: i4
    } = this;
    this._centerGraphic = new d3({
      symbol: i4.centerIndicator,
      attributes: t
    }), this.showCenterGraphic && this.layer.add(this._centerGraphic), this._backgroundGraphic = new d3({
      symbol: i4.fill.default,
      attributes: t
    }), this.layer.add(this._backgroundGraphic), this._rotateLineGraphic = new d3({
      symbol: i4.rotatorLine,
      attributes: t
    }), this._rotateHandleGraphic = new d3({
      symbol: i4.rotator.default,
      attributes: t
    }), this.enableRotation && !this._hasExtentGraphic() && this.layer.addMany([this._rotateLineGraphic, this._rotateHandleGraphic]);
    for (let s3 = 0; s3 < 8; s3++) this._vertexGraphics.push(new d3({
      symbol: i4.handles.default,
      attributes: t
    }));
    this.enableScaling && this.layer.addMany(this._vertexGraphics);
  }
  _updateSymbolsForTheme() {
    const t = this.view.effectiveTheme.accentColor;
    this.symbols = __spreadProps(__spreadValues({}, this.symbols), {
      fill: {
        active: this.symbols.fill.active?.clone().set("outline.color", t),
        default: this.symbols.fill.default?.clone().set("outline.color", t)
      },
      handles: __spreadProps(__spreadValues({}, this.symbols.handles), {
        default: this.symbols.handles.default.clone().set("outline.color", t)
      }),
      rotator: __spreadProps(__spreadValues({}, this.symbols.rotator), {
        default: this.symbols.rotator.default.clone().set("outline.color", t)
      }),
      rotatorLine: this.symbols.rotatorLine.clone().set("color", t)
    });
    for (const e4 of this._vertexGraphics) e4.symbol = e4 === this._hoveredGraphic ? this.symbols.handles.hover : this.symbols.handles.default;
    this._backgroundGraphic.symbol = this.symbols.fill.default, this._rotateHandleGraphic.symbol = this._rotateHandleGraphic === this._hoveredGraphic ? this.symbols.rotator.hover : this.symbols.rotator.default, this._rotateLineGraphic.symbol = this.symbols.rotatorLine;
  }
  _updateGraphics() {
    this._updateBackgroundGraphic(), this._updateHandleGraphics(), this._updateCenterGraphic(), this._updateRotateGraphic(), this._updateRotateLineGraphic();
  }
  _hideGraphicsBeforeUpdate() {
    this._centerGraphic.visible = false, this._rotateHandleGraphic.visible = false, this._rotateLineGraphic.visible = false, this._vertexGraphics.forEach((t) => t.visible = false);
  }
  _updateHandleGraphics() {
    const t = this._getCoordinates(true);
    this._vertexGraphics.forEach((e4, i4) => {
      const [s3, o4] = t[i4];
      this._updateXY(e4, s3, o4);
    });
  }
  _updateBackgroundGraphic() {
    const t = this._getCoordinates();
    this._backgroundGraphic.geometry = new j({
      rings: t,
      spatialReference: this.view.spatialReference
    });
  }
  _updateCenterGraphic() {
    const [t, e4, i4, s3] = this._getBoxBounds(u3()), o4 = (i4 + t) / 2, r2 = (s3 + e4) / 2;
    this._centerGraphic.geometry = new _(o4, r2, this.view.spatialReference);
  }
  _updateRotateGraphic() {
    if (!this._vertexGraphics.length) return;
    const {
      x: t,
      y: e4
    } = this._vertexGraphics[1].geometry, i4 = e4 + this.view.state.resolution * this._rotateGraphicOffset;
    this._rotateHandleGraphic.geometry = new _(t, i4, this.view.spatialReference);
  }
  _updateRotateLineGraphic() {
    if (!this._vertexGraphics.length || !this._rotateHandleGraphic?.geometry) return;
    const t = this._vertexGraphics[1].geometry, e4 = this._rotateHandleGraphic.geometry;
    this._rotateLineGraphic.geometry = new m({
      paths: [[t.x, t.y], [e4.x, e4.y]],
      spatialReference: this.view.spatialReference
    });
  }
  _updateXY(t, e4, i4) {
    t.geometry = new _(e4, i4, this.view.spatialReference);
  }
  _updateX(t, e4) {
    const i4 = t.geometry.y;
    t.geometry = new _(e4, i4, this.view.spatialReference);
  }
  _updateY(t, e4) {
    const i4 = t.geometry.x;
    t.geometry = new _(i4, e4, this.view.spatialReference);
  }
  _hasExtentGraphic() {
    return this.graphics.some((t) => null != t?.geometry && "extent" === t.geometry.type);
  }
  _getBoxBounds(t) {
    const e4 = this.graphics.map((t2) => t2.geometry);
    return this._getBounds(t, e4);
  }
  _getCoordinates(t) {
    const [e4, i4, s3, o4] = this._getBoxBounds(u3());
    if (t) {
      const t2 = (e4 + s3) / 2, r2 = (o4 + i4) / 2;
      return [[e4, o4], [t2, o4], [s3, o4], [s3, r2], [s3, i4], [t2, i4], [e4, i4], [e4, r2]];
    }
    return [[e4, o4], [s3, o4], [s3, i4], [e4, i4]];
  }
  _updateTooltip(t, e4) {
    if (null == this.tooltip) return;
    if (!t) return void this.tooltip.clear();
    const {
      _backgroundGraphic: i4,
      graphics: s3,
      _vertexGraphics: o4,
      _rotateHandleGraphic: r2
    } = this;
    t === r2 ? this._updateRotateTooltip() : o4.includes(t) ? this._updateScaleTooltip() : (s3.includes(t) || t === i4) && this._updateMoveTooltip(e4);
  }
  _updateRotateTooltip() {
    null != this.tooltip && (this.tooltip.info = new s({
      sketchOptions: this.sketchOptions,
      angle: -this._angleOfRotation
    }));
  }
  _updateScaleTooltip() {
    const {
      tooltip: t,
      _xScale: e4,
      _yScale: i4,
      sketchOptions: s3,
      view: o4
    } = this;
    if (null == t) return;
    const r2 = this._getCoordinates(), a4 = o2({
      topLeft: r2[0],
      topRight: r2[1],
      bottomRight: r2[2],
      bottomLeft: r2[3],
      spatialReference: o4.spatialReference
    });
    if (null == a4) return;
    const {
      xSize: h5,
      ySize: c
    } = a4, n = Math.abs(e4), l2 = Math.abs(i4);
    t.info = new i2({
      sketchOptions: s3,
      xScale: n,
      yScale: l2,
      xSize: h5,
      ySize: c
    });
  }
  _updateMoveTooltip(t) {
    const {
      tooltip: e4,
      sketchOptions: i4,
      view: s3
    } = this;
    if (null == e4) return;
    const r2 = new i({
      sketchOptions: i4
    });
    if (t) {
      const {
        x: e5,
        y: i5
      } = t.origin, a4 = s3.toMap(t), h5 = s3.toMap({
        x: e5,
        y: i5
      }), c = m2(h5, a4);
      r2.distance = null != c ? c : h;
    }
    e4.info = r2;
  }
};
function J(t, e4 = 2) {
  return Number.parseFloat(t.toFixed(e4));
}
e([y()], q.prototype, "tooltip", void 0), e([y({
  readOnly: true
})], q.prototype, "type", void 0), e([y()], q.prototype, "callbacks", void 0), e([y()], q.prototype, "enableMovement", void 0), e([y()], q.prototype, "enableRotation", void 0), e([y()], q.prototype, "enableScaling", void 0), e([y()], q.prototype, "graphics", void 0), e([y()], q.prototype, "highlightsEnabled", void 0), e([y()], q.prototype, "layer", void 0), e([y()], q.prototype, "preserveAspectRatio", void 0), e([y()], q.prototype, "showCenterGraphic", void 0), e([y({
  readOnly: true
})], q.prototype, "state", null), e([y()], q.prototype, "symbols", void 0), e([y({
  type: l
})], q.prototype, "sketchOptions", void 0), e([y({
  constructOnly: true
})], q.prototype, "view", void 0), q = e([a("esri.views.draw.support.Box")], q);
var K = q;
export {
  K as default
};
//# sourceMappingURL=Box-6WOESIZZ.js.map
