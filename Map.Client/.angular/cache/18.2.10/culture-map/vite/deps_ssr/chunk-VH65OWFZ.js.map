{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/chunks/LineMarker.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { markerTextureSize as e, markerSymbolSize as r, markerTipThicknessFactor as o } from \"../views/3d/support/engineContent/marker.js\";\nimport { ShaderOutput as i } from \"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";\nimport { SliceDraw as a } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { RibbonVertexPosition as t } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js\";\nimport { MarkerSizing as n } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MarkerSizing.glsl.js\";\nimport { multipassTerrainTest as s } from \"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js\";\nimport { symbolAlphaCutoff as l } from \"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";\nimport { ColorConversion as c } from \"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";\nimport { RgbaFloatEncoding as d } from \"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";\nimport { addProjViewLocalOrigin as p, addViewNormal as v, addPixelRatio as m } from \"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";\nimport { Float2PassUniform as f } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { Float4PassUniform as g } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as h } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as u } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as w } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { ShaderBuilder as y } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as S } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nimport { TransparencyPassType as b } from \"../views/3d/webgl-engine/lib/TransparencyPassType.js\";\nimport { VertexAttribute as P } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nimport { LineMarkerSpace as x, LineMarkerAnchor as z } from \"../views/3d/webgl-engine/shaders/LineMarkerTechniqueConfiguration.js\";\nfunction C(C) {\n  const j = new y(),\n    L = C.multipassEnabled && C.output === i.Color,\n    M = C.space === x.World;\n  j.include(t, C), j.include(n, C);\n  const {\n    vertex: k,\n    fragment: N\n  } = j;\n  return N.include(d), p(k, C), j.attributes.add(P.POSITION, \"vec3\"), j.attributes.add(P.PREVPOSITION, \"vec3\"), j.attributes.add(P.UV0, \"vec2\"), j.varyings.add(\"vColor\", \"vec4\"), j.varyings.add(\"vpos\", \"vec3\"), j.varyings.add(\"vUV\", \"vec2\"), j.varyings.add(\"vSize\", \"float\"), L && j.varyings.add(\"depth\", \"float\"), C.hasTip && j.varyings.add(\"vLineWidth\", \"float\"), k.uniforms.add(new f(\"nearFar\", (e, r) => r.camera.nearFar), new g(\"viewport\", (e, r) => r.camera.fullViewport)), k.code.add(u`vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}`), k.code.add(u`void clip(vec4 pos, inout vec4 prev) {\nfloat vnp = nearFar[0] * 0.99;\nif (prev.z > -nearFar[0]) {\nfloat interpolation = (-vnp - pos.z) / (prev.z - pos.z);\nprev = mix(pos, prev, interpolation);\n}\n}`), M ? (j.attributes.add(P.NORMAL, \"vec3\"), v(k), k.constants.add(\"tiltThreshold\", \"float\", .7), k.code.add(u`vec3 perpendicular(vec3 v) {\nvec3 n = (viewNormal * vec4(normal.xyz, 1.0)).xyz;\nvec3 n2 = cross(v, n);\nvec3 forward = vec3(0.0, 0.0, 1.0);\nfloat tiltDot = dot(forward, n);\nreturn abs(tiltDot) < tiltThreshold ? n : n2;\n}`)) : k.code.add(u`vec2 perpendicular(vec2 v) {\nreturn vec2(v.y, -v.x);\n}`), k.code.add(u`\n      #define vecN ${M ? \"vec3\" : \"vec2\"}\n\n      vecN normalizedSegment(vecN pos, vecN prev) {\n        vecN segment = pos - prev;\n        float segmentLen = length(segment);\n\n        // normalize or zero if too short\n        return (segmentLen > 0.001) ? segment / segmentLen : ${M ? \"vec3(0.0, 0.0, 0.0)\" : \"vec2(0.0, 0.0)\"};\n      }\n\n      vecN displace(vecN pos, vecN prev, float displacementLen) {\n        vecN segment = normalizedSegment(pos, prev);\n\n        vecN displacementDirU = perpendicular(segment);\n        vecN displacementDirV = segment;\n\n        ${C.anchor === z.Tip ? \"pos -= 0.5 * displacementLen * displacementDirV;\" : \"\"}\n\n        return pos + displacementLen * (uv0.x * displacementDirU + uv0.y * displacementDirV);\n      }\n    `), C.space === x.Screen && (k.uniforms.add(new w(\"inverseProjectionMatrix\", (e, r) => r.camera.inverseProjectionMatrix)), k.code.add(u`vec3 inverseProject(vec4 posScreen) {\nposScreen.xy = (posScreen.xy / viewport.zw) * posScreen.w;\nreturn (inverseProjectionMatrix * posScreen).xyz;\n}`), k.code.add(u`bool rayIntersectPlane(vec3 rayDir, vec3 planeOrigin, vec3 planeNormal, out vec3 intersection) {\nfloat cos = dot(rayDir, planeNormal);\nfloat t = dot(planeOrigin, planeNormal) / cos;\nintersection = t * rayDir;\nreturn abs(cos) > 0.001 && t > 0.0;\n}`), k.uniforms.add(new h(\"perScreenPixelRatio\", (e, r) => r.camera.perScreenPixelRatio)), k.code.add(u`\n      vec4 toFront(vec4 displacedPosScreen, vec3 posLeft, vec3 posRight, vec3 prev, float lineWidth) {\n        // Project displaced position back to camera space\n        vec3 displacedPos = inverseProject(displacedPosScreen);\n\n        // Calculate the plane that we want the marker to lie in. Note that this will always be an approximation since ribbon lines are generally\n        // not planar and we do not know the actual position of the displaced prev vertices (they are offset in screen space, too).\n        vec3 planeNormal = normalize(cross(posLeft - posRight, posLeft - prev));\n        vec3 planeOrigin = posLeft;\n\n        ${C.hasCap ? \"\\n                if(prev.z > posLeft.z) {\\n                  vec2 diff = posLeft.xy - posRight.xy;\\n                  planeOrigin.xy += perpendicular(diff) / 2.0;\\n                }\\n              \" : \"\"};\n\n        // Move the plane towards the camera by a margin dependent on the line width (approximated in world space). This tolerance corrects for the\n        // non-planarity in most cases, but sharp joins can place the prev vertices at arbitrary positions so markers can still clip.\n        float offset = lineWidth * perScreenPixelRatio;\n        planeOrigin *= (1.0 - offset);\n\n        // Intersect camera ray with the plane and make sure it is within clip space\n        vec3 rayDir = normalize(displacedPos);\n        vec3 intersection;\n        if (rayIntersectPlane(rayDir, planeOrigin, planeNormal, intersection) && intersection.z < -nearFar[0] && intersection.z > -nearFar[1]) {\n          return vec4(intersection.xyz, 1.0);\n        }\n\n        // Fallback: use depth of pos or prev, whichever is closer to the camera\n        float minDepth = planeOrigin.z > prev.z ? length(planeOrigin) : length(prev);\n        displacedPos *= minDepth / length(displacedPos);\n        return vec4(displacedPos.xyz, 1.0);\n      }\n  `)), m(k), k.code.add(u`void main(void) {\nif (uv0.y == 0.0) {\ngl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n}\nelse {\nfloat lineWidth = getLineWidth();\nfloat screenMarkerSize = getScreenMarkerSize();\nvec4 pos  = view * vec4(position, 1.0);\nvec4 prev = view * vec4(prevPosition, 1.0);\nclip(pos, prev);`), M ? (C.hideOnShortSegments && k.code.add(u`if (areWorldMarkersHidden(pos, prev)) {\ngl_Position = vec4(1e038, 1e038, 1e038, 1.0);\nreturn;\n}`), k.code.add(u`pos.xyz = displace(pos.xyz, prev.xyz, getWorldMarkerSize(pos));\nvec4 displacedPosScreen = projectAndScale(pos);`)) : (k.code.add(u`vec4 posScreen = projectAndScale(pos);\nvec4 prevScreen = projectAndScale(prev);\nvec4 displacedPosScreen = posScreen;\ndisplacedPosScreen.xy = displace(posScreen.xy, prevScreen.xy, screenMarkerSize);`), C.space === x.Screen && k.code.add(u`vec2 displacementDirU = perpendicular(normalizedSegment(posScreen.xy, prevScreen.xy));\nvec3 lineRight = inverseProject(posScreen + lineWidth * vec4(displacementDirU.xy, 0.0, 0.0));\nvec3 lineLeft = pos.xyz + (pos.xyz - lineRight);\npos = toFront(displacedPosScreen, lineLeft, lineRight, prev.xyz, lineWidth);\ndisplacedPosScreen = projectAndScale(pos);`)), k.code.add(u`\n        ${L ? \"depth = pos.z;\" : \"\"}\n\n        // Convert back into NDC\n        displacedPosScreen.xy = (displacedPosScreen.xy / viewport.zw) * displacedPosScreen.w;\n\n        // Convert texture coordinate into [0,1]\n        vUV = (uv0 + 1.0) / 2.0;\n\n        ${M ? \"\" : \"vUV *= displacedPosScreen.w;\"}\n\n        ${C.hasTip ? \"vLineWidth = lineWidth;\" : \"\"}\n\n        vSize = screenMarkerSize;\n        vColor = getColor();\n\n        // Use camera space for slicing\n        vpos = pos.xyz;\n\n        gl_Position = displacedPosScreen;\n      }\n    }\n  `), L && j.include(s, C), j.include(a, C), N.uniforms.add(new g(\"intrinsicColor\", e => e.color), new S(\"tex\", e => e.markerTexture)), N.include(c), j.constants.add(\"texelSize\", \"float\", 1 / e), N.code.add(u`float markerAlpha(vec2 samplePos) {\nsamplePos += vec2(0.5, -0.5) * texelSize;\nfloat sdf = rgba2float(texture(tex, samplePos)) - 0.5;\nfloat distance = sdf * vSize;\ndistance -= 0.5;\nreturn clamp(0.5 - distance, 0.0, 1.0);\n}`), C.hasTip && (j.constants.add(\"relativeMarkerSize\", \"float\", r / e), j.constants.add(\"relativeTipLineWidth\", \"float\", o), N.code.add(u`\n    float tipAlpha(vec2 samplePos) {\n      // Convert coordinates s.t. they are in pixels and relative to the tip of an arrow marker\n      samplePos -= vec2(0.5, 0.5 + 0.5 * relativeMarkerSize);\n      samplePos *= vSize;\n\n      float halfMarkerSize = 0.5 * relativeMarkerSize * vSize;\n      float halfTipLineWidth = 0.5 * max(1.0, relativeTipLineWidth * vLineWidth);\n\n      ${M ? \"halfTipLineWidth *= fwidth(samplePos.y);\" : \"\"}\n\n      float distance = max(abs(samplePos.x) - halfMarkerSize, abs(samplePos.y) - halfTipLineWidth);\n      return clamp(0.5 - distance, 0.0, 1.0);\n    }\n  `)), C.transparencyPassType === b.ColorAlpha && (j.outputs.add(\"fragColor\", \"vec4\", 0), j.outputs.add(\"fragAlpha\", \"float\", 1)), j.constants.add(\"symbolAlphaCutoff\", \"float\", l), N.code.add(u`\n  void main() {\n    discardBySlice(vpos);\n    ${L ? \"terrainDepthTest(depth);\" : \"\"}\n\n    vec4 finalColor = intrinsicColor * vColor;\n\n    ${M ? \"vec2 samplePos = vUV;\" : \"vec2 samplePos = vUV * gl_FragCoord.w;\"}\n\n    ${C.hasTip ? \"finalColor.a *= max(markerAlpha(samplePos), tipAlpha(samplePos));\" : \"finalColor.a *= markerAlpha(samplePos);\"}\n\n    ${C.output === i.ObjectAndLayerIdColor ? u`finalColor.a = 1.0;` : \"\"}\n\n    if (finalColor.a < symbolAlphaCutoff) {\n      discard;\n    }\n\n    ${C.output === i.Color ? u`fragColor = highlightSlice(finalColor, vpos);` : \"\"}\n    ${C.output === i.Color && C.transparencyPassType === b.ColorAlpha ? u`\n            fragColor = premultiplyAlpha(fragColor);\n            fragAlpha = fragColor.a;` : \"\"}\n    ${C.output === i.Highlight ? u`fragColor = vec4(1.0);` : \"\"}\n  }\n  `), j;\n}\nconst j = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: C\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { j as L, C as b };"],
  "mappings": "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",
  "names": ["C", "j", "o", "p", "e", "s", "a", "w"]
}
