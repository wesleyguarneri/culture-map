import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  K,
  ee,
  oe
} from "./chunk-YWDTOPSE.js";
import "./chunk-DXSJK4BX.js";
import {
  E,
  N
} from "./chunk-MWMAA7SE.js";
import {
  p
} from "./chunk-LUKDK354.js";
import "./chunk-MWDGD75N.js";
import {
  m
} from "./chunk-BYXMUOMW.js";
import "./chunk-YEWOBDQB.js";
import {
  $
} from "./chunk-FWEBARAB.js";
import "./chunk-RHUWRAPT.js";
import "./chunk-VY63YX6I.js";
import "./chunk-EXKCGLRO.js";
import "./chunk-WRLGLGM6.js";
import "./chunk-47DYJR3W.js";
import {
  j,
  x
} from "./chunk-NE35ZNG6.js";
import "./chunk-ZLSZAC2I.js";
import "./chunk-QRWQ6QBB.js";
import "./chunk-TFW6WS6R.js";
import {
  ot,
  rt
} from "./chunk-X5QZGB37.js";
import "./chunk-T5C2TZNO.js";
import "./chunk-AOGKNBDG.js";
import "./chunk-F4FQ67JP.js";
import "./chunk-FDI2X6GO.js";
import "./chunk-3XHDZQO5.js";
import "./chunk-2BLQXT54.js";
import "./chunk-JSWVKNBA.js";
import "./chunk-LL33G4DK.js";
import "./chunk-CILHMGNK.js";
import "./chunk-2BOKEEZV.js";
import "./chunk-VZ37C3ID.js";
import {
  Z
} from "./chunk-5R3HARKC.js";
import "./chunk-BKSTWG4S.js";
import "./chunk-FSG7HOZQ.js";
import "./chunk-Q5TIVVER.js";
import "./chunk-VOOO6FU5.js";
import "./chunk-NU4K6CTR.js";
import "./chunk-42ZAWY2C.js";
import "./chunk-TVHVZK5G.js";
import "./chunk-P2MUOE6G.js";
import "./chunk-CRYYUS4E.js";
import "./chunk-V33IUWAS.js";
import "./chunk-E5NWFBZG.js";
import "./chunk-FP37456K.js";
import "./chunk-VSQZQLTQ.js";
import "./chunk-K43CZ3M5.js";
import "./chunk-6EIBUVMG.js";
import "./chunk-YCXNHEGB.js";
import "./chunk-CSATD3VX.js";
import "./chunk-NXXQ35YM.js";
import "./chunk-LM3JDV4W.js";
import "./chunk-34V2CLL5.js";
import "./chunk-CXNERL22.js";
import "./chunk-7V4JSBFA.js";
import "./chunk-ZT7V2AVD.js";
import "./chunk-C2OXE4NQ.js";
import "./chunk-KOI252FF.js";
import "./chunk-I2TVVMQ6.js";
import "./chunk-5EGQYY2H.js";
import "./chunk-JKPUNUQA.js";
import "./chunk-SR7PRON4.js";
import "./chunk-HGHPYGKP.js";
import "./chunk-4DSGTDZJ.js";
import "./chunk-VYTPFEL2.js";
import "./chunk-RLGDH6IY.js";
import "./chunk-MRPCXIVS.js";
import "./chunk-YTKVV2Y3.js";
import "./chunk-GCVQXAS4.js";
import "./chunk-UFQD6AL4.js";
import "./chunk-THZPD5CT.js";
import "./chunk-OBCA6CWH.js";
import {
  i
} from "./chunk-2JI245BP.js";
import "./chunk-CBOFHWPI.js";
import "./chunk-ABIG6PT5.js";
import "./chunk-ZEZ3LI2L.js";
import "./chunk-N34BRXVM.js";
import "./chunk-KETDH2J4.js";
import "./chunk-7QV7DHWN.js";
import "./chunk-4L4Y34YK.js";
import "./chunk-BXONKQKI.js";
import "./chunk-2HDBQXAR.js";
import "./chunk-RNF7VOCU.js";
import "./chunk-TIRJMGGG.js";
import "./chunk-ZDRQSPB6.js";
import "./chunk-DCXDXGAR.js";
import "./chunk-BCCDYCTQ.js";
import "./chunk-AYL3HQHD.js";
import "./chunk-66YQWHHE.js";
import "./chunk-QGBMZIP4.js";
import "./chunk-AOEBZVTA.js";
import "./chunk-2OZSYJDX.js";
import "./chunk-MZM4INJV.js";
import "./chunk-J4GMQHGL.js";
import "./chunk-MHPE4SZA.js";
import {
  G
} from "./chunk-6SSA7P3A.js";
import "./chunk-FQBTLEUI.js";
import "./chunk-GS7Y3YOG.js";
import "./chunk-Y2HYKTTT.js";
import "./chunk-XLEC46FY.js";
import "./chunk-4AZPIP7K.js";
import "./chunk-G73HQZEL.js";
import "./chunk-LZSLQ24Q.js";
import "./chunk-U3RHUXYK.js";
import "./chunk-7DBI6LQG.js";
import {
  d
} from "./chunk-AUUN7RFQ.js";
import "./chunk-JAMSDYD6.js";
import "./chunk-PH6NPTP7.js";
import "./chunk-NUICEVIH.js";
import "./chunk-NXK752PZ.js";
import "./chunk-UVNLCXWD.js";
import "./chunk-PNUA7JOS.js";
import "./chunk-OR2FKGUM.js";
import {
  s3
} from "./chunk-UDMPWVPF.js";
import "./chunk-XJNKCEWL.js";
import {
  b,
  s as s2
} from "./chunk-AIZ3T7E3.js";
import "./chunk-6UEMNP3E.js";
import "./chunk-6WGE3IUL.js";
import "./chunk-MLYB2YW4.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-6JFGZTLU.js";
import "./chunk-2ZJE6ZFX.js";
import {
  __async
} from "./chunk-XBPEBUD5.js";

// ../../../node_modules/@arcgis/core/layers/graphics/sources/WFSSourceWorker.js
var w = "esri.layers.WFSLayer";
var R = class {
  constructor() {
    this._customParameters = null, this._queryEngine = null, this._supportsPagination = true;
  }
  destroy() {
    this._queryEngine?.destroy(), this._queryEngine = null;
  }
  load(_0) {
    return __async(this, arguments, function* (e, r = {}) {
      const {
        getFeatureUrl: s4,
        getFeatureOutputFormat: o,
        fields: n2,
        geometryType: i2,
        featureType: u,
        maxRecordCount: c,
        maxTotalRecordCount: p2,
        maxPageCount: d2,
        objectIdField: g,
        customParameters: y
      } = e, {
        spatialReference: _,
        getFeatureSpatialReference: w2
      } = oe(s4, u, e.spatialReference);
      try {
        yield x(w2, _);
      } catch {
        throw new s("unsupported-projection", "Projection not supported", {
          inSpatialReference: w2,
          outSpatialReference: _
        });
      }
      s2(r), this._customParameters = y, this._featureType = u, this._fieldsIndex = Z.fromLayerJSON({
        fields: n2,
        dateFieldsTimeReference: n2.some((e2) => "esriFieldTypeDate" === e2.type) ? {
          timeZoneIANA: i
        } : null
      }), this._geometryType = i2, this._getFeatureUrl = s4, this._getFeatureOutputFormat = o, this._getFeatureSpatialReference = w2, this._maxRecordCount = c, this._maxTotalRecordCount = p2, this._maxPageCount = d2, this._objectIdField = g, this._spatialReference = _;
      let R2 = yield this._snapshotFeatures(r);
      if (R2.errors.length > 0 && (this._supportsPagination = false, R2 = yield this._snapshotFeatures(r), R2.errors.length > 0)) throw R2.errors[0];
      return this._queryEngine = new $({
        fieldsIndex: this._fieldsIndex,
        geometryType: i2,
        hasM: false,
        hasZ: false,
        objectIdField: g,
        spatialReference: _,
        timeInfo: null,
        featureStore: new m({
          geometryType: i2,
          hasM: false,
          hasZ: false
        })
      }), this._queryEngine.featureStore.addMany(R2.features), {
        warnings: T(R2),
        extent: (yield this._queryEngine.fetchRecomputedExtents()).fullExtent
      };
    });
  }
  applyEdits() {
    return __async(this, null, function* () {
      throw new s("wfs-source:editing-not-supported", "applyEdits() is not supported on WFSLayer");
    });
  }
  queryFeatures() {
    return __async(this, arguments, function* (e = {}, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
    });
  }
  queryFeatureCount() {
    return __async(this, arguments, function* (e = {}, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
    });
  }
  queryObjectIds() {
    return __async(this, arguments, function* (e = {}, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t.signal);
    });
  }
  queryExtent() {
    return __async(this, arguments, function* (e = {}, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
    });
  }
  querySnapping(_0) {
    return __async(this, arguments, function* (e, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e, t.signal);
    });
  }
  refresh(t) {
    return __async(this, null, function* () {
      return this._customParameters = t.customParameters, this._maxRecordCount = t.maxRecordCount, this._maxTotalRecordCount = t.maxTotalRecordCount, this._maxPageCount = t.maxPageCount, this._snapshotTask?.abort(), this._snapshotTask = d((e) => this._snapshotFeatures({
        signal: e
      })), this._snapshotTask.promise.then((e) => {
        this._queryEngine.featureStore.clear(), this._queryEngine.featureStore.addMany(e.features);
        for (const t2 of T(e)) n.getLogger(w).warn(new s3("wfs-layer:refresh-warning", t2.message, t2.details));
        e.errors?.length && n.getLogger(w).warn(new s3("wfs-layer:refresh-error", "Refresh completed with errors", {
          errors: e.errors
        }));
      }, () => {
        this._queryEngine.featureStore.clear();
      }), yield this._waitSnapshotComplete(), {
        extent: (yield this._queryEngine.fetchRecomputedExtents()).fullExtent
      };
    });
  }
  _waitSnapshotComplete() {
    return __async(this, null, function* () {
      if (this._snapshotTask && !this._snapshotTask.finished) {
        try {
          yield this._snapshotTask.promise;
        } catch {
        }
        return this._waitSnapshotComplete();
      }
    });
  }
  _snapshotFeatures(e) {
    return __async(this, null, function* () {
      const t = e?.signal, r = this._maxTotalRecordCount, o = this._maxPageCount, n2 = this._supportsPagination ? yield ee(this._getFeatureUrl, this._featureType.typeName, {
        customParameters: this._customParameters,
        signal: t
      }) : void 0;
      let i2 = [];
      const u = [];
      if (null == n2) try {
        i2 = yield this._singleQuery(t);
      } catch (l) {
        b(l) || u.push(l);
      }
      else {
        const e2 = Math.min(n2, r), a = F(this, Math.max(1, Math.min(Math.ceil(e2 / this._maxRecordCount), o)), t);
        yield Promise.allSettled(Array.from({
          length: 10
        }).map(() => S(a, i2, u)));
      }
      return s2(t), {
        features: i2,
        totalRecordCount: n2,
        maxTotalRecordCount: r,
        maxPageCount: o,
        errors: u
      };
    });
  }
  _singleQuery(e) {
    return __async(this, null, function* () {
      const t = yield K(this._getFeatureUrl, this._featureType.typeName, this._getFeatureSpatialReference, this._getFeatureOutputFormat, {
        customParameters: this._customParameters,
        signal: e
      });
      return this._processGeoJSON(t, {
        signal: e
      });
    });
  }
  _pageQuery(e, t) {
    return __async(this, null, function* () {
      const r = e * this._maxRecordCount, a = yield K(this._getFeatureUrl, this._featureType.typeName, this._getFeatureSpatialReference, this._getFeatureOutputFormat, {
        customParameters: this._customParameters,
        startIndex: r,
        count: this._maxRecordCount,
        signal: t
      });
      return this._processGeoJSON(a, {
        startIndex: r,
        signal: t
      });
    });
  }
  _processGeoJSON(e, t) {
    E(e, this._getFeatureSpatialReference.wkid);
    const {
      startIndex: r,
      signal: s4
    } = t;
    s2(s4);
    const o = N(e, {
      geometryType: this._geometryType,
      hasZ: false,
      objectIdField: this._objectIdField
    });
    if (!G(this._spatialReference, this._getFeatureSpatialReference)) for (const a of o) null != a.geometry && (a.geometry = ot(j(rt(a.geometry, this._geometryType, false, false), this._getFeatureSpatialReference, this._spatialReference)));
    let l = r ?? 1;
    for (const a of o) {
      const e2 = {};
      p(this._fieldsIndex, e2, a.attributes, true), a.attributes = e2, null == e2[this._objectIdField] && (a.objectId = e2[this._objectIdField] = l++);
    }
    return o;
  }
};
function* F(e, t, r) {
  for (let a = 0; a < t; a++) yield e._pageQuery(a, r);
}
function S(e, t, r) {
  return __async(this, null, function* () {
    let a = e.next();
    for (; !a.done; ) {
      try {
        const e2 = yield a.value;
        t.push(...e2);
      } catch (o) {
        b(o) || r.push(o);
      }
      a = e.next();
    }
  });
}
function T(e) {
  const t = [];
  return null != e.totalRecordCount && (e.features.length < e.totalRecordCount && t.push({
    name: "wfs-layer:maxRecordCount-too-low",
    message: `Could only fetch ${e.features.length} of ${e.totalRecordCount} in ${e.maxPageCount} queries. Try increasing the value of WFSLayer.maxRecordCount.`,
    details: {
      recordCount: e.features.length,
      totalRecordCount: e.totalRecordCount
    }
  }), e.totalRecordCount > e.maxTotalRecordCount && t.push({
    name: "wfs-layer:large-dataset",
    message: `The number of ${e.totalRecordCount} features exceeds the maximum allowed of ${e.maxTotalRecordCount}.`,
    details: {
      recordCount: e.features.length,
      totalRecordCount: e.totalRecordCount,
      maxTotalRecordCount: e.maxTotalRecordCount
    }
  })), t;
}
export {
  R as default
};
//# sourceMappingURL=WFSSourceWorker-JRLRYTD5.js.map
