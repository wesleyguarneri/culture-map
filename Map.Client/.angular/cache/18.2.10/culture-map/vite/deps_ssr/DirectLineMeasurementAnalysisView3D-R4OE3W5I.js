import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  e as e7,
  o as o5
} from "./chunk-YNMAPIWB.js";
import {
  N,
  u2 as u4
} from "./chunk-6HPSJYGF.js";
import "./chunk-MHXYSS6C.js";
import "./chunk-PPFE3CUD.js";
import {
  e as e6
} from "./chunk-YQGPDXSM.js";
import {
  e as e5
} from "./chunk-K2LPE2X5.js";
import {
  s as s4
} from "./chunk-FOQTZUFZ.js";
import {
  _ as _3,
  f as f4,
  m,
  v
} from "./chunk-A3Y2HRWK.js";
import {
  D
} from "./chunk-FVMSCDY4.js";
import "./chunk-K2PGE3SJ.js";
import {
  M,
  g as g2,
  j as j3,
  w,
  y as y2
} from "./chunk-2I3RVFNX.js";
import "./chunk-MH54QISY.js";
import {
  h as h5
} from "./chunk-JEWURWPQ.js";
import "./chunk-PPORR5ZR.js";
import {
  p
} from "./chunk-CP2IGGT7.js";
import {
  f as f2,
  i
} from "./chunk-ZEZCWQFR.js";
import {
  s as s3
} from "./chunk-AOVKCTSO.js";
import {
  r as r7,
  t as t4
} from "./chunk-DVWZMNZY.js";
import {
  f as f3
} from "./chunk-FJ65I6KE.js";
import {
  a as a3
} from "./chunk-F2LQGEBE.js";
import "./chunk-7RXQQ22H.js";
import "./chunk-IVVINOEJ.js";
import "./chunk-OPYMVWCV.js";
import {
  h as h4
} from "./chunk-IRKNVCIL.js";
import "./chunk-BV256A2V.js";
import "./chunk-KJGRJNY4.js";
import "./chunk-AJ474NL3.js";
import "./chunk-X3HF4XA3.js";
import "./chunk-N7TLJ6LV.js";
import "./chunk-VTFYXQEG.js";
import "./chunk-INUNNFZT.js";
import "./chunk-NF2MOJH5.js";
import "./chunk-2NPPOPEZ.js";
import "./chunk-JP4VYCP3.js";
import "./chunk-BKOZEXTL.js";
import "./chunk-NLRSH3TD.js";
import "./chunk-3Q4YEFJ3.js";
import "./chunk-K6JW77RY.js";
import "./chunk-377KSYNB.js";
import "./chunk-PSH57UZT.js";
import "./chunk-KRRPY5PU.js";
import "./chunk-YUYMEQ3T.js";
import "./chunk-ZTTGFJJT.js";
import "./chunk-TFCCIKDP.js";
import "./chunk-FT6GF7ST.js";
import "./chunk-4B3LNBOC.js";
import "./chunk-KAKCJGSZ.js";
import {
  gt
} from "./chunk-LEBOC3ZD.js";
import "./chunk-FSYMZVRK.js";
import "./chunk-T4DTOVU4.js";
import "./chunk-GYNRSS5Q.js";
import "./chunk-TO2KOAJE.js";
import "./chunk-JZISCETB.js";
import "./chunk-DM6DHTKZ.js";
import "./chunk-OEBP4L4N.js";
import "./chunk-UT2ZOLZR.js";
import "./chunk-DTMLHZFB.js";
import "./chunk-Z3B4X2BG.js";
import "./chunk-ZCCDVQ3H.js";
import "./chunk-WYPPXVX7.js";
import {
  s as s2
} from "./chunk-T2SCEBLQ.js";
import "./chunk-O7RCHW3H.js";
import "./chunk-N4FQBAT2.js";
import "./chunk-K7U66W6G.js";
import "./chunk-WQMUOLHB.js";
import "./chunk-LVERV6OU.js";
import "./chunk-3FFTEL3W.js";
import {
  E as E3
} from "./chunk-4WON4QDF.js";
import "./chunk-45GTM6LF.js";
import {
  A as A2,
  c as c4
} from "./chunk-XUZTWNKD.js";
import "./chunk-Q5PBA64J.js";
import {
  t as t3
} from "./chunk-TIAWSZQK.js";
import "./chunk-KWHFMZEB.js";
import "./chunk-FBMJVQWQ.js";
import "./chunk-WUTM5T74.js";
import "./chunk-ONVI4SC3.js";
import "./chunk-2IRGMYX2.js";
import "./chunk-OU2TYICP.js";
import "./chunk-DZAXDRPA.js";
import "./chunk-RV5QLAWU.js";
import "./chunk-AA5NMQ6N.js";
import "./chunk-Z4PRO5ND.js";
import "./chunk-MHGADXDL.js";
import "./chunk-VYJ7IUDT.js";
import "./chunk-2ZXVDYHF.js";
import {
  r as r4,
  r2 as r5,
  t as t2
} from "./chunk-22UDIQGJ.js";
import "./chunk-XFLPRRYT.js";
import {
  t
} from "./chunk-Z5ZLX3BE.js";
import "./chunk-23Q4INNG.js";
import "./chunk-LZSSTWLW.js";
import "./chunk-ALQIX2AS.js";
import "./chunk-D3VQCVGJ.js";
import "./chunk-PFTDB6ZJ.js";
import "./chunk-6YHZYHJS.js";
import "./chunk-FCVY35OB.js";
import "./chunk-TSTMST4X.js";
import "./chunk-I47GCEJP.js";
import {
  r as r6
} from "./chunk-LA4GCRJY.js";
import "./chunk-ZTMARHUQ.js";
import "./chunk-P5MJSFMN.js";
import "./chunk-HMPRRFR4.js";
import {
  c2 as c3,
  h as h3,
  u2 as u3
} from "./chunk-UE7ZYRIH.js";
import "./chunk-W24M6HII.js";
import "./chunk-FWGI52X4.js";
import "./chunk-E5RXQH35.js";
import {
  o as o3
} from "./chunk-62ZEBDPC.js";
import "./chunk-ZFMS3XGM.js";
import "./chunk-QWQJOAVR.js";
import "./chunk-YLQMUXQA.js";
import "./chunk-4U7LUZFD.js";
import "./chunk-T257OY4U.js";
import "./chunk-BMO2W6EC.js";
import "./chunk-QA265FYQ.js";
import {
  S as S2,
  _ as _2,
  o as o4
} from "./chunk-HUOFTIIK.js";
import "./chunk-ZDFN6OZC.js";
import "./chunk-DUV7OLAZ.js";
import "./chunk-KSOKDIBG.js";
import "./chunk-3NWWTJOW.js";
import "./chunk-TRF6JO5N.js";
import "./chunk-ZHVMMFTW.js";
import "./chunk-HKAONIBH.js";
import "./chunk-2B3WLK32.js";
import "./chunk-EPIUUGS2.js";
import "./chunk-TMXHZTIG.js";
import "./chunk-FIQ7DCCC.js";
import "./chunk-SNHVHW2N.js";
import "./chunk-MDEPINSI.js";
import "./chunk-QATJRB5Q.js";
import "./chunk-7Z4UWMRU.js";
import "./chunk-YEB36ZCF.js";
import "./chunk-WHVSAUHM.js";
import "./chunk-LQUVB46M.js";
import {
  H
} from "./chunk-GHPF24X4.js";
import "./chunk-UC4DX4SE.js";
import "./chunk-44O4APOL.js";
import "./chunk-LCPLUSDH.js";
import "./chunk-KINQ7OJ3.js";
import {
  E as E2,
  O as O2
} from "./chunk-KYLW5XXS.js";
import "./chunk-YSJVVDDH.js";
import "./chunk-DLWZ3HVT.js";
import {
  j as j2
} from "./chunk-B76NC7GX.js";
import "./chunk-EFLOBCAZ.js";
import "./chunk-EXKCGLRO.js";
import "./chunk-WRLGLGM6.js";
import "./chunk-47DYJR3W.js";
import "./chunk-QRWQ6QBB.js";
import "./chunk-ZSJNH2BT.js";
import "./chunk-RIZOHDTP.js";
import "./chunk-ZFES27RA.js";
import "./chunk-XP2AJZUL.js";
import "./chunk-CZA7RDJP.js";
import "./chunk-NCMX3DAD.js";
import "./chunk-BCNABTAE.js";
import "./chunk-3PPEJ4QJ.js";
import "./chunk-ZEOLGKXL.js";
import {
  o as o2
} from "./chunk-HITI6WDM.js";
import "./chunk-IS4RJOPJ.js";
import "./chunk-XK3CKE5Q.js";
import "./chunk-AMH7CZMY.js";
import "./chunk-EAVSYZXD.js";
import "./chunk-7GHUVMBI.js";
import "./chunk-Q5JLNMWZ.js";
import "./chunk-AABDXAD3.js";
import "./chunk-LGS63R4F.js";
import "./chunk-L6FG3WIC.js";
import "./chunk-6ZLH7XBS.js";
import "./chunk-44ZUWZXU.js";
import {
  E,
  F,
  G,
  P as P2,
  R,
  q
} from "./chunk-NAG6YX7T.js";
import "./chunk-U4EMQMDC.js";
import "./chunk-AVCKPV77.js";
import "./chunk-MNBTLVRM.js";
import "./chunk-GNCXYHNE.js";
import "./chunk-CSK4VZQ7.js";
import {
  c as c2
} from "./chunk-2TNGEJGS.js";
import "./chunk-OYGNGIHQ.js";
import "./chunk-GSG4T2KM.js";
import {
  e as e4
} from "./chunk-D7C26LZP.js";
import "./chunk-BZHHBBFX.js";
import "./chunk-GK5M6FUR.js";
import "./chunk-MRP3FBLV.js";
import "./chunk-Y7SJWJAL.js";
import "./chunk-A2FDYA6M.js";
import {
  e as e3
} from "./chunk-YGAXDKHF.js";
import "./chunk-4TOSJLKR.js";
import "./chunk-FSG7HOZQ.js";
import "./chunk-C7BQE556.js";
import "./chunk-DL2B6IFJ.js";
import "./chunk-VOOO6FU5.js";
import "./chunk-KUBMHTYA.js";
import {
  n as n3,
  r as r3
} from "./chunk-VSQZQLTQ.js";
import {
  a as a2
} from "./chunk-K43CZ3M5.js";
import "./chunk-6EIBUVMG.js";
import "./chunk-S4XQLN73.js";
import "./chunk-LM3JDV4W.js";
import "./chunk-34V2CLL5.js";
import "./chunk-2EJFYNM7.js";
import "./chunk-ASCK5HJ5.js";
import "./chunk-5X5U7R6O.js";
import "./chunk-KOI252FF.js";
import "./chunk-SR7PRON4.js";
import "./chunk-HGHPYGKP.js";
import "./chunk-4DSGTDZJ.js";
import {
  s,
  x as x2
} from "./chunk-VYTPFEL2.js";
import "./chunk-RLGDH6IY.js";
import "./chunk-MRPCXIVS.js";
import "./chunk-YTKVV2Y3.js";
import "./chunk-GCVQXAS4.js";
import "./chunk-UFQD6AL4.js";
import "./chunk-EBCBYN6Y.js";
import "./chunk-ODFKYX74.js";
import "./chunk-THZPD5CT.js";
import {
  h
} from "./chunk-OBCA6CWH.js";
import "./chunk-2JI245BP.js";
import "./chunk-N34BRXVM.js";
import "./chunk-7QV7DHWN.js";
import "./chunk-4L4Y34YK.js";
import "./chunk-2HDBQXAR.js";
import "./chunk-RNF7VOCU.js";
import "./chunk-TIRJMGGG.js";
import "./chunk-ZDRQSPB6.js";
import "./chunk-DCXDXGAR.js";
import "./chunk-BCCDYCTQ.js";
import {
  f
} from "./chunk-AYL3HQHD.js";
import "./chunk-66YQWHHE.js";
import "./chunk-QGBMZIP4.js";
import "./chunk-AOEBZVTA.js";
import {
  c,
  h as h2
} from "./chunk-2OZSYJDX.js";
import {
  K,
  O,
  Y,
  _,
  e as e2,
  g,
  o,
  r as r2,
  u as u2,
  x,
  z
} from "./chunk-MZM4INJV.js";
import {
  n as n2
} from "./chunk-J4GMQHGL.js";
import "./chunk-MHPE4SZA.js";
import {
  J,
  j
} from "./chunk-6SSA7P3A.js";
import "./chunk-FQBTLEUI.js";
import "./chunk-GS7Y3YOG.js";
import "./chunk-Y2HYKTTT.js";
import "./chunk-XLEC46FY.js";
import "./chunk-4AZPIP7K.js";
import "./chunk-JSKTDZU2.js";
import "./chunk-G73HQZEL.js";
import {
  A,
  P,
  d
} from "./chunk-LZSLQ24Q.js";
import "./chunk-U3RHUXYK.js";
import "./chunk-7DBI6LQG.js";
import "./chunk-AUUN7RFQ.js";
import "./chunk-JAMSDYD6.js";
import "./chunk-PH6NPTP7.js";
import {
  e
} from "./chunk-NUICEVIH.js";
import {
  S,
  r
} from "./chunk-NXK752PZ.js";
import {
  y
} from "./chunk-UVNLCXWD.js";
import "./chunk-PNUA7JOS.js";
import "./chunk-OR2FKGUM.js";
import {
  a3 as a
} from "./chunk-UDMPWVPF.js";
import "./chunk-XJNKCEWL.js";
import "./chunk-AIZ3T7E3.js";
import "./chunk-6UEMNP3E.js";
import {
  u
} from "./chunk-6WGE3IUL.js";
import "./chunk-MLYB2YW4.js";
import {
  n2 as n
} from "./chunk-6JFGZTLU.js";
import "./chunk-2ZJE6ZFX.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-XBPEBUD5.js";

// ../../../node_modules/@arcgis/core/views/3d/analysis/DirectLineMeasurement/DirectLineMeasurementController.js
var m2 = class extends S {
  constructor(e8) {
    super(e8);
  }
  initialize() {
    this.addHandles([d(() => ({
      viewData: this.viewData,
      startPoint: this.analysis.startPoint
    }), ({
      viewData: e8,
      startPoint: t5
    }) => {
      e8.elevationAlignedStartPoint = this._applyProjectionAndElevationAlignment(t5);
    }, A), d(() => ({
      viewData: this.viewData,
      endPoint: this.analysis.endPoint
    }), ({
      viewData: e8,
      endPoint: t5
    }) => {
      e8.elevationAlignedEndPoint = this._applyProjectionAndElevationAlignment(t5);
    }, A), d(() => ({
      result: this._computedResult,
      viewData: this.viewData
    }), ({
      result: e8,
      viewData: t5
    }) => {
      t5.result = e8;
    }, A)]);
  }
  _applyProjectionAndElevationAlignment(e8) {
    if (null == e8) return e8;
    const {
      spatialReference: t5,
      elevationProvider: o6
    } = this.view, r8 = r7(e8, t5, o6);
    return r8 ?? (t4(this.analysis, e8.spatialReference, n.getLogger(this)), null);
  }
  get _computedResult() {
    const {
      elevationAlignedStartPoint: e8,
      elevationAlignedEndPoint: t5,
      measurementMode: i2
    } = this.viewData;
    if (null == e8 || null == t5) return null;
    const o6 = h5(e8, t5), r8 = f2(e8, t5);
    if (null == o6) return null;
    let s5, n4;
    switch (i2) {
      case e6.Auto:
        n4 = null != r8 ? "geodesic" : "euclidean", s5 = r8 ?? o6.horizontal;
        break;
      case e6.Geodesic:
        if (null == r8) return null;
        n4 = "geodesic", s5 = r8;
        break;
      case e6.Euclidean:
        n4 = "euclidean", s5 = o6.horizontal;
    }
    return {
      mode: n4,
      directDistance: o6.direct,
      horizontalDistance: s5,
      verticalDistance: o6.vertical,
      distance: i2 === e6.Euclidean || o6.horizontal.value <= i ? o6.direct : r8 ?? o6.horizontal
    };
  }
};
e([y()], m2.prototype, "view", void 0), e([y()], m2.prototype, "analysis", void 0), e([y()], m2.prototype, "viewData", void 0), e([y()], m2.prototype, "_computedResult", null), m2 = e([a("esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementController")], m2);

// ../../../node_modules/@arcgis/core/views/3d/webgl-engine/shaders/MeasurementArrowTechnique.js
var g3 = class _g extends r4 {
  constructor(e8, r8, t5) {
    super(e8, r8, t5);
  }
  initializeProgram(e8) {
    return new r5(e8.rctx, _g.shader.get().build(this.configuration), y3);
  }
  _setPipelineState(e8) {
    const r8 = e8 === o3.NONE, t5 = this.configuration;
    return S2({
      blending: t5.transparent ? r8 ? A2 : c4(e8) : null,
      polygonOffset: this.configuration.polygonOffsetEnabled ? {
        factor: 0,
        units: -4
      } : null,
      depthTest: {
        func: O2.LESS
      },
      depthWrite: o4,
      colorWrite: _2
    });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
  get primitiveType() {
    return E2.TRIANGLE_STRIP;
  }
};
g3.shader = new t2(s4, () => import("./MeasurementArrow.glsl-QDJI6EWO.js"));
var T = class extends t3 {
  constructor() {
    super(...arguments), this.polygonOffsetEnabled = false, this.transparent = false, this.transparencyPassType = o3.NONE;
  }
};
e([r6()], T.prototype, "polygonOffsetEnabled", void 0), e([r6()], T.prototype, "transparent", void 0), e([r6({
  count: o3.COUNT
})], T.prototype, "transparencyPassType", void 0);
var y3 = /* @__PURE__ */ new Map([[e4.POSITION, 0], [e4.NORMAL, 1], [e4.UV0, 2], [e4.LENGTH, 3]]);

// ../../../node_modules/@arcgis/core/views/3d/webgl-engine/materials/MeasurementArrowMaterial.js
var O3 = class extends c3 {
  constructor(t5) {
    super(t5, new A3()), this._vertexAttributeLocations = y3, this.produces = /* @__PURE__ */ new Map([[E3.OPAQUE_MATERIAL, (t6) => !this._transparent && t6 === o2.Color], [E3.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL, (t6) => this._transparent && t6 === o2.Color]]), this._configuration = new T();
  }
  getConfiguration(t5, e8) {
    return this._configuration.polygonOffsetEnabled = this.parameters.polygonOffset, this._configuration.transparent = this._transparent, this._configuration.transparencyPassType = e8.transparencyPassType, this._configuration;
  }
  intersect() {
  }
  createGLMaterial(t5) {
    return new _4(t5);
  }
  createBufferWriter() {
    return new j4();
  }
  get _transparent() {
    const {
      parameters: t5
    } = this;
    return t5.outlineColor[3] < 1 || t5.stripeEvenColor[3] < 1 || t5.stripeOddColor[3] < 1;
  }
};
var _4 = class extends t {
  beginSlot(t5) {
    return this.ensureTechnique(g3, t5);
  }
};
var A3 = class extends u3 {
  constructor() {
    super(...arguments), this.width = 32, this.outlineSize = 0.2, this.outlineColor = r3(1, 0.5, 0, 1), this.stripeEvenColor = r3(1, 1, 1, 1), this.stripeOddColor = r3(1, 0.5, 0, 1), this.stripeLength = 1, this.polygonOffset = false;
  }
};
var T2 = H().vec3f(e4.POSITION).vec3f(e4.NORMAL).vec2f(e4.UV0).f32(e4.LENGTH);
var L = n2();
var v2 = n2();
var E4 = n2();
var I = n2();
var M2 = n2();
var j4 = class {
  constructor() {
    this.vertexBufferLayout = T2;
  }
  elementCount(t5) {
    return 2 * (t5.attributes.get(e4.POSITION).indices.length / 2 + 1);
  }
  write(n4, a4, c5, l, u5) {
    const {
      data: p3,
      indices: f5
    } = c5.attributes.get(e4.POSITION), h6 = c5.attributes.get(e4.NORMAL).data, g4 = p3.length / 3;
    f5 && f5.length !== 2 * (g4 - 1) && console.warn("MeasurementArrowMaterial does not support indices");
    const d2 = L, b2 = v2, O4 = E4, _5 = I, A4 = M2, T3 = l.position, j6 = l.normal, w2 = l.uv0;
    let y6 = 0;
    for (let m3 = 0; m3 < g4; ++m3) {
      const c6 = 3 * m3;
      if (o(d2, p3[c6], p3[c6 + 1], p3[c6 + 2]), m3 < g4 - 1) {
        const o6 = 3 * (m3 + 1);
        o(b2, p3[o6], p3[o6 + 1], p3[o6 + 2]), o(A4, h6[o6], h6[o6 + 1], h6[o6 + 2]), z(A4, A4), e2(O4, b2, d2), z(O4, O4), _(_5, A4, O4), z(_5, _5);
      }
      const l2 = x(d2, b2);
      n4 && a4 && (O(d2, d2, n4), O(b2, b2, n4), O(_5, _5, a4));
      const f6 = u5 + 2 * m3, L2 = f6 + 1;
      T3.setVec(f6, d2), T3.setVec(L2, d2), j6.setVec(f6, _5), j6.setVec(L2, _5), w2.set(f6, 0, y6), w2.set(f6, 1, -1), w2.set(L2, 0, y6), w2.set(L2, 1, 1), m3 < g4 - 1 && (y6 += l2);
    }
    const C = l.length;
    for (let t5 = 0; t5 < 2 * g4; ++t5) C.set(u5 + t5, y6);
  }
};

// ../../../node_modules/@arcgis/core/views/3d/interactive/visualElements/MeasurementArrowVisualElement.js
var y4 = class extends a3 {
  constructor(e8) {
    super(e8), this._arrowWidth = 16, this._arrowSubdivisions = 128, this._origin = n2(), this._originTransform = e3(), this._arrowCenter = n2(), this._renderOccluded = h3.OccludeAndTransparent, this._geometry = null, this._stripeLength = 1, this._stripesEnabled = true, this._color = n3(), this._contrastColor = n3(), this.applyProperties(e8);
  }
  get renderOccluded() {
    return this._renderOccluded;
  }
  set renderOccluded(e8) {
    e8 !== this._renderOccluded && (this._renderOccluded = e8, this._arrowMaterial && this._arrowMaterial.setParameters({
      renderOccluded: e8
    }));
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(e8) {
    this._geometry = e8, this._geometryChanged();
  }
  get stripeLength() {
    return this._stripeLength;
  }
  set stripeLength(e8) {
    this._stripeLength = e8, this.attached && this._arrowMaterial.setParameters({
      stripeLength: this._stripeLength
    });
  }
  get stripesEnabled() {
    return this._stripesEnabled;
  }
  set stripesEnabled(e8) {
    if (this._stripesEnabled = e8, this.attached) {
      const e9 = this._stripesEnabled ? this._contrastColor : this._color;
      this._arrowMaterial.setParameters({
        stripeEvenColor: e9
      });
    }
  }
  get color() {
    return this._color;
  }
  set color(t5) {
    P2(t5, this._color) || (a2(this._color, t5), this._updateArrowColor());
  }
  get contrastColor() {
    return this._contrastColor;
  }
  set contrastColor(t5) {
    P2(t5, this._color) || (a2(this._contrastColor, t5), this._updateArrowColor());
  }
  createExternalResources() {
    const e8 = this._color, r8 = this._contrastColor, o6 = this._stripesEnabled ? r8 : e8;
    this._arrowMaterial = new O3({
      outlineColor: e8,
      stripeEvenColor: o6,
      stripeOddColor: e8,
      renderOccluded: this.renderOccluded,
      polygonOffset: true,
      isDecoration: this.isDecoration
    }), this._handles = new r(), this._handles.add(d(() => this.view.state.camera, () => {
      this._viewChanged();
    }));
  }
  destroyExternalResources() {
    this._arrowMaterial = null, this._handles = u(this._handles);
  }
  forEachExternalMaterial(e8) {
    e8(this._arrowMaterial);
  }
  createGeometries(e8) {
    if (null == this._geometry?.startRenderSpace || null == this._geometry.endRenderSpace) return;
    const t5 = this._createArrowGeometry(this._geometry.startRenderSpace, this._geometry.endRenderSpace, this._origin, this._geometry);
    t5.transformation = this._originTransform, e8.addGeometry(t5), this._viewChanged();
  }
  _createArrowGeometry(e8, t5, r8, s5) {
    const o6 = this.view, a4 = o6.renderCoordsHelper, n4 = [], l = [], c5 = (e9, t6) => {
      const s6 = c2.get();
      e2(s6, e9, r8), n4.push(s6), l.push(t6);
    };
    if ("euclidean" === s5.type) {
      s5.eval(0.5, this._arrowCenter);
      const r9 = c2.get();
      if (a4.worldUpAtPosition(this._arrowCenter, r9), b(e8, t5, r9)) {
        const {
          heading: t6,
          tilt: s6
        } = o6.camera, {
          direction: a5
        } = N(o6, e8, t6, s6, j5);
        r2(r9, a5);
      }
      c5(e8, r9), c5(t5, r9);
    } else {
      s5.eval(0.5, this._arrowCenter);
      const e9 = this._arrowSubdivisions + 1 & -2;
      for (let t6 = 0; t6 < e9; ++t6) {
        const r9 = t6 / (e9 - 1), o7 = c2.get(), i2 = c2.get();
        s5.eval(r9, o7), a4.worldUpAtPosition(o7, i2), c5(o7, i2);
      }
    }
    return gt(this._arrowMaterial, n4, l);
  }
  _geometryChanged() {
    this.recreateGeometry();
  }
  _viewChanged() {
    if (this.view.ready && this.attached && null != this._geometry) {
      const e8 = this.view.state.camera.computeScreenPixelSizeAt(this._arrowCenter);
      this._arrowMaterial.setParameters({
        width: this._arrowWidth * e8
      });
    }
  }
  _updateArrowColor() {
    if (!this.attached) return;
    const e8 = this._color, t5 = this._contrastColor, r8 = this._stripesEnabled ? t5 : e8, s5 = e8, o6 = e8;
    this._arrowMaterial.setParameters({
      stripeEvenColor: r8,
      outlineColor: s5,
      stripeOddColor: o6
    });
  }
};
function b(e8, t5, r8) {
  const s5 = K(v3, t5, e8), o6 = _(v3, s5, r8);
  return 0 === Y(o6);
}
var v3 = n2();
var j5 = u4();

// ../../../node_modules/@arcgis/core/views/3d/analysis/DirectLineMeasurement/DirectLineMeasurementVisualization.js
var W = class extends S {
  get _parameters() {
    const e8 = this.view.effectiveTheme, {
      accentColor: t5,
      textColor: l
    } = e8, a4 = E(t5), c5 = F(t5, 0.75), d2 = E(G(t5)), h6 = G(l, q.Low);
    return {
      accentColor: a4,
      contrastColor: d2,
      translucentAccentColor: c5,
      triangleLineWidth: 3,
      geodesicProjectionLineWidth: 2,
      guideLineWidth: 2,
      guideStippleLengthPixels: 3,
      directLabelFontSize: 16,
      horizontalLabelFontSize: 12,
      verticalLabelFontSize: 12,
      textColor: l,
      textBackgroundColor: R(h6, 0.6),
      textCalloutColor: R(h6, 0.5)
    };
  }
  get visible() {
    return this.analysisView.visible;
  }
  get viewMode() {
    const {
      elevationAlignedStartPoint: e8,
      elevationAlignedEndPoint: t5
    } = this.analysisView;
    if (null == e8 || null == t5 || e8.equals(t5)) return e7.None;
    const i2 = this.analysisView.result;
    if (null == i2) return e7.Direct;
    if ("geodesic" === this.actualVisualizedMeasurement) return this._requiresGeodesicGuideAt(this._startPosition) || this._requiresGeodesicGuideAt(this._endPosition) ? e7.ProjectedGeodesic : e7.Direct;
    const {
      verticalDistance: s5,
      horizontalDistance: n4
    } = i2, o6 = s5.value, r8 = n4.value;
    return Math.min(o6 / r8, r8 / o6) < this.triangleCollapseRatioThreshold ? e7.Direct : e7.Triangle;
  }
  get actualVisualizedMeasurement() {
    const {
      measurementMode: e8,
      result: t5
    } = this.analysisView;
    switch (e8) {
      case e6.Auto:
        return null != t5 && t5.horizontalDistance.value > i ? "geodesic" : "euclidean";
      case e6.Euclidean:
        return "euclidean";
      case e6.Geodesic:
        return "geodesic";
    }
  }
  get allowVisualElementsOrientationChange() {
    return null == this._triangleOrientationOverride;
  }
  set allowVisualElementsOrientationChange(e8) {
    null == this._triangleOrientationOverride !== e8 && (null == this._triangleOrientationOverride ? this._triangleOrientationOverride = this._actualVisualElementsOrientation : this._triangleOrientationOverride = null);
  }
  get labels() {
    return "geodesic" === this.actualVisualizedMeasurement ? {
      direct: null,
      horizontal: this._segmentLabel,
      vertical: this._verticalLabel
    } : {
      direct: this._segmentLabel,
      horizontal: this._horizontalLabel,
      vertical: this._verticalLabel
    };
  }
  constructor(e8) {
    super(e8), this._segmentVisualElement = null, this._triangleVisualElement = null, this._rightAngleQuad = null, this._projectedGeodesicLine = null, this._geodesicStartHint = null, this._geodesicEndHint = null, this._segmentLabel = null, this._verticalLabel = null, this._horizontalLabel = null, this._startPosition = n2(), this._endPosition = n2(), this._cornerPosition = n2(), this._startPositionAtSeaLevel = n2(), this._endPositionAtSeaLevel = n2(), this._triangleOrientationOverride = null, this.messages = null, this.loadingMessages = true, this.visualElementOrientation = o5.Auto, this.triangleCollapseRatioThreshold = 0.03;
  }
  initialize() {
    const e8 = this._parameters, t5 = {
      attached: true,
      view: this.view,
      isDecoration: true
    }, {
      guideLineWidth: i2,
      guideStippleLengthPixels: s5,
      triangleLineWidth: n4,
      geodesicProjectionLineWidth: o6,
      directLabelFontSize: r8,
      verticalLabelFontSize: l,
      horizontalLabelFontSize: a4
    } = e8;
    this._segmentVisualElement = new y4(__spreadProps(__spreadValues({}, t5), {
      geometry: null,
      renderOccluded: h3.OccludeAndTransparent
    })), this._triangleVisualElement = new f3(__spreadProps(__spreadValues({}, t5), {
      width: n4,
      renderOccluded: h3.OccludeAndTransparent
    })), this._rightAngleQuad = new D(__spreadProps(__spreadValues({}, t5), {
      renderOccluded: h3.OccludeAndTransparent
    }));
    const c5 = __spreadProps(__spreadValues({}, t5), {
      polygonOffset: true,
      renderOccluded: h3.OccludeAndTransparent
    });
    this._projectedGeodesicLine = new f3(__spreadProps(__spreadValues({}, c5), {
      width: o6,
      stipplePattern: h4(s5)
    })), this._geodesicStartHint = new f3(__spreadProps(__spreadValues({}, c5), {
      width: i2,
      stipplePattern: h4(s5)
    })), this._geodesicEndHint = new f3(__spreadProps(__spreadValues({}, c5), {
      width: i2,
      stipplePattern: h4(s5)
    })), this._segmentLabel = new f4(__spreadProps(__spreadValues({}, t5), {
      fontSize: r8
    })), this._verticalLabel = new f4(__spreadProps(__spreadValues({}, t5), {
      fontSize: l
    })), this._horizontalLabel = new f4(__spreadProps(__spreadValues({}, t5), {
      fontSize: a4
    })), this.addHandles([d(() => {
      const {
        elevationAlignedStartPoint: e9,
        elevationAlignedEndPoint: t6
      } = this.analysisView, i3 = this.view;
      return {
        view: i3,
        camera: i3.state.camera,
        viewMode: this.viewMode,
        elevationAlignedStartPoint: e9,
        elevationAlignedEndPoint: t6,
        orientation: this._actualVisualElementsOrientation,
        visualizedMeasurement: this.actualVisualizedMeasurement,
        stripeLength: this._measurementArrowStripeLength
      };
    }, (e9) => this._updateGeometryAndViewMode(e9), A), d(() => ({
      visible: this.visible,
      viewMode: this.viewMode
    }), (e9) => this._updateVisualElementVisibility(e9), A), d(() => ({
      text: this._labelsText,
      visualizedMeasurement: this.actualVisualizedMeasurement
    }), (e9) => this._updateLabelText(e9), A), d(() => ({
      visible: this.visible,
      viewMode: this.viewMode
    }), (e9) => this._updateLabelVisibility(e9), A), d(() => this._measurementArrowStripeLength, (e9) => this._updateSegmentStripeLength(e9), A), f(() => __async(this, null, function* () {
      return this._updateMessageBundle();
    })), d(() => this._parameters, ({
      textBackgroundColor: e9,
      textCalloutColor: t6,
      textColor: i3,
      translucentAccentColor: s6,
      accentColor: n5,
      contrastColor: o7
    }) => {
      const {
        _segmentLabel: r9,
        _verticalLabel: l2,
        _horizontalLabel: a5,
        _triangleVisualElement: c6,
        _rightAngleQuad: d2,
        _projectedGeodesicLine: h6,
        _geodesicStartHint: u5,
        _geodesicEndHint: m3,
        _segmentVisualElement: g4
      } = this;
      r9.backgroundColor = e9, r9.calloutColor = t6, r9.textColor = i3, l2.backgroundColor = e9, l2.calloutColor = t6, l2.textColor = i3, a5.backgroundColor = e9, a5.calloutColor = t6, a5.textColor = i3, c6.color = s6, d2.color = s6, h6.color = s6, u5.color = s6, m3.color = s6, g4.color = n5, g4.contrastColor = o7;
    }, P)]), this._updateMessageBundle();
  }
  destroy() {
    this._segmentVisualElement = u(this._segmentVisualElement), this._triangleVisualElement = u(this._triangleVisualElement), this._rightAngleQuad = u(this._rightAngleQuad), this._projectedGeodesicLine = u(this._projectedGeodesicLine), this._geodesicStartHint = u(this._geodesicStartHint), this._geodesicEndHint = u(this._geodesicEndHint), this._segmentLabel = u(this._segmentLabel), this._verticalLabel = u(this._verticalLabel), this._horizontalLabel = u(this._horizontalLabel), this.set("view", null);
  }
  _updateVisualElementVisibility({
    visible: e8,
    viewMode: t5
  }) {
    if (this._segmentVisualElement.visible = false, this._triangleVisualElement.visible = false, this._rightAngleQuad.visible = false, this._projectedGeodesicLine.visible = false, this._geodesicStartHint.visible = false, this._geodesicEndHint.visible = false, e8) switch (t5) {
      case e7.None:
        break;
      case e7.Direct:
        this._segmentVisualElement.visible = true;
        break;
      case e7.Triangle:
        this._segmentVisualElement.visible = true, this._triangleVisualElement.visible = true, this._rightAngleQuad.visible = true;
        break;
      case e7.ProjectedGeodesic:
        this._segmentVisualElement.visible = true, this._projectedGeodesicLine.visible = true, this._geodesicStartHint.visible = true, this._geodesicEndHint.visible = true;
    }
  }
  _updateGeometryAndViewMode({
    view: e8,
    camera: t5,
    viewMode: i2,
    elevationAlignedStartPoint: s5,
    elevationAlignedEndPoint: n4,
    orientation: o6,
    visualizedMeasurement: r8,
    stripeLength: l
  }) {
    const a4 = e8.renderCoordsHelper;
    if (null == a4 || null == s5 || null == n4 || s5.equals(n4)) return;
    let c5 = this._startPosition, d2 = this._endPosition;
    a4.toRenderCoords(s5, c5), a4.toRenderCoords(n4, d2);
    const h6 = o6 === o5.AboveSegment ? 1 : -1, u5 = h6 * (a4.getAltitude(d2) - a4.getAltitude(c5));
    u5 < 0 && (c5 = this._endPosition, d2 = this._startPosition);
    const m3 = "geodesic" === r8 ? new _3(this._startPosition, this._endPosition, a4.spatialReference) : new m(this._startPosition, this._endPosition);
    switch (this._segmentVisualElement.geometry = m3, this._updateSegmentStripeLength(l), i2) {
      case e7.Direct:
        this._updateSegment(m3, o6);
        break;
      case e7.Triangle:
        this._updateSegmentAndTriangle({
          view: e8,
          camera: t5,
          segment: m3,
          orientation: o6,
          startPosition: c5,
          endPosition: d2,
          deltaSign: h6,
          altitudeDelta: u5
        });
        break;
      case e7.ProjectedGeodesic:
        this._updateSegmentAndProjection({
          view: e8,
          orientation: o6,
          startPosition: c5,
          endPosition: d2
        });
    }
  }
  _updateSegment(e8, t5) {
    this._segmentLabel.anchor = t5 === o5.AboveSegment ? "top" : "bottom", this._segmentLabel.geometry = {
      type: "segment",
      segment: e8,
      sampleLocation: "center"
    };
  }
  _updateSegmentAndTriangle({
    view: {
      renderCoordsHelper: e8
    },
    camera: t5,
    segment: i2,
    orientation: s5,
    startPosition: n4,
    endPosition: o6,
    deltaSign: r8,
    altitudeDelta: l
  }) {
    const a4 = this._cornerPosition;
    e8.worldUpAtPosition(n4, a4), g(a4, a4, r8 * Math.abs(l)), u2(a4, a4, n4), this._triangleVisualElement.geometry = [[[n4[0], n4[1], n4[2]], [a4[0], a4[1], a4[2]], [o6[0], o6[1], o6[2]]]], this._rightAngleQuad.geometry = {
      previous: n4,
      center: a4,
      next: o6
    };
    const c5 = new m(n4, a4), d2 = new m(a4, o6), h6 = N2(n4, o6, a4, s5, t5);
    this._segmentLabel.anchor = h6.segment, this._segmentLabel.geometry = {
      type: "segment",
      segment: i2,
      sampleLocation: "center"
    }, this._verticalLabel.geometry = {
      type: "segment",
      segment: c5,
      sampleLocation: "center"
    }, this._verticalLabel.anchor = h6.vertical, this._horizontalLabel.geometry = {
      type: "segment",
      segment: d2,
      sampleLocation: "center"
    }, this._horizontalLabel.anchor = h6.horizontal;
  }
  _updateSegmentAndProjection({
    view: {
      renderCoordsHelper: e8
    },
    orientation: t5,
    startPosition: i2,
    endPosition: s5
  }) {
    e8.setAltitude(this._startPositionAtSeaLevel, 0, i2), e8.setAltitude(this._endPositionAtSeaLevel, 0, s5);
    const n4 = new _3(this._startPositionAtSeaLevel, this._endPositionAtSeaLevel, e8.spatialReference);
    this._projectedGeodesicLine.setGeometryFromSegment(n4), this._geodesicStartHint.setGeometryFromSegment(new m(this._startPositionAtSeaLevel, i2)), this._geodesicEndHint.setGeometryFromSegment(new m(this._endPositionAtSeaLevel, s5)), this._segmentLabel.geometry = {
      type: "segment",
      segment: n4,
      sampleLocation: "center"
    }, this._segmentLabel.anchor = t5 === o5.AboveSegment ? "top" : "bottom";
  }
  _updateLabelText({
    text: e8,
    visualizedMeasurement: t5
  }) {
    null != e8 ? (this._segmentLabel.text = "euclidean" === t5 ? e8.directDistance : e8.horizontalDistance, this._horizontalLabel.text = e8.horizontalDistance, this._verticalLabel.text = e8.verticalDistance) : (this._segmentLabel.text = null, this._horizontalLabel.text = null, this._verticalLabel.text = null), this.notifyChange("labels");
  }
  _updateLabelVisibility({
    visible: e8,
    viewMode: t5
  }) {
    const i2 = this._segmentLabel, s5 = this._horizontalLabel, n4 = this._verticalLabel;
    if (i2.visible = false, s5.visible = false, n4.visible = false, e8) switch (t5) {
      case e7.Direct:
        i2.visible = true;
        break;
      case e7.Triangle:
        i2.visible = true, s5.visible = true, n4.visible = true;
        break;
      case e7.ProjectedGeodesic:
        i2.visible = true;
      case e7.None:
    }
  }
  get _labelsText() {
    if (this.destroyed) return null;
    const e8 = this.messages, t5 = this.analysisView.result;
    if (null == t5 || null == e8) return null;
    const {
      directDistance: i2,
      horizontalDistance: s5,
      verticalDistance: n4
    } = t5, o6 = this.analysisView.unit, r8 = (e9) => __spreadValues({
      directDistance: "",
      horizontalDistance: "",
      verticalDistance: ""
    }, e9);
    switch (o6) {
      case "metric":
        return r8({
          directDistance: i2 && M(e8, i2),
          horizontalDistance: s5 && M(e8, s5),
          verticalDistance: n4 && w(e8, n4)
        });
      case "imperial":
        return r8({
          directDistance: i2 && y2(e8, i2),
          horizontalDistance: s5 && y2(e8, s5),
          verticalDistance: n4 && j3(e8, n4)
        });
      default:
        return r8({
          directDistance: i2 && g2(e8, i2, o6),
          horizontalDistance: s5 && g2(e8, s5, o6),
          verticalDistance: n4 && g2(e8, n4, o6)
        });
    }
  }
  _updateSegmentStripeLength(e8) {
    const t5 = this._segmentVisualElement;
    null != e8 ? (t5.stripeLength = e8, t5.stripesEnabled = true) : t5.stripesEnabled = false;
  }
  get _actualVisualElementsOrientation() {
    if (null != this._triangleOrientationOverride) return this._triangleOrientationOverride;
    const e8 = this.visualElementOrientation;
    return e8 === o5.Auto ? this.view.state.camera.aboveGround ? o5.AboveSegment : o5.BelowSegment : e8;
  }
  _requiresGeodesicGuideAt(e8) {
    const t5 = this.view;
    if (!t5?.state) return false;
    const i2 = t5.state.camera, s5 = t5.renderCoordsHelper;
    if (!s5) return false;
    const n4 = i2.computeScreenPixelSizeAt(e8);
    return s5.getAltitude(e8) / n4 >= 10;
  }
  get _measurementArrowStripeLength() {
    const {
      result: e8,
      unit: t5
    } = this.analysisView;
    if (null == e8) return null;
    let i2 = null;
    const s5 = e8.directDistance;
    switch (t5) {
      case "metric":
        i2 = s5 && s2(s5, "meters");
        break;
      case "imperial":
        i2 = s5 && s2(s5, J(s5.value, s5.unit));
        break;
      default:
        i2 = s5 && s2(s5, t5);
    }
    if (null == i2) return null;
    return c(i2.value / 30) * j(1, i2.unit, "meters");
  }
  _updateMessageBundle() {
    this.loadingMessages = true, h("esri/core/t9n/Units").then((e8) => {
      this.messages = e8;
    }).finally(() => {
      this.loadingMessages = false;
    });
  }
  get testData() {
  }
};
function N2(e8, t5, i2, s5, n4) {
  const o6 = J2, r8 = K2;
  n4.projectToRenderScreen(i2, o6), n4.projectToRenderScreen(t5, r8);
  const l = {
    segment: "bottom",
    horizontal: "top",
    vertical: o6[0] < r8[0] ? "left" : "right"
  };
  {
    const s6 = X, o7 = Y2;
    if (p(e8, i2, n4, s6), p(e8, t5, n4, o7), j2(s6, o7) >= I2) {
      const e9 = Math.sign(s6[1]) === Math.sign(o7[1]);
      l.segment = e9 ? v(l.vertical) : l.vertical;
    } else {
      const e9 = Z;
      p(i2, t5, n4, e9), j2(e9, o7) >= I2 && (l.segment = Math.sign(e9[0]) === Math.sign(o7[0]) ? v(l.horizontal) : l.horizontal);
    }
  }
  if (s5 === o5.BelowSegment) {
    const e9 = (e10) => "top" === e10 ? "bottom" : "top";
    l.segment = e9(l.segment), l.horizontal = e9(l.horizontal), l.vertical = e9(l.vertical);
  }
  return l;
}
e([y()], W.prototype, "_parameters", null), e([y()], W.prototype, "_triangleOrientationOverride", void 0), e([y()], W.prototype, "messages", void 0), e([y()], W.prototype, "view", void 0), e([y()], W.prototype, "analysis", void 0), e([y()], W.prototype, "analysisView", void 0), e([y()], W.prototype, "loadingMessages", void 0), e([y()], W.prototype, "visible", null), e([y()], W.prototype, "viewMode", null), e([y()], W.prototype, "actualVisualizedMeasurement", null), e([y()], W.prototype, "visualElementOrientation", void 0), e([y()], W.prototype, "triangleCollapseRatioThreshold", void 0), e([y()], W.prototype, "allowVisualElementsOrientationChange", null), e([y()], W.prototype, "labels", null), e([y()], W.prototype, "_labelsText", null), e([y()], W.prototype, "_actualVisualElementsOrientation", null), e([y()], W.prototype, "_measurementArrowStripeLength", null), W = e([a("esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementVisualization")], W);
var I2 = Math.cos(h2(12));
var J2 = x2();
var K2 = x2();
var X = s();
var Y2 = s();
var Z = s();

// ../../../node_modules/@arcgis/core/views/3d/analysis/DirectLineMeasurementAnalysisView3D.js
var p2 = class extends s3(S) {
  constructor(t5) {
    super(t5), this.type = "direct-line-measurement-view-3d", this.analysis = null, this.result = null, this.measurementMode = e6.Auto, this.elevationAlignedStartPoint = null, this.elevationAlignedEndPoint = null;
  }
  initialize() {
    const t5 = this.view, e8 = this.analysis;
    this._analysisVisualization = new W({
      view: t5,
      analysis: e8,
      analysisView: this
    }), this._analysisController = new m2({
      view: t5,
      analysis: e8,
      viewData: this
    });
  }
  destroy() {
    this._analysisController = u(this._analysisController), this._analysisVisualization = u(this._analysisVisualization);
  }
  get updating() {
    return !!this._analysisVisualization?.loadingMessages;
  }
  get viewMode() {
    return this._analysisVisualization.viewMode;
  }
  get actualVisualizedMeasurement() {
    return this._analysisVisualization.actualVisualizedMeasurement;
  }
  get visualElementOrientation() {
    return this._analysisVisualization.visualElementOrientation;
  }
  set visualElementOrientation(t5) {
    this._analysisVisualization.visualElementOrientation = t5;
  }
  get allowVisualElementsOrientationChange() {
    return this._analysisVisualization.allowVisualElementsOrientationChange;
  }
  set allowVisualElementsOrientationChange(t5) {
    this._analysisVisualization.allowVisualElementsOrientationChange = t5;
  }
  get triangleCollapseRatioThreshold() {
    return this._analysisVisualization.triangleCollapseRatioThreshold;
  }
  set triangleCollapseRatioThreshold(t5) {
    this._analysisVisualization.triangleCollapseRatioThreshold = t5;
  }
  get directLabelText() {
    return this._analysisVisualization.labels.direct?.text ?? "";
  }
  get horizontalLabelText() {
    return this._analysisVisualization.labels.horizontal?.text ?? "";
  }
  get verticalLabelText() {
    return this._analysisVisualization.labels.vertical?.text ?? "";
  }
  get unit() {
    return this.analysis.unit ?? this._defaultUnit;
  }
  get testData() {
  }
};
e([y()], p2.prototype, "updating", null), e([y({
  readOnly: true
})], p2.prototype, "type", void 0), e([y({
  constructOnly: true,
  nonNullable: true
})], p2.prototype, "analysis", void 0), e([y()], p2.prototype, "result", void 0), e([y()], p2.prototype, "measurementMode", void 0), e([y()], p2.prototype, "elevationAlignedStartPoint", void 0), e([y()], p2.prototype, "elevationAlignedEndPoint", void 0), e([y({
  readOnly: true
})], p2.prototype, "viewMode", null), e([y({
  readOnly: true
})], p2.prototype, "actualVisualizedMeasurement", null), e([y()], p2.prototype, "visualElementOrientation", null), e([y()], p2.prototype, "allowVisualElementsOrientationChange", null), e([y()], p2.prototype, "triangleCollapseRatioThreshold", null), e([y({
  readOnly: true
})], p2.prototype, "directLabelText", null), e([y({
  readOnly: true
})], p2.prototype, "horizontalLabelText", null), e([y({
  readOnly: true
})], p2.prototype, "verticalLabelText", null), e([y()], p2.prototype, "_analysisVisualization", void 0), e([y()], p2.prototype, "_analysisController", void 0), e([y()], p2.prototype, "unit", null), e([y(e5)], p2.prototype, "_defaultUnit", void 0), p2 = e([a("esri.views.3d.analysis.DirectLineMeasurementAnalysisView3D")], p2);
var y5 = p2;
export {
  y5 as default
};
//# sourceMappingURL=DirectLineMeasurementAnalysisView3D-R4OE3W5I.js.map
