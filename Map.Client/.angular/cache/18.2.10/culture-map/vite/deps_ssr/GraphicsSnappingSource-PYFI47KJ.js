import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  i as i2,
  o as o2
} from "./chunk-LRC2VZON.js";
import "./chunk-2KWC6XPV.js";
import {
  t
} from "./chunk-6NBMJUQX.js";
import "./chunk-WXECQAUG.js";
import "./chunk-RFURERTV.js";
import "./chunk-CATQ6UZ5.js";
import {
  f,
  y as y3
} from "./chunk-MIWJLMUG.js";
import "./chunk-MDOKECP3.js";
import "./chunk-IVVINOEJ.js";
import "./chunk-DUSY4H5O.js";
import "./chunk-XUM2DDAI.js";
import "./chunk-JRL65HQ7.js";
import "./chunk-62PN4TEW.js";
import "./chunk-OPXEKSUB.js";
import {
  a as a2
} from "./chunk-FW7J76DZ.js";
import {
  J as J2
} from "./chunk-5ZLERKFB.js";
import "./chunk-62NDSO75.js";
import "./chunk-B76NC7GX.js";
import {
  i,
  n,
  r
} from "./chunk-FK5JVO4B.js";
import {
  h as h2
} from "./chunk-HFXXFWYN.js";
import {
  m
} from "./chunk-BYXMUOMW.js";
import "./chunk-YEWOBDQB.js";
import {
  $
} from "./chunk-FWEBARAB.js";
import "./chunk-RHUWRAPT.js";
import "./chunk-VY63YX6I.js";
import {
  I
} from "./chunk-EXKCGLRO.js";
import "./chunk-WRLGLGM6.js";
import "./chunk-47DYJR3W.js";
import "./chunk-NE35ZNG6.js";
import "./chunk-ZLSZAC2I.js";
import "./chunk-QRWQ6QBB.js";
import "./chunk-TFW6WS6R.js";
import {
  ot
} from "./chunk-X5QZGB37.js";
import "./chunk-T5C2TZNO.js";
import "./chunk-AOGKNBDG.js";
import "./chunk-F4FQ67JP.js";
import "./chunk-FDI2X6GO.js";
import "./chunk-3XHDZQO5.js";
import {
  e as e2
} from "./chunk-2BLQXT54.js";
import "./chunk-JSWVKNBA.js";
import "./chunk-LL33G4DK.js";
import "./chunk-CILHMGNK.js";
import "./chunk-2BOKEEZV.js";
import {
  y as y2
} from "./chunk-ZSJNH2BT.js";
import "./chunk-XP2AJZUL.js";
import "./chunk-L6FG3WIC.js";
import "./chunk-6ZLH7XBS.js";
import "./chunk-44ZUWZXU.js";
import "./chunk-EKHRAAS6.js";
import "./chunk-NHYYZMJR.js";
import "./chunk-2TNGEJGS.js";
import "./chunk-OYGNGIHQ.js";
import "./chunk-GSG4T2KM.js";
import "./chunk-BZHHBBFX.js";
import "./chunk-YGAXDKHF.js";
import "./chunk-4TOSJLKR.js";
import "./chunk-ORYC4PVJ.js";
import "./chunk-DXIKKLD7.js";
import "./chunk-VQNXE43R.js";
import "./chunk-VZ37C3ID.js";
import {
  Z
} from "./chunk-5R3HARKC.js";
import "./chunk-BKSTWG4S.js";
import "./chunk-FSG7HOZQ.js";
import "./chunk-Q5TIVVER.js";
import "./chunk-ZREJ3Y2F.js";
import "./chunk-IR6CVPPC.js";
import "./chunk-BBUQOCRA.js";
import "./chunk-YBUJLIWZ.js";
import "./chunk-DL2B6IFJ.js";
import "./chunk-VOOO6FU5.js";
import "./chunk-IUPJR3FF.js";
import "./chunk-TGZW6QWO.js";
import "./chunk-OYIDHTXG.js";
import "./chunk-KUBMHTYA.js";
import "./chunk-NU4K6CTR.js";
import "./chunk-42ZAWY2C.js";
import "./chunk-TVHVZK5G.js";
import "./chunk-P2MUOE6G.js";
import "./chunk-CRYYUS4E.js";
import "./chunk-V33IUWAS.js";
import "./chunk-E5NWFBZG.js";
import "./chunk-FP37456K.js";
import "./chunk-VSQZQLTQ.js";
import "./chunk-K43CZ3M5.js";
import "./chunk-6EIBUVMG.js";
import "./chunk-YCXNHEGB.js";
import "./chunk-CSATD3VX.js";
import "./chunk-NXXQ35YM.js";
import {
  J,
  K,
  N
} from "./chunk-LM3JDV4W.js";
import "./chunk-34V2CLL5.js";
import "./chunk-7V4JSBFA.js";
import "./chunk-JEFPXTYT.js";
import "./chunk-MVS2BECH.js";
import "./chunk-2EJFYNM7.js";
import "./chunk-DC5LRNPY.js";
import "./chunk-5X5U7R6O.js";
import "./chunk-XNLAOXPY.js";
import "./chunk-ZT7V2AVD.js";
import "./chunk-C2OXE4NQ.js";
import "./chunk-KOI252FF.js";
import "./chunk-I2TVVMQ6.js";
import "./chunk-5EGQYY2H.js";
import "./chunk-JKPUNUQA.js";
import "./chunk-SR7PRON4.js";
import {
  o
} from "./chunk-HGHPYGKP.js";
import "./chunk-4DSGTDZJ.js";
import "./chunk-VYTPFEL2.js";
import "./chunk-RLGDH6IY.js";
import {
  j
} from "./chunk-MRPCXIVS.js";
import "./chunk-YTKVV2Y3.js";
import "./chunk-GCVQXAS4.js";
import "./chunk-UFQD6AL4.js";
import "./chunk-THZPD5CT.js";
import "./chunk-OBCA6CWH.js";
import "./chunk-2JI245BP.js";
import "./chunk-CBOFHWPI.js";
import "./chunk-ABIG6PT5.js";
import "./chunk-ZEZ3LI2L.js";
import "./chunk-N34BRXVM.js";
import "./chunk-KETDH2J4.js";
import "./chunk-7QV7DHWN.js";
import "./chunk-4L4Y34YK.js";
import "./chunk-BXONKQKI.js";
import "./chunk-2HDBQXAR.js";
import "./chunk-RNF7VOCU.js";
import "./chunk-TIRJMGGG.js";
import "./chunk-ZDRQSPB6.js";
import "./chunk-DCXDXGAR.js";
import "./chunk-BCCDYCTQ.js";
import "./chunk-AYL3HQHD.js";
import "./chunk-66YQWHHE.js";
import "./chunk-QGBMZIP4.js";
import "./chunk-AOEBZVTA.js";
import "./chunk-2OZSYJDX.js";
import "./chunk-MZM4INJV.js";
import "./chunk-J4GMQHGL.js";
import "./chunk-MHPE4SZA.js";
import "./chunk-6SSA7P3A.js";
import "./chunk-FQBTLEUI.js";
import "./chunk-GS7Y3YOG.js";
import "./chunk-Y2HYKTTT.js";
import "./chunk-XLEC46FY.js";
import "./chunk-4AZPIP7K.js";
import "./chunk-G73HQZEL.js";
import {
  P,
  d as d2,
  v
} from "./chunk-LZSLQ24Q.js";
import "./chunk-U3RHUXYK.js";
import "./chunk-7DBI6LQG.js";
import {
  d
} from "./chunk-AUUN7RFQ.js";
import "./chunk-JAMSDYD6.js";
import "./chunk-PH6NPTP7.js";
import {
  e
} from "./chunk-NUICEVIH.js";
import {
  S as S2
} from "./chunk-NXK752PZ.js";
import {
  y
} from "./chunk-UVNLCXWD.js";
import "./chunk-PNUA7JOS.js";
import "./chunk-OR2FKGUM.js";
import {
  a3 as a
} from "./chunk-UDMPWVPF.js";
import "./chunk-XJNKCEWL.js";
import {
  g,
  h,
  s
} from "./chunk-AIZ3T7E3.js";
import "./chunk-6UEMNP3E.js";
import "./chunk-6WGE3IUL.js";
import "./chunk-MLYB2YW4.js";
import "./chunk-6JFGZTLU.js";
import {
  S
} from "./chunk-2ZJE6ZFX.js";
import {
  __async
} from "./chunk-XBPEBUD5.js";

// ../../../node_modules/@arcgis/core/views/interactive/snapping/featureSources/GraphicsSnappingSource.js
var z = "graphics-collections";
var O = class extends S2 {
  get updating() {
    return this._updatingHandles.updating;
  }
  get _hasZ() {
    const e3 = this.view;
    return null != e3 && "3d" === e3.type && "map-notes" !== this.layerSource.layer.type;
  }
  get _snappingElevationAligner() {
    const {
      view: e3
    } = this, {
      layer: t2
    } = this.layerSource, o3 = null != e3 && "3d" === e3.type;
    if (!o3 || "map-notes" === t2.type) return i();
    const s2 = (o4, s3) => __async(this, null, function* () {
      return (yield h(e3.whenLayerView(t2), s3)).elevationAlignPointsInFeatures(o4, s3);
    });
    return i(o3, {
      elevationInfo: t2.elevationInfo,
      alignPointsInFeatures: s2
    });
  }
  get _snappingElevationFilter() {
    const {
      view: e3
    } = this, t2 = null != e3 && "3d" === e3.type && "map-notes" !== this.layerSource.layer.type;
    return r(t2);
  }
  get _symbologySnappingFetcher() {
    const {
      view: e3
    } = this, {
      layer: t2
    } = this.layerSource, o3 = null != e3 && "3d" === e3.type, s2 = this._extrudedPolygonSymbolsCount > 0;
    return o3 && "map-notes" !== t2.type && s2 ? n(s2, (o4, s3) => __async(this, null, function* () {
      const r2 = yield e3.whenLayerView(t2);
      return s(s3), r2.queryForSymbologySnapping({
        candidates: o4,
        spatialReference: e3.spatialReference
      }, s3);
    })) : n();
  }
  constructor(e3) {
    super(e3), this.availability = 1, this._sources = {
      multipoint: null,
      point: null,
      polygon: null,
      polyline: null
    }, this._loadedWkids = /* @__PURE__ */ new Set(), this._loadedWkts = /* @__PURE__ */ new Set(), this._pendingAdds = [], this._extrudedPolygonSymbolsCount = 0, this._updatingHandles = new h2(), this._memoizedMakeGetGroundElevation = t(i2);
  }
  destroy() {
    for (const e3 of this._pendingAdds) e3.task.abort();
    this._pendingAdds.length = 0, this._mapSources((e3) => this._destroySource(e3)), this._updatingHandles.destroy();
  }
  initialize() {
    this._updatingHandles.add(() => this.getGraphicsLayers(), (e4) => {
      this._updatingHandles.removeHandles(z);
      for (const t3 of e4) this._addMany(t3.graphics.toArray()), this.addHandles([t3.on("graphic-update", (e5) => this._onGraphicUpdate(e5)), this._updatingHandles.addOnCollectionChange(() => t3.graphics, (e5) => this._onGraphicsChanged(e5))], z);
    }, P);
    const {
      view: e3
    } = this, {
      layer: t2
    } = this.layerSource;
    null != e3 && "3d" === e3.type && "map-notes" !== t2.type && e3.elevationProvider && this.addHandles([e3.elevationProvider.on("elevation-change", ({
      context: e4
    }) => {
      y2(e4, t2.elevationInfo) && this._snappingElevationAligner.notifyElevationSourceChange();
    }), d2(() => t2.elevationInfo, () => this._snappingElevationAligner.notifyElevationSourceChange(), P), v(() => t2, ["edits", "apply-edits", "graphic-update"], () => this._symbologySnappingFetcher.notifySymbologyChange())]);
  }
  fetchCandidates(e3, t2) {
    return __async(this, null, function* () {
      const {
        point: o3,
        coordinateHelper: {
          spatialReference: s2
        }
      } = e3, r2 = yield g(this._mapSources((o4) => this._fetchCandidatesForSource(o4, e3, t2)));
      s(t2);
      const a3 = this._memoizedMakeGetGroundElevation(this.view, s2), p = r2.flat().map((e4) => o2(e4, a3));
      return f(o3, p), p;
    });
  }
  _fetchCandidatesForSource(e3, t2, o3) {
    return __async(this, null, function* () {
      const s2 = y3(t2, this.view?.type ?? "2d"), r2 = yield e3.queryEngine.executeQueryForSnapping(s2, o3);
      s(o3);
      const n2 = yield this._snappingElevationAligner.alignCandidates(r2.candidates, t2.coordinateHelper.spatialReference, o3);
      s(o3);
      const a3 = yield this._symbologySnappingFetcher.fetch(n2, o3);
      s(o3);
      const p = 0 === a3.length ? n2 : [...n2, ...a3];
      return this._snappingElevationFilter.filter(s2, p);
    });
  }
  refresh() {
  }
  _onGraphicUpdate(e3) {
    if (this.getGraphicsLayers().some((t2) => t2.graphics.includes(e3.graphic))) switch (e3.property) {
      case "geometry":
      case "visible":
        this._remove(e3.graphic), this._addMany([e3.graphic]);
    }
  }
  _onGraphicsChanged(e3) {
    for (const t2 of e3.removed) this._remove(t2);
    this._addMany(e3.added);
  }
  _addMany(e3) {
    const t2 = [], o3 = /* @__PURE__ */ new Map();
    for (const s2 of e3) null != s2.geometry && (this._needsInitializeProjection(s2.geometry.spatialReference) ? (t2.push(s2.geometry.spatialReference), o3.set(s2.uid, s2)) : this._add(s2));
    this._createPendingAdd(t2, o3);
  }
  _createPendingAdd(e3, t2) {
    if (!e3.length) return;
    const r2 = d((o3) => __async(this, null, function* () {
      yield N(e3.map((e4) => ({
        source: e4,
        dest: this.spatialReference
      })), {
        signal: o3
      }), this._markLoadedSpatialReferences(e3);
      for (const [, e4] of t2) this._add(e4);
    }));
    this._updatingHandles.addPromise(r2.promise);
    const i3 = {
      task: r2,
      graphics: t2
    }, n2 = () => S(this._pendingAdds, i3);
    r2.promise.then(n2, n2), this._pendingAdds.push(i3);
  }
  _markLoadedSpatialReferences(e3) {
    for (const t2 of e3) {
      null != t2.wkid && this._loadedWkids.add(t2.wkid);
      const e4 = t2.wkt2 || t2.wkt;
      e4 && this._loadedWkts.add(e4);
    }
  }
  _add(e3) {
    if (null == e3.geometry || !e3.visible) return;
    let t2 = e3.geometry;
    if ("mesh" === t2.type) return;
    "extent" === t2.type && (t2 = j.fromExtent(t2));
    const o3 = this._ensureSource(t2.type);
    if (null == o3) return;
    const s2 = this._createOptimizedFeature(e3.uid, t2);
    null != s2 && (o3.featureStore.add(s2), J2(e3.symbol) && this._extrudedPolygonSymbolsCount++);
  }
  _needsInitializeProjection(e3) {
    if (null != e3.wkid && this._loadedWkids.has(e3.wkid)) return false;
    const t2 = e3.wkt2 || e3.wkt;
    return (!t2 || !this._loadedWkts.has(t2)) && !J(e3, this.spatialReference);
  }
  _createOptimizedFeature(e3, t2) {
    const o3 = K(a2(t2), this.spatialReference);
    if (!o3) return null;
    const s2 = this._ensureGeometryHasZ(o3), r2 = ot(s2, this._hasZ, false);
    return new e2(r2, {
      [U]: e3
    }, null, e3);
  }
  _ensureGeometryHasZ(e3) {
    if (!this._hasZ) return e3;
    const t2 = (e4) => {
      for (; e4.length < 3; ) e4.push(0);
    }, o3 = e3.clone();
    switch (o3.hasZ = true, o3.type) {
      case "point":
        o3.z = o3.z ?? 0;
        break;
      case "multipoint":
        o3.points.forEach(t2);
        break;
      case "polyline":
        o3.paths.forEach((e4) => e4.forEach(t2));
        break;
      case "polygon":
        o3.rings.forEach((e4) => e4.forEach(t2));
    }
    return o3;
  }
  _ensureSource(e3) {
    const t2 = this._sources[e3];
    if (null != t2) return t2;
    const o3 = this._createSource(e3);
    return this._sources[e3] = o3, o3;
  }
  _createSource(e3) {
    const t2 = o.toJSON(e3), o3 = this._hasZ, s2 = new m({
      geometryType: t2,
      hasZ: o3,
      hasM: false
    });
    return {
      featureStore: s2,
      queryEngine: new $({
        featureStore: s2,
        fieldsIndex: Z.fromLayerJSON({
          fields: [{
            name: U,
            type: "esriFieldTypeOID",
            alias: U
          }]
        }),
        geometryType: t2,
        hasM: false,
        hasZ: o3,
        objectIdField: U,
        spatialReference: this.spatialReference,
        priority: I.SNAPPING,
        scheduler: null != this.view && "3d" === this.view.type ? this.view.resourceController.scheduler : null
      }),
      type: e3
    };
  }
  _remove(e3) {
    this._mapSources((t2) => this._removeFromSource(t2, e3));
    for (const t2 of this._pendingAdds) t2.graphics.delete(e3.uid), 0 === t2.graphics.size && t2.task.abort();
  }
  _removeFromSource(e3, t2) {
    const o3 = t2.uid;
    e3.featureStore.has(o3) && (e3.featureStore.removeById(t2.uid), J2(t2.symbol) && this._extrudedPolygonSymbolsCount--);
  }
  _destroySource(e3) {
    e3.queryEngine.destroy(), this._sources[e3.type] = null;
  }
  _mapSources(e3) {
    const {
      point: t2,
      polygon: o3,
      polyline: s2,
      multipoint: r2
    } = this._sources, i3 = [];
    return null != t2 && i3.push(e3(t2)), null != o3 && i3.push(e3(o3)), null != s2 && i3.push(e3(s2)), null != r2 && i3.push(e3(r2)), i3;
  }
};
e([y()], O.prototype, "getGraphicsLayers", void 0), e([y({
  constructOnly: true
})], O.prototype, "layerSource", void 0), e([y({
  constructOnly: true
})], O.prototype, "spatialReference", void 0), e([y({
  constructOnly: true
})], O.prototype, "view", void 0), e([y({
  readOnly: true
})], O.prototype, "updating", null), e([y({
  readOnly: true
})], O.prototype, "availability", void 0), e([y()], O.prototype, "_hasZ", null), e([y()], O.prototype, "_snappingElevationAligner", null), e([y()], O.prototype, "_snappingElevationFilter", null), e([y()], O.prototype, "_symbologySnappingFetcher", null), e([y()], O.prototype, "_extrudedPolygonSymbolsCount", void 0), O = e([a("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")], O);
var U = "OBJECTID";
export {
  O as GraphicsSnappingSource
};
//# sourceMappingURL=GraphicsSnappingSource-PYFI47KJ.js.map
