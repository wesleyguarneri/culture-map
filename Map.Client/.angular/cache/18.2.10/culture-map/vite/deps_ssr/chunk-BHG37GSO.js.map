{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/shaders/sources/edgeRenderer/EdgeUtil.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { maxElevationOffset as o } from \"../../../collections/Component/Material/shader/ComponentData.glsl.js\";\nimport { NormalAttribute as e } from \"../../../core/shaderLibrary/attributes/NormalAttribute.glsl.js\";\nimport { DoublePrecision as r } from \"../../../core/shaderLibrary/util/DoublePrecision.glsl.js\";\nimport { RgbaFloatEncoding as t } from \"../../../core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";\nimport { Float3DrawUniform as a } from \"../../../core/shaderModules/Float3DrawUniform.js\";\nimport { Float3PassUniform as l } from \"../../../core/shaderModules/Float3PassUniform.js\";\nimport { FloatPassUniform as n } from \"../../../core/shaderModules/FloatPassUniform.js\";\nimport { glsl as d } from \"../../../core/shaderModules/interfaces.js\";\nimport { Matrix3DrawUniform as m } from \"../../../core/shaderModules/Matrix3DrawUniform.js\";\nimport { Matrix3PassUniform as s } from \"../../../core/shaderModules/Matrix3PassUniform.js\";\nimport { Matrix4PassUniform as i } from \"../../../core/shaderModules/Matrix4PassUniform.js\";\nimport { Texture2DDrawUniform as c } from \"../../../core/shaderModules/Texture2DDrawUniform.js\";\nimport { VertexAttribute as f } from \"../../../lib/VertexAttribute.js\";\nfunction v(v, u) {\n  const p = v.vertex;\n  p.include(t), v.include(e, u), p.uniforms.add(new n(\"distanceFalloffFactor\", o => o.distanceFalloffFactor)), p.code.add(d`float distanceBasedPerspectiveFactor(float distance) {\nreturn clamp(sqrt(distanceFalloffFactor / distance), 0.0, 1.0);\n}`), p.uniforms.add(new c(\"componentDataTex\", o => o.componentDataTexture)), v.attributes.add(f.COMPONENTINDEX, \"float\"), p.constants.add(\"componentColorFieldOffset\", \"float\", 0), p.constants.add(\"componentOtherFieldOffset\", \"float\", 1), p.constants.add(\"componentVerticalOffsetFieldOffset\", \"float\", 2), p.constants.add(\"componentFieldCount\", \"float\", 3), p.constants.add(\"lineWidthFractionFactor\", \"float\", 8), p.constants.add(\"extensionLengthOffset\", \"float\", 128), p.constants.add(\"verticalOffsetScale\", \"float\", 2 * o), p.code.add(d`\n    vec2 _componentTextureCoords(float componentIndex, float fieldOffset) {\n      float fieldIndex = componentFieldCount * componentIndex + fieldOffset;\n      float texSize = float(textureSize(componentDataTex, 0).x);\n      float colIndex = mod(fieldIndex, texSize);\n      float rowIndex = floor(fieldIndex / texSize);\n\n      return vec2(colIndex, rowIndex) + 0.5;\n    }\n\n    struct ComponentData {\n      vec4 color;\n      vec3 normal;\n      vec3 normal2;\n      float lineWidth;\n      float extensionLength;\n      float type;\n      float verticalOffset;\n    };\n\n    ComponentData readComponentData() {\n      vec2 colorIndex = _componentTextureCoords(componentIndex, componentColorFieldOffset);\n      vec2 otherIndex = _componentTextureCoords(componentIndex, componentOtherFieldOffset);\n      vec2 verticalOffsetIndex = _componentTextureCoords(componentIndex, componentVerticalOffsetFieldOffset);\n      vec3 normal = normalModel();\n      vec3 normal2 = ${u.silhouette ? d`decompressNormal(normal2Compressed)` : d`normal`};\n\n      vec4 colorValue = texelFetch(componentDataTex, ivec2(colorIndex), 0);\n      vec4 otherValue = texelFetch(componentDataTex, ivec2(otherIndex), 0);\n      float verticalOffset = (rgba2float(texelFetch(componentDataTex, ivec2(verticalOffsetIndex), 0)) - 0.5) * verticalOffsetScale;\n\n      return ComponentData(\n        vec4(colorValue.rgb, colorValue.a * otherValue.w), // otherValue.w stores separate opacity\n        normal, normal2,\n        otherValue.x * (255.0 / lineWidthFractionFactor),\n        otherValue.y * 255.0 - extensionLengthOffset,\n        -(otherValue.z * 255.0) + 0.5, // SOLID (=0/255) needs to be > 0.0, SKETCHY (=1/255) needs to be <= 0;\n        verticalOffset\n      );\n    }\n  `), u.legacy ? p.code.add(d`vec3 _modelToWorldNormal(vec3 normal) {\nreturn (model * vec4(normal, 0.0)).xyz;\n}\nvec3 _modelToViewNormal(vec3 normal) {\nreturn (localView * model * vec4(normal, 0.0)).xyz;\n}`) : (p.uniforms.add(new m(\"transformNormalGlobalFromModel\", o => o.transformNormalGlobalFromModel)), p.code.add(d`vec3 _modelToWorldNormal(vec3 normal) {\nreturn transformNormalGlobalFromModel * normal;\n}`)), u.silhouette ? (v.attributes.add(f.NORMAL2COMPRESSED, \"vec2\"), p.code.add(d`vec3 worldNormal(ComponentData data) {\nreturn _modelToWorldNormal(normalize(data.normal + data.normal2));\n}`)) : p.code.add(d`vec3 worldNormal(ComponentData data) {\nreturn _modelToWorldNormal(data.normal);\n}`), u.legacy ? p.code.add(d`void worldAndViewFromModelPosition(vec3 modelPos, float verticalOffset, out vec3 worldPos, out vec3 viewPos) {\nworldPos = (model * vec4(modelPos, 1.0)).xyz;\nviewPos = (localView * vec4(worldPos, 1.0)).xyz;\n}`) : (p.include(r, u), p.uniforms.add(new s(\"transformViewFromCameraRelativeRS\", o => o.transformViewFromCameraRelativeRS), new m(\"transformWorldFromModelRS\", o => o.transformWorldFromModelRS), new a(\"transformWorldFromModelTL\", o => o.transformWorldFromModelTL), new a(\"transformWorldFromModelTH\", o => o.transformWorldFromModelTH), new l(\"transformWorldFromViewTL\", o => o.transformWorldFromViewTL), new l(\"transformWorldFromViewTH\", o => o.transformWorldFromViewTH)), p.code.add(d`\n      void worldAndViewFromModelPosition(vec3 modelPos, float verticalOffset, out vec3 worldPos, out vec3 viewPos) {\n        vec3 rotatedModelPosition = transformWorldFromModelRS * modelPos;\n\n        vec3 transformCameraRelativeFromModel = dpAdd(\n          transformWorldFromModelTL,\n          transformWorldFromModelTH,\n          -transformWorldFromViewTL,\n          -transformWorldFromViewTH\n        );\n\n        worldPos = transformCameraRelativeFromModel + rotatedModelPosition;\n\n        if (verticalOffset != 0.0) {\n          vec3 vUp = ${u.spherical ? d`normalize(transformWorldFromModelTL + rotatedModelPosition);` : d`vec3(0.0, 0.0, 1.0);`}\n          worldPos += verticalOffset * vUp;\n        }\n\n        viewPos = transformViewFromCameraRelativeRS * worldPos;\n      }\n    `)), p.uniforms.add(new i(\"transformProjFromView\", (o, e) => e.camera.projectionMatrix)), p.code.add(d`vec4 projFromViewPosition(vec3 position) {\nreturn transformProjFromView * vec4(position, 1.0);\n}`), p.code.add(d`float calculateExtensionLength(float extensionLength, float lineLength) {\nreturn extensionLength / (log2(max(1.0, 256.0 / lineLength)) * 0.2 + 1.0);\n}`);\n}\nfunction u(o) {\n  return o === p.Sketch || o === p.Mixed;\n}\nvar p, x;\n!function (o) {\n  o[o.Solid = 0] = \"Solid\", o[o.Sketch = 1] = \"Sketch\", o[o.Mixed = 2] = \"Mixed\", o[o.COUNT = 3] = \"COUNT\";\n}(p || (p = {})), function (o) {\n  o[o.REGULAR = 0] = \"REGULAR\", o[o.SILHOUETTE = 1] = \"SILHOUETTE\";\n}(x || (x = {}));\nexport { x as EdgeSilhouette, p as EdgeType, v as EdgeUtil, u as usesSketchLogic };"],
  "mappings": "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",
  "names": ["v", "u", "p", "o", "e", "x"]
}
