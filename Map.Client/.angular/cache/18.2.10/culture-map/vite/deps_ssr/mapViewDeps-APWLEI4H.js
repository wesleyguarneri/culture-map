import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  s as s8,
  s2 as s9
} from "./chunk-5XDYHWIT.js";
import {
  p as p2
} from "./chunk-2X5P5FLW.js";
import {
  e as e11
} from "./chunk-ZYO2ZGSV.js";
import {
  w as w4
} from "./chunk-TM56WRQ7.js";
import {
  f as f5
} from "./chunk-SI737Z27.js";
import {
  e as e10,
  i as i8
} from "./chunk-4GLI5PQY.js";
import {
  o as o10
} from "./chunk-YPXYKVMN.js";
import {
  y as y3
} from "./chunk-FCOW4GHI.js";
import {
  a as a3,
  c as c4,
  l as l5,
  m as m3
} from "./chunk-NJ3JLLJN.js";
import {
  t as t9
} from "./chunk-TKVHHGIS.js";
import "./chunk-S5XISVKE.js";
import "./chunk-DJBRQU7Y.js";
import {
  a as a4,
  a2 as a5,
  e as e9,
  n as n5,
  r as r5,
  r2 as r6,
  t as t8,
  t2 as t10,
  y as y4
} from "./chunk-JSRMSYFX.js";
import "./chunk-NYQ72E6S.js";
import "./chunk-62PN4TEW.js";
import "./chunk-OPXEKSUB.js";
import "./chunk-KZBRH42J.js";
import "./chunk-AENXIHUM.js";
import "./chunk-Z3B4X2BG.js";
import {
  e as e5
} from "./chunk-H5GZAILH.js";
import "./chunk-A5U437OT.js";
import "./chunk-OPZOJLPA.js";
import {
  V
} from "./chunk-5QRKSSRL.js";
import "./chunk-4OEN6IBN.js";
import {
  T as T4,
  w as w3
} from "./chunk-HUMKNI5V.js";
import "./chunk-3SFUX3VL.js";
import "./chunk-YQ4BFXXY.js";
import {
  h as h6,
  h2 as h7,
  i as i7,
  n as n4
} from "./chunk-BUAHJQUY.js";
import {
  m as m4,
  t as t7
} from "./chunk-MWR6F5NE.js";
import {
  e as e8
} from "./chunk-NLU6ZPOA.js";
import "./chunk-YQDGVKY6.js";
import "./chunk-PAFRRTJD.js";
import "./chunk-A47NS37R.js";
import {
  A as A3,
  E as E4,
  h2 as h5,
  i as i6,
  o as o9,
  t as t6
} from "./chunk-VOJZD4TW.js";
import "./chunk-6JRLR4LF.js";
import {
  s as s7
} from "./chunk-OQI6JU2J.js";
import {
  e as e6
} from "./chunk-7PJ3GUSK.js";
import {
  e as e7
} from "./chunk-BNFI45VE.js";
import "./chunk-CSA6OEKA.js";
import {
  o as o8
} from "./chunk-ZCCDVQ3H.js";
import {
  i as i5
} from "./chunk-WHHFLSL5.js";
import "./chunk-NZTRS5LW.js";
import {
  t as t5
} from "./chunk-FV32SB4U.js";
import "./chunk-FW7J76DZ.js";
import "./chunk-WUTM5T74.js";
import "./chunk-ONVI4SC3.js";
import "./chunk-QA265FYQ.js";
import "./chunk-HUOFTIIK.js";
import "./chunk-HKAONIBH.js";
import "./chunk-RVGJHCZ2.js";
import "./chunk-EPIUUGS2.js";
import {
  s as s6
} from "./chunk-NOVQFMBE.js";
import "./chunk-DDV74AXO.js";
import "./chunk-LWQIYZ7J.js";
import "./chunk-37RAJ54N.js";
import {
  W as W2
} from "./chunk-BNFJNBHR.js";
import "./chunk-CIJQ7JPR.js";
import {
  l as l4
} from "./chunk-NP5MLSB6.js";
import "./chunk-6C3NPNB6.js";
import "./chunk-SM7IYUF6.js";
import "./chunk-Y72ZILQ6.js";
import "./chunk-V4U3XK2O.js";
import "./chunk-7DRGM3JS.js";
import "./chunk-LR3PYNHM.js";
import {
  M as M2,
  j,
  y as y2
} from "./chunk-VM4DYPO2.js";
import "./chunk-PXFPCKFW.js";
import "./chunk-RAYFUCRQ.js";
import "./chunk-ONQZSDXQ.js";
import {
  E as E3,
  i as i2,
  s as s4
} from "./chunk-FWYSNIVU.js";
import {
  c
} from "./chunk-MDEPINSI.js";
import {
  ee,
  i as i3,
  t as t3
} from "./chunk-Q2RVB4BK.js";
import "./chunk-SKOGSS6Z.js";
import {
  f as f4,
  u as u6
} from "./chunk-G3WMCIUE.js";
import "./chunk-WS7U2AGS.js";
import {
  a as a2,
  c as c3,
  i as i4,
  s as s5
} from "./chunk-U4NXHH3L.js";
import "./chunk-J7FRIDYV.js";
import {
  _
} from "./chunk-QWE4DSVN.js";
import "./chunk-2LHHRVKS.js";
import {
  c as c2,
  e2 as e4
} from "./chunk-QATJRB5Q.js";
import "./chunk-7Z4UWMRU.js";
import "./chunk-IQEF4U4C.js";
import "./chunk-QJK66QPF.js";
import "./chunk-KB6CBN72.js";
import {
  t as t4
} from "./chunk-BCMXVFG5.js";
import "./chunk-FB2GCV4L.js";
import {
  H,
  I as I3,
  L as L4,
  S,
  T as T3,
  Ut,
  W,
  X,
  b as b3,
  et,
  nt,
  st,
  tt,
  ut,
  wt,
  x as x2
} from "./chunk-NOBDTR4N.js";
import {
  i
} from "./chunk-5RF6XDV4.js";
import "./chunk-Q47GASPN.js";
import "./chunk-YEB36ZCF.js";
import "./chunk-LCPLUSDH.js";
import {
  t as t2
} from "./chunk-KINQ7OJ3.js";
import {
  B,
  C,
  D,
  E as E2,
  F,
  G,
  I as I2,
  L as L3,
  N as N2,
  O as O2,
  P as P3,
  R as R2,
  T as T2,
  U as U2
} from "./chunk-KYLW5XXS.js";
import "./chunk-B76NC7GX.js";
import {
  h as h4
} from "./chunk-HFXXFWYN.js";
import {
  n as n3
} from "./chunk-4O23HCRT.js";
import "./chunk-NE35ZNG6.js";
import "./chunk-ZLSZAC2I.js";
import {
  r as r4
} from "./chunk-QRWQ6QBB.js";
import "./chunk-X5QZGB37.js";
import "./chunk-T5C2TZNO.js";
import "./chunk-AOGKNBDG.js";
import "./chunk-F4FQ67JP.js";
import "./chunk-FDI2X6GO.js";
import "./chunk-3XHDZQO5.js";
import "./chunk-2BLQXT54.js";
import "./chunk-JSWVKNBA.js";
import "./chunk-CILHMGNK.js";
import "./chunk-2BOKEEZV.js";
import {
  y
} from "./chunk-MPLS4PY6.js";
import {
  o as o7
} from "./chunk-CZA7RDJP.js";
import "./chunk-LGS63R4F.js";
import {
  o as o5
} from "./chunk-NAG6YX7T.js";
import "./chunk-WFNAKG2H.js";
import {
  A as A2,
  E,
  I,
  L as L2,
  N,
  O,
  P as P2,
  R,
  T,
  b as b2,
  f as f2,
  h as h2,
  o as o6,
  p,
  q,
  t,
  u as u5,
  v,
  w as w2,
  x
} from "./chunk-EKHRAAS6.js";
import "./chunk-IEB4ZCRH.js";
import "./chunk-NHYYZMJR.js";
import "./chunk-U4EMQMDC.js";
import {
  r as r3
} from "./chunk-BZHHBBFX.js";
import {
  M,
  f as f3,
  h as h3,
  l as l3
} from "./chunk-A2FDYA6M.js";
import "./chunk-ORYC4PVJ.js";
import "./chunk-DXIKKLD7.js";
import "./chunk-VQNXE43R.js";
import "./chunk-VZ37C3ID.js";
import "./chunk-5R3HARKC.js";
import "./chunk-Q5TIVVER.js";
import "./chunk-X36BR2QB.js";
import "./chunk-RGG3YJQA.js";
import "./chunk-YBUJLIWZ.js";
import "./chunk-DL2B6IFJ.js";
import "./chunk-VOOO6FU5.js";
import "./chunk-IUPJR3FF.js";
import "./chunk-TGZW6QWO.js";
import "./chunk-OYIDHTXG.js";
import "./chunk-KUBMHTYA.js";
import "./chunk-FP37456K.js";
import "./chunk-VSQZQLTQ.js";
import "./chunk-K43CZ3M5.js";
import "./chunk-6EIBUVMG.js";
import "./chunk-LM3JDV4W.js";
import "./chunk-34V2CLL5.js";
import "./chunk-MVS2BECH.js";
import "./chunk-DC5LRNPY.js";
import "./chunk-ASCK5HJ5.js";
import "./chunk-5X5U7R6O.js";
import "./chunk-ZT7V2AVD.js";
import "./chunk-C2OXE4NQ.js";
import "./chunk-KOI252FF.js";
import "./chunk-I2TVVMQ6.js";
import "./chunk-5EGQYY2H.js";
import "./chunk-JKPUNUQA.js";
import "./chunk-SR7PRON4.js";
import "./chunk-HGHPYGKP.js";
import "./chunk-4DSGTDZJ.js";
import {
  e as e3,
  u as u4
} from "./chunk-VYTPFEL2.js";
import "./chunk-RLGDH6IY.js";
import "./chunk-MRPCXIVS.js";
import "./chunk-YTKVV2Y3.js";
import "./chunk-GCVQXAS4.js";
import "./chunk-UFQD6AL4.js";
import "./chunk-THZPD5CT.js";
import "./chunk-OBCA6CWH.js";
import "./chunk-2JI245BP.js";
import "./chunk-ABIG6PT5.js";
import "./chunk-ZEZ3LI2L.js";
import "./chunk-N34BRXVM.js";
import "./chunk-RNF7VOCU.js";
import "./chunk-TIRJMGGG.js";
import "./chunk-ZDRQSPB6.js";
import "./chunk-DCXDXGAR.js";
import "./chunk-BCCDYCTQ.js";
import "./chunk-AYL3HQHD.js";
import "./chunk-66YQWHHE.js";
import "./chunk-QGBMZIP4.js";
import "./chunk-AOEBZVTA.js";
import {
  e as e2,
  h
} from "./chunk-2OZSYJDX.js";
import {
  o as o4
} from "./chunk-MZM4INJV.js";
import {
  n as n2
} from "./chunk-J4GMQHGL.js";
import {
  u as u3
} from "./chunk-MHPE4SZA.js";
import "./chunk-6SSA7P3A.js";
import "./chunk-FQBTLEUI.js";
import "./chunk-GS7Y3YOG.js";
import "./chunk-Y2HYKTTT.js";
import {
  Pt,
  U
} from "./chunk-XLEC46FY.js";
import "./chunk-4AZPIP7K.js";
import "./chunk-G73HQZEL.js";
import {
  P,
  d as d2
} from "./chunk-LZSLQ24Q.js";
import "./chunk-U3RHUXYK.js";
import "./chunk-7DBI6LQG.js";
import {
  d
} from "./chunk-AUUN7RFQ.js";
import {
  o as o3
} from "./chunk-JAMSDYD6.js";
import "./chunk-PH6NPTP7.js";
import "./chunk-NUICEVIH.js";
import {
  A,
  r
} from "./chunk-NXK752PZ.js";
import "./chunk-UVNLCXWD.js";
import "./chunk-PNUA7JOS.js";
import "./chunk-OR2FKGUM.js";
import "./chunk-UDMPWVPF.js";
import "./chunk-XJNKCEWL.js";
import {
  L,
  b,
  f2 as f,
  m as m2,
  o2,
  s as s3,
  u as u2,
  w
} from "./chunk-AIZ3T7E3.js";
import {
  o
} from "./chunk-6UEMNP3E.js";
import {
  e,
  l as l2,
  r as r2,
  u
} from "./chunk-6WGE3IUL.js";
import "./chunk-MLYB2YW4.js";
import {
  a,
  l2 as l,
  n2 as n,
  s,
  s2
} from "./chunk-6JFGZTLU.js";
import {
  has,
  m
} from "./chunk-2ZJE6ZFX.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-XBPEBUD5.js";

// ../../../node_modules/@arcgis/core/symbols/cim/cimAnalyzer.js
var N3 = () => n.getLogger("esri.symbols.cim.cimAnalyzer");
function w5(e13) {
  const r12 = e13.markerPlacement;
  return r12 && r12.angleToLine ? i.MAP : i.SCREEN;
}
var R3 = class {
  constructor(e13) {
    this._cimLayers = [], this._poMap = {}, this._primitiveOverrides = [], e13 && (this._resourceManager = e13);
  }
  analyzeSymbolReference(r12, t15, i12) {
    if (this._cimLayers = i12 ?? [], !r12) return this._cimLayers;
    if (this._reset(), r12.primitiveOverrides) {
      this._primitiveOverrides = r12.primitiveOverrides;
      for (const r13 of this._primitiveOverrides) {
        const t16 = r13.valueExpressionInfo;
        if (t16) this._setPoMap(r13.primitiveName, r13.propertyName, t16);
        else if (null != r13.value) {
          let t17 = r13.value;
          r13.propertyName.includes("Color") && (o5(t17) && (t17 = o6(t17)), t17 = f2(t17)), this._setPoMap(r13.primitiveName, r13.propertyName, t17);
        }
      }
    }
    return this._analyzeSymbol(r12.symbol, t15), this._cimLayers;
  }
  _reset() {
    this._cimLayers = [], this._poMap = {}, this._primitiveOverrides = [];
  }
  _analyzeSymbol(e13, r12) {
    switch (e13?.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        this._analyzeMultiLayerSymbol(e13, r12);
    }
  }
  _analyzeMultiLayerSymbol(e13, r12) {
    const t15 = e13?.symbolLayers;
    if (!t15) return;
    const i12 = e13.effects;
    let o13 = i.SCREEN;
    const a9 = q(e13) ?? 0;
    "CIMPointSymbol" === e13.type && "Map" === e13.angleAlignment && (o13 = i.MAP);
    const s13 = "CIMPolygonSymbol" === e13.type;
    let l12 = t15.length;
    for (; l12--; ) {
      const n11 = t15[l12];
      if (!n11 || false === n11.enable) continue;
      let c12;
      i12?.length && (c12 = [...i12]);
      const m7 = n11.effects;
      m7?.length && (i12 ? c12.push(...m7) : c12 = [...m7]);
      let f8 = null;
      if (c12) {
        f8 = [];
        for (const e14 of c12) {
          const r13 = y.findEffectOverrides(e14, this._primitiveOverrides);
          r13 && f8.push(r13);
        }
      }
      const y5 = [];
      switch (y.findApplicableOverrides(n11, this._primitiveOverrides, y5), n11.type) {
        case "CIMSolidFill":
          this._analyzeSolidFill(n11, f8);
          break;
        case "CIMPictureFill":
          this._analyzePictureFill(n11, f8);
          break;
        case "CIMHatchFill":
          this._analyzeHatchFill(n11, f8);
          break;
        case "CIMGradientFill":
          this._analyzeGradientFill(n11, f8);
          break;
        case "CIMSolidStroke":
          this._analyzeSolidStroke(n11, f8, s13, a9);
          break;
        case "CIMPictureStroke":
          this._analyzePictureStroke(n11, f8, s13, a9);
          break;
        case "CIMGradientStroke":
          this._analyzeGradientStroke(n11, f8, s13, a9);
          break;
        case "CIMCharacterMarker":
        case "CIMPictureMarker":
        case "CIMVectorMarker": {
          "CIMLineSymbol" !== e13.type && "CIMPolygonSymbol" !== e13.type || (o13 = w5(n11));
          const t16 = [], i13 = n11.primitiveName;
          i13 && t16.push(i13);
          const l13 = s13 && b2(n11.markerPlacement);
          this._analyzeMarker(n11, f8, null, t16, o13, a9, r12, [], false, l13);
          break;
        }
        default:
          N3().error("Cannot analyze CIM layer", n11.type);
      }
    }
  }
  _analyzeSolidFill(e13, r12) {
    const {
      primitiveName: t15,
      type: i12
    } = e13, o13 = f2(e13.color);
    this._cimLayers.push({
      type: "fill",
      spriteRasterizationParam: null,
      colorLocked: !!e13.colorLocked,
      color: this._getValueOrOverrideExpression(i12, t15, "Color", o13),
      height: 0,
      angle: 0,
      offsetX: 0,
      offsetY: 0,
      scaleX: 1,
      effects: r12,
      applyRandomOffset: false,
      sampleAlphaOnly: true,
      hasUnresolvedReplacementColor: false
    });
  }
  _analyzePictureFill(e13, r12) {
    const {
      primitiveName: t15,
      type: i12
    } = e13, o13 = h2(e13), a9 = I(e13.height, t.CIMPictureFill.height);
    let s13 = I(e13.scaleX, 1);
    if ("width" in e13 && "number" == typeof e13.width) {
      const r13 = e13.width;
      let t16 = 1;
      const i13 = this._resourceManager.getResource(e13.url);
      null != i13 && (t16 = i13.width / i13.height), s13 /= t16 * (a9 / r13);
    }
    const l12 = {
      type: "sprite-rasterization-param",
      resource: e13,
      overrides: this._getPrimitiveMaterialOverrides(t15, i12)
    };
    this._cimLayers.push({
      type: "fill",
      spriteRasterizationParam: l12,
      colorLocked: !!e13.colorLocked,
      effects: r12,
      color: this._getValueOrOverrideExpression(i12, t15, "TintColor", o13),
      height: this._getValueOrOverrideExpression(i12, t15, "Height", a9),
      scaleX: this._getValueOrOverrideExpression(i12, t15, "ScaleX", s13),
      angle: this._getValueOrOverrideExpression(i12, t15, "Rotation", I(e13.rotation)),
      offsetX: this._getValueOrOverrideExpression(i12, t15, "OffsetX", I(e13.offsetX)),
      offsetY: this._getValueOrOverrideExpression(i12, t15, "OffsetY", I(e13.offsetY)),
      applyRandomOffset: false,
      sampleAlphaOnly: false,
      hasUnresolvedReplacementColor: false
    });
  }
  _analyzeHatchFill(e13, r12) {
    const {
      primitiveName: t15,
      type: i12
    } = e13, o13 = this._analyzeMaterialOverrides(t15, ["Rotation", "OffsetX", "OffsetY"]), a9 = R(o13);
    let s13 = [255, 255, 255, 1], l12 = false;
    if (e13.lineSymbol?.symbolLayers) for (const n11 of e13.lineSymbol.symbolLayers) {
      if ("CIMSolidStroke" !== n11.type) continue;
      const e14 = n11.primitiveName ?? t15;
      l12 || !e14 || n11.colorLocked || null == this._poMap[e14]?.Color && null == this._poMap[e14]?.StrokeColor || (s13 = f2(n11.color), s13 = this._maybeGetValueOrOverrideExpression(e14, "StrokeColor") ?? this._getValueOrOverrideExpression(i12, e14, "Color", s13), l12 = true);
      const r13 = this._maybeGetValueOrOverrideExpression(e14, "StrokeWidth");
      if (r13) {
        let t16 = null, o14 = null;
        "number" == typeof r13 ? t16 = r13 : o14 = r13.valueExpressionInfo;
        let s14 = a9.find((e15) => "strokeWidth" === e15.propertyName);
        s14 ? s14.propertyName = "width" : (s14 = {
          type: "CIMPrimitiveOverride",
          primitiveName: e14,
          propertyName: "width",
          valueExpressionInfo: o14,
          value: t16,
          defaultValue: O(i12, "width")
        }, a9.push(s14));
      }
    }
    const c12 = {
      type: "sprite-rasterization-param",
      resource: e13,
      overrides: a9
    };
    this._cimLayers.push({
      type: "fill",
      spriteRasterizationParam: c12,
      colorLocked: !!e13.colorLocked,
      effects: r12,
      color: s13,
      height: this._getValueOrOverrideExpression(i12, t15, "Separation", I(e13.separation, t.CIMHatchFill.separation)),
      scaleX: 1,
      angle: this._getValueOrOverrideExpression(i12, t15, "Rotation", I(e13.rotation)),
      offsetX: this._getValueOrOverrideExpression(i12, t15, "OffsetX", I(e13.offsetX)),
      offsetY: this._getValueOrOverrideExpression(i12, t15, "OffsetY", I(e13.offsetY)),
      applyRandomOffset: false,
      sampleAlphaOnly: true,
      hasUnresolvedReplacementColor: !l12
    });
  }
  _analyzeGradientFill(e13, r12) {
    this._cimLayers.push({
      type: "fill",
      spriteRasterizationParam: null,
      colorLocked: !!e13.colorLocked,
      effects: r12,
      color: [128, 128, 128, 1],
      height: 0,
      angle: 0,
      offsetX: 0,
      offsetY: 0,
      scaleX: 1,
      applyRandomOffset: false,
      sampleAlphaOnly: false,
      hasUnresolvedReplacementColor: false
    });
  }
  _analyzeSolidStroke(e13, r12, t15, i12) {
    const {
      primitiveName: o13,
      type: a9
    } = e13, s13 = f2(e13.color), l12 = I(e13.width, t.CIMSolidStroke.width), c12 = p(e13.capStyle, t.CIMSolidStroke.capstyle), p5 = p(e13.joinStyle, t.CIMSolidStroke.joinstyle), m7 = e13.miterLimit;
    let f8, y5, d4 = [];
    if (this._analyzePrimitiveOverrides(o13, r12, null, null) && (d4 = this._getPrimitiveMaterialOverrides(o13, a9)), r12 && Array.isArray(r12) && r12.length > 0) {
      const e14 = r12[r12.length - 1].effect;
      e14 && "CIMGeometricEffectDashes" === e14.type && "NoConstraint" === e14.lineDashEnding && null === e14.offsetAlongLine && (f8 = e14.dashTemplate, y5 = e14.scaleDash, (r12 = [...r12]).pop());
    }
    const u11 = void 0 !== f8 ? {
      type: "sprite-rasterization-param",
      resource: {
        type: "dash",
        dashTemplate: f8,
        capStyle: c12
      },
      overrides: d4
    } : null;
    this._cimLayers.push({
      type: "line",
      spriteRasterizationParam: u11,
      isOutline: t15,
      colorLocked: !!e13.colorLocked,
      effects: r12,
      color: this._getValueOrOverrideExpression(a9, o13, "Color", s13),
      width: this._getValueOrOverrideExpression(a9, o13, "Width", l12),
      cap: this._getValueOrOverrideExpression(a9, o13, "CapStyle", c12),
      join: this._getValueOrOverrideExpression(a9, o13, "JoinStyle", p5),
      miterLimit: m7 && this._getValueOrOverrideExpression(a9, o13, "MiterLimit", m7),
      referenceWidth: i12,
      zOrder: G2(e13.name),
      dashTemplate: f8,
      scaleDash: y5,
      sampleAlphaOnly: true
    });
  }
  _analyzePictureStroke(e13, r12, t15, i12) {
    const {
      primitiveName: o13,
      type: a9
    } = e13, s13 = h2(e13), l12 = I(e13.width, t.CIMPictureStroke.width), c12 = p(e13.capStyle, t.CIMPictureStroke.capstyle), p5 = p(e13.joinStyle, t.CIMPictureStroke.joinstyle), m7 = e13.miterLimit, f8 = {
      type: "sprite-rasterization-param",
      resource: e13,
      overrides: this._getPrimitiveMaterialOverrides(o13, a9)
    };
    this._cimLayers.push({
      type: "line",
      spriteRasterizationParam: f8,
      isOutline: t15,
      colorLocked: !!e13.colorLocked,
      effects: r12,
      color: this._getValueOrOverrideExpression(a9, o13, "TintColor", s13),
      width: this._getValueOrOverrideExpression(a9, o13, "Width", l12),
      cap: this._getValueOrOverrideExpression(a9, o13, "CapStyle", c12),
      join: this._getValueOrOverrideExpression(a9, o13, "JoinStyle", p5),
      miterLimit: m7 && this._getValueOrOverrideExpression(a9, o13, "MiterLimit", m7),
      referenceWidth: i12,
      zOrder: G2(e13.name),
      dashTemplate: null,
      scaleDash: false,
      sampleAlphaOnly: false
    });
  }
  _analyzeGradientStroke(e13, r12, t15, i12) {
    const {
      primitiveName: o13,
      type: a9
    } = e13, s13 = I(e13.width, t.CIMSolidStroke.width), l12 = p(e13.capStyle, t.CIMGradientStroke.capstyle), c12 = p(e13.joinStyle, t.CIMGradientStroke.joinstyle), p5 = e13.miterLimit;
    this._cimLayers.push({
      type: "line",
      spriteRasterizationParam: null,
      isOutline: t15,
      colorLocked: !!e13.colorLocked,
      effects: r12,
      color: [128, 128, 128, 1],
      width: this._getValueOrOverrideExpression(a9, o13, "Width", s13),
      cap: this._getValueOrOverrideExpression(a9, o13, "CapStyle", l12),
      join: this._getValueOrOverrideExpression(a9, o13, "JoinStyle", c12),
      miterLimit: p5 && this._getValueOrOverrideExpression(a9, o13, "MiterLimit", p5),
      referenceWidth: i12,
      zOrder: G2(e13.name),
      dashTemplate: null,
      scaleDash: false,
      sampleAlphaOnly: false
    });
  }
  _analyzeMarker(e13, r12, t15, i12, o13, a9, s13, l12, c12 = false, p5 = false) {
    if (c12 ||= !!e13.colorLocked, this._analyzeMarkerInsidePolygon(e13, r12, c12)) return;
    const m7 = I(e13.size, t.CIMVectorMarker.size), f8 = I(e13.rotation), y5 = I(e13.offsetX), h13 = I(e13.offsetY), {
      primitiveName: d4,
      type: u11
    } = e13, v4 = this._getValueOrOverrideExpression(u11, d4, "Size", m7), _5 = this._getValueOrOverrideExpression(u11, d4, "Rotation", f8), g3 = this._getValueOrOverrideExpression(u11, d4, "OffsetX", y5), k2 = this._getValueOrOverrideExpression(u11, d4, "OffsetY", h13);
    switch (e13.type) {
      case "CIMPictureMarker":
        this._analyzePictureMarker(e13, r12, t15, i12, o13, a9, v4, _5, g3, k2, l12, c12, p5);
        break;
      case "CIMVectorMarker":
        this._analyzeVectorMarker(e13, r12, t15, i12, o13, a9, v4, _5, g3, k2, l12, s13, c12, p5);
    }
  }
  _analyzeMarkerInsidePolygon(e13, r12, t15) {
    const {
      markerPlacement: i12,
      type: o13
    } = e13;
    if (!i12 || "CIMMarkerPlacementInsidePolygon" !== i12.type) return false;
    if ("CIMVectorMarker" === o13 || "CIMPictureMarker" === o13) {
      const t16 = e13.primitiveName;
      if (t16 && this._analyzePrimitiveOverrides([t16], r12, null, null)) return false;
      const a9 = i12.primitiveName;
      if (a9 && this._analyzePrimitiveOverrides([a9], r12, null, null)) return false;
      if ("CIMVectorMarker" === o13) {
        const {
          markerGraphics: r13
        } = e13;
        if (r13) for (const e14 of r13) {
          const {
            symbol: r14
          } = e14;
          if ("CIMPolygonSymbol" === r14?.type && r14.symbolLayers) {
            const {
              symbolLayers: e15
            } = r14;
            for (const r15 of e15) if ("CIMSolidStroke" === r15.type) return false;
          }
        }
      } else {
        const {
          animatedSymbolProperties: r13
        } = e13;
        if (r13) return false;
      }
    }
    const s13 = Math.abs(i12.stepX), l12 = Math.abs(i12.stepY);
    if (0 === s13 || 0 === l12) return true;
    let n11, c12;
    if ("Random" === i12.gridType) {
      const e14 = e3(st), r13 = Math.max(Math.floor(e14 / s13), 1);
      n11 = l12 * Math.max(Math.floor(e14 / l12), 1);
      c12 = r13 * s13 / n11;
    } else i12.shiftOddRows ? (n11 = 2 * l12, c12 = s13 / l12 * 0.5) : (n11 = l12, c12 = s13 / l12);
    const p5 = h2(e13), m7 = "CIMCharacterMarker" === e13.type ? null : {
      type: "sprite-rasterization-param",
      resource: e13,
      overrides: []
    };
    return this._cimLayers.push({
      type: "fill",
      spriteRasterizationParam: m7,
      colorLocked: t15,
      effects: r12,
      color: p5,
      height: n11,
      scaleX: c12,
      angle: i12.gridAngle,
      offsetX: I(i12.offsetX),
      offsetY: I(i12.offsetY),
      applyRandomOffset: "Random" === i12.gridType,
      sampleAlphaOnly: "CIMPictureMarker" !== e13.type,
      hasUnresolvedReplacementColor: true
    }), true;
  }
  _analyzePictureMarker(e13, r12, i12, o13, a9, l12, n11, c12, p5, m7, f8, y5, h13) {
    const {
      animatedSymbolProperties: d4,
      primitiveName: u11,
      type: _5
    } = e13;
    let g3 = I(e13.scaleX, 1);
    const k2 = h2(e13);
    i12 || (i12 = this._createMarkerPlacementOverrideExpression(e13.markerPlacement));
    const M3 = this._createGIFAnimatedSymbolPropertiesOverrideExpression(d4), S2 = e13.anchorPoint ?? {
      x: 0,
      y: 0
    };
    if ("width" in e13 && "number" == typeof e13.width) {
      const r13 = e13.width;
      let t15 = 1;
      const i13 = this._resourceManager.getResource(e13.url);
      null != i13 && (t15 = i13.width / i13.height);
      g3 /= t15 * (I(e13.size) / r13);
    }
    const C3 = [...o13];
    let b5;
    e13.primitiveName && C3.push(e13.primitiveName), d4 || M3 ? b5 = {
      type: "animated",
      url: e13.url,
      urlHash: "H" + l(e13.url),
      playAnimation: e13.animatedSymbolProperties?.playAnimation,
      reverseAnimation: e13.animatedSymbolProperties?.reverseAnimation,
      randomizeStartTime: e13.animatedSymbolProperties?.randomizeStartTime,
      randomizeStartSeed: e13.animatedSymbolProperties?.randomizeStartSeed,
      startTimeOffset: e13.animatedSymbolProperties?.startTimeOffset,
      duration: e13.animatedSymbolProperties?.duration,
      repeatType: e13.animatedSymbolProperties?.repeatType,
      repeatDelay: e13.animatedSymbolProperties?.repeatDelay
    } : (b5 = a(e13), b5.markerPlacement = null);
    const P5 = {
      type: "sprite-rasterization-param",
      resource: b5,
      overrides: this._getMaterialOverrides(C3, _5)
    };
    M3 && P5.overrides.push(...M3.overrides), this._cimLayers.push({
      type: "marker",
      spriteRasterizationParam: P5,
      colorLocked: y5,
      effects: r12,
      scaleSymbolsProportionally: false,
      alignment: a9,
      size: n11,
      scaleX: this._getValueOrOverrideExpression(_5, u11, "ScaleX", g3),
      rotation: c12,
      offsetX: p5,
      offsetY: m7,
      transform: {
        type: "cim-marker-transform-param",
        params: f8
      },
      color: this._getValueOrOverrideExpression(_5, u11, "TintColor", k2),
      anchorPoint: {
        x: S2.x,
        y: S2.y
      },
      isAbsoluteAnchorPoint: "Relative" !== e13.anchorPointUnits,
      outlineColor: [0, 0, 0, 0],
      outlineWidth: 0,
      frameHeight: 0,
      widthRatio: 1,
      rotateClockwise: !!e13.rotateClockwise,
      referenceSize: l12,
      sizeRatio: 1,
      isOutline: h13,
      markerPlacement: i12
    });
  }
  _analyzeVectorMarker(e13, r12, t15, i12, o13, a9, s13, l12, n11, c12, p5, m7, f8, y5) {
    const h13 = e13.markerGraphics;
    if (!h13) return;
    const d4 = e13.frame;
    let u11 = 0;
    if (u11 = d4 ? d4.ymax - d4.ymin : a9, u11) {
      const r13 = {
        offsetX: n11,
        offsetY: c12,
        rotation: l12,
        size: s13,
        frameHeight: u11,
        rotateClockWise: !!e13.rotateClockwise
      };
      p5 = [...p5, r13];
    }
    t15 || (t15 = this._createMarkerPlacementOverrideExpression(e13.markerPlacement));
    for (const v4 of h13) if (v4) {
      const s14 = v4.symbol;
      if (!s14) continue;
      const l13 = v4.primitiveName;
      let n12;
      if (l13 && i12.push(l13), ("CIMPointSymbol" === s14.type || "CIMTextSymbol" === s14.type) && d4) {
        let r13 = 0, t16 = 0;
        const i13 = v4.geometry;
        "x" in i13 && "y" in i13 && (r13 += i13.x - 0.5 * (d4.xmin + d4.xmax), t16 += i13.y - 0.5 * (d4.ymin + d4.ymax));
        const o14 = e13.anchorPoint;
        o14 && ("Absolute" === e13.anchorPointUnits ? (r13 -= o14.x, t16 -= o14.y) : d4 && (r13 -= (d4.xmax - d4.xmin) * o14.x, t16 -= (d4.ymax - d4.ymin) * o14.y));
        const a10 = {
          offsetX: r13,
          offsetY: t16,
          rotation: 0,
          size: 0,
          frameHeight: 0,
          rotateClockWise: false
        };
        n12 = [...p5, a10];
      }
      switch (s14.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          m7 || T5(s14) ? this._analyzeMultiLayerGraphicNonSDF(e13, r12, t15, v4, i12, o13, a9, n12 ?? p5, u11, f8, y5) : this._analyzeMultiLayerGraphic(e13, r12, t15, v4, i12, o13, a9, n12 ?? p5, u11, f8, y5);
          break;
        case "CIMTextSymbol":
          this._analyzeTextGraphic(r12, t15, v4, i12, o13, a9, n12 ?? p5, f8);
      }
      l13 && i12.pop();
    }
  }
  _analyzeMultiLayerGraphic(e13, r12, t15, i12, o13, a9, s13, l12, n11, c12, p5) {
    const y5 = i12.symbol, d4 = y5.symbolLayers;
    if (!d4) return;
    let u11 = d4.length;
    if (F2(d4)) return void this._analyzeCompositeMarkerGraphic(e13, r12, t15, i12, d4, a9, s13, l12, n11, c12, p5);
    const v4 = this._resourceManager.geometryEngine, O3 = l4.applyEffects(y5.effects, i12.geometry, v4);
    if (O3) for (; u11--; ) {
      const y6 = d4[u11];
      if (!y6 || false === y6.enable) continue;
      const _5 = y6.primitiveName;
      switch (_5 && o13.push(_5), y6.type) {
        case "CIMSolidFill":
        case "CIMSolidStroke": {
          const o14 = l4.applyEffects(y6.effects, O3, v4), d5 = m3(o14);
          if (!d5) continue;
          const u12 = "Relative" !== e13.anchorPointUnits, [g3, k2, b5, P5] = a3(d5, e13.frame, e13.size, e13.anchorPoint, u12), x3 = "CIMSolidFill" === y6.type, z = {
            type: "sdf",
            geom: o14,
            asFill: x3
          }, {
            path: L5
          } = y6, E5 = x3 ? f2(L2(y6)) : null == L5 ? f2(N(y6)) : [0, 0, 0, 0], V2 = x3 ? [0, 0, 0, 0] : f2(N(y6)), N5 = T(y6) ?? 0;
          if (!x3 && !N5) break;
          const w6 = i12.primitiveName;
          let R4 = null;
          x3 && !y6.colorLocked && (R4 = this._maybeGetValueOrOverrideExpression(w6, "FillColor"));
          let A8 = null;
          x3 || y6.colorLocked || (A8 = this._maybeGetValueOrOverrideExpression(w6, "StrokeColor"));
          const G4 = R4 ?? this._getValueOrOverrideExpression(y6.type, _5, "Color", E5), X2 = A8 ?? this._getValueOrOverrideExpression(y6.type, _5, "Color", V2), F4 = this._maybeGetValueOrOverrideExpression(w6, "StrokeWidth") ?? this._getValueOrOverrideExpression(y6.type, _5, "Width", N5), T6 = L5 ? {
            type: "sprite-rasterization-param",
            resource: {
              type: "path",
              path: L5,
              asFill: x3
            },
            overrides: []
          } : {
            type: "sprite-rasterization-param",
            resource: z,
            overrides: []
          };
          this._cimLayers.push({
            type: "marker",
            spriteRasterizationParam: T6,
            colorLocked: !!y6.colorLocked || !!c12,
            effects: r12,
            scaleSymbolsProportionally: !!e13.scaleSymbolsProportionally,
            alignment: a9,
            anchorPoint: {
              x: k2,
              y: b5
            },
            isAbsoluteAnchorPoint: u12,
            size: n11,
            rotation: 0,
            offsetX: 0,
            offsetY: 0,
            scaleX: 1,
            transform: {
              type: "cim-marker-transform-param",
              params: l12
            },
            frameHeight: n11,
            widthRatio: P5,
            rotateClockwise: false,
            referenceSize: s13,
            sizeRatio: g3,
            color: G4,
            outlineColor: X2,
            outlineWidth: F4,
            isOutline: p5,
            markerPlacement: t15
          });
          break;
        }
        case "CIMPictureMarker":
        case "CIMVectorMarker":
          y6.markerPlacement ? this._analyzeMultiLayerGraphicNonSDF(e13, r12, t15, i12, o13, a9, s13, l12, n11, !!y6.colorLocked || !!c12, p5) : this._analyzeMarker(y6, r12, t15, o13, a9, s13, false, l12, c12, p5);
          break;
        default:
          this._analyzeMultiLayerGraphicNonSDF(e13, r12, t15, i12, o13, a9, s13, l12, n11, !!y6.colorLocked || !!c12, p5);
      }
      _5 && o13.pop();
    }
  }
  _analyzeTextGraphic(e13, t15, i12, o13, a9, s13, l12, c12) {
    const m7 = [];
    y.findApplicableOverrides(i12, this._primitiveOverrides, m7);
    const f8 = i12.geometry;
    if (!("x" in f8) || !("y" in f8)) return;
    const y5 = i12.symbol, d4 = w2(y5), u11 = P2(y5.fontStyleName), v4 = u6(y5.fontFamilyName);
    y5.font = __spreadValues({
      family: v4,
      decoration: d4
    }, u11);
    const _5 = I(y5.height, t.CIMTextSymbol.height), g3 = I(y5.angle), k2 = I(y5.offsetX), L5 = I(y5.offsetY), E5 = f2(L2(y5));
    let I4 = f2(N(y5)), V2 = T(y5) ?? 0;
    V2 || (I4 = f2(L2(y5.haloSymbol)), V2 = I(y5.haloSize));
    let N5 = false;
    if (y5.symbol?.symbolLayers) for (const r12 of y5.symbol.symbolLayers) {
      null != f2(L2(r12)) && (N5 = !!r12.colorLocked);
    }
    const w6 = i12.primitiveName;
    let R4 = null;
    N5 || (R4 = this._maybeGetValueOrOverrideExpression(w6, "FillColor"));
    const A8 = this._maybeGetValueOrOverrideExpression(w6, "TextSize"), G4 = this._maybeGetValueOrOverrideExpression(w6, "TextAngle"), X2 = this._maybeGetValueOrOverrideExpression(w6, "TextOffsetX"), F4 = this._maybeGetValueOrOverrideExpression(w6, "TextOffsetY");
    let T6 = null, Y2 = null, j3 = 0;
    if (y5.callout && "CIMBackgroundCallout" === y5.callout.type) {
      const e14 = y5.callout;
      if (e14.backgroundSymbol) {
        const r12 = e14.backgroundSymbol.symbolLayers;
        if (r12) for (const e15 of r12) "CIMSolidFill" === e15.type ? T6 = f2(e15.color) : "CIMSolidStroke" === e15.type && (Y2 = f2(e15.color), j3 = I(e15.width, t.CIMSolidStroke.width));
      }
    }
    const W3 = this._getValueOrOverrideExpression(y5.type, i12.primitiveName, "TextString", i12.textString ?? "");
    if (null == W3) return;
    const {
      fontStyleName: D2
    } = y5, H2 = v4 + (D2 ? "-" + D2.toLowerCase() : "-regular"), U3 = this._getMaterialOverrides(o13, y5.type);
    U3.push(...this._getPrimitiveMaterialOverrides(i12.primitiveName, y5.type));
    const J = {
      type: "text-rasterization-param",
      resource: {
        type: "text",
        textString: i12.textString ?? "",
        font: y5.font,
        symbol: y5,
        primitiveName: i12.primitiveName
      },
      overrides: U3
    };
    this._cimLayers.push({
      type: "text",
      lineWidth: y5.lineWidth,
      textRasterizationParam: J,
      colorLocked: !!c12 || !!N5,
      effects: e13,
      alignment: a9,
      anchorPoint: {
        x: 0,
        y: 0
      },
      isAbsoluteAnchorPoint: false,
      fontName: H2,
      decoration: d4,
      weight: u11.weight,
      style: u11.style,
      size: A8 ?? _5,
      angle: G4 ?? g3,
      offsetX: X2 ?? k2,
      offsetY: F4 ?? L5,
      transform: {
        type: "cim-marker-transform-param",
        params: l12
      },
      horizontalAlignment: x(y5.horizontalAlignment),
      verticalAlignment: A2(y5.verticalAlignment),
      text: W3,
      color: R4 ?? this._getValueOrOverrideExpression(y5.type, i12.primitiveName, "Color", E5),
      outlineColor: I4,
      outlineSize: V2,
      backgroundColor: T6,
      borderLineColor: Y2,
      borderLineWidth: j3,
      referenceSize: s13,
      sizeRatio: 1,
      markerPlacement: t15
    });
  }
  _analyzeMultiLayerGraphicNonSDF(e13, r12, t15, i12, a9, s13, n11, c12, p5, m7, f8) {
    const y5 = A4(e13, i12), h13 = e13.primitiveName, d4 = this._analyzeMaterialOverrides(h13, ["Rotation", "OffsetX", "OffsetY"]), u11 = R(d4), [v4, O3, g3] = ee.getTextureAnchor(y5, this._resourceManager), k2 = this._getMaterialOverrides(a9, e13.type);
    k2.push(...u11);
    const M3 = {
      type: "sprite-rasterization-param",
      resource: __spreadProps(__spreadValues({}, y5), {
        avoidSDFRasterization: true
      }),
      overrides: k2
    };
    this._cimLayers.push({
      type: "marker",
      spriteRasterizationParam: M3,
      colorLocked: m7,
      effects: r12,
      scaleSymbolsProportionally: !!e13.scaleSymbolsProportionally,
      alignment: s13,
      anchorPoint: {
        x: v4,
        y: O3
      },
      isAbsoluteAnchorPoint: false,
      size: p5,
      rotation: 0,
      offsetX: 0,
      offsetY: 0,
      transform: {
        type: "cim-marker-transform-param",
        params: c12
      },
      color: [255, 255, 255, 1],
      outlineColor: [0, 0, 0, 0],
      outlineWidth: 0,
      scaleX: 1,
      frameHeight: p5,
      widthRatio: 1,
      rotateClockwise: !!e13.rotateClockwise,
      referenceSize: n11,
      sizeRatio: g3 / u4(e13.size),
      isOutline: f8,
      markerPlacement: t15
    });
  }
  _createMarkerPlacementOverrideExpression(e13) {
    if (!e13) return null;
    const r12 = [];
    return y.findApplicableOverrides(e13, this._primitiveOverrides, r12), {
      type: "cim-marker-placement-param",
      placement: e13,
      overrides: Y(r12)
    };
  }
  _createGIFAnimatedSymbolPropertiesOverrideExpression(e13) {
    if (!e13) return null;
    const r12 = [];
    return y.findApplicableOverrides(e13, this._primitiveOverrides, r12), {
      type: "cim-gif-animation-params",
      animation: e13,
      overrides: Y(r12)
    };
  }
  _analyzeCompositeMarkerGraphic(e13, r12, t15, i12, o13, a9, s13, l12, c12, p5, y5) {
    const d4 = i12.geometry, u11 = o13[0], v4 = o13[1], _5 = m3(d4);
    if (!_5) return;
    const g3 = "Relative" !== e13.anchorPointUnits, [k2, M3, S2, C3] = a3(_5, e13.frame, e13.size, e13.anchorPoint, g3), {
      path: b5
    } = v4, P5 = v4.primitiveName, x3 = u11.primitiveName, z = i12.primitiveName;
    let L5 = null;
    v4.colorLocked || p5 || (L5 = this._maybeGetValueOrOverrideExpression(z, "FillColor"));
    const E5 = L5 ?? this._getValueOrOverrideExpression(v4.type, P5, "Color", f2(v4.color));
    let I4 = null;
    u11.colorLocked || p5 || (I4 = this._maybeGetValueOrOverrideExpression(z, "StrokeColor"));
    const V2 = I4 ?? this._getValueOrOverrideExpression(u11.type, x3, "Color", f2(u11.color)), N5 = this._maybeGetValueOrOverrideExpression(z, "StrokeWidth") ?? this._getValueOrOverrideExpression(u11.type, x3, "Width", I(u11.width, t.CIMSolidStroke.width)), w6 = {
      type: "sprite-rasterization-param",
      resource: b5 ? {
        type: "path",
        path: b5,
        asFill: true
      } : {
        type: "sdf",
        geom: d4,
        asFill: true
      },
      overrides: []
    };
    this._cimLayers.push({
      type: "marker",
      spriteRasterizationParam: w6,
      colorLocked: p5,
      effects: r12,
      scaleSymbolsProportionally: !!e13.scaleSymbolsProportionally,
      alignment: a9,
      anchorPoint: {
        x: M3,
        y: S2
      },
      isAbsoluteAnchorPoint: g3,
      size: c12,
      rotation: 0,
      offsetX: 0,
      offsetY: 0,
      scaleX: 1,
      transform: {
        type: "cim-marker-transform-param",
        params: l12
      },
      frameHeight: c12,
      widthRatio: C3,
      rotateClockwise: false,
      referenceSize: s13,
      sizeRatio: k2,
      color: E5,
      outlineColor: V2,
      outlineWidth: N5,
      isOutline: y5,
      markerPlacement: t15
    });
  }
  _setPoMap(e13, r12, t15) {
    let i12;
    this._poMap[e13] ? i12 = this._poMap[e13] : (i12 = {}, this._poMap[e13] = i12), i12[r12] = t15;
  }
  _maybeGetValueOrOverrideExpression(e13, r12, t15) {
    return this._getValueOrOverrideExpression("", e13, r12, t15, false);
  }
  _getValueOrOverrideExpression(e13, r12, t15, i12, o13 = true) {
    if (o13 && !E(i12) && (i12 = O(e13, t15.toLowerCase())), null == r12) return i12;
    const a9 = this._poMap[r12];
    if (null == a9) return i12;
    const s13 = a9[t15];
    return "string" == typeof s13 || "number" == typeof s13 || Array.isArray(s13) ? s13 : s13 ? {
      valueExpressionInfo: s13,
      defaultValue: i12
    } : i12;
  }
  _analyzePrimitiveOverrides(e13, r12, t15, i12) {
    if (null == e13) return false;
    "string" == typeof e13 && (e13 = [e13]);
    for (const o13 of this._primitiveOverrides) if (e13.includes(o13.primitiveName) && o13.valueExpressionInfo) return true;
    if (null != r12) {
      for (const o13 of r12) if (o13?.overrides.length > 0) return true;
    }
    if (null != t15) {
      for (const o13 of t15) if (o13?.overrides.length > 0) return true;
    }
    if (null != i12) {
      for (const o13 of i12) if (o13?.overrides.length > 0) return true;
    }
    return false;
  }
  _getMaterialOverrides(e13, r12) {
    if (!e13) return [];
    const t15 = [];
    for (const i12 of e13) t15.push(...this._getPrimitiveMaterialOverrides(i12, r12));
    return t15;
  }
  _getPrimitiveMaterialOverrides(e13, r12) {
    if (!e13) return [];
    const t15 = R(this._primitiveOverrides.filter((r13) => r13.primitiveName === e13));
    return t15.forEach((e14) => e14.defaultValue = O(r12, e14.propertyName.toLowerCase())), t15;
  }
  _analyzeMaterialOverrides(e13, r12) {
    return this._primitiveOverrides.filter((t15) => t15.primitiveName !== e13 || !r12.includes(t15.propertyName));
  }
};
function A4(e13, r12) {
  return {
    type: e13.type,
    enable: true,
    name: e13.name,
    colorLocked: e13.colorLocked,
    primitiveName: e13.primitiveName,
    anchorPoint: e13.anchorPoint,
    anchorPointUnits: e13.anchorPointUnits,
    offsetX: 0,
    offsetY: 0,
    rotateClockwise: e13.rotateClockwise,
    rotation: 0,
    size: e13.size,
    billboardMode3D: e13.billboardMode3D,
    depth3D: e13.depth3D,
    frame: e13.frame,
    markerGraphics: [r12],
    scaleSymbolsProportionally: e13.scaleSymbolsProportionally,
    respectFrame: e13.respectFrame,
    clippingPath: e13.clippingPath
  };
}
function G2(e13) {
  if (e13 && 0 === e13.indexOf("Level_")) {
    const r12 = parseInt(e13.substr(6), 10);
    if (!isNaN(r12)) return r12;
  }
  return 0;
}
var F2 = (e13) => e13 && 2 === e13.length && e13[0].enable && e13[1].enable && "CIMSolidStroke" === e13[0].type && "CIMSolidFill" === e13[1].type && null == e13[0].path && null == e13[1].path && !e13[0].effects && !e13[1].effects;
function T5(e13) {
  const r12 = e13.symbolLayers;
  if (!r12 || 2 !== r12.length) return false;
  const t15 = r12.find((e14) => e14.effects?.find((e15) => "CIMGeometricEffectDashes" === e15.type && null != e15.dashTemplate)), i12 = r12.find((e14) => e14.effects?.find((e15) => "CIMGeometricEffectAddControlPoints" === e15.type));
  return !!t15 || !!i12;
}
function Y(e13) {
  return a(e13).map((e14) => __spreadProps(__spreadValues({}, e14), {
    propertyName: v(e14.propertyName)
  }));
}

// ../../../node_modules/@arcgis/core/views/2d/engine/ManagedCanvas.js
var l6 = class {
  constructor(s13) {
    this.events = new o3(), this._hasMajorPerformanceCaveat = false, this._lastRenderFrameCounter = 0, this._canvas = document.createElement("canvas"), this._canvas.setAttribute("style", "width: 100%; height:100%; display:block; willChange:transform");
    const r12 = {
      failIfMajorPerformanceCaveat: true,
      alpha: true,
      antialias: false,
      depth: true,
      stencil: true
    };
    s13.appendChild(this._canvas);
    let i12 = t5(this._canvas, r12);
    i12 || (i12 = t5(this._canvas, __spreadProps(__spreadValues({}, r12), {
      failIfMajorPerformanceCaveat: false
    })), this._hasMajorPerformanceCaveat = true), this._gl = i12, this._handles = o([o2(this._canvas, "webglcontextlost", (e13) => this.events.emit("webgl-context-lost", e13))]);
  }
  destroy() {
    this._canvas.parentNode?.removeChild(this._canvas), this._canvas = null, this._handles.remove(), this._gl = null;
  }
  get gl() {
    return this._gl;
  }
  render(e13, t15) {
    if (this._hasMajorPerformanceCaveat || has("esri-force-performance-mode")) {
      if (++this._lastRenderFrameCounter >= has("esri-performance-mode-frames-between-render") && (t15(), this._lastRenderViewState = e13.state.clone(), this._lastRenderFrameCounter = 0), this._lastRenderViewState) {
        const [t16, a9, s13, r12, i12, o13] = this._computeViewTransform(this._lastRenderViewState, e13.state);
        this._canvas.style.transform = `matrix(${t16}, ${a9}, ${s13}, ${r12}, ${i12}, ${o13})`;
      }
    } else t15();
  }
  resize(e13) {
    const t15 = this._canvas, a9 = t15.style, {
      state: {
        size: s13
      },
      pixelRatio: r12
    } = e13, i12 = s13[0], o13 = s13[1], n11 = Math.round(i12 * r12), h13 = Math.round(o13 * r12);
    t15.width === n11 && t15.height === h13 || (t15.width = n11, t15.height = h13), a9.width = i12 + "px", a9.height = o13 + "px";
  }
  _computeViewTransform(e13, t15) {
    const [a9, c12] = e13.center, [l12, m7] = t15.center, [d4, f8] = e13.toScreen([0, 0], l12, m7), [_5, v4] = e13.toScreen([0, 0], a9, c12), p5 = _5 - d4, g3 = v4 - f8, w6 = e13.scale / t15.scale, u11 = t15.rotation - e13.rotation, j3 = e5();
    return a2(j3), c3(j3, j3, [w6, w6]), s5(j3, j3, h(u11)), i4(j3, j3, [p5, g3]), j3;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/BitBlitRenderer.js
var _2 = class {
  constructor() {
    this._initialized = false;
  }
  dispose() {
    this._program = r2(this._program), this._vertexArrayObject = r2(this._vertexArrayObject);
  }
  render(r12, t15, e13, i12) {
    r12 && (this._initialized || this._initialize(r12), r12.setBlendFunctionSeparate(R2.ONE, R2.ONE_MINUS_SRC_ALPHA, R2.ONE, R2.ONE_MINUS_SRC_ALPHA), r12.bindVAO(this._vertexArrayObject), r12.useProgram(this._program), t15.setSamplingMode(e13), r12.bindTexture(t15, 0), this._program.setUniform1i("u_tex", 0), this._program.setUniform1f("u_opacity", i12), r12.drawArrays(E2.TRIANGLE_STRIP, 0, 4), r12.bindTexture(null, 0), r12.bindVAO());
  }
  _initialize(r12) {
    if (this._initialized) return true;
    const s13 = e7(r12, e9);
    if (!s13) return false;
    const o13 = new Int8Array(16);
    o13[0] = -1, o13[1] = -1, o13[2] = 0, o13[3] = 0, o13[4] = 1, o13[5] = -1, o13[6] = 1, o13[7] = 0, o13[8] = -1, o13[9] = 1, o13[10] = 0, o13[11] = 1, o13[12] = 1, o13[13] = 1, o13[14] = 1, o13[15] = 1;
    const _5 = e9.attributes, p5 = new o8(r12, _5, t7, {
      geometry: c.createVertex(r12, F.STATIC_DRAW, o13)
    });
    return this._program = s13, this._vertexArrayObject = p5, this._initialized = true, true;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/MaterialManager.js
var e12 = class {
  constructor(r12) {
    this._rctx = r12, this._programByKey = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._programByKey.forEach((r12) => r12.dispose()), this._programByKey.clear();
  }
  getProgram(e13, t15 = []) {
    const a9 = e13.vsPath + "." + e13.fsPath + JSON.stringify(t15);
    if (this._programByKey.has(a9)) return this._programByKey.get(a9);
    const s13 = __spreadValues({}, t15.map((r12) => "string" == typeof r12 ? {
      name: r12,
      value: true
    } : r12).reduce((r12, e14) => __spreadProps(__spreadValues({}, r12), {
      [e14.name]: e14.value
    }), {})), {
      vsPath: o13,
      fsPath: h13,
      attributes: i12
    } = e13, g3 = o10(o13, h13, i12, s13), m7 = this._rctx.programCache.acquire(g3.shaders.vertexShader, g3.shaders.fragmentShader, g3.attributes);
    if (!m7) throw new Error("Unable to get program for key: ${key}");
    return this._programByKey.set(a9, m7), m7;
  }
};

// ../../../node_modules/@arcgis/core/symbols/cim/Rasterizer.js
var c5 = 512;
var l7 = class {
  constructor(e13) {
    this._resourceManager = e13, this._cachedRasterizationCanvas = null;
  }
  dispose() {
    this._cachedRasterizationCanvas = null;
  }
  get _canvas() {
    return this._cachedRasterizationCanvas || (this._cachedRasterizationCanvas = document.createElement("canvas")), this._cachedRasterizationCanvas;
  }
  rasterizeJSONResource(e13) {
    switch (e13.type) {
      case "dash": {
        const r12 = e13.dashTemplate, a9 = e13.capStyle, [n11, s13, i12] = i8(r12, a9);
        return {
          size: [s13, i12],
          image: new Uint32Array(n11.buffer),
          sdf: true,
          simplePattern: true,
          anchorX: 0,
          anchorY: 0
        };
      }
      case "fill-style": {
        const [t15, a9, n11, s13] = e10(this._canvas, e13, et);
        return {
          size: [a9, n11],
          image: new Uint32Array(t15.buffer),
          sdf: false,
          simplePattern: true,
          anchorX: 0,
          anchorY: 0,
          rasterizationScale: s13
        };
      }
      case "sdf":
        return h8(e13);
      case "CIMHatchFill":
      case "CIMVectorMarker":
      case "CIMPictureMarker":
        return this._rasterizeCIMJSONResource(e13);
    }
  }
  _rasterizeCIMJSONResource(r12) {
    switch (r12.type) {
      case "CIMHatchFill": {
        const t15 = ee.fromCIMHatchFill(r12, et);
        return this._rasterizeCIMVectorMarker(t15);
      }
      case "CIMPictureMarker": {
        const t15 = ee.fromCIMInsidePolygon(r12);
        return this._rasterizeCIMVectorMarker(t15);
      }
      case "CIMVectorMarker": {
        if ("CIMMarkerPlacementInsidePolygon" === r12.markerPlacement?.type) {
          const t16 = ee.fromCIMInsidePolygon(r12);
          return this._rasterizeCIMVectorMarker(t16);
        }
        const t15 = l5(r12);
        return t15 && !r12.avoidSDFRasterization ? h8(t15) : this._rasterizeCIMVectorMarker(r12, false);
      }
    }
  }
  _rasterizeCIMVectorMarker(r12, t15 = true) {
    const n11 = t15 ? t3.fromExtent(r12.frame) : null, [s13, i12, o13, c12, l12] = ee.rasterize(this._canvas, r12, n11, this._resourceManager);
    return s13 ? {
      size: [i12, o13],
      image: new Uint32Array(s13.buffer),
      sdf: false,
      simplePattern: false,
      anchorX: c12,
      anchorY: l12
    } : null;
  }
  rasterizeImageResource(e13, r12, t15, a9) {
    this._canvas.width = e13, this._canvas.height = r12;
    const n11 = this._canvas.getContext("2d", {
      willReadFrequently: true
    });
    t15 instanceof ImageData ? n11.putImageData(t15, 0, 0) : (t15.setAttribute("width", `${e13}px`), t15.setAttribute("height", `${r12}px`), n11.drawImage(t15, 0, 0, e13, r12));
    const s13 = n11.getImageData(0, 0, e13, r12), o13 = new Uint8Array(s13.data);
    if (a9) {
      for (const i12 of a9) if (i12 && i12.oldColor && 4 === i12.oldColor.length && i12.newColor && 4 === i12.newColor.length) {
        const [e14, r13, t16, a10] = i12.oldColor, [n12, s14, c12, l13] = i12.newColor;
        if (e14 === n12 && r13 === s14 && t16 === c12 && a10 === l13) continue;
        for (let i13 = 0; i13 < o13.length; i13 += 4) e14 === o13[i13] && r13 === o13[i13 + 1] && t16 === o13[i13 + 2] && a10 === o13[i13 + 3] && (o13[i13] = n12, o13[i13 + 1] = s14, o13[i13 + 2] = c12, o13[i13 + 3] = l13);
      }
    }
    let l12;
    for (let i12 = 0; i12 < o13.length; i12 += 4) l12 = o13[i12 + 3] / 255, o13[i12] = o13[i12] * l12, o13[i12 + 1] = o13[i12 + 1] * l12, o13[i12 + 2] = o13[i12 + 2] * l12;
    let h13 = o13, u11 = e13, f8 = r12;
    const m7 = c5;
    if (u11 >= m7 || f8 >= m7) {
      const t16 = u11 / f8;
      t16 > 1 ? (u11 = m7, f8 = Math.round(m7 / t16)) : (f8 = m7, u11 = Math.round(m7 * t16)), h13 = new Uint8Array(4 * u11 * f8);
      const a10 = new Uint8ClampedArray(h13.buffer);
      u5(o13, e13, r12, a10, u11, f8, false);
    }
    return {
      size: [u11, f8],
      image: new Uint32Array(h13.buffer),
      sdf: false,
      simplePattern: false,
      anchorX: 0,
      anchorY: 0
    };
  }
};
function h8(e13) {
  if (!e13) return null;
  const [r12, t15, a9] = c4(e13);
  return r12 ? {
    size: [t15, a9],
    image: new Uint32Array(r12.buffer),
    sdf: true,
    simplePattern: true,
    anchorX: 0,
    anchorY: 0
  } : null;
}

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/RectangleBinPack.js
var t11 = class {
  constructor(t15, e13) {
    this._width = 0, this._height = 0, this._free = [], this._width = t15, this._height = e13, this._free.push(new t4(0, 0, t15, e13));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(t15, e13) {
    if (t15 > this._width || e13 > this._height) return new t4();
    let i12 = null, s13 = -1;
    for (let h13 = 0; h13 < this._free.length; ++h13) {
      const r12 = this._free[h13];
      t15 <= r12.width && e13 <= r12.height && (null === i12 || r12.y <= i12.y && r12.x <= i12.x) && (i12 = r12, s13 = h13);
    }
    return null === i12 ? new t4() : (this._free.splice(s13, 1), i12.width < i12.height ? (i12.width > t15 && this._free.push(new t4(i12.x + t15, i12.y, i12.width - t15, e13)), i12.height > e13 && this._free.push(new t4(i12.x, i12.y + e13, i12.width, i12.height - e13))) : (i12.width > t15 && this._free.push(new t4(i12.x + t15, i12.y, i12.width - t15, i12.height)), i12.height > e13 && this._free.push(new t4(i12.x, i12.y + e13, t15, i12.height - e13))), new t4(i12.x, i12.y, t15, e13));
  }
  release(h13) {
    for (let t15 = 0; t15 < this._free.length; ++t15) {
      const e13 = this._free[t15];
      if (e13.y === h13.y && e13.height === h13.height && e13.x + e13.width === h13.x) e13.width += h13.width;
      else if (e13.x === h13.x && e13.width === h13.width && e13.y + e13.height === h13.y) e13.height += h13.height;
      else if (h13.y === e13.y && h13.height === e13.height && h13.x + h13.width === e13.x) e13.x = h13.x, e13.width += h13.width;
      else {
        if (h13.x !== e13.x || h13.width !== e13.width || h13.y + h13.height !== e13.y) continue;
        e13.y = h13.y, e13.height += h13.height;
      }
      this._free.splice(t15, 1), this.release(h13);
    }
    this._free.push(h13);
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/GlyphMosaic.js
var n6 = 256;
var o11 = (t15) => Math.floor(t15 / 256);
function c6(t15) {
  const e13 = /* @__PURE__ */ new Set();
  for (const i12 of t15) e13.add(o11(i12));
  return e13;
}
function l8(e13, i12, h13) {
  return e13.has(i12) || e13.set(i12, h13().then(() => {
    e13.delete(i12);
  }).catch((h14) => {
    e13.delete(i12), f(h14);
  })), e13.get(i12);
}
var g = (t15) => ({
  rect: new t4(0, 0, 0, 0),
  page: 0,
  metrics: {
    left: 0,
    width: 0,
    height: 0,
    advance: 0,
    top: 0
  },
  code: t15,
  sdf: true
});
var p3 = class {
  constructor(t15, e13, h13) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphCache = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this._preloadCache = {}, this.width = t15, this.height = e13, this._glyphSource = h13, this._binPack = new t11(t15 - 4, e13 - 4), this._glyphData.push(new Uint8Array(t15 * e13)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs();
  }
  dispose() {
    this._binPack = null;
    for (const t15 of this._textures) t15 && t15.dispose();
    this._textures.length = 0, this._glyphData.length = 0;
  }
  _initDecorationGlyphs() {
    const t15 = [117, 149, 181, 207, 207, 181, 149, 117], e13 = [], i12 = [];
    for (let r12 = 0; r12 < t15.length; r12++) {
      const h14 = t15[r12];
      for (let t16 = 0; t16 < 11; t16++) {
        const s14 = r12 >= 3 && r12 < 5 && t16 >= 3 && t16 < 8 ? 255 : 0;
        e13.push(h14), i12.push(s14);
      }
    }
    const h13 = {
      metrics: {
        width: 5,
        height: 2,
        left: 0,
        top: 0,
        advance: 0
      },
      bitmap: new Uint8Array(e13)
    }, s13 = {
      metrics: {
        width: 5,
        height: 2,
        left: 0,
        top: 0,
        advance: 0
      },
      bitmap: new Uint8Array(i12)
    };
    this._recordGlyph(h13), this._recordGlyph(s13);
  }
  getTexture(t15, e13) {
    if (!this._textures[e13]) {
      const i12 = new e4();
      i12.pixelFormat = G.ALPHA, i12.wrapMode = D.CLAMP_TO_EDGE, i12.width = this.width, i12.height = this.height, this._textures[e13] = new c2(t15, i12, new Uint8Array(this.width * this.height));
    }
    return this._dirties[e13] && (this._textures[e13].setData(this._glyphData[e13]), this._dirties[e13] = false), this._textures[e13];
  }
  getGlyphItems(t15, e13, i12) {
    return __async(this, null, function* () {
      const h13 = this._getGlyphCache(t15);
      return yield this._fetchRanges(t15, e13, i12), e13.map((e14) => this._getMosaicItem(h13, t15, e14));
    });
  }
  bind(t15, e13, i12, h13) {
    const s13 = this.getTexture(t15, i12);
    s13.setSamplingMode(e13), t15.bindTexture(s13, h13);
  }
  preloadASCIIGlyphCache(t15) {
    const e13 = this._preloadCache[t15];
    if (null != e13) return e13;
    const i12 = this._glyphSource.preloadASCIIRange(t15).then(() => {
      const e14 = this._getGlyphCache(t15);
      for (let i13 = 0; i13 < 256; i13++) this._getMosaicItem(e14, t15, i13);
    });
    return this._preloadCache[t15] = i12, i12;
  }
  _getGlyphCache(t15) {
    return this._glyphCache[t15] || (this._glyphCache[t15] = {}), this._glyphCache[t15];
  }
  _invalidate() {
    this._dirties[this._currentPage] = true;
  }
  _fetchRanges(t15, e13, i12) {
    return __async(this, null, function* () {
      const h13 = c6(e13), s13 = [];
      h13.forEach((e14) => {
        s13.push(this._fetchRange(t15, e14, i12));
      }), yield Promise.all(s13);
    });
  }
  _fetchRange(t15, e13, i12) {
    return __async(this, null, function* () {
      if (e13 > n6) return;
      const h13 = t15 + e13;
      return l8(this._rangePromises, h13, () => this._glyphSource.getRange(t15, e13, i12));
    });
  }
  _getMosaicItem(t15, e13, i12) {
    if (!t15[i12]) {
      const h13 = this._glyphSource.getGlyph(e13, i12);
      if (!h13?.metrics) return g(i12);
      const s13 = this._recordGlyph(h13), r12 = this._currentPage, a9 = h13.metrics;
      t15[i12] = {
        rect: s13,
        page: r12,
        metrics: a9,
        code: i12,
        sdf: true
      }, this._invalidate();
    }
    return t15[i12];
  }
  _recordGlyph(t15) {
    const h13 = t15.metrics;
    let s13;
    if (0 === h13.width) s13 = new t4(0, 0, 0, 0);
    else {
      const e13 = 3, r12 = h13.width + 2 * e13, a9 = h13.height + 2 * e13;
      s13 = this._binPack.allocate(r12, a9), s13.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs(), this._binPack = new t11(this.width - 4, this.height - 4), s13 = this._binPack.allocate(r12, a9));
      const n11 = this._glyphData[this._currentPage], o13 = t15.bitmap;
      let c12, l12;
      if (o13) for (let t16 = 0; t16 < a9; t16++) {
        c12 = r12 * t16, l12 = this.width * (s13.y + t16) + s13.x;
        for (let t17 = 0; t17 < r12; t17++) n11[l12 + t17] = o13[c12 + t17];
      }
      has("esri-glyph-debug") && this._showDebugPage(n11);
    }
    return s13;
  }
  _showDebugPage(t15) {
    const e13 = document.createElement("canvas"), i12 = e13.getContext("2d"), h13 = new ImageData(this.width, this.height), s13 = h13.data;
    e13.width = this.width, e13.height = this.height, e13.style.border = "1px solid black";
    for (let r12 = 0; r12 < t15.length; ++r12) s13[4 * r12] = t15[r12], s13[4 * r12 + 1] = 0, s13[4 * r12 + 2] = 0, s13[4 * r12 + 3] = 255;
    i12.putImageData(h13, 0, 0), document.body.appendChild(e13);
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/GlyphSource.js
var a6 = class {
  constructor(e13) {
    for (this._metrics = [], this._bitmaps = []; e13.next(); ) switch (e13.tag()) {
      case 1: {
        const t15 = e13.getMessage();
        for (; t15.next(); ) switch (t15.tag()) {
          case 3: {
            const e14 = t15.getMessage();
            let a9, s13, r12, n11, i12, c12, g3;
            for (; e14.next(); ) switch (e14.tag()) {
              case 1:
                a9 = e14.getUInt32();
                break;
              case 2:
                s13 = e14.getBytes();
                break;
              case 3:
                r12 = e14.getUInt32();
                break;
              case 4:
                n11 = e14.getUInt32();
                break;
              case 5:
                i12 = e14.getSInt32();
                break;
              case 6:
                c12 = e14.getSInt32();
                break;
              case 7:
                g3 = e14.getUInt32();
                break;
              default:
                e14.skip();
            }
            e14.release(), a9 && (this._metrics[a9] = {
              width: r12,
              height: n11,
              left: i12,
              top: c12,
              advance: g3
            }, this._bitmaps[a9] = s13);
            break;
          }
          default:
            t15.skip();
        }
        t15.release();
        break;
      }
      default:
        e13.skip();
    }
  }
  getMetrics(e13) {
    return this._metrics[e13];
  }
  getBitmap(e13) {
    return this._bitmaps[e13];
  }
};
var s10 = class {
  constructor() {
    this._ranges = [];
  }
  getRange(e13) {
    return this._ranges[e13];
  }
  addRange(e13, t15) {
    this._ranges[e13] = t15;
  }
};
var r7 = class {
  constructor(e13) {
    this._glyphInfo = {}, this._baseURL = e13;
  }
  getRange(s13, r12, n11) {
    const i12 = this._getFontStack(s13);
    if (i12.getRange(r12)) return Promise.resolve();
    const c12 = 256 * r12, g3 = c12 + 255, o13 = this._baseURL.replace("{fontstack}", s13).replace("{range}", c12 + "-" + g3);
    return U(o13, __spreadValues({
      responseType: "array-buffer"
    }, n11)).then((e13) => {
      i12.addRange(r12, new a6(new n3(new Uint8Array(e13.data), new DataView(e13.data))));
    });
  }
  preloadASCIIRange(s13) {
    return __async(this, null, function* () {
      const r12 = this._getFontStack(s13), n11 = 0, i12 = 255, c12 = this._baseURL.replace("{fontstack}", s13).replace("{range}", n11 + "-" + i12), g3 = yield U(c12, {
        responseType: "array-buffer"
      }), o13 = new a6(new n3(new Uint8Array(g3.data), new DataView(g3.data)));
      for (let e13 = n11; e13 <= i12; e13++) r12.getRange(e13) || r12.addRange(e13, o13);
    });
  }
  getGlyph(e13, t15) {
    const a9 = this._getFontStack(e13);
    if (!a9) return;
    const s13 = Math.floor(t15 / 256), r12 = a9.getRange(s13);
    return r12 ? {
      metrics: r12.getMetrics(t15),
      bitmap: r12.getBitmap(t15)
    } : void 0;
  }
  _getFontStack(e13) {
    let t15 = this._glyphInfo[e13];
    return t15 || (t15 = this._glyphInfo[e13] = new s10()), t15;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/SDFConverter.js
var s11 = 1e20;
var r8 = class {
  constructor(t15, e13 = 2) {
    this._textureSize = t15, this._rasterizationScale = e13, this._canvasSize = this._textureSize * this._rasterizationScale, this._svg = null;
    const {
      _canvasSize: i12
    } = this, s13 = document.createElement("canvas");
    s13.width = s13.height = i12, this._context = s13.getContext("2d", {
      willReadFrequently: false
    }), this._gridOuter = new Float64Array(i12 * i12), this._gridInner = new Float64Array(i12 * i12), this._f = new Float64Array(i12), this._d = new Float64Array(i12), this._z = new Float64Array(i12 + 1), this._v = new Int16Array(i12);
  }
  dispose() {
    this._context = this._gridOuter = this._gridInner = this._f = this._d = this._z = this._v = null, this._svg && (document.body.removeChild(this._svg), this._svg = null);
  }
  draw(r12, n11, o13) {
    const {
      _canvasSize: h13,
      _textureSize: a9,
      _rasterizationScale: l12
    } = this, d4 = a9 / 4;
    this._initSVG();
    const _5 = this.createSVGString(r12, n11);
    return new Promise((r13, n12) => {
      const c12 = new Image();
      c12.src = "data:image/svg+xml; charset=utf8, " + encodeURIComponent(_5), c12.onload = () => {
        c12.onload = null, this._context.clearRect(0, 0, h13, h13), this._context.drawImage(c12, 0, 0, h13, h13);
        const e13 = this._context.getImageData(0, 0, h13, h13), i12 = new Uint8Array(a9 * a9 * 4);
        for (let t15 = 0; t15 < h13 * h13; t15++) {
          const i13 = e13.data[4 * t15 + 3] / 255;
          this._gridOuter[t15] = 1 === i13 ? 0 : 0 === i13 ? s11 : Math.max(0, 0.5 - i13) ** 2, this._gridInner[t15] = 1 === i13 ? s11 : 0 === i13 ? 0 : Math.max(0, i13 - 0.5) ** 2;
        }
        this._edt(this._gridOuter, h13, h13), this._edt(this._gridInner, h13, h13);
        for (let s13 = 0; s13 < a9 * a9; s13++) {
          let e14 = 0;
          for (let t15 = 0; t15 < l12; t15++) {
            const i13 = Math.floor(s13 / a9) * l12 + t15;
            for (let t16 = 0; t16 < l12; t16++) {
              const r14 = i13 * h13 + (s13 % a9 * l12 + t16);
              e14 += this._gridOuter[r14] - this._gridInner[r14];
            }
          }
          e14 /= l12 * l12, e14 /= l12;
          o7(0.5 - e14 / (2 * d4), i12, 4 * s13);
        }
        r13(i12);
      };
      const g3 = o13?.signal;
      g3 && m2(g3, () => n12(u2()));
    });
  }
  _initSVG() {
    if (!this._svg) {
      const t15 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      t15.setAttribute("style", "position: absolute;"), t15.setAttribute("width", "0"), t15.setAttribute("height", "0"), t15.setAttribute("aria-hidden", "true"), t15.setAttribute("role", "presentation"), document.body.appendChild(t15), this._svg = t15;
    }
    return this._svg;
  }
  createSVGString(t15, e13) {
    const i12 = this._initSVG(), s13 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    s13.setAttribute("d", t15), i12.appendChild(s13);
    const r12 = s13.getBBox(), n11 = r12.width / r12.height, o13 = this._canvasSize / 2;
    let h13, a9, l12;
    if (n11 > 1) {
      h13 = o13 / r12.width;
      const t16 = o13 * (1 / n11);
      a9 = this._canvasSize / 4, l12 = o13 - t16 / 2;
    } else {
      h13 = o13 / r12.height;
      a9 = o13 - o13 * n11 / 2, l12 = this._canvasSize / 4;
    }
    const d4 = -r12.x * h13 + a9, _5 = -r12.y * h13 + l12;
    s13.setAttribute("style", `transform: matrix(${h13}, 0, 0, ${h13}, ${d4}, ${_5})`), s13.setAttribute("stroke-width", "" + 0.5 / h13);
    const c12 = `<svg style="fill:${e13 ? "red" : "none"}; stroke:${e13 ? "none" : "red"}" height="${this._canvasSize}" width="${this._canvasSize}" xmlns="http://www.w3.org/2000/svg">${i12.innerHTML}</svg>`;
    return i12.removeChild(s13), c12;
  }
  _edt(t15, e13, i12) {
    const s13 = this._f, r12 = this._d, n11 = this._v, o13 = this._z;
    for (let h13 = 0; h13 < e13; h13++) {
      for (let r13 = 0; r13 < i12; r13++) s13[r13] = t15[r13 * e13 + h13];
      this._edt1d(s13, r12, n11, o13, i12);
      for (let s14 = 0; s14 < i12; s14++) t15[s14 * e13 + h13] = r12[s14];
    }
    for (let h13 = 0; h13 < i12; h13++) {
      for (let i13 = 0; i13 < e13; i13++) s13[i13] = t15[h13 * e13 + i13];
      this._edt1d(s13, r12, n11, o13, e13);
      for (let i13 = 0; i13 < e13; i13++) t15[h13 * e13 + i13] = Math.sqrt(r12[i13]);
    }
  }
  _edt1d(t15, e13, i12, r12, n11) {
    i12[0] = 0, r12[0] = -s11, r12[1] = +s11;
    for (let o13 = 1, h13 = 0; o13 < n11; o13++) {
      let e14 = (t15[o13] + o13 * o13 - (t15[i12[h13]] + i12[h13] * i12[h13])) / (2 * o13 - 2 * i12[h13]);
      for (; e14 <= r12[h13]; ) h13--, e14 = (t15[o13] + o13 * o13 - (t15[i12[h13]] + i12[h13] * i12[h13])) / (2 * o13 - 2 * i12[h13]);
      h13++, i12[h13] = o13, r12[h13] = e14, r12[h13 + 1] = +s11;
    }
    for (let s13 = 0, o13 = 0; s13 < n11; s13++) {
      for (; r12[o13 + 1] < s13; ) o13++;
      e13[s13] = (s13 - i12[o13]) * (s13 - i12[o13]) + t15[i12[o13]];
    }
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/SpriteMosaic.js
function c7(t15) {
  return t15 && "static" === t15.type;
}
var n7 = class _n {
  constructor(t15, e13, i12 = 0) {
    this._mosaicPages = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = /* @__PURE__ */ new Map(), this._spriteCopyQueue = [], this.pixelRatio = 1, this._pageWidth = t15, this._pageHeight = e13, i12 > 0 && (this._maxItemSize = i12), this.pixelRatio = window.devicePixelRatio || 1, this._binPack = new t11(this._pageWidth, this._pageHeight);
    const s13 = Math.floor(this._pageWidth), r12 = Math.floor(this._pageHeight);
    this._mosaicPages.push({
      mosaicsData: {
        type: "static",
        data: new Uint32Array(s13 * r12)
      },
      size: [this._pageWidth, this._pageHeight],
      dirty: true,
      texture: void 0
    });
  }
  getWidth(t15) {
    return t15 >= this._mosaicPages.length ? -1 : this._mosaicPages[t15].size[0];
  }
  getHeight(t15) {
    return t15 >= this._mosaicPages.length ? -1 : this._mosaicPages[t15].size[1];
  }
  getPageTexture(t15) {
    return t15 < this._mosaicPages.length ? this._mosaicPages[t15].texture : null;
  }
  has(t15) {
    return this._mosaicRects.has(t15);
  }
  get itemCount() {
    return this._mosaicRects.size;
  }
  getSpriteItem(t15) {
    return this._mosaicRects.get(t15);
  }
  addSpriteItem(t15, i12, a9, r12, o13, h13, n11 = 1) {
    if (this._mosaicRects.has(t15)) return this._mosaicRects.get(t15);
    let g3, p5, m7;
    if (c7(a9)) [g3, p5, m7] = this._allocateImage(i12[0], i12[1]);
    else {
      g3 = new t4(0, 0, i12[0], i12[1]), p5 = this._mosaicPages.length;
      const t16 = void 0;
      this._mosaicPages.push({
        mosaicsData: a9,
        size: [i12[0] + 2 * tt, i12[1] + 2 * tt],
        dirty: true,
        texture: t16
      });
    }
    if (g3.width <= 0 || g3.height <= 0) return null;
    const d4 = {
      type: "sprite",
      rect: g3,
      width: i12[0],
      height: i12[1],
      sdf: o13,
      simplePattern: h13,
      rasterizationScale: n11,
      page: p5
    };
    return this._mosaicRects.set(t15, d4), c7(a9) && (has("esri-mosaic-debug") && this._showDebugSprite(i12, a9.data), this._copy({
      rect: g3,
      spriteSize: i12,
      spriteData: a9.data,
      page: p5,
      pageSize: m7,
      repeat: r12,
      sdf: o13
    })), d4;
  }
  hasItemsToProcess() {
    return 0 !== this._spriteCopyQueue.length;
  }
  processNextItem() {
    const t15 = this._spriteCopyQueue.pop();
    t15 && this._copy(t15);
  }
  getMosaicItemPosition(t15) {
    const i12 = this.getSpriteItem(t15), s13 = i12?.rect;
    if (!s13) return null;
    s13.width = i12.width, s13.height = i12.height;
    const a9 = i12.width, r12 = i12.height, o13 = tt, h13 = this._mosaicPages[i12.page].size;
    return {
      size: [i12.width, i12.height],
      tl: [(s13.x + o13) / h13[0], (s13.y + o13) / h13[1]],
      br: [(s13.x + o13 + a9) / h13[0], (s13.y + o13 + r12) / h13[1]],
      page: i12.page
    };
  }
  bind(t15, e13, i12 = 0, s13 = 0) {
    const a9 = this._mosaicPages[i12], r12 = a9.mosaicsData;
    let o13 = a9.texture;
    if (o13 || (o13 = p4(t15, a9.size), a9.texture = o13), o13.setSamplingMode(e13), c7(r12)) t15.bindTexture(o13, s13), a9.dirty && (o13.setData(new Uint8Array(r12.data.buffer)), o13.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(i12));
    else {
      r12.data.loadFrame(o13), t15.bindTexture(o13, s13), o13.generateMipmap();
    }
    a9.dirty = false;
  }
  getTexture(t15, e13 = 0) {
    const i12 = this._mosaicPages[e13], s13 = i12.mosaicsData;
    let a9 = i12.texture;
    if (a9 || (a9 = p4(t15, i12.size), i12.texture = a9), c7(s13)) i12.dirty && (a9.setData(new Uint8Array(s13.data.buffer)), a9.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(e13));
    else {
      s13.data.loadFrame(a9), a9.generateMipmap();
    }
    return i12.dirty = false, a9;
  }
  dispose() {
    this._binPack = null;
    for (const t15 of this._mosaicPages) {
      const e13 = t15.texture;
      e13 && e13.dispose();
      const i12 = t15.mosaicsData;
      if (!c7(i12)) {
        i12.data.destroy();
      }
    }
    this._mosaicPages = null, this._mosaicRects.clear();
  }
  static _copyBits(t15, e13, i12, s13, a9, r12, o13, h13, c12, n11, g3) {
    let p5 = s13 * e13 + i12, m7 = h13 * r12 + o13;
    if (g3) {
      m7 -= r12;
      for (let o14 = -1; o14 <= n11; o14++, p5 = ((o14 + n11) % n11 + s13) * e13 + i12, m7 += r12) for (let e14 = -1; e14 <= c12; e14++) a9[m7 + e14] = t15[p5 + (e14 + c12) % c12];
    } else for (let d4 = 0; d4 < n11; d4++) {
      for (let e14 = 0; e14 < c12; e14++) a9[m7 + e14] = t15[p5 + e14];
      p5 += e13, m7 += r12;
    }
  }
  _copy(i12) {
    if (i12.page >= this._mosaicPages.length) return;
    const s13 = this._mosaicPages[i12.page], a9 = s13.mosaicsData;
    if (!c7(s13.mosaicsData)) throw new s2("mapview-invalid-resource", "unsuitable data type!");
    const r12 = i12.spriteData, o13 = a9.data;
    _n._copyBits(r12, i12.spriteSize[0], 0, 0, o13, i12.pageSize[0], i12.rect.x + tt, i12.rect.y + tt, i12.spriteSize[0], i12.spriteSize[1], i12.repeat), s13.dirty = true;
  }
  _allocateImage(t15, r12) {
    t15 += 2 * tt, r12 += 2 * tt;
    const o13 = Math.max(t15, r12);
    if (this._maxItemSize && this._maxItemSize < o13) {
      const e13 = 2 ** Math.ceil(e8(t15)), a9 = 2 ** Math.ceil(e8(r12)), o14 = new t4(0, 0, t15, r12);
      return this._mosaicPages.push({
        mosaicsData: {
          type: "static",
          data: new Uint32Array(e13 * a9)
        },
        size: [e13, a9],
        dirty: true,
        texture: void 0
      }), [o14, this._mosaicPages.length - 1, [e13, a9]];
    }
    const h13 = this._binPack.allocate(t15, r12);
    if (h13.width <= 0) {
      const e13 = this._mosaicPages[this._currentPage];
      return !e13.dirty && c7(e13.mosaicsData) && (e13.mosaicsData.data = null), this._currentPage = this._mosaicPages.length, this._mosaicPages.push({
        mosaicsData: {
          type: "static",
          data: new Uint32Array(this._pageWidth * this._pageHeight)
        },
        size: [this._pageWidth, this._pageHeight],
        dirty: true,
        texture: void 0
      }), this._binPack = new t11(this._pageWidth, this._pageHeight), this._allocateImage(t15, r12);
    }
    return [h13, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _showDebugSprite([t15, e13], i12) {
    const s13 = document.createElement("canvas");
    s13.width = t15, s13.height = e13, s13.setAttribute("style", `position: absolute; top: ${4 + 204 * g2++}px; right: 208px; width: 200px; height: 200px; border: 1px solid black;`);
    const a9 = s13.getContext("2d"), r12 = new ImageData(t15, e13);
    r12.data.set(new Uint8Array(i12.buffer)), a9.putImageData(r12, 0, 0), document.body.appendChild(s13);
  }
  _showDebugPage(t15) {
    const e13 = this._mosaicPages[t15], {
      size: [i12, s13],
      mosaicsData: a9
    } = e13;
    if (!c7(a9)) return;
    const r12 = `mosaicDebugPage${t15}`, o13 = document.getElementById(r12) ?? document.createElement("canvas");
    o13.id = r12, o13.width = i12, o13.height = s13, o13.setAttribute("style", `position: absolute; top: ${4 + 204 * t15}px; right: 4px; width: 200px; height: 200px; border: 1px solid black;`);
    const h13 = o13.getContext("2d"), n11 = new ImageData(i12, s13);
    n11.data.set(new Uint8Array(a9.data.buffer)), h13.putImageData(n11, 0, 0), document.body.appendChild(o13);
  }
};
var g2 = 0;
function p4(t15, e13) {
  const i12 = new e4();
  return i12.width = e13[0], i12.height = e13[1], i12.wrapMode = D.CLAMP_TO_EDGE, new c2(t15, i12, null);
}

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/animatedFormats/AnimatableTextureResource.js
var a7 = class {
  constructor(t15, a9, h13, e13) {
    this._animation = t15, this._frameData = null;
    const n11 = (t16) => {
      this._frameData = t16, a9.requestRender();
    };
    this.frameCount = this._animation.frameDurations.length, this.width = this._animation.width, this.height = this._animation.height, this._playHandle = f5(this._animation, h13, e13, n11);
  }
  destroy() {
    this._playHandle.remove();
  }
  loadFrame(i12) {
    const a9 = this._frameData;
    if (null == a9) return;
    const h13 = "width" in a9 ? a9.width : a9.codedWidth, e13 = "height" in a9 ? a9.height : a9.codedHeight;
    i12.updateData(0, tt, tt, h13, e13, a9), this._frameData = null;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/TextureManager.js
var C2 = "arial-unicode-ms-regular";
var P4 = () => n.getLogger("esri.views.2d.engine.webgl.TextureManager");
var b4 = (e13, t15, i12) => P4().error(new s2(e13, t15, i12));
var v2 = class _v {
  static fromMosaic(e13, t15) {
    return new _v(e13, t15.page, t15.sdf);
  }
  constructor(e13, t15, i12) {
    this.mosaicType = e13, this.page = t15, this.sdf = i12;
  }
};
var j2 = class {
  constructor(i12) {
    this._requestRender = i12, this._resourceManager = new i5(), this._invalidFontsMap = /* @__PURE__ */ new Map(), this._sdfConverter = new r8(nt), this._bindingInfos = new Array(), this._hashToBindingIndex = /* @__PURE__ */ new Map(), this._ongoingRasterizations = /* @__PURE__ */ new Map(), this._imageRequestQueue = new _({
      concurrency: 10,
      process: (e13, i13) => __async(this, null, function* () {
        s3(i13);
        try {
          return yield U(e13, {
            responseType: "image",
            signal: i13
          });
        } catch (r12) {
          if (!b(r12)) throw new s2("mapview-invalid-resource", `Could not fetch requested resource at ${e13}`, r12);
          throw r12;
        }
      })
    }), this._spriteMosaic = new n7(2048, 2048, 500), this._glyphSource = new r7(`${s.fontsUrl}/{fontstack}/{range}.pbf`), this._glyphMosaic = new p3(1024, 1024, this._glyphSource), this._rasterizer = new l7(this.resourceManager);
  }
  dispose() {
    this._spriteMosaic.dispose(), this._glyphMosaic.dispose(), this._rasterizer.dispose(), this._sdfConverter.dispose(), this._spriteMosaic = null, this._glyphMosaic = null, this._sdfConverter = null, this._hashToBindingIndex.clear(), this._hashToBindingIndex = null, this._bindingInfos = null, this._ongoingRasterizations.clear(), this._ongoingRasterizations = null, this._imageRequestQueue.clear(), this._imageRequestQueue = null, this._resourceManager.destroy();
  }
  get sprites() {
    return this._spriteMosaic;
  }
  get glyphs() {
    return this._glyphMosaic;
  }
  get resourceManager() {
    return this._resourceManager;
  }
  rasterizeItem(e13, t15) {
    return __async(this, null, function* () {
      if (null == e13) return b4("mapview-null-resource", "Unable to rasterize null resource"), null;
      if ("cim-rasterization-info" !== e13.type) return b4("mapview-unexpected-resource", "Unable to rasterize resource"), null;
      const {
        resource: i12
      } = e13;
      if ("text" === i12.type) {
        const e14 = yield this._rasterizeText(i12, t15);
        for (const t16 of e14.glyphs) this._setTextureBinding(A3.GLYPH, t16);
        return e14;
      }
      const s13 = yield this._rasterizeSprite(i12, t15);
      return s13 && this._setTextureBinding(A3.SPRITE, s13), s13;
    });
  }
  getMosaicInfo(e13, t15, i12 = false) {
    const s13 = this._getTextureBindingInfo(e13, t15, i12);
    return s13 ? {
      size: s13.size,
      texture: {
        texture: s13.texture,
        unit: "sprite" === s13.type ? x2 : b3
      }
    } : (b4("mapview-invalid-resource", `Unable to find resource for ${t15}`), {
      size: [0, 0],
      texture: {
        texture: null,
        unit: 0
      }
    });
  }
  _getTextureBindingInfo(e13, t15, i12) {
    const s13 = this._bindingInfos[t15 - 1], r12 = s13.page, a9 = i12 ? L3.LINEAR_MIPMAP_LINEAR : L3.LINEAR;
    switch (s13.mosaicType) {
      case A3.SPRITE: {
        const t16 = [this.sprites.getWidth(r12), this.sprites.getHeight(r12)], i13 = this._spriteMosaic.getTexture(e13, r12);
        return i13.setSamplingMode(a9), {
          type: "sprite",
          texture: i13,
          size: t16
        };
      }
      case A3.GLYPH: {
        const t16 = [this.glyphs.width, this.glyphs.height], i13 = this._glyphMosaic.getTexture(e13, r12);
        return this._glyphMosaic.bind(e13, a9, r12, b3), i13.setSamplingMode(a9), {
          type: "glyph",
          texture: i13,
          size: t16
        };
      }
      default:
        return b4("mapview-texture-manager", `Cannot handle unknown type ${s13.mosaicType}`), null;
    }
  }
  _hashMosaic(e13, t15) {
    return 1 | e13 << 1 | (t15.sdf ? 1 : 0) << 2 | t15.page << 3;
  }
  _setTextureBinding(e13, t15) {
    const i12 = this._hashMosaic(e13, t15);
    if (!this._hashToBindingIndex.has(i12)) {
      const s13 = v2.fromMosaic(e13, t15), r12 = this._bindingInfos.length + 1;
      this._hashToBindingIndex.set(i12, r12), this._bindingInfos.push(s13);
    }
    t15.textureBinding = this._hashToBindingIndex.get(i12);
  }
  _rasterizeText(e13, t15) {
    return __async(this, null, function* () {
      const {
        font: s13,
        textString: a9
      } = e13, n11 = f4(s13), o13 = this._invalidFontsMap.has(n11), [c12, h13] = i3(a9), u11 = j(c12);
      try {
        const e14 = o13 ? C2 : n11;
        has("esri-2d-stabilize-glyphs") && (yield this._glyphMosaic.preloadASCIIGlyphCache(e14));
        return {
          type: "glyphs",
          glyphs: yield this._glyphMosaic.getGlyphItems(e14, u11, t15),
          isRightToLeft: h13
        };
      } catch (l12) {
        b4("mapview-invalid-resource", `Couldn't find font ${n11}. Falling back to Arial Unicode MS Regular`), this._invalidFontsMap.set(n11, true);
        return {
          type: "glyphs",
          glyphs: yield this._glyphMosaic.getGlyphItems(C2, u11, t15),
          isRightToLeft: h13
        };
      }
    });
  }
  _hashSpriteResource(e13) {
    switch (e13.type) {
      case "path":
        return `path:${e13.path}.${e13.asFill ? 1 : 0}`;
      case "CIMPictureMarker":
        return `${e13.type}:${e13.url}:${e13.size}`;
      case "CIMPictureFill":
        return `${e13.type}:${e13.url}:${e13.height}`;
      case "CIMPictureStroke":
        return `${e13.type}:${e13.url}:${e13.width}`;
      case "dash":
        return `dash:${e13.capStyle}.${e13.dashTemplate.join("")}`;
      case "sdf":
        return `sdf:${JSON.stringify(e13.geom)}.${e13.asFill ? 1 : 0}`;
      case "fill-style":
        return `fill_style:${e13.style}`;
      case "animated":
        return JSON.stringify(M2(e13));
      case "CIMHatchFill":
      case "CIMVectorMarker":
        return JSON.stringify(e13);
    }
  }
  _rasterizeSprite(e13, t15) {
    return __async(this, null, function* () {
      if (!e13) return null;
      const i12 = l(this._hashSpriteResource(e13));
      if (this._spriteMosaic.has(i12)) return this._spriteMosaic.getSpriteItem(i12);
      if ("url" in e13 && e13.url || "CIMPictureFill" === e13.type || "CIMPictureStroke" === e13.type || "CIMPictureMarker" === e13.type || "CIMVectorMarker" === e13.type) {
        const t16 = [];
        ee.fetchResources({
          type: "CIMPointSymbol",
          symbolLayers: [e13]
        }, this._resourceManager, t16), t16.length > 0 && (yield Promise.all(t16));
      }
      switch (e13.type) {
        case "CIMPictureMarker":
          return "CIMMarkerPlacementInsidePolygon" === e13.markerPlacement?.type ? this._rasterizeJSONResource(i12, e13) : this._handleAsyncResource(i12, e13, t15);
        case "animated":
        case "CIMPictureFill":
        case "CIMPictureStroke":
        case "path":
          return this._handleAsyncResource(i12, e13, t15);
        case "sdf":
        case "dash":
        case "fill-style":
        case "CIMVectorMarker":
        case "CIMHatchFill":
          return this._rasterizeJSONResource(i12, e13);
      }
    });
  }
  _rasterizeJSONResource(e13, t15) {
    const i12 = this._rasterizer.rasterizeJSONResource(t15);
    if (i12) {
      const {
        size: s13,
        image: r12,
        sdf: a9,
        simplePattern: n11,
        rasterizationScale: o13
      } = i12;
      return this._addItemToMosaic(e13, s13, {
        type: "static",
        data: r12
      }, $(t15), a9, n11, o13);
    }
    return null;
  }
  _handleAsyncResource(e13, t15, i12) {
    return __async(this, null, function* () {
      if (this._ongoingRasterizations.has(e13)) return this._ongoingRasterizations.get(e13);
      let s13;
      return s13 = "path" === t15.type ? this._handleSVG(t15, e13, i12) : this._handleImage(t15, e13, i12), this._ongoingRasterizations.set(e13, s13), s13.finally(() => this._ongoingRasterizations.delete(e13)), s13;
    });
  }
  _handleSVG(e13, t15, i12) {
    return __async(this, null, function* () {
      const s13 = [nt, nt], {
        asFill: r12
      } = e13, a9 = yield this._sdfConverter.draw(e13.path, r12, i12);
      return this._addItemToMosaic(t15, s13, {
        type: "static",
        data: new Uint32Array(a9.buffer)
      }, false, true, true);
    });
  }
  _handleGIFOrPNG(e13, t15, i12) {
    return __async(this, null, function* () {
      const s13 = e13.url, r12 = this.resourceManager.getResource(s13);
      if (null == r12) return null;
      const {
        width: a9,
        height: n11
      } = r12;
      if (r12 instanceof HTMLImageElement) {
        if ("animated" === e13.type) return b4("mapview-unexpected-resource", "Attempt to configure animations for a non-animated image."), null;
        const i13 = "colorSubstitutions" in e13 ? e13.colorSubstitutions : void 0, {
          size: s14,
          sdf: o14,
          image: c13
        } = this._rasterizer.rasterizeImageResource(a9, n11, r12, i13);
        return this._addItemToMosaic(t15, s14, {
          type: "static",
          data: c13
        }, $(e13), o14, false);
      }
      let o13, c12, h13;
      "animated" === e13.type ? (o13 = false, c12 = {
        playAnimation: e13.playAnimation,
        reverseAnimation: e13.reverseAnimation,
        randomizeStartTime: e13.randomizeStartTime,
        randomizeStartSeed: e13.randomizeStartSeed,
        startTimeOffset: e13.startTimeOffset,
        duration: e13.duration,
        repeatType: e13.repeatType,
        repeatDelay: e13.repeatDelay
      }, h13 = e13.startGroup || 0) : (o13 = $(e13), c12 = {}, h13 = 0);
      const u11 = new a7(r12, this._requestRender, c12, h13);
      return this._addItemToMosaic(t15, [u11.width, u11.height], {
        type: "animated",
        data: u11
      }, o13, false, false);
    });
  }
  _handleImage(e13, t15, i12) {
    return __async(this, null, function* () {
      const r12 = e13.url;
      if (A5(r12) || G3(r12)) return this._handleGIFOrPNG(e13, t15, i12);
      if ("animated" === e13.type) return b4("mapview-unexpected-resource", "Attempt to configure animations for a non-animated image."), null;
      try {
        let s13;
        const a9 = this.resourceManager.getResource(r12);
        if (null != a9 && a9 instanceof HTMLImageElement) s13 = a9;
        else {
          const {
            data: e14
          } = yield this._imageRequestQueue.push(r12, __spreadValues({}, i12));
          s13 = e14;
        }
        if (y2(r12)) {
          if ("width" in e13 && "height" in e13) s13.width = u4(e13.width), s13.height = u4(e13.height);
          else if ("cim" in e13) {
            const t16 = e13;
            s13.width = u4(t16.width ?? t16.scaleX * t16.size), s13.height = u4(t16.size);
          }
        }
        if (!s13.width || !s13.height) return null;
        const n11 = s13.width, o13 = s13.height, h13 = "colorSubstitutions" in e13 ? e13.colorSubstitutions : void 0, {
          size: u11,
          sdf: l12,
          image: p5
        } = this._rasterizer.rasterizeImageResource(n11, o13, s13, h13);
        return this._addItemToMosaic(t15, u11, {
          type: "static",
          data: p5
        }, $(e13), l12, false);
      } catch (b5) {
        if (!b(b5)) throw new s2("mapview-invalid-resource", `Could not fetch requested resource at ${r12}. ${b5.message}`);
        throw b5;
      }
    });
  }
  _addItemToMosaic(e13, t15, i12, s13, r12, a9, n11) {
    return this._spriteMosaic.addSpriteItem(e13, t15, i12, s13, r12, a9, n11);
  }
};
function $(e13) {
  switch (e13.type) {
    case "CIMVectorMarker":
    case "CIMPictureMarker":
      return B2(e13);
    default:
      return true;
  }
}
var k = (e13) => null != e13 && e13.startsWith("data:image/gif");
var A5 = (e13) => e13 && (e13.includes(".gif") || k(e13));
var F3 = (e13) => null != e13 && e13.startsWith("data:image/png");
var G3 = (e13) => e13 && (e13.includes(".png") || F3(e13));
var B2 = (e13) => e13 && "markerPlacement" in e13 && e13.markerPlacement && "CIMMarkerPlacementInsidePolygon" === e13.markerPlacement.type;

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/TextureUploadManager.js
var r9 = class {
  constructor(e13) {
    this._queue = [], this._refreshable = e13;
  }
  destroy() {
    this._queue = [];
  }
  enqueueTextureUpdate(o13, r12) {
    const n11 = L(), h13 = o13, i12 = Ut, a9 = Math.ceil(h13.height / i12);
    s3(r12);
    for (let e13 = 0; e13 < a9; e13++) {
      const t15 = e13 * i12, s13 = e13 === a9 - 1, u11 = s13 ? h13.height - i12 * e13 : i12;
      this._queue.push({
        type: "chunk",
        request: o13,
        resolver: n11,
        chunk: e13,
        chunkOffset: t15,
        destHeight: u11,
        chunkIsLast: s13,
        options: r12
      });
    }
    return w(r12, (e13) => n11.reject(e13)), n11.promise;
  }
  upload() {
    let e13 = 0;
    for (; this._queue.length; ) {
      const t15 = performance.now(), s13 = this._queue.shift();
      if (s13) {
        if (null != s13.options.signal && s13.options.signal.aborted) continue;
        switch (s13.type) {
          case "chunk":
            this._uploadChunk(s13);
            break;
          case "no-chunk":
            this._uploadNoChunk(s13);
        }
        const u11 = performance.now() - t15;
        if (e13 += u11, e13 + u11 >= ut) break;
      }
    }
    this._queue.length && this._refreshable.requestRender();
  }
  _uploadChunk(e13) {
    const {
      request: t15,
      resolver: s13,
      chunkOffset: o13,
      chunkIsLast: u11,
      destHeight: r12
    } = e13, {
      data: n11,
      texture: h13,
      width: i12
    } = t15;
    null != n11 && (h13.updateData(0, 0, o13, i12, r12, n11, o13), u11 && s13.resolve());
  }
  _uploadNoChunk(e13) {
    const {
      request: t15,
      resolver: s13
    } = e13, {
      data: o13,
      texture: u11
    } = t15;
    u11.setData(o13), s13.resolve();
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/WorldExtentClipRenderer.js
var f6 = r3(-0.5, -0.5);
var u7 = class {
  constructor() {
    this._centerNdc = n2(), this._pxToNdc = n2(), this._worldDimensionsPx = n2(), this._mat3 = e6(), this._initialized = false;
  }
  dispose() {
    this._program = r2(this._program), this._quad = r2(this._quad);
  }
  render(t15, i12, e13) {
    const {
      context: r12
    } = t15, s13 = this._updateGeometry(t15, e13);
    if (null != i12) {
      const {
        r: t16,
        g: e14,
        b: s14,
        a: o13
      } = i12;
      r12.setClearColor(o13 * t16 / 255, o13 * e14 / 255, o13 * s14 / 255, o13);
    } else r12.setClearColor(0, 0, 0, 0);
    if (r12.setStencilFunction(O2.ALWAYS, 0, 255), r12.setStencilWriteMask(255), !s13) return r12.setClearStencil(1), void r12.clear(r12.gl.STENCIL_BUFFER_BIT | r12.gl.COLOR_BUFFER_BIT);
    r12.setClearStencil(0), r12.clear(r12.gl.STENCIL_BUFFER_BIT | r12.gl.COLOR_BUFFER_BIT), this._initialized || this._initialize(r12), r12.setDepthWriteEnabled(false), r12.setDepthTestEnabled(false), r12.setColorMask(false, false, false, false), r12.setBlendingEnabled(false), r12.setStencilOp(I2.KEEP, I2.KEEP, I2.REPLACE), r12.setStencilFunction(O2.ALWAYS, 1, 255), r12.setStencilTestEnabled(true), r12.useProgram(this._program), this._program.setUniformMatrix3fv("u_worldExtent", this._mat3), this._quad.draw(), this._quad.unbind();
  }
  _initialize(t15) {
    if (this._initialized) return;
    const i12 = e7(t15, r5);
    i12 && (this._program = i12, this._quad = new h6(t15, [0, 0, 1, 0, 0, 1, 1, 1]), this._initialized = true);
  }
  _updateGeometry(t15, a9) {
    const {
      state: n11,
      pixelRatio: m7
    } = t15, {
      size: c12,
      rotation: h13
    } = n11, _5 = Math.round(c12[0] * m7), d4 = Math.round(c12[1] * m7);
    if (!n11.spatialReference.isWrappable) return false;
    const p5 = u3(h13), u11 = Math.abs(Math.cos(p5)), g3 = Math.abs(Math.sin(p5)), b5 = Math.round(_5 * u11 + d4 * g3), x3 = Math.round(m7 * n11.worldScreenWidth);
    if (b5 <= x3) return false;
    const E5 = _5 * g3 + d4 * u11, S2 = (a9.left - a9.right) * m7 / _5, C3 = (a9.bottom - a9.top) * m7 / d4;
    o4(this._worldDimensionsPx, x3, E5, 1), o4(this._pxToNdc, 2 / _5, -2 / d4, 1), o4(this._centerNdc, S2, C3, 1);
    const T6 = this._mat3;
    return l3(T6, this._centerNdc), f3(T6, T6, this._pxToNdc), 0 !== h13 && h3(T6, T6, p5), f3(T6, T6, this._worldDimensionsPx), M(T6, T6, f6), true;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/effects/Effect.js
var t12 = class {
  constructor() {
    this.name = this.constructor.name;
  }
  createOptions(t15, r12) {
    return null;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/effects/AnimationEffect.js
var i9 = class extends t12 {
  constructor() {
    super(...arguments), this.defines = [], this._desc = {
      vsPath: "fx/integrate",
      fsPath: "fx/integrate",
      attributes: /* @__PURE__ */ new Map([["a_position", 0]])
    };
  }
  dispose() {
    this._quad && this._quad.dispose();
  }
  bind() {
  }
  unbind() {
  }
  draw(r12, i12) {
    if (!i12?.size) return;
    const {
      context: n11,
      renderingOptions: o13
    } = r12;
    this._quad || (this._quad = new h6(n11, [0, 0, 1, 0, 0, 1, 1, 1]));
    const a9 = n11.getBoundFramebufferObject(), {
      x: s13,
      y: u11,
      width: m7,
      height: d4
    } = n11.getViewport(), f8 = i12.getBlock(L4.Animation);
    if (null == f8) return;
    const l12 = i12.getUniforms(n11);
    n11.setViewport(0, 0, i12.size, i12.size);
    const c12 = l12.filterFlags, x3 = l12.animation, p5 = has("featurelayer-animation-enabled") ? o13.labelsAnimationTime : 1, _5 = f8.getFBO(n11, 1);
    n11.unbindTexture(_5.colorTexture), this._computeDelta(r12, _5, x3, c12, p5);
    const g3 = f8.getFBO(n11);
    n11.unbindTexture(g3.colorTexture), this._updateAnimationState(r12, _5, g3), n11.bindFramebuffer(a9), n11.setViewport(s13, u11, m7, d4);
  }
  _computeDelta(e13, t15, r12, i12, n11) {
    const {
      context: o13,
      painter: a9,
      displayLevel: s13
    } = e13, u11 = a9.materialManager.getProgram(this._desc, ["delta"]);
    if (o13.bindFramebuffer(t15), o13.setColorMask(true, true, true, true), o13.setClearColor(0, 0, 0, 0), o13.clear(o13.gl.COLOR_BUFFER_BIT), o13.useProgram(u11), !("type" in i12.texture) || !("type" in r12.texture)) throw new Error("InternalError: Expected to find texture");
    o13.bindTexture(i12.texture, i12.unit), o13.bindTexture(r12.texture, r12.unit), u11.setUniform1i("u_maskTexture", i12.unit), u11.setUniform1i("u_sourceTexture", r12.unit), u11.setUniform1f("u_timeDelta", e13.deltaTime), u11.setUniform1f("u_animationTime", n11), u11.setUniform1f("u_zoomLevel", Math.round(10 * s13)), this._quad.draw();
  }
  _updateAnimationState(e13, t15, r12) {
    const {
      context: i12,
      painter: n11
    } = e13, o13 = n11.materialManager.getProgram(this._desc, ["update"]);
    i12.bindTexture(t15.colorTexture, 1), i12.useProgram(o13), o13.setUniform1i("u_sourceTexture", 1), i12.bindFramebuffer(r12), i12.setColorMask(true, true, true, true), i12.setClearColor(0, 0, 0, 0), i12.clear(i12.gl.COLOR_BUFFER_BIT), this._quad.draw();
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BlendPrograms.js
var r10 = (e13) => e13.replace("-", "_").toUpperCase();
var t13 = (e13) => `#define ${r10(e13)}
`;
function n8(r12) {
  return {
    attributes: /* @__PURE__ */ new Map([["a_pos", 0], ["a_tex", 1]]),
    shaders: {
      vertexShader: t13(r12) + n4("blend/blend.vert"),
      fragmentShader: t13(r12) + n4("blend/blend.frag")
    }
  };
}

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/effects/BlendEffect.js
var c8 = () => n.getLogger("esri.views.2d.engine.webgl.effects.blendEffects.BlendEffect");
var m5 = class {
  constructor() {
    this._size = [0, 0];
  }
  dispose(e13) {
    this._backBufferTexture = r2(this._backBufferTexture), this._quad = r2(this._quad);
  }
  draw(r12, t15, i12, a9, d4) {
    const {
      context: u11,
      drawPhase: f8
    } = r12;
    if (this._setupShader(u11), a9 && "normal" !== a9 && f8 !== E4.LABEL) return void this._drawBlended(r12, t15, i12, a9, d4);
    const m7 = n8("normal"), h13 = u11.programCache.acquire(m7.shaders.vertexShader, m7.shaders.fragmentShader, m7.attributes);
    if (!h13) return void c8().error(new s2("mapview-BlendEffect", 'Error creating shader program for blend mode "normal"'));
    u11.useProgram(h13), t15.setSamplingMode(i12), u11.bindTexture(t15, 0), h13.setUniform1i("u_layerTexture", 0), h13.setUniform1f("u_opacity", d4), u11.setBlendingEnabled(true), u11.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA);
    const l12 = this._quad;
    l12.draw(), l12.unbind(), h13.dispose();
  }
  _drawBlended(r12, t15, s13, i12, a9) {
    const {
      context: d4,
      state: u11,
      pixelRatio: f8,
      inFadeTransition: m7
    } = r12, {
      size: h13
    } = u11, l12 = d4.getBoundFramebufferObject();
    let _5, p5;
    null != l12 ? (_5 = l12.width, p5 = l12.height) : (_5 = Math.round(f8 * h13[0]), p5 = Math.round(f8 * h13[1])), this._createOrResizeTexture(r12, _5, p5);
    const b5 = this._backBufferTexture;
    l12.copyToTexture(0, 0, _5, p5, 0, 0, b5), d4.setStencilTestEnabled(false), d4.setStencilWriteMask(0), d4.setBlendingEnabled(true), d4.setDepthTestEnabled(false), d4.setDepthWriteEnabled(false);
    const g3 = n8(i12), x3 = d4.programCache.acquire(g3.shaders.vertexShader, g3.shaders.fragmentShader, g3.attributes);
    if (!x3) return void c8().error(new s2("mapview-BlendEffect", `Error creating shader program for blend mode ${i12}`));
    d4.useProgram(x3), b5.setSamplingMode(s13), d4.bindTexture(b5, 0), x3.setUniform1i("u_backbufferTexture", 0), t15.setSamplingMode(s13), d4.bindTexture(t15, 1), x3.setUniform1i("u_layerTexture", 1), x3.setUniform1f("u_opacity", a9), x3.setUniform1f("u_inFadeOpacity", m7 ? 1 : 0), d4.setBlendFunction(R2.ONE, R2.ZERO);
    const T6 = this._quad;
    T6.draw(), T6.unbind(), x3.dispose(), d4.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA);
  }
  _setupShader(e13) {
    this._quad || (this._quad = new h6(e13, [-1, -1, 1, -1, -1, 1, 1, 1]));
  }
  _createOrResizeTexture(e13, r12, t15) {
    const {
      context: s13
    } = e13;
    if (null === this._backBufferTexture || r12 !== this._size[0] || t15 !== this._size[1]) {
      if (this._backBufferTexture) this._backBufferTexture.resize(r12, t15);
      else {
        const e14 = new e4();
        e14.internalFormat = G.RGBA, e14.wrapMode = D.CLAMP_TO_EDGE, e14.width = r12, e14.height = t15, this._backBufferTexture = new c2(s13, e14);
      }
      this._size[0] = r12, this._size[1] = t15;
    }
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/effects/FeatureEffect.js
var s12 = class extends t12 {
  constructor(e13) {
    super(), this.name = this.constructor.name, this.defines = [e13];
  }
  dispose() {
  }
  bind({
    context: e13,
    painter: t15
  }) {
    this._prev = e13.getBoundFramebufferObject();
    const s13 = t15.getFbos().effect0;
    e13.bindFramebuffer(s13), e13.setColorMask(true, true, true, true), e13.setClearColor(0, 0, 0, 0), e13.clear(e13.gl.COLOR_BUFFER_BIT);
  }
  unbind() {
  }
  draw(e13, s13) {
    const {
      context: r12,
      painter: o13
    } = e13, n11 = o13.getPostProcessingEffects(s13), c12 = r12.getBoundFramebufferObject();
    for (const {
      postProcessingEffect: t15,
      effect: f8
    } of n11) t15.draw(e13, c12, f8);
    r12.bindFramebuffer(this._prev), r12.setStencilTestEnabled(false), o13.blitTexture(r12, c12.colorTexture, L3.NEAREST), r12.setStencilTestEnabled(true);
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightRenderer.js
var c9 = class {
  constructor() {
    this._width = void 0, this._height = void 0, this._resources = null;
  }
  dispose() {
    this._resources && (this._resources.quadGeometry.dispose(), this._resources.quadVAO.dispose(), this._resources.highlightProgram.dispose(), this._resources.blurProgram.dispose(), this._resources = null);
  }
  preBlur(e13, i12) {
    e13.bindTexture(i12, H), e13.useProgram(this._resources.blurProgram), this._resources.blurProgram.setUniform4fv("u_direction", [1, 0, 1 / this._width, 0]), this._resources.blurProgram.setUniformMatrix4fv("u_channelSelector", t6), e13.bindVAO(this._resources.quadVAO), e13.drawArrays(E2.TRIANGLE_STRIP, 0, 4), e13.bindVAO();
  }
  finalBlur(e13, s13) {
    e13.bindTexture(s13, H), e13.useProgram(this._resources.blurProgram), this._resources.blurProgram.setUniform4fv("u_direction", [0, 1, 0, 1 / this._height]), this._resources.blurProgram.setUniformMatrix4fv("u_channelSelector", i6), e13.bindVAO(this._resources.quadVAO), e13.drawArrays(E2.TRIANGLE_STRIP, 0, 4), e13.bindVAO();
  }
  renderHighlight(e13, s13, i12) {
    e13.bindTexture(s13, H), e13.useProgram(this._resources.highlightProgram), i12.applyHighlightOptions(e13, this._resources.highlightProgram), e13.bindVAO(this._resources.quadVAO), e13.setBlendingEnabled(true), e13.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA), e13.drawArrays(E2.TRIANGLE_STRIP, 0, 4), e13.bindVAO();
  }
  _initialize(s13, i12, a9) {
    this._width = i12, this._height = a9;
    const m7 = c.createVertex(s13, F.STATIC_DRAW, new Int8Array([-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]).buffer), c12 = new o8(s13, /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]), {
      geometry: [new t2("a_position", 2, C.BYTE, 0, 4), new t2("a_texcoord", 2, C.UNSIGNED_BYTE, 2, 4)]
    }, {
      geometry: m7
    }), f8 = e7(s13, t8), b5 = e7(s13, r6);
    s13.useProgram(f8), f8.setUniform1i("u_texture", H), f8.setUniform1i("u_shade", I3), f8.setUniform1f("u_sigma", o9), s13.useProgram(b5), b5.setUniform1i("u_texture", H), b5.setUniform1f("u_sigma", o9), this._resources = {
      quadGeometry: m7,
      quadVAO: c12,
      highlightProgram: f8,
      blurProgram: b5
    };
  }
  setup(r12, e13, s13) {
    this._resources ? (this._width = e13, this._height = s13) : this._initialize(r12, e13, s13);
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightSurfaces.js
function i10(i12, h13, u11) {
  const l12 = new e4(h13, u11);
  return l12.wrapMode = D.CLAMP_TO_EDGE, new E3(i12, l12, new i2(B.STENCIL_INDEX8, h13, u11));
}
var h9 = class {
  constructor() {
    this._width = void 0, this._height = void 0, this._resources = null;
  }
  dispose() {
    this._resources && (this._resources.sharedBlur1Fbo.dispose(), this._resources.sharedBlur2Fbo.dispose(), this._resources = null);
  }
  _initialize(r12, e13, s13) {
    this._width = e13, this._height = s13;
    const t15 = i10(r12, e13, s13), o13 = i10(r12, e13, s13);
    this._resources = {
      sharedBlur1Fbo: t15,
      sharedBlur2Fbo: o13
    };
  }
  setup(r12, e13, s13) {
    !this._resources || this._width === e13 && this._height === s13 || this.dispose(), this._resources || this._initialize(r12, e13, s13);
  }
  get sharedBlur1Tex() {
    return this._resources.sharedBlur1Fbo.colorTexture;
  }
  get sharedBlur1Fbo() {
    return this._resources.sharedBlur1Fbo;
  }
  get sharedBlur2Tex() {
    return this._resources.sharedBlur2Fbo.colorTexture;
  }
  get sharedBlur2Fbo() {
    return this._resources.sharedBlur2Fbo;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/effects/HighlightEffect.js
var h10 = 4;
var d3 = 4 / h10;
var l9 = class extends t12 {
  constructor() {
    super(...arguments), this.defines = ["highlight"], this._hlRenderer = new c9(), this._width = void 0, this._height = void 0, this._boundFBO = null, this._hlSurfaces = new h9(), this._adjustedWidth = void 0, this._adjustedHeight = void 0, this._blitRenderer = new _2();
  }
  dispose() {
    this._hlSurfaces?.dispose(), this._hlRenderer?.dispose(), this._boundFBO = null;
  }
  bind(e13) {
    const {
      context: t15,
      painter: s13
    } = e13, {
      width: r12,
      height: i12
    } = t15.getViewport(), h13 = s13.getFbos().effect0;
    this.setup(e13, r12, i12), t15.bindFramebuffer(h13), t15.setColorMask(true, true, true, true), t15.setClearColor(0, 0, 0, 0), t15.clear(t15.gl.COLOR_BUFFER_BIT);
  }
  unbind() {
  }
  setup({
    context: e13
  }, t15, s13) {
    this._width = t15, this._height = s13;
    const r12 = t15 % h10, i12 = s13 % h10;
    t15 += r12 < h10 / 2 ? -r12 : h10 - r12, s13 += i12 < h10 / 2 ? -i12 : h10 - i12, this._adjustedWidth = t15, this._adjustedHeight = s13, this._boundFBO = e13.getBoundFramebufferObject();
    const l12 = Math.round(t15 * d3), o13 = Math.round(s13 * d3);
    this._hlRenderer.setup(e13, l12, o13), this._hlSurfaces.setup(e13, l12, o13);
  }
  draw(e13) {
    const {
      context: t15,
      passOptions: s13
    } = e13, r12 = s13.activeGradient, h13 = t15.getBoundFramebufferObject();
    t15.setViewport(0, 0, this._adjustedWidth * d3, this._adjustedHeight * d3), t15.bindFramebuffer(this._hlSurfaces.sharedBlur1Fbo), t15.setStencilTestEnabled(false), t15.setClearColor(0, 0, 0, 0), t15.clear(t15.gl.COLOR_BUFFER_BIT), this._blitRenderer.render(t15, h13.colorTexture, L3.NEAREST, 1), t15.setStencilTestEnabled(false), t15.setBlendingEnabled(false), t15.setColorMask(false, false, false, true), t15.bindFramebuffer(this._hlSurfaces.sharedBlur2Fbo), t15.setClearColor(0, 0, 0, 0), t15.clear(t15.gl.COLOR_BUFFER_BIT), this._hlRenderer.preBlur(t15, this._hlSurfaces.sharedBlur1Tex), t15.bindFramebuffer(this._hlSurfaces.sharedBlur1Fbo), t15.setClearColor(0, 0, 0, 0), t15.clear(t15.gl.COLOR_BUFFER_BIT), this._hlRenderer.finalBlur(t15, this._hlSurfaces.sharedBlur2Tex), t15.bindFramebuffer(this._boundFBO), t15.setBlendingEnabled(true), t15.setColorMask(true, true, true, true), t15.setViewport(0, 0, this._width, this._height), this._hlRenderer.renderHighlight(t15, this._hlSurfaces.sharedBlur1Tex, r12), this._boundFBO = null;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/effects/HittestEffect.js
var c10 = class extends t12 {
  constructor() {
    super(...arguments), this.name = this.constructor.name, this.defines = ["hittest"];
  }
  dispose() {
    null != this._fbo && this._fbo.dispose();
  }
  createOptions({
    pixelRatio: t15
  }, r12) {
    if (!r12.length) return null;
    const n11 = r12.shift(), l12 = n11.x, c12 = n11.y;
    this._outstanding = n11;
    const a9 = has("esri-mobile");
    return {
      type: "hittest",
      distance: (a9 ? S : T3) * t15,
      smallSymbolDistance: (a9 ? S : W) * t15,
      smallSymbolSizeThreshold: X,
      position: [l12, c12]
    };
  }
  bind(e13) {
    const {
      context: s13,
      attributeView: i12
    } = e13;
    if (!i12.size) return;
    const o13 = i12.getBlock(L4.GPGPU);
    if (null == o13) return;
    const r12 = o13.getFBO(s13);
    s13.setViewport(0, 0, i12.size, i12.size), s13.bindFramebuffer(r12), s13.setColorMask(true, true, true, true), s13.setClearColor(0, 0, 0, 0), s13.clear(s13.gl.COLOR_BUFFER_BIT | s13.gl.DEPTH_BUFFER_BIT);
  }
  unbind() {
  }
  draw(t15) {
    if (null == this._outstanding) return;
    const e13 = this._outstanding;
    this._outstanding = null, this._resolve(t15, e13.resolvers);
  }
  _resolve(e13, s13) {
    return __async(this, null, function* () {
      const {
        context: i12,
        attributeView: o13
      } = e13, r12 = o13.getBlock(L4.GPGPU);
      if (null == r12) return void s13.forEach((t15) => t15.resolve([]));
      const c12 = r12.getFBO(i12), a9 = new Uint8Array(c12.width * c12.height * 4);
      try {
        yield c12.readPixelsAsync(0, 0, c12.width, c12.height, G.RGBA, U2.UNSIGNED_BYTE, a9);
      } catch (u11) {
        return void s13.forEach((t15) => t15.resolve([]));
      }
      const h13 = [];
      for (let t15 = 0; t15 < a9.length; t15 += 4) {
        const e14 = t15 / 4;
        a9[t15] && h13.push(e14);
      }
      s13.forEach((t15) => t15.resolve(h13));
    });
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Bloom.js
var a8 = 5;
var u8 = [1, 0];
var l10 = [0, 1];
var m6 = [1, 0.8, 0.6, 0.4, 0.2];
var _3 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var h11 = class {
  constructor() {
    this._intensityFBO = null, this._compositeFBO = null, this._mipsFBOs = new Array(a8), this._nMips = a8, this._kernelSizeArray = [3, 5, 7, 9, 11], this._size = [0, 0], this._programDesc = {
      luminosityHighPass: {
        vsPath: "post-processing/pp",
        fsPath: "post-processing/bloom/luminosityHighPass",
        attributes: /* @__PURE__ */ new Map([["a_position", 0]])
      },
      gaussianBlur: {
        vsPath: "post-processing/pp",
        fsPath: "post-processing/bloom/gaussianBlur",
        attributes: /* @__PURE__ */ new Map([["a_position", 0]])
      },
      composite: {
        vsPath: "post-processing/pp",
        fsPath: "post-processing/bloom/composite",
        attributes: /* @__PURE__ */ new Map([["a_position", 0]])
      },
      blit: {
        vsPath: "post-processing/pp",
        fsPath: "post-processing/blit",
        attributes: /* @__PURE__ */ new Map([["a_position", 0]])
      }
    };
  }
  dispose() {
    if (this._quad = r2(this._quad), this._intensityFBO = r2(this._intensityFBO), this._compositeFBO = r2(this._compositeFBO), this._mipsFBOs) {
      for (let t15 = 0; t15 < this._nMips; t15++) this._mipsFBOs[t15] && (this._mipsFBOs[t15].horizontal.dispose(), this._mipsFBOs[t15].vertical.dispose());
      this._mipsFBOs = null;
    }
  }
  draw(t15, i12, r12) {
    const {
      width: o13,
      height: n11
    } = i12, {
      context: h13,
      painter: p5
    } = t15, {
      materialManager: c12
    } = p5, d4 = h13.gl, f8 = this._programDesc, {
      strength: b5,
      radius: F4,
      threshold: O3
    } = r12;
    this._quad || (this._quad = new h6(h13, [-1, -1, 1, -1, -1, 1, 1, 1])), this._createOrResizeResources(t15, o13, n11), h13.setStencilTestEnabled(false), h13.setBlendingEnabled(true), h13.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA), h13.setStencilWriteMask(0);
    const B3 = this._quad;
    B3.bind(), h13.bindFramebuffer(this._intensityFBO);
    const g3 = c12.getProgram(f8.luminosityHighPass);
    h13.useProgram(g3), h13.bindTexture(i12.colorTexture, 0), g3.setUniform1i("u_texture", 0), g3.setUniform3fv("u_defaultColor", [0, 0, 0]), g3.setUniform1f("u_defaultOpacity", 0), g3.setUniform1f("u_luminosityThreshold", O3), g3.setUniform1f("u_smoothWidth", 0.01);
    const T6 = [Math.round(o13 / 2), Math.round(n11 / 2)];
    h13.setViewport(0, 0, T6[0], T6[1]), h13.setClearColor(0, 0, 0, 0), h13.clear(d4.COLOR_BUFFER_BIT), B3.draw(), h13.setBlendingEnabled(false);
    let x3 = this._intensityFBO.colorTexture;
    for (let e13 = 0; e13 < this._nMips; e13++) {
      const t16 = c12.getProgram(f8.gaussianBlur, [{
        name: "radius",
        value: this._kernelSizeArray[e13]
      }]);
      h13.useProgram(t16), h13.bindTexture(x3, e13 + 1), t16.setUniform1i("u_colorTexture", e13 + 1), t16.setUniform2fv("u_texSize", T6), t16.setUniform2fv("u_direction", u8), h13.setViewport(0, 0, T6[0], T6[1]);
      const s13 = this._mipsFBOs[e13];
      h13.bindFramebuffer(s13.horizontal), B3.draw(), x3 = s13.horizontal.colorTexture, h13.bindFramebuffer(s13.vertical), h13.bindTexture(x3, e13 + 1), t16.setUniform2fv("u_direction", l10), B3.draw(), x3 = s13.vertical.colorTexture, T6[0] = Math.round(T6[0] / 2), T6[1] = Math.round(T6[1] / 2);
    }
    h13.setViewport(0, 0, o13, n11);
    const w6 = c12.getProgram(f8.composite, [{
      name: "nummips",
      value: a8
    }]);
    h13.bindFramebuffer(this._compositeFBO), h13.useProgram(w6), w6.setUniform1f("u_bloomStrength", b5), w6.setUniform1f("u_bloomRadius", F4), w6.setUniform1fv("u_bloomFactors", m6), w6.setUniform3fv("u_bloomTintColors", _3), h13.bindTexture(this._mipsFBOs[0].vertical.colorTexture, 1), w6.setUniform1i("u_blurTexture1", 1), h13.bindTexture(this._mipsFBOs[1].vertical.colorTexture, 2), w6.setUniform1i("u_blurTexture2", 2), h13.bindTexture(this._mipsFBOs[2].vertical.colorTexture, 3), w6.setUniform1i("u_blurTexture3", 3), h13.bindTexture(this._mipsFBOs[3].vertical.colorTexture, 4), w6.setUniform1i("u_blurTexture4", 4), h13.bindTexture(this._mipsFBOs[4].vertical.colorTexture, 5), w6.setUniform1i("u_blurTexture5", 5), B3.draw(), h13.bindFramebuffer(i12), h13.setBlendingEnabled(true);
    const M3 = c12.getProgram(f8.blit);
    h13.useProgram(M3), h13.bindTexture(this._compositeFBO.colorTexture, 6), M3.setUniform1i("u_texture", 6), h13.setBlendFunction(R2.ONE, R2.ONE), B3.draw(), B3.unbind(), h13.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA), h13.setStencilTestEnabled(true);
  }
  _createOrResizeResources(t15, e13, s13) {
    const {
      context: a9
    } = t15;
    if (this._compositeFBO && this._size[0] === e13 && this._size[1] === s13) return;
    this._size[0] = e13, this._size[1] = s13;
    const u11 = [Math.round(e13 / 2), Math.round(s13 / 2)];
    if (this._compositeFBO) this._compositeFBO.resize(e13, s13);
    else {
      const t16 = new e4(e13, s13);
      t16.internalFormat = G.RGBA, t16.wrapMode = D.CLAMP_TO_EDGE, this._compositeFBO = new E3(a9, t16);
    }
    if (this._intensityFBO) this._intensityFBO.resize(u11[0], u11[1]);
    else {
      const t16 = new e4(u11[0], u11[1]);
      t16.internalFormat = G.RGBA, t16.wrapMode = D.CLAMP_TO_EDGE, this._intensityFBO = new E3(a9, t16);
    }
    for (let l12 = 0; l12 < this._nMips; l12++) {
      if (this._mipsFBOs[l12]) this._mipsFBOs[l12].horizontal.resize(u11[0], u11[1]), this._mipsFBOs[l12].vertical.resize(u11[0], u11[1]);
      else {
        const t16 = new e4(u11[0], u11[1]);
        t16.internalFormat = G.RGBA, t16.wrapMode = D.CLAMP_TO_EDGE, this._mipsFBOs[l12] = {
          horizontal: new E3(a9, t16),
          vertical: new E3(a9, t16)
        };
      }
      u11[0] = Math.round(u11[0] / 2), u11[1] = Math.round(u11[1] / 2);
    }
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Blur.js
var n9 = [1, 0];
var o12 = [0, 1];
var u9 = class {
  constructor() {
    this._blurFBO = null, this._size = [0, 0], this._programDesc = {
      gaussianBlur: {
        vsPath: "post-processing/pp",
        fsPath: "post-processing/blur/gaussianBlur",
        attributes: /* @__PURE__ */ new Map([["a_position", 0]])
      },
      radialBlur: {
        vsPath: "post-processing/pp",
        fsPath: "post-processing/blur/radial-blur",
        attributes: /* @__PURE__ */ new Map([["a_position", 0]])
      },
      blit: {
        vsPath: "post-processing/pp",
        fsPath: "post-processing/blit",
        attributes: /* @__PURE__ */ new Map([["a_position", 0]])
      }
    };
  }
  dispose() {
    this._blurFBO && (this._blurFBO.dispose(), this._blurFBO = null);
  }
  draw(t15, s13, r12) {
    const {
      context: i12
    } = t15, {
      type: a9,
      radius: n11
    } = r12;
    if (0 === n11) return;
    this._createOrResizeResources(t15), this._quad || (this._quad = new h6(i12, [-1, -1, 1, -1, -1, 1, 1, 1]));
    const o13 = this._quad;
    o13.bind(), "blur" === a9 ? this._gaussianBlur(t15, s13, n11) : this._radialBlur(t15, s13), o13.unbind();
  }
  _gaussianBlur(e13, s13, r12) {
    const {
      context: i12,
      state: a9,
      painter: u11,
      pixelRatio: l12
    } = e13, {
      size: d4
    } = a9, {
      materialManager: b5
    } = u11, c12 = this._programDesc, _5 = this._quad, p5 = [Math.round(l12 * d4[0]), Math.round(l12 * d4[1])], h13 = this._blurFBO, m7 = b5.getProgram(c12.gaussianBlur, [{
      name: "radius",
      value: Math.ceil(r12)
    }]);
    i12.useProgram(m7), i12.setBlendingEnabled(false), i12.bindFramebuffer(h13), i12.bindTexture(s13.colorTexture, 4), m7.setUniform1i("u_colorTexture", 4), m7.setUniform2fv("u_texSize", p5), m7.setUniform2fv("u_direction", n9), m7.setUniform1f("u_sigma", r12), _5.draw(), i12.bindFramebuffer(s13), i12.setStencilWriteMask(0), i12.setStencilTestEnabled(false), i12.setDepthWriteEnabled(false), i12.setDepthTestEnabled(false), i12.bindTexture(h13?.colorTexture, 5), m7.setUniform1i("u_colorTexture", 5), m7.setUniform2fv("u_direction", o12), _5.draw(), i12.setBlendingEnabled(true), i12.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA), i12.setStencilTestEnabled(true);
  }
  _radialBlur(e13, s13) {
    const {
      context: r12,
      painter: i12
    } = e13, {
      materialManager: a9
    } = i12, n11 = this._programDesc, o13 = this._quad, u11 = this._blurFBO;
    r12.bindFramebuffer(u11);
    const l12 = a9.getProgram(n11.radialBlur);
    r12.useProgram(l12), r12.setBlendingEnabled(false), r12.bindTexture(s13.colorTexture, 4), l12.setUniform1i("u_colorTexture", 4), o13.draw(), r12.bindFramebuffer(s13), r12.setStencilWriteMask(0), r12.setStencilTestEnabled(false), r12.setDepthWriteEnabled(false), r12.setDepthTestEnabled(false), r12.setBlendingEnabled(true);
    const d4 = a9.getProgram(n11.blit);
    r12.useProgram(d4), r12.bindTexture(u11?.colorTexture, 5), d4.setUniform1i("u_texture", 5), r12.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA), o13.draw();
  }
  _createOrResizeResources(e13) {
    const {
      context: t15,
      state: n11,
      pixelRatio: o13
    } = e13, {
      size: u11
    } = n11, l12 = Math.round(o13 * u11[0]), d4 = Math.round(o13 * u11[1]);
    if (!this._blurFBO || this._size[0] !== l12 || this._size[1] !== d4) if (this._size[0] = l12, this._size[1] = d4, this._blurFBO) this._blurFBO.resize(l12, d4);
    else {
      const e14 = new e4(l12, d4);
      e14.internalFormat = G.RGBA, e14.wrapMode = D.CLAMP_TO_EDGE, this._blurFBO = new E3(t15, e14);
    }
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Colorize.js
var n10 = class {
  constructor() {
    this._layerFBOTexture = null, this._size = [0, 0], this._programDesc = {
      vsPath: "post-processing/pp",
      fsPath: "post-processing/filterEffect",
      attributes: /* @__PURE__ */ new Map([["a_position", 0]])
    };
  }
  dispose() {
    this._layerFBOTexture = r2(this._layerFBOTexture);
  }
  draw(e13, t15, s13) {
    const {
      width: i12,
      height: o13
    } = t15;
    this._createOrResizeResources(e13, i12, o13);
    const {
      context: a9,
      painter: n11
    } = e13, {
      materialManager: c12
    } = n11, l12 = this._programDesc, u11 = this._quad, _5 = s13.colorMatrix;
    u11.bind();
    const h13 = this._layerFBOTexture;
    a9.bindFramebuffer(t15), t15.copyToTexture(0, 0, i12, o13, 0, 0, h13), a9.setBlendingEnabled(false), a9.setStencilTestEnabled(false);
    const m7 = c12.getProgram(l12);
    a9.useProgram(m7), a9.bindTexture(h13, 2), m7.setUniformMatrix4fv("u_coefficients", _5), m7.setUniform1i("u_colorTexture", 2), u11.draw(), a9.setBlendingEnabled(true), a9.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA), a9.setStencilTestEnabled(true), u11.unbind();
  }
  _createOrResizeResources(e13, r12, n11) {
    const {
      context: c12
    } = e13;
    if (!this._layerFBOTexture || this._size[0] !== r12 || this._size[1] !== n11) {
      if (this._size[0] = r12, this._size[1] = n11, this._layerFBOTexture) this._layerFBOTexture.resize(r12, n11);
      else {
        const e14 = new e4();
        e14.internalFormat = G.RGBA, e14.wrapMode = D.CLAMP_TO_EDGE, e14.width = r12, e14.height = n11, this._layerFBOTexture = new c2(c12, e14);
      }
      this._quad || (this._quad = new h6(c12, [-1, -1, 1, -1, -1, 1, 1, 1]));
    }
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/DropShadow.js
var u10 = [1, 0];
var h12 = [0, 1];
var _4 = class {
  constructor() {
    this._layerFBOTexture = null, this._horizontalBlurFBO = null, this._verticalBlurFBO = null, this._size = [0, 0], this._quad = null, this._programDesc = {
      blur: {
        vsPath: "post-processing/pp",
        fsPath: "post-processing/blur/gaussianBlur",
        attributes: /* @__PURE__ */ new Map([["a_position", 0]])
      },
      composite: {
        vsPath: "post-processing/pp",
        fsPath: "post-processing/drop-shadow/composite",
        attributes: /* @__PURE__ */ new Map([["a_position", 0]])
      },
      blit: {
        vsPath: "post-processing/pp",
        fsPath: "post-processing/blit",
        attributes: /* @__PURE__ */ new Map([["a_position", 0]])
      }
    };
  }
  dispose() {
    this._layerFBOTexture = r2(this._layerFBOTexture), this._horizontalBlurFBO = r2(this._horizontalBlurFBO), this._verticalBlurFBO = r2(this._verticalBlurFBO);
  }
  draw(e13, i12, o13) {
    const {
      context: a9,
      state: n11,
      painter: l12
    } = e13, {
      materialManager: _5
    } = l12, c12 = this._programDesc, p5 = i12.width, m7 = i12.height, f8 = [Math.round(p5), Math.round(m7)], {
      blurRadius: B3,
      offsetX: d4,
      offsetY: b5,
      color: O3
    } = o13, F4 = [u4(d4), u4(b5)];
    this._createOrResizeResources(e13, p5, m7, f8);
    const w6 = this._horizontalBlurFBO, T6 = this._verticalBlurFBO;
    a9.setStencilWriteMask(0), a9.setStencilTestEnabled(false), a9.setDepthWriteEnabled(false), a9.setDepthTestEnabled(false);
    const x3 = this._layerFBOTexture;
    i12.copyToTexture(0, 0, p5, m7, 0, 0, x3), this._quad || (this._quad = new h6(a9, [-1, -1, 1, -1, -1, 1, 1, 1])), a9.setViewport(0, 0, f8[0], f8[1]);
    const g3 = this._quad;
    g3.bind(), a9.setBlendingEnabled(false);
    const z = _5.getProgram(c12.blur, [{
      name: "radius",
      value: Math.ceil(B3)
    }]);
    a9.useProgram(z), a9.bindFramebuffer(w6), a9.bindTexture(i12.colorTexture, 4), z.setUniform1i("u_colorTexture", 4), z.setUniform2fv("u_texSize", f8), z.setUniform2fv("u_direction", u10), z.setUniform1f("u_sigma", B3), g3.draw(), a9.bindFramebuffer(T6), a9.bindTexture(w6?.colorTexture, 5), z.setUniform1i("u_colorTexture", 5), z.setUniform2fv("u_direction", h12), g3.draw(), a9.bindFramebuffer(i12), a9.setViewport(0, 0, p5, m7);
    const M3 = _5.getProgram(c12.composite);
    a9.useProgram(M3), a9.bindTexture(T6?.colorTexture, 2), M3.setUniform1i("u_blurTexture", 2), a9.bindTexture(x3, 3), M3.setUniform1i("u_layerFBOTexture", 3), M3.setUniform4fv("u_shadowColor", [O3[3] * (O3[0] / 255), O3[3] * (O3[1] / 255), O3[3] * (O3[2] / 255), O3[3]]), M3.setUniformMatrix3fv("u_displayViewMat3", n11.displayMat3), M3.setUniform2fv("u_shadowOffset", F4), g3.draw(), a9.setBlendingEnabled(true), a9.setStencilTestEnabled(true), a9.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA), g3.unbind();
  }
  _createOrResizeResources(e13, t15, r12, s13) {
    const {
      context: u11
    } = e13;
    if (!this._horizontalBlurFBO || this._size[0] !== t15 || this._size[1] !== r12) {
      if (this._size[0] = t15, this._size[1] = r12, this._horizontalBlurFBO) this._horizontalBlurFBO.resize(s13[0], s13[1]);
      else {
        const e14 = new e4(s13[0], s13[1]);
        e14.internalFormat = G.RGBA, e14.wrapMode = D.CLAMP_TO_EDGE, this._horizontalBlurFBO = new E3(u11, e14);
      }
      if (this._verticalBlurFBO) this._verticalBlurFBO.resize(s13[0], s13[1]);
      else {
        const e14 = new e4(s13[0], s13[1]);
        e14.internalFormat = G.RGBA, e14.wrapMode = D.CLAMP_TO_EDGE, this._verticalBlurFBO = new E3(u11, e14);
      }
      if (this._layerFBOTexture) this._layerFBOTexture.resize(t15, r12);
      else {
        const e14 = new e4();
        e14.internalFormat = G.RGBA, e14.wrapMode = D.CLAMP_TO_EDGE, e14.width = t15, e14.height = r12, this._layerFBOTexture = new c2(u11, e14);
      }
    }
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Opacity.js
var l11 = class {
  constructor() {
    this._size = [0, 0], this._layerFBOTexture = null;
  }
  dispose() {
    this._layerFBOTexture = r2(this._layerFBOTexture);
  }
  draw(e13, r12, s13) {
    const {
      width: i12,
      height: o13
    } = r12;
    this._createOrResizeResources(e13, i12, o13);
    const {
      context: l12,
      painter: a9
    } = e13, {
      amount: n11
    } = s13, h13 = l12.gl, u11 = this._layerFBOTexture;
    l12.bindFramebuffer(r12), r12.copyToTexture(0, 0, i12, o13, 0, 0, u11), l12.setBlendingEnabled(true), l12.setStencilTestEnabled(false), l12.setDepthTestEnabled(false), l12.setClearColor(0, 0, 0, 0), l12.clear(h13.COLOR_BUFFER_BIT), a9.blitTexture(l12, u11, L3.NEAREST, n11);
  }
  _createOrResizeResources(e13, l12, a9) {
    const {
      context: n11
    } = e13;
    if (!this._layerFBOTexture || this._size[0] !== l12 || this._size[1] !== a9) if (this._size[0] = l12, this._size[1] = a9, this._layerFBOTexture) this._layerFBOTexture.resize(l12, a9);
    else {
      const e14 = new e4();
      e14.internalFormat = G.RGBA, e14.wrapMode = D.CLAMP_TO_EDGE, e14.samplingMode = L3.NEAREST, e14.width = l12, e14.height = a9, this._layerFBOTexture = new c2(n11, e14);
    }
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/EffectManager.js
function c11(o13) {
  switch (o13) {
    case "bloom":
    case "blur":
    case "opacity":
    case "drop-shadow":
      return o13;
    default:
      return "colorize";
  }
}
var f7 = {
  colorize: () => new n10(),
  blur: () => new u9(),
  bloom: () => new h11(),
  opacity: () => new l11(),
  "drop-shadow": () => new _4()
};
var i11 = class {
  constructor() {
    this._effectMap = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._effectMap.forEach((o13) => o13.dispose()), this._effectMap.clear();
  }
  getPostProcessingEffects(o13) {
    if (!o13 || 0 === o13.length) return [];
    const e13 = [];
    for (const t15 of o13) {
      const o14 = c11(t15.type);
      let s13 = this._effectMap.get(o14);
      s13 || (s13 = f7[o14](), this._effectMap.set(o14, s13)), e13.push({
        postProcessingEffect: s13,
        effect: t15
      });
    }
    return e13;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/painter/RenderPass.js
var t14 = class {
  constructor(e13, t15) {
    this.brushes = e13, this.name = t15.name, this.drawPhase = t15.drawPhase || E4.MAP, this._targetFn = t15.target, this.effects = t15.effects || [], this.enableDefaultDraw = t15.enableDefaultDraw ?? (() => true), this.forceDrawByDisplayOrder = !!t15.forceDrawByDisplayOrder;
  }
  render(e13) {
    const {
      context: r12,
      profiler: t15
    } = e13, s13 = this._targetFn(), a9 = this.drawPhase & e13.drawPhase;
    if (t15.recordPassStart(this.name), a9) {
      this.enableDefaultDraw() && this._doRender(e13, s13), t15.recordPassEnd();
      for (const t16 of this.effects) {
        if (!t16.enable()) continue;
        const a10 = t16.apply, n11 = t16.args?.(), i12 = r12.getViewport(), o13 = r12.getBoundFramebufferObject(), d4 = e13.passOptions;
        this._bindEffect(e13, a10, n11), this._doRender(e13, s13, a10.defines), this._drawAndUnbindEffect(e13, a10, i12, o13, d4, n11);
      }
    }
  }
  _doRender(e13, r12, t15) {
    if (null == r12) return;
    const {
      profiler: s13,
      context: a9
    } = e13;
    for (const n11 of this.brushes) {
      if (s13.recordBrushStart(n11.name), null != n11.brushEffect) {
        const s14 = a9.getViewport(), i12 = a9.getBoundFramebufferObject(), o13 = e13.passOptions;
        this._bindEffect(e13, n11.brushEffect), this._drawWithBrush(n11, e13, r12, t15), this._drawAndUnbindEffect(e13, n11.brushEffect, s14, i12, o13);
      } else this._drawWithBrush(n11, e13, r12, t15);
      s13.recordBrushEnd();
    }
  }
  _drawWithBrush(r12, t15, s13, a9) {
    m(s13) ? (r12.prepareState(t15, a9), r12.drawMany(t15, s13, a9)) : s13.visible && (r12.prepareState(t15, a9), r12.draw(t15, s13, a9));
  }
  _bindEffect(e13, r12, t15) {
    const {
      profiler: s13
    } = e13;
    s13.recordPassStart(this.name + "." + r12.name), r12.bind(e13, t15);
    const a9 = r12.createOptions(e13, t15);
    e13.passOptions = a9;
  }
  _drawAndUnbindEffect(e13, r12, t15, s13, a9, n11) {
    const {
      profiler: i12,
      context: o13
    } = e13;
    e13.passOptions = a9, i12.recordBrushStart(r12.name), r12.draw(e13, n11), r12.unbind(e13, n11), o13.bindFramebuffer(s13);
    const {
      x: d4,
      y: f8,
      width: h13,
      height: c12
    } = t15;
    o13.setViewport(d4, f8, h13, c12), i12.recordBrushEnd(), i12.recordPassEnd();
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/TechniqueProgramCache.js
var r11 = class {
  constructor() {
    this._programCache = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const r12 of this._programCache.values()) r12.destroy();
    this._programCache.clear();
  }
  getProgram(r12, e13, t15, a9, o13) {
    const s13 = r12.getShaderKey(e13, t15, a9, o13);
    let c12 = this._programCache.get(s13);
    return c12 || (c12 = r12.getProgram(e13, t15, a9, o13), this._programCache.set(s13, c12)), c12;
  }
};

// ../../../node_modules/@arcgis/core/views/2d/engine/webgl/Painter.js
var A6 = class {
  constructor(e13, t15) {
    this.context = e13, this._currentPipelineStateNeedsUpdate = false, this._blitRenderer = new _2(), this._worldExtentRenderer = new u7(), this._brushCache = /* @__PURE__ */ new Map(), this._lastWidth = null, this._lastHeight = null, this._vtlMaterialManager = new p2(), this._blendEffect = new m5(), this._stencilBuf = null, this._prevBeforeLayerFBOStack = [], this._fboPool = [], this.effects = {
      highlight: new l9(),
      hittest: new c10(),
      integrate: new i9(),
      insideEffect: new s12("inside"),
      outsideEffect: new s12("outside")
    }, this._programCache = new r11(), this._shaderState = {
      shader: null,
      uniforms: null,
      defines: null,
      optionalAttributes: null,
      useComputeBuffer: false
    }, this.materialManager = new e12(e13), this.textureManager = new j2(t15), this.textureUploadManager = new r9(t15), this._effectsManager = new i11(), this._quadMesh = new h6(e13, [0, 0, 1, 0, 0, 1, 1, 1]);
  }
  dispose() {
    if (this._programCache.destroy(), this.materialManager.dispose(), this.textureManager.dispose(), this.textureUploadManager.destroy(), this._blitRenderer = r2(this._blitRenderer), this._worldExtentRenderer = r2(this._worldExtentRenderer), this._quadMesh.dispose(), this._brushCache && (this._brushCache.forEach((e13) => e13.dispose()), this._brushCache.clear(), this._brushCache = null), this._fbos) {
      let e13;
      for (e13 in this._fbos) this._fbos[e13] && this._fbos[e13].dispose();
    }
    for (const e13 of this._fboPool) e13.dispose();
    if (this._fboPool.length = 0, this.effects) {
      let e13;
      for (e13 in this.effects) this.effects[e13] && this.effects[e13].dispose();
    }
    this._effectsManager.dispose(), this._blendEffect.dispose(this.context), this._vtlMaterialManager = r2(this._vtlMaterialManager);
  }
  clearShaderCache() {
    this._programCache.destroy(), this._programCache = new r11();
  }
  get blitRenderer() {
    return this._blitRenderer;
  }
  get vectorTilesMaterialManager() {
    return this._vtlMaterialManager;
  }
  getFbos() {
    if (!this._fbos) throw new Error("InternalError: Painter FBOs not initialized");
    return this._fbos;
  }
  acquireFbo(e13, t15) {
    let s13;
    if (this._fboPool.length > 0) s13 = this._fboPool.pop();
    else {
      const r12 = new e4(e13, t15);
      r12.samplingMode = L3.NEAREST, r12.wrapMode = D.CLAMP_TO_EDGE, s13 = new E3(this.context, r12, this._stencilBuf);
    }
    return s13.width === e13 && s13.height === t15 || s13.resize(e13, t15), s13;
  }
  releaseFbo(e13) {
    this._fboPool.push(e13);
  }
  getSharedStencilBuffer() {
    return this._stencilBuf;
  }
  beforeRenderPhases(e13, t15, s13) {
    const {
      context: r12
    } = e13;
    this._worldExtentRenderer.render(e13, t15, s13);
    const {
      width: i12,
      height: n11
    } = r12.getViewport();
    if (this.updateFBOs(i12, n11), this._prevFBO = r12.getBoundFramebufferObject(), r12.bindFramebuffer(this.getFbos().output), r12.setColorMask(true, true, true, true), null != t15) {
      const {
        r: e14,
        g: s14,
        b: i13,
        a: n12
      } = t15;
      r12.setClearColor(n12 * e14 / 255, n12 * s14 / 255, n12 * i13 / 255, n12);
    } else r12.setClearColor(0, 0, 0, 0);
    r12.setDepthWriteEnabled(true), r12.setClearDepth(1), r12.clear(r12.gl.COLOR_BUFFER_BIT | r12.gl.DEPTH_BUFFER_BIT), r12.setDepthWriteEnabled(false);
  }
  afterRenderPhases(e13) {
    const {
      context: t15
    } = e13;
    t15.bindFramebuffer(this._prevFBO), t15.setStencilFunction(O2.EQUAL, 1, 255), t15.setStencilTestEnabled(true), t15.setDepthTestEnabled(false), this.blitTexture(t15, this.getFbos().output.colorTexture, L3.NEAREST);
  }
  beforeRenderLayer(e13, t15, s13) {
    const {
      context: r12,
      blendMode: i12,
      effects: n11,
      drawPhase: a9,
      requireFBO: o13
    } = e13;
    if (o13 || N4(a9, i12, n11, s13)) {
      const e14 = r12.getBoundFramebufferObject();
      this._prevBeforeLayerFBOStack.push(e14);
      const {
        width: t16,
        height: s14
      } = r12.getViewport(), i13 = this.acquireFbo(t16, s14);
      r12.bindFramebuffer(i13), r12.setColorMask(true, true, true, true), r12.setClearColor(0, 0, 0, 0), r12.setDepthWriteEnabled(true), r12.setClearDepth(1), r12.clear(r12.gl.COLOR_BUFFER_BIT | r12.gl.DEPTH_BUFFER_BIT), r12.setDepthWriteEnabled(false);
    }
    r12.setDepthWriteEnabled(false), r12.setDepthTestEnabled(false), r12.setStencilTestEnabled(true), r12.setClearStencil(t15), r12.setStencilWriteMask(255), r12.clear(r12.gl.STENCIL_BUFFER_BIT);
  }
  afterRenderLayer(e13, t15) {
    const {
      context: s13,
      blendMode: r12,
      effects: n11,
      requireFBO: a9,
      drawPhase: o13
    } = e13;
    if (a9 || N4(o13, r12, n11, t15)) {
      const a10 = s13.getBoundFramebufferObject();
      null != n11 && n11.length > 0 && o13 === E4.MAP && (s13.setColorMask(true, true, true, true), this._applyEffects(e13, n11, a10)), s13.bindFramebuffer(this._prevBeforeLayerFBOStack.pop()), s13.setStencilTestEnabled(false), s13.setStencilWriteMask(0), s13.setBlendingEnabled(true), s13.setBlendFunctionSeparate(R2.ONE, R2.ONE_MINUS_SRC_ALPHA, R2.ONE, R2.ONE_MINUS_SRC_ALPHA), s13.setColorMask(true, true, true, true);
      const l12 = null == r12 || o13 === E4.HIGHLIGHT ? "normal" : r12;
      this._blendEffect.draw(e13, a10.colorTexture, L3.NEAREST, l12, t15), this.releaseFbo(a10);
    }
  }
  renderObject(e13, s13, r12, i12) {
    const n11 = h7[r12];
    if (!n11) return;
    let a9 = this._brushCache.get(n11);
    void 0 === a9 && (a9 = new n11(), this._brushCache.set(n11, a9)), a9.prepareState(e13), a9.draw(e13, s13, i12);
  }
  renderObjects(e13, s13, r12, i12) {
    const n11 = h7[r12];
    if (!n11) return;
    let a9 = this._brushCache.get(n11);
    void 0 === a9 && (a9 = new n11(), this._brushCache.set(n11, a9)), a9.drawMany(e13, s13, i12);
  }
  registerRenderPass(e13) {
    const t15 = e13.brushes.map((e14) => (this._brushCache.has(e14) || this._brushCache.set(e14, new e14()), this._brushCache.get(e14)));
    return new t14(t15, e13);
  }
  blitTexture(e13, t15, s13, r12 = 1) {
    e13.setBlendingEnabled(true), e13.setBlendFunctionSeparate(R2.ONE, R2.ONE_MINUS_SRC_ALPHA, R2.ONE, R2.ONE_MINUS_SRC_ALPHA), e13.setColorMask(true, true, true, true), this._blitRenderer.render(e13, t15, s13, r12), this._currentPipelineStateNeedsUpdate = true;
  }
  getPostProcessingEffects(e13) {
    return this._effectsManager.getPostProcessingEffects(e13);
  }
  updateFBOs(e13, t15) {
    if (e13 !== this._lastWidth || t15 !== this._lastHeight) {
      if (this._lastWidth = e13, this._lastHeight = t15, this._fbos) {
        let s14;
        for (s14 in this._fbos) this._fbos[s14].resize(e13, t15);
        return;
      }
      const s13 = new e4(e13, t15);
      s13.samplingMode = L3.NEAREST, s13.wrapMode = D.CLAMP_TO_EDGE;
      const r12 = new i2(B.DEPTH_STENCIL, e13, t15);
      this._stencilBuf = new s4(this.context, r12), this._fbos = {
        output: new E3(this.context, s13, this._stencilBuf),
        effect0: new E3(this.context, s13, this._stencilBuf)
      };
    }
  }
  _applyEffects(e13, t15, s13) {
    const {
      context: r12
    } = e13, i12 = this._effectsManager.getPostProcessingEffects(t15);
    for (const {
      postProcessingEffect: n11,
      effect: a9
    } of i12) r12.bindFramebuffer(s13), n11.draw(e13, s13, a9);
    this._currentPipelineStateNeedsUpdate = true;
  }
  setShader(e13) {
    this._shaderState.shader = e13.shader, this._shaderState.uniforms = e13.uniforms, this._shaderState.defines = e13.defines, this._shaderState.optionalAttributes = e13.optionalAttributes, this._shaderState.useComputeBuffer = e13.useComputeBuffer ?? false;
  }
  setPipelineState(e13) {
    e13 !== this._currentPipelineState && (this._currentPipelineState = e13, this._currentPipelineStateNeedsUpdate = true);
  }
  submitDraw(e13, t15) {
    const {
      shader: s13,
      uniforms: r12,
      defines: i12,
      optionalAttributes: n11
    } = this._shaderState, a9 = e13.context, o13 = t15.getAttributePrecisionPackFactors(), l12 = this._programCache.getProgram(s13, o13, r12, i12 ?? {}, n11 ?? {});
    return l12.setUniforms(r12), l12.bind(a9), this.updatePipelineState(a9), this.setStencilRef(a9, t15), t15.draw(e13, s13.locationInfo), l12.cleanupTemporaryTextures(), {
      vertexShader: l12.vertexShader,
      fragmentShader: l12.fragmentShader
    };
  }
  submitDrawQuad(e13) {
    const {
      shader: t15,
      uniforms: s13,
      defines: r12,
      optionalAttributes: i12
    } = this._shaderState, n11 = this._programCache.getProgram(t15, {}, s13, r12 ?? {}, i12 ?? {});
    n11.setUniforms(s13), n11.bind(e13), this.updatePipelineState(e13), this._quadMesh.draw(), e13.bindVAO(null), n11.cleanupTemporaryTextures();
  }
  submitDrawMesh(e13, t15, s13) {
    const {
      shader: r12,
      uniforms: i12,
      defines: n11,
      optionalAttributes: a9
    } = this._shaderState, o13 = this._programCache.getProgram(r12, {}, i12, n11 ?? {}, a9 ?? {});
    if (o13.setUniforms(i12), o13.bind(e13), this.updatePipelineState(e13), s13) for (const l12 of s13) t15.bind(e13, l12), t15.draw(e13);
    else for (let l12 = 0; l12 < t15.parts.length; l12++) t15.bind(e13, l12), t15.draw(e13);
    t15.unbind(e13), o13.cleanupTemporaryTextures();
  }
  updatePipelineState(e13) {
    this._currentPipelineStateNeedsUpdate && (this._currentPipelineStateNeedsUpdate = false, this._updatePipelineState(e13));
  }
  _updatePipelineState(e13) {
    if (null == this._currentPipelineState) throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");
    const {
      color: t15,
      depth: s13,
      stencil: r12
    } = this._currentPipelineState;
    if (t15) {
      const {
        blendMode: s14,
        write: r13
      } = t15;
      switch (e13.setColorMask(...r13), e13.setBlendingEnabled(true), e13.setBlendEquation(T2.ADD), s14) {
        case "composite":
          e13.setBlendFunctionSeparate(R2.ONE, R2.ONE_MINUS_SRC_ALPHA, R2.ONE, R2.ONE_MINUS_SRC_ALPHA);
          break;
        case "additive":
          e13.setBlendFunctionSeparate(R2.ONE, R2.ONE, R2.ONE, R2.ONE);
          break;
        case "custom": {
          const {
            blendParameters: s15
          } = t15, {
            dstAlpha: r14,
            dstRGB: i12,
            srcAlpha: n11,
            srcRGB: a9
          } = s15;
          e13.setBlendFunctionSeparate(a9, i12, n11, r14);
          break;
        }
        case "delete":
          e13.setBlendEquation(T2.REVERSE_SUBTRACT), e13.setBlendFunctionSeparate(R2.ONE, R2.ONE_MINUS_SRC_ALPHA, R2.ONE, R2.ONE_MINUS_SRC_ALPHA);
      }
    }
    if (s13) {
      const {
        test: t16,
        write: r13
      } = s13;
      r13 ? (e13.setDepthWriteEnabled(true), e13.setDepthRange(r13.zNear, r13.zFar)) : e13.setDepthWriteEnabled(false), t16 ? (e13.setDepthTestEnabled(true), e13.setDepthFunction(t16)) : e13.setDepthTestEnabled(false);
    } else e13.setDepthTestEnabled(false), e13.setDepthWriteEnabled(false);
    if (r12) {
      const {
        test: t16,
        write: s14
      } = r12;
      if (t16) {
        const {
          compare: s15,
          mask: r13,
          op: i12,
          ref: n11
        } = t16;
        e13.setStencilTestEnabled(true), "function" != typeof n11 && e13.setStencilFunctionSeparate(N2.FRONT_AND_BACK, s15, n11, r13), e13.setStencilOpSeparate(N2.FRONT_AND_BACK, i12.fail, i12.zFail, i12.zPass);
      } else e13.setStencilTestEnabled(false);
      if (s14) {
        const {
          mask: t17
        } = s14;
        e13.setStencilWriteMask(t17);
      } else e13.setStencilWriteMask(0);
    } else e13.setStencilTestEnabled(false), e13.setStencilWriteMask(0);
  }
  setStencilRef(e13, t15) {
    if (null == this._currentPipelineState) throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");
    const {
      stencil: s13
    } = this._currentPipelineState;
    if (s13) {
      const {
        test: r12
      } = s13;
      if (r12) {
        const {
          compare: s14,
          mask: i12,
          ref: n11
        } = r12;
        if ("function" == typeof n11) {
          const r13 = t15.getStencilReference();
          if (null === r13) throw new Error("InternalError: Stencil reference expected for target but not defined");
          e13.setStencilFunctionSeparate(N2.FRONT_AND_BACK, s14, r13, i12);
        }
      }
    }
  }
};
function N4(e13, t15, s13, r12) {
  return e13 !== E4.LABEL_ALPHA && e13 !== E4.LABEL && e13 !== E4.HIGHLIGHT && (1 !== r12 || null != t15 && "normal" !== t15 || null != s13 && s13.length > 0);
}

// ../../../node_modules/@arcgis/core/views/2d/engine/Stage.js
var v3 = 2e3;
var q2 = class extends h5 {
  constructor(t15, i12) {
    super(), this.meshWriterRegistry = new W2(), this._trash = /* @__PURE__ */ new Set(), this._renderRemainingTime = 0, this._lastFrameRenderTime = 0, this._renderRequested = r4(false), this.stage = this, this._stationary = true, this._reshuffleManager = new s8(), this._canvas = new l6(t15), this.context = new y3(this._canvas.gl, i12.contextOptions ?? {}), this.painter = new A6(this.context, this), this._cimAnalyzer = new R3(this.painter.textureManager.resourceManager), has("esri-2d-profiler") && (this._debugOutput = document.createElement("div"), this._debugOutput.setAttribute("style", "margin: 24px 64px; position: absolute; color: red;"), t15.appendChild(this._debugOutput));
    const a9 = () => this._highlightGradient;
    this._renderParameters = {
      drawPhase: 0,
      state: this.state,
      pixelRatio: window.devicePixelRatio,
      stationary: false,
      globalOpacity: 1,
      blendMode: null,
      deltaTime: -1,
      time: 0,
      inFadeTransition: false,
      effects: null,
      context: this.context,
      painter: this.painter,
      timeline: i12.timeline || new e11(),
      renderingOptions: i12.renderingOptions,
      requestRender: () => this.requestRender(),
      allowDelayedRender: false,
      requireFBO: false,
      profiler: new n5(this.context, this._debugOutput),
      dataUploadCounter: 0,
      get highlightGradient() {
        return a9();
      },
      reshuffleManager: this._reshuffleManager,
      backgroundColor: i12.backgroundColor
    }, this._taskHandle = A({
      render: (e13) => this.renderFrame(e13)
    }), this._taskHandle.pause(), this._lostWebGLContextHandle = this._canvas.events.on("webgl-context-lost", (t16) => this.emit("webgl-error", {
      error: new s2("webgl-context-lost", t16.statusMessage)
    })), this._bufferPool = new i7(), T4();
  }
  destroy() {
    w3(this.context), this.removeAllChildren(), this._emptyTrash(), this._taskHandle = l2(this._taskHandle), this._lostWebGLContextHandle = l2(this._lostWebGLContextHandle), this._canvas.destroy(), this._debugOutput?.parentNode?.removeChild(this._debugOutput), this._bufferPool.destroy(), this.painter.dispose(), this.context.dispose(), this._canvas = null;
  }
  get textureManager() {
    return this.painter.textureManager;
  }
  get backgroundColor() {
    return this._renderParameters.backgroundColor;
  }
  set backgroundColor(e13) {
    this._renderParameters.backgroundColor = e13, this.requestRender();
  }
  get bufferPool() {
    return this._bufferPool;
  }
  get cimAnalyzer() {
    return this._cimAnalyzer;
  }
  get renderingOptions() {
    return this._renderingOptions;
  }
  set renderingOptions(e13) {
    this._renderingOptions = e13, this.requestRender();
  }
  get renderRequested() {
    return this._renderRequested.value;
  }
  get state() {
    return this._state;
  }
  set state(e13) {
    this._state = e13, this.requestRender();
  }
  get stationary() {
    return this._stationary;
  }
  set stationary(e13) {
    this._stationary !== e13 && (this._stationary = e13, this.requestRender());
  }
  trashDisplayObject(e13) {
    this._trash.add(e13), this.requestRender();
  }
  untrashDisplayObject(e13) {
    return this._trash.delete(e13);
  }
  requestRender() {
    this._renderRemainingTime = v3, this.renderRequested || (this._renderRequested.value = true, this._taskHandle.resume());
  }
  renderFrame(e13) {
    const t15 = this._lastFrameRenderTime ? e13.time - this._lastFrameRenderTime : 0;
    this._renderRemainingTime -= t15, this._renderRemainingTime <= 0 && this._taskHandle.pause(), this._lastFrameRenderTime = e13.time, this._renderRequested.value = false, this._renderParameters.state = this._state, this._renderParameters.stationary = this.stationary, this._renderParameters.pixelRatio = window.devicePixelRatio, this._renderParameters.globalOpacity = 1, this._renderParameters.time = e13.time, this._renderParameters.deltaTime = e13.deltaTime, this._renderParameters.effects = null, this.processRender(this._renderParameters), this._emptyTrash();
  }
  _createTransforms() {
    return {
      displayViewScreenMat3: e6()
    };
  }
  renderChildren(e13) {
    for (const t15 of this.children) t15.beforeRender(e13);
    this._reshuffleManager.reshuffle(wt), this._canvas.render(e13, () => this._renderChildren(this.children, e13));
    for (const t15 of this.children) t15.afterRender(e13);
  }
  _renderChildren(e13, t15) {
    const r12 = this.context;
    this.painter.textureUploadManager.upload(), r12.resetInfo(), t15.profiler.recordStart("drawLayers"), t15.dataUploadCounter = 0, this.painter.beforeRenderPhases(t15, t15.backgroundColor, this.state.padding), t15.drawPhase = E4.MAP;
    for (const s13 of e13) s13.processRender(t15);
    if (this.children.some((e14) => e14.hasHighlight)) {
      t15.drawPhase = E4.HIGHLIGHT;
      for (const r13 of e13) r13.processRender(t15);
    }
    if (this.children.some((e14) => e14.hasLabels)) {
      t15.drawPhase = E4.LABEL;
      for (const r13 of e13) r13.processRender(t15);
    }
    if (has("esri-tiles-debug")) {
      t15.drawPhase = E4.DEBUG;
      for (const r13 of e13) r13.processRender(t15);
    }
    this.painter.afterRenderPhases(t15), t15.profiler.recordEnd("drawLayers"), r12.logInfo();
  }
  doRender(e13) {
    const t15 = this.context, {
      state: r12,
      pixelRatio: s13
    } = e13;
    this._canvas.resize(e13), t15.setViewport(0, 0, s13 * r12.size[0], s13 * r12.size[1]), t15.setDepthWriteEnabled(true), t15.setStencilWriteMask(255), this.renderChildren(e13);
  }
  takeScreenshot(e13, t15, r12, s13) {
    return __async(this, null, function* () {
      const i12 = Math.round(this.state.size[0] * e13.resolutionScale), n11 = Math.round(this.state.size[1] * e13.resolutionScale), a9 = e13.resolutionScale, o13 = this.context, h13 = this._state.clone();
      if (null != s13) {
        const e14 = h13.viewpoint;
        h13.viewpoint.rotation = s13, h13.viewpoint = e14;
      }
      const d4 = __spreadProps(__spreadValues({}, this._renderParameters), {
        drawPhase: null,
        globalOpacity: 1,
        stationary: true,
        state: h13,
        pixelRatio: a9,
        time: performance.now(),
        deltaTime: 0,
        blendMode: null,
        effects: null,
        inFadeTransition: false,
        backgroundColor: r12
      }), l12 = new e4(i12, n11);
      l12.wrapMode = D.CLAMP_TO_EDGE, l12.internalFormat = P3.RGBA8, l12.isImmutable = true;
      const m7 = new E3(o13, l12, new i2(B.DEPTH_STENCIL, i12, n11)), c12 = o13.getBoundFramebufferObject(), u11 = o13.getViewport();
      o13.bindFramebuffer(m7), o13.setViewport(0, 0, i12, n11), this._renderChildren(t15 ?? this.children, d4);
      const p5 = this._readbackScreenshot(m7, __spreadProps(__spreadValues({}, e13.cropArea), {
        y: n11 - (e13.cropArea.y + e13.cropArea.height)
      }));
      o13.bindFramebuffer(c12), o13.setViewport(u11.x, u11.y, u11.width, u11.height), this.requestRender();
      const f8 = yield p5;
      let g3;
      return 1 === e13.outputScale ? g3 = f8 : (g3 = new ImageData(Math.round(f8.width * e13.outputScale), Math.round(f8.height * e13.outputScale)), w4(f8, g3, true)), m7.dispose(), g3;
    });
  }
  _readbackScreenshot(e13, t15) {
    return __async(this, null, function* () {
      const r12 = s6(t15.width, t15.height, document.createElement("canvas"));
      return yield e13.readPixelsAsync(t15.x, t15.y, t15.width, t15.height, G.RGBA, U2.UNSIGNED_BYTE, new Uint8Array(r12.data.buffer)), r12;
    });
  }
  _emptyTrash() {
    for (; this._trash.size > 0; ) {
      const e13 = Array.from(this._trash);
      this._trash.clear();
      for (const t15 of e13) t15.processDetach();
    }
  }
};

// ../../../node_modules/@arcgis/core/views/2d/magnifier/MagnifierView2D.js
var A7 = class extends s7 {
  constructor() {
    super(), this._handles = new r(), this._resourcePixelRatio = 1, this.updatingHandles = new h4(), this.visible = false;
  }
  destroy() {
    this._handles = u(this._handles), this._disposeRenderResources(), this._resourcesTask = e(this._resourcesTask);
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(e13) {
    this._backgroundColor = e13, this.requestRender();
  }
  get magnifier() {
    return this._magnifier;
  }
  set magnifier(e13) {
    this._magnifier = e13, this._handles.removeAll(), this._handles.add([d2(() => e13.version, () => {
      this.visible = e13.visible && null != e13.position && e13.size > 0, this.requestRender();
    }, P), d2(() => [e13.maskUrl, e13.overlayUrl], () => this._reloadResources()), d2(() => e13.size, () => {
      this._disposeRenderResources(), this.requestRender();
    })]);
  }
  _createTransforms() {
    return {
      displayViewScreenMat3: e6()
    };
  }
  doRender(e13) {
    const r12 = e13.context;
    if (!this._resourcesTask) return void this._reloadResources();
    if (e13.drawPhase !== E4.MAP || !this._canRender()) return;
    this._updateResources(e13);
    const s13 = this._magnifier;
    if (null == s13.position) return;
    const i12 = e13.pixelRatio, o13 = s13.size * i12, a9 = 1 / s13.factor, n11 = Math.ceil(a9 * o13);
    this._readbackTexture.resize(n11, n11);
    const {
      size: l12
    } = e13.state, h13 = i12 * l12[0], m7 = i12 * l12[1], u11 = 0.5 * n11, c12 = 0.5 * n11, d4 = e2(i12 * s13.position.x, u11, h13 - u11 - 1), p5 = e2(m7 - i12 * s13.position.y, c12, m7 - c12 - 1);
    r12.setBlendingEnabled(true);
    const f8 = d4 - u11, g3 = p5 - c12, x3 = this._readbackTexture;
    r12.bindTexture(x3, 0), r12.gl.copyTexImage2D(x3.descriptor.target, 0, x3.descriptor.pixelFormat, f8, g3, n11, n11, 0);
    const T6 = this.backgroundColor, y5 = T6 ? [T6.a * T6.r / 255, T6.a * T6.g / 255, T6.a * T6.b / 255, T6.a] : [1, 1, 1, 1], k2 = (d4 + s13.offset.x * i12) / h13 * 2 - 1, R4 = (p5 - s13.offset.y * i12) / m7 * 2 - 1, v4 = o13 / h13 * 2, j3 = o13 / m7 * 2, w6 = this._program;
    r12.bindVAO(this._vertexArrayObject), r12.bindTexture(this._overlayTexture, 6), r12.bindTexture(this._maskTexture, 7), r12.useProgram(w6), w6.setUniform4fv("u_background", y5), w6.setUniform1i("u_readbackTexture", 0), w6.setUniform1i("u_overlayTexture", 6), w6.setUniform1i("u_maskTexture", 7), w6.setUniform4f("u_drawPos", k2, R4, v4, j3), w6.setUniform1i("u_maskEnabled", s13.maskEnabled ? 1 : 0), w6.setUniform1i("u_overlayEnabled", s13.overlayEnabled ? 1 : 0), r12.setStencilTestEnabled(false), r12.setColorMask(true, true, true, true), r12.drawArrays(E2.TRIANGLE_STRIP, 0, 4), r12.bindVAO();
  }
  _canRender() {
    return this._mask && this._overlay && null != this._magnifier;
  }
  _reloadResources() {
    this._resourcesTask && this._resourcesTask.abort();
    const s13 = null != this._magnifier ? this._magnifier.maskUrl : null, t15 = null != this._magnifier ? this._magnifier.overlayUrl : null;
    this._resourcesTask = d((r12) => __async(this, null, function* () {
      const i12 = null == s13 || null == t15 ? s9(r12) : null, o13 = null != s13 ? U(s13, {
        responseType: "image",
        signal: r12
      }).then((e13) => e13.data) : i12.then((e13) => e13.mask), a9 = null != t15 ? U(t15, {
        responseType: "image",
        signal: r12
      }).then((e13) => e13.data) : i12.then((e13) => e13.overlay), [n11, l12] = yield Promise.all([o13, a9]);
      this._mask = n11, this._overlay = l12, this._disposeRenderResources(), this.requestRender();
    })), this.updatingHandles.addPromise(this._resourcesTask.promise);
  }
  _disposeRenderResources() {
    this._readbackTexture = r2(this._readbackTexture), this._overlayTexture = r2(this._overlayTexture), this._maskTexture = r2(this._maskTexture), this._vertexArrayObject = r2(this._vertexArrayObject), this._program = r2(this._program);
  }
  _updateResources(e13) {
    if (e13.pixelRatio !== this._resourcePixelRatio && this._disposeRenderResources(), this._readbackTexture) return;
    const r12 = e13.context;
    this._resourcePixelRatio = e13.pixelRatio;
    const s13 = Math.ceil(this._magnifier.size * e13.pixelRatio);
    this._program = t10(r12);
    const t15 = new Uint16Array([0, 1, 0, 0, 1, 1, 1, 0]), i12 = a5.attributes;
    this._vertexArrayObject = new o8(r12, i12, m4, {
      geometry: c.createVertex(r12, F.STATIC_DRAW, t15)
    }), this._overlay.width = s13, this._overlay.height = s13;
    const o13 = new e4();
    o13.internalFormat = G.RGBA, o13.wrapMode = D.CLAMP_TO_EDGE, o13.samplingMode = L3.NEAREST, o13.flipped = true, o13.preMultiplyAlpha = !Pt(this._overlay.src) || !e13.context.driverTest.svgPremultipliesAlpha.result, this._overlayTexture = new c2(r12, o13, this._overlay), this._mask.width = s13, this._mask.height = s13, o13.pixelFormat = o13.internalFormat = G.ALPHA, this._maskTexture = new c2(r12, o13, this._mask);
    const a9 = 1 / this._magnifier.factor;
    o13.pixelFormat = o13.internalFormat = G.RGBA, o13.width = o13.height = Math.ceil(a9 * s13), o13.samplingMode = L3.LINEAR, o13.flipped = false, this._readbackTexture = new c2(r12, o13);
  }
};
export {
  t9 as GraphicContainer,
  V as GraphicsView2D,
  a4 as LabelManager,
  A7 as MagnifierView2D,
  y4 as MapViewNavigation,
  q2 as Stage
};
//# sourceMappingURL=mapViewDeps-APWLEI4H.js.map
