{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/chunks/NativeLine.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { ShaderOutput as e } from \"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";\nimport { SliceDraw as o } from \"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";\nimport { Transform as r } from \"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";\nimport { VertexColor as i } from \"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js\";\nimport { OutputHighlight as t } from \"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";\nimport { symbolAlphaCutoff as s } from \"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";\nimport { addProjViewLocalOrigin as l } from \"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";\nimport { Float4PassUniform as a } from \"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";\nimport { FloatPassUniform as d } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as n } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as g } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { VertexAttribute as c } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nfunction u(u) {\n  const m = new g(),\n    {\n      vertex: p,\n      fragment: w\n    } = m;\n  return m.include(r, u), m.include(i, u), l(p, u), m.attributes.add(c.POSITION, \"vec3\"), m.varyings.add(\"vpos\", \"vec3\"), p.code.add(n`void main(void) {\nvpos = position;\nforwardNormalizedVertexColor();\ngl_Position = transformPosition(proj, view, vpos);\n}`), u.output === e.Highlight && m.include(t, u), m.include(o, u), w.uniforms.add(new d(\"alphaCoverage\", (e, o) => Math.min(1, e.width * o.camera.pixelRatio))), u.hasVertexColors || w.uniforms.add(new a(\"constantColor\", e => e.color)), w.code.add(n`\n  void main() {\n    discardBySlice(vpos);\n\n    vec4 color = ${u.hasVertexColors ? \"vColor\" : \"constantColor\"};\n\n    ${u.output === e.ObjectAndLayerIdColor ? n`color.a = 1.0;` : \"\"}\n\n    if (color.a < ${n.float(s)}) {\n      discard;\n    }\n\n    ${u.output === e.Color ? n`fragColor = highlightSlice(color, vpos);` : \"\"}\n    ${u.output === e.Highlight ? n`outputHighlight();` : \"\"}\n  }\n  `), m;\n}\nconst m = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: u\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { m as N, u as b };"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA,SAAS,EAAEA,IAAG;AACZ,QAAMC,KAAI,IAAIC,GAAE,GACd;AAAA,IACE,QAAQ;AAAA,IACR,UAAU;AAAA,EACZ,IAAID;AACN,SAAOA,GAAE,QAAQC,IAAGF,EAAC,GAAGC,GAAE,QAAQE,IAAGH,EAAC,GAAG,EAAE,GAAGA,EAAC,GAAGC,GAAE,WAAW,IAAI,EAAE,UAAU,MAAM,GAAGA,GAAE,SAAS,IAAI,QAAQ,MAAM,GAAG,EAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA,EAInI,GAAGD,GAAE,WAAWE,GAAE,aAAaD,GAAE,QAAQ,GAAGD,EAAC,GAAGC,GAAE,QAAQ,GAAGD,EAAC,GAAG,EAAE,SAAS,IAAI,IAAIE,GAAE,iBAAiB,CAACC,IAAGD,OAAM,KAAK,IAAI,GAAGC,GAAE,QAAQD,GAAE,OAAO,UAAU,CAAC,CAAC,GAAGF,GAAE,mBAAmB,EAAE,SAAS,IAAI,IAAIG,GAAE,iBAAiB,CAAAA,OAAKA,GAAE,KAAK,CAAC,GAAG,EAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA,mBAIpOH,GAAE,kBAAkB,WAAW,eAAe;AAAA;AAAA,MAE3DA,GAAE,WAAWE,GAAE,wBAAwB,oBAAoB,EAAE;AAAA;AAAA,oBAE/C,EAAE,MAAM,CAAC,CAAC;AAAA;AAAA;AAAA;AAAA,MAIxBF,GAAE,WAAWE,GAAE,QAAQ,8CAA8C,EAAE;AAAA,MACvEF,GAAE,WAAWE,GAAE,YAAY,wBAAwB,EAAE;AAAA;AAAA,GAExD,GAAGD;AACN;AACA,IAAM,IAAI,OAAO,OAAO,OAAO,eAAe;AAAA,EAC5C,WAAW;AAAA,EACX,OAAO;AACT,GAAG,OAAO,aAAa;AAAA,EACrB,OAAO;AACT,CAAC,CAAC;",
  "names": ["u", "m", "o", "e"]
}
