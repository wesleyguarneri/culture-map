{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/views/3d/environment/PrecipitationTechniqueConfiguration.js", "../../../../../../node_modules/@arcgis/core/chunks/Precipitation.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { _ as e } from \"../../../chunks/tslib.es6.js\";\nimport { parameter as n, ShaderTechniqueConfiguration as o } from \"../webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration.js\";\nvar t;\n!function (e) {\n  e[e.Rain = 0] = \"Rain\", e[e.Snow = 1] = \"Snow\", e[e.COUNT = 2] = \"COUNT\";\n}(t || (t = {}));\nclass i extends o {\n  constructor() {\n    super(...arguments), this.type = t.Rain;\n  }\n}\ne([n({\n  count: t.COUNT\n})], i.prototype, \"type\", void 0);\nexport { i as PrecipitationTechniqueConfiguration, t as PrecipitationType };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { J as e, s as t, z as o, j as i, n as a, m as r, o as n } from \"./vec32.js\";\nimport { create as s, fromValues as d } from \"../core/libs/gl-matrix-2/factories/vec3f64.js\";\nimport { PrecipitationType as c } from \"../views/3d/environment/PrecipitationTechniqueConfiguration.js\";\nimport { Float3PassUniform as m } from \"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";\nimport { FloatPassUniform as v } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as l } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as f } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { ShaderBuilder as p } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { VertexAttribute as u } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nfunction h(e) {\n  const t = new p();\n  return t.attributes.add(u.POSITION, \"vec3\"), t.attributes.add(u.INSTANCEFEATUREATTRIBUTE, \"float\"), t.vertex.uniforms.add(new m(\"cameraPosition\", (e, t) => t.camera.eye)), t.vertex.uniforms.add(new m(\"offset\", (e, t) => g(e, t))), t.vertex.uniforms.add(new v(\"width\", e => e.width)), t.vertex.uniforms.add(new f(\"proj\", (e, t) => t.camera.projectionMatrix)), t.vertex.uniforms.add(new f(\"view\", (e, t) => t.camera.viewMatrix)), t.vertex.uniforms.add(new v(\"time\", e => e.time)), t.varyings.add(\"vUv\", \"vec2\"), t.vertex.code.add(l`\n    vec3 hash31(float p){\n      vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n      p3 += dot(p3, p3.yzx + 33.33);\n      return fract((p3.xxy + p3.yzz) * p3.zyx);\n    }\n\n    float hash11(float p){\n      p = fract(p * 0.1031);\n      p *= p + 33.33;\n      p *= p + p;\n      return fract(p);\n    }\n\n    //https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\n    vec3 rotateVectorByQuaternion(vec3 v, vec4 q){\n      return 2.0 * cross(q.xyz, v * q.w + cross(q.xyz, v)) + v;\n    }\n\n    void main(void) {\n\n      vUv = position.xz;\n\n      vec3 rand = hash31(instanceFeatureAttribute);\n\n      // Set random position for all particles\n      // The hash function space is not high resolution so offset particles by an additional random value\n      // This creates grids of 1000 particles which are shifted by random hundreths of the tile width\n      // overlaying multiple identical but offset grids\n      vec3 randomPosition = 2.0 * (rand + (0.01 + 0.01 * rand) * floor(0.001 * instanceFeatureAttribute)) - 1.0;\n\n      // Random orientation of rain drops\n      float angle = 3.1415 * hash11(instanceFeatureAttribute);\n\n      vec3 up = vec3(0, 0, 1);\n\n      // Gravity and wind direction\n      vec3 direction = normalize(cameraPosition);\n\n      vec3 tangent = normalize(cross(direction, up));\n\n      // Gravity\n      vec3 animatedPos = randomPosition + direction * -time;\n\n      // Rain particles fall straight down and are randomly oriented\n      // Snow particles have random sinusoid trajectories and are rotated to face the camera\n      ${e.type === c.Rain ? l`\n            // Random rotation for particle\n            vec3 rotationAxis = up;\n            vec4 quat = vec4(rotationAxis * sin(angle), cos(angle));\n            vec3 transformedPos = rotateVectorByQuaternion(vec3(0.2, 0.2, 4.0) * (position - vec3(0.5, 0.0, 0.5)), quat);\n\n            // Rotate particle to planetary position\n            rotationAxis = tangent;\n            angle = 0.5 * -acos(dot(direction, up));\n            quat = vec4(rotationAxis * sin(angle), cos(angle));\n            transformedPos = rotateVectorByQuaternion(transformedPos, quat);\n\n            vec4 pos = mat4(mat3(view)) * vec4(transformedPos + (mod(width * animatedPos - offset, width) - 0.5 * width), 1.0);\n            gl_Position = proj * pos;\n      ` : l`\n            vec3 rotationAxis = direction;\n            vec4 quat = vec4(rotationAxis * sin(angle), cos(angle));\n\n            tangent = rotateVectorByQuaternion(tangent, quat);\n            // Random sinusoid from friction\n            animatedPos += tangent * 0.25 * sin(dot(animatedPos, direction));\n            vec4 pos = mat4(mat3(view)) * vec4((mod(width * animatedPos - offset, width) - 0.5 * width), 1.0);\n            gl_Position = proj * (0.5 * vec4(position.xzy, 0.0) + pos);\n      `}\n    }\n  `), t.fragment.uniforms.add(new v(\"opacity\", e => e.opacity), new m(\"particleColor\", (t, o) => w(o, e))), t.fragment.code.add(l`\n    void main() {\n\n      // Cut off corners of the triangle\n      if(vUv.x < 0.0 || vUv.y < 0.0){\n        discard;\n      }\n\n      float d = length(vUv - vec2(0.5));\n\n      ${e.type === c.Rain ? l`d = 0.35 * smoothstep(0.5, 0.0, d);` : l`d = smoothstep(0.5, 0.1, d);`}\n      fragColor = opacity * vec4(particleColor * d, d);\n    }\n  `), t;\n}\nfunction g(a, r) {\n  const n = r.camera.eye,\n    s = .5 * a.width,\n    d = 1 / a.width,\n    c = e(y, t(y, (n[0] + s) * d, (n[1] + s) * d, (n[2] + s) * d));\n  return o(c, n, i(c, c, a.width));\n}\nfunction w(e, t) {\n  const o = t.type === c.Rain ? P : b,\n    s = i(y, o, j),\n    d = e.camera.eye;\n  a(x, d);\n  const m = Math.max(0, r(x, e.lighting.mainLight.direction));\n  return n(s, s, o, m);\n}\nconst y = s(),\n  x = s(),\n  b = d(1, 1, 1),\n  P = d(.85, .85, .85),\n  j = .7,\n  A = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    build: h\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { A as P, h as b };"],
  "mappings": "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",
  "names": ["t", "e", "r", "e", "t", "o", "g", "r", "n", "P", "A"]
}
