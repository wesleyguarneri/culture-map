import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  E,
  I,
  N
} from "./chunk-MWMAA7SE.js";
import {
  d as d2,
  f,
  j as j2,
  p as p2,
  y
} from "./chunk-LUKDK354.js";
import {
  c,
  i as i3,
  o
} from "./chunk-6A4CZ4JY.js";
import "./chunk-MWDGD75N.js";
import {
  m
} from "./chunk-BYXMUOMW.js";
import "./chunk-YEWOBDQB.js";
import {
  $
} from "./chunk-FWEBARAB.js";
import "./chunk-RHUWRAPT.js";
import "./chunk-VY63YX6I.js";
import "./chunk-EXKCGLRO.js";
import "./chunk-WRLGLGM6.js";
import "./chunk-47DYJR3W.js";
import {
  j,
  x
} from "./chunk-NE35ZNG6.js";
import "./chunk-ZLSZAC2I.js";
import "./chunk-QRWQ6QBB.js";
import "./chunk-TFW6WS6R.js";
import {
  et,
  nt,
  ot,
  rt,
  tt
} from "./chunk-X5QZGB37.js";
import "./chunk-T5C2TZNO.js";
import "./chunk-AOGKNBDG.js";
import "./chunk-F4FQ67JP.js";
import "./chunk-FDI2X6GO.js";
import "./chunk-3XHDZQO5.js";
import "./chunk-2BLQXT54.js";
import "./chunk-JSWVKNBA.js";
import "./chunk-LL33G4DK.js";
import "./chunk-CILHMGNK.js";
import "./chunk-2BOKEEZV.js";
import {
  Z
} from "./chunk-5R3HARKC.js";
import "./chunk-BKSTWG4S.js";
import "./chunk-FSG7HOZQ.js";
import {
  i as i2
} from "./chunk-Q5TIVVER.js";
import "./chunk-RGG3YJQA.js";
import "./chunk-VOOO6FU5.js";
import "./chunk-NU4K6CTR.js";
import "./chunk-42ZAWY2C.js";
import "./chunk-TVHVZK5G.js";
import "./chunk-P2MUOE6G.js";
import "./chunk-CRYYUS4E.js";
import "./chunk-V33IUWAS.js";
import "./chunk-E5NWFBZG.js";
import "./chunk-FP37456K.js";
import "./chunk-VSQZQLTQ.js";
import "./chunk-K43CZ3M5.js";
import "./chunk-6EIBUVMG.js";
import "./chunk-YCXNHEGB.js";
import "./chunk-CSATD3VX.js";
import "./chunk-NXXQ35YM.js";
import "./chunk-LM3JDV4W.js";
import "./chunk-34V2CLL5.js";
import "./chunk-7V4JSBFA.js";
import "./chunk-ZT7V2AVD.js";
import "./chunk-C2OXE4NQ.js";
import "./chunk-KOI252FF.js";
import {
  H2 as H,
  K
} from "./chunk-I2TVVMQ6.js";
import "./chunk-5EGQYY2H.js";
import "./chunk-JKPUNUQA.js";
import "./chunk-SR7PRON4.js";
import "./chunk-HGHPYGKP.js";
import {
  p
} from "./chunk-4DSGTDZJ.js";
import "./chunk-VYTPFEL2.js";
import "./chunk-RLGDH6IY.js";
import "./chunk-MRPCXIVS.js";
import "./chunk-YTKVV2Y3.js";
import "./chunk-GCVQXAS4.js";
import "./chunk-UFQD6AL4.js";
import "./chunk-THZPD5CT.js";
import "./chunk-OBCA6CWH.js";
import {
  i
} from "./chunk-2JI245BP.js";
import "./chunk-CBOFHWPI.js";
import "./chunk-ABIG6PT5.js";
import "./chunk-ZEZ3LI2L.js";
import "./chunk-N34BRXVM.js";
import "./chunk-KETDH2J4.js";
import "./chunk-7QV7DHWN.js";
import "./chunk-4L4Y34YK.js";
import "./chunk-BXONKQKI.js";
import "./chunk-2HDBQXAR.js";
import "./chunk-RNF7VOCU.js";
import "./chunk-TIRJMGGG.js";
import "./chunk-ZDRQSPB6.js";
import "./chunk-DCXDXGAR.js";
import "./chunk-BCCDYCTQ.js";
import "./chunk-AYL3HQHD.js";
import "./chunk-66YQWHHE.js";
import "./chunk-QGBMZIP4.js";
import "./chunk-AOEBZVTA.js";
import "./chunk-2OZSYJDX.js";
import "./chunk-MZM4INJV.js";
import "./chunk-J4GMQHGL.js";
import "./chunk-MHPE4SZA.js";
import {
  G,
  g2 as g
} from "./chunk-6SSA7P3A.js";
import "./chunk-FQBTLEUI.js";
import "./chunk-GS7Y3YOG.js";
import "./chunk-Y2HYKTTT.js";
import {
  U
} from "./chunk-XLEC46FY.js";
import "./chunk-4AZPIP7K.js";
import "./chunk-G73HQZEL.js";
import "./chunk-LZSLQ24Q.js";
import "./chunk-U3RHUXYK.js";
import "./chunk-7DBI6LQG.js";
import {
  d
} from "./chunk-AUUN7RFQ.js";
import "./chunk-JAMSDYD6.js";
import "./chunk-PH6NPTP7.js";
import "./chunk-NUICEVIH.js";
import "./chunk-NXK752PZ.js";
import "./chunk-UVNLCXWD.js";
import "./chunk-PNUA7JOS.js";
import "./chunk-OR2FKGUM.js";
import "./chunk-UDMPWVPF.js";
import "./chunk-XJNKCEWL.js";
import {
  b
} from "./chunk-AIZ3T7E3.js";
import "./chunk-6UEMNP3E.js";
import "./chunk-6WGE3IUL.js";
import "./chunk-MLYB2YW4.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-6JFGZTLU.js";
import "./chunk-2ZJE6ZFX.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-XBPEBUD5.js";

// ../../../node_modules/@arcgis/core/layers/graphics/sources/geojson/GeoJSONSourceWorker.js
var D = {
  hasAttachments: false,
  capabilities: "query, editing, create, delete, update",
  useStandardizedQueries: true,
  supportsCoordinatesQuantization: true,
  supportsReturningQueryGeometry: true,
  advancedQueryCapabilities: {
    supportsQueryAttachments: false,
    supportsStatistics: true,
    supportsPercentileStatistics: true,
    supportsReturningGeometryCentroid: true,
    supportsQueryWithDistance: true,
    supportsDistinct: true,
    supportsReturningQueryExtent: true,
    supportsReturningGeometryProperties: false,
    supportsHavingClause: true,
    supportsOrderBy: true,
    supportsPagination: true,
    supportsQueryWithResultType: false,
    supportsSqlExpression: true,
    supportsDisjointSpatialRel: true
  }
};
var Q = class {
  constructor() {
    this._queryEngine = null, this._snapshotFeatures = (e) => __async(this, null, function* () {
      const t = yield this._fetch(e);
      return this._createFeatures(t);
    });
  }
  destroy() {
    this._queryEngine?.destroy(), this._queryEngine = this._createDefaultAttributes = null;
  }
  load(_0) {
    return __async(this, arguments, function* (e, t = {}) {
      this._loadOptions = {
        url: e.url,
        customParameters: e.customParameters
      };
      const i4 = [], [r] = yield Promise.all([e.url ? this._fetch(t?.signal) : null, this._checkProjection(e.spatialReference)]), n2 = I(r, {
        geometryType: e.geometryType
      }), o2 = e.fields || n2.fields || [], l = null != e.hasZ ? e.hasZ : n2.hasZ, u = n2.geometryType;
      let d3 = e.objectIdField || n2.objectIdFieldName || "__OBJECTID";
      const p3 = e.spatialReference || g;
      let c2 = e.timeInfo;
      o2 === n2.fields && n2.unknownFields.length > 0 && i4.push({
        name: "geojson-layer:unknown-field-types",
        message: "Some fields types couldn't be inferred from the features and were dropped",
        details: {
          unknownFields: n2.unknownFields
        }
      });
      const y2 = new Z(o2);
      let h = y2.get(d3);
      h ? ("esriFieldTypeString" !== h.type && (h.type = "esriFieldTypeOID"), h.editable = false, h.nullable = false, d3 = h.name) : (h = {
        alias: d3,
        name: d3,
        type: "string" === n2.objectIdFieldType ? "esriFieldTypeString" : "esriFieldTypeOID",
        editable: false,
        nullable: false
      }, o2.unshift(h));
      const _ = {};
      for (const a of o2) {
        if (null == a.name && (a.name = a.alias), null == a.alias && (a.alias = a.name), !a.name) throw new s("geojson-layer:invalid-field-name", "field name is missing", {
          field: a
        });
        if (!i2.jsonValues.includes(a.type)) throw new s("geojson-layer:invalid-field-type", `invalid type for field "${a.name}"`, {
          field: a
        });
        if (a.name !== h.name) {
          const e2 = H(a);
          void 0 !== e2 && (_[a.name] = e2);
        }
        null == a.length && (a.length = K(a));
      }
      if (c2) {
        if (c2.startTimeField) {
          const e2 = y2.get(c2.startTimeField);
          e2 ? (c2.startTimeField = e2.name, e2.type = "esriFieldTypeDate") : c2.startTimeField = null;
        }
        if (c2.endTimeField) {
          const e2 = y2.get(c2.endTimeField);
          e2 ? (c2.endTimeField = e2.name, e2.type = "esriFieldTypeDate") : c2.endTimeField = null;
        }
        if (c2.trackIdField) {
          const e2 = y2.get(c2.trackIdField);
          e2 ? c2.trackIdField = e2.name : (c2.trackIdField = null, i4.push({
            name: "geojson-layer:invalid-timeInfo-trackIdField",
            message: "trackIdField is missing",
            details: {
              timeInfo: c2
            }
          }));
        }
        c2.startTimeField || c2.endTimeField || (i4.push({
          name: "geojson-layer:invalid-timeInfo",
          message: "startTimeField and endTimeField are missing",
          details: {
            timeInfo: c2
          }
        }), c2 = null);
      }
      const F = u ? o(u) : void 0, b2 = y2.dateFields.length ? {
        timeZoneIANA: i
      } : null, T = {
        warnings: i4,
        featureErrors: [],
        layerDefinition: __spreadProps(__spreadValues({}, D), {
          drawingInfo: F ?? void 0,
          templates: c(_),
          extent: void 0,
          geometryType: u,
          objectIdField: d3,
          fields: o2,
          hasZ: !!l,
          timeInfo: c2,
          dateFieldsTimeReference: b2
        })
      };
      this._queryEngine = new $({
        fieldsIndex: Z.fromLayerJSON({
          fields: o2,
          timeInfo: c2,
          dateFieldsTimeReference: b2
        }),
        geometryType: u,
        hasM: false,
        hasZ: l,
        objectIdField: d3,
        spatialReference: p3,
        timeInfo: c2,
        featureStore: new m({
          geometryType: u,
          hasM: false,
          hasZ: l
        }),
        cacheSpatialQueries: true
      });
      const w = this._queryEngine.fieldsIndex.requiredFields.indexOf(h);
      w > -1 && this._queryEngine.fieldsIndex.requiredFields.splice(w, 1), this._createDefaultAttributes = i3(_, d3);
      const q = yield this._createFeatures(r);
      this._objectIdGenerator = this._createObjectIdGenerator(this._queryEngine, q);
      const x2 = this._normalizeFeatures(q, T.featureErrors);
      this._queryEngine.featureStore.addMany(x2);
      const {
        fullExtent: Q2,
        timeExtent: v
      } = yield this._queryEngine.fetchRecomputedExtents();
      if (T.layerDefinition.extent = Q2, v) {
        const {
          start: e2,
          end: t2
        } = v;
        T.layerDefinition.timeInfo.timeExtent = [e2, t2];
      }
      return T;
    });
  }
  applyEdits(e) {
    return __async(this, null, function* () {
      const {
        spatialReference: t,
        geometryType: s2
      } = this._queryEngine;
      return yield Promise.all([j2(t, s2), x(e.adds, t), x(e.updates, t)]), yield this._waitSnapshotComplete(), this._applyEdits(e);
    });
  }
  queryFeatures() {
    return __async(this, arguments, function* (e = {}, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
    });
  }
  queryFeatureCount() {
    return __async(this, arguments, function* (e = {}, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
    });
  }
  queryObjectIds() {
    return __async(this, arguments, function* (e = {}, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t.signal);
    });
  }
  queryExtent() {
    return __async(this, arguments, function* (e = {}, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
    });
  }
  querySnapping(_0) {
    return __async(this, arguments, function* (e, t = {}) {
      return yield this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e, t.signal);
    });
  }
  refresh(e) {
    return __async(this, null, function* () {
      this._loadOptions.customParameters = e, this._snapshotTask?.abort(), this._snapshotTask = d(this._snapshotFeatures), this._snapshotTask.promise.then((e2) => {
        this._queryEngine.featureStore.clear(), this._objectIdGenerator = this._createObjectIdGenerator(this._queryEngine, e2);
        const t = this._normalizeFeatures(e2);
        t && this._queryEngine.featureStore.addMany(t);
      }, (e2) => {
        this._queryEngine.featureStore.clear(), b(e2) || n.getLogger("esri.layers.GeoJSONLayer").error(new s("geojson-layer:refresh", "An error occurred during refresh", {
          error: e2
        }));
      }), yield this._waitSnapshotComplete();
      const {
        fullExtent: n2,
        timeExtent: a
      } = yield this._queryEngine.fetchRecomputedExtents();
      return {
        extent: n2,
        timeExtent: a
      };
    });
  }
  _createFeatures(e) {
    return __async(this, null, function* () {
      if (null == e) return [];
      const {
        geometryType: t,
        hasZ: s2,
        objectIdField: i4
      } = this._queryEngine, r = N(e, {
        geometryType: t,
        hasZ: s2,
        objectIdField: i4
      });
      if (!G(this._queryEngine.spatialReference, g)) for (const n2 of r) null != n2.geometry && (n2.geometry = ot(j(rt(n2.geometry, this._queryEngine.geometryType, this._queryEngine.hasZ, false), g, this._queryEngine.spatialReference)));
      return r;
    });
  }
  _waitSnapshotComplete() {
    return __async(this, null, function* () {
      if (this._snapshotTask && !this._snapshotTask.finished) {
        try {
          yield this._snapshotTask.promise;
        } catch {
        }
        return this._waitSnapshotComplete();
      }
    });
  }
  _fetch(t) {
    return __async(this, null, function* () {
      const {
        url: s2,
        customParameters: i4
      } = this._loadOptions, r = (yield U(s2 ?? "", {
        responseType: "json",
        query: __spreadValues({}, i4),
        signal: t
      })).data;
      return E(r), r;
    });
  }
  _normalizeFeatures(e, t) {
    const {
      objectIdField: s2,
      fieldsIndex: i4
    } = this._queryEngine, r = [];
    for (const n2 of e) {
      const e2 = this._createDefaultAttributes(), a = p2(i4, e2, n2.attributes, true);
      a ? t?.push(a) : (this._assignObjectId(e2, n2.attributes, true), n2.attributes = e2, n2.objectId = e2[s2], r.push(n2));
    }
    return r;
  }
  _applyEdits(e) {
    return __async(this, null, function* () {
      const {
        adds: t,
        updates: s2,
        deletes: i4
      } = e, r = {
        addResults: [],
        deleteResults: [],
        updateResults: [],
        uidToObjectId: {}
      };
      if (t?.length && this._applyAddEdits(r, t), s2?.length && this._applyUpdateEdits(r, s2), i4?.length) {
        for (const e2 of i4) r.deleteResults.push(d2(e2));
        this._queryEngine.featureStore.removeManyById(i4);
      }
      const {
        fullExtent: n2,
        timeExtent: a
      } = yield this._queryEngine.fetchRecomputedExtents();
      return {
        extent: n2,
        timeExtent: a,
        featureEditResults: r
      };
    });
  }
  _applyAddEdits(e, t) {
    const {
      addResults: s2
    } = e, {
      geometryType: i4,
      hasM: r,
      hasZ: a,
      objectIdField: o2,
      spatialReference: l,
      featureStore: u,
      fieldsIndex: p3
    } = this._queryEngine, c2 = [];
    for (const d3 of t) {
      if (d3.geometry && i4 !== p(d3.geometry)) {
        s2.push(f("Incorrect geometry type."));
        continue;
      }
      const t2 = this._createDefaultAttributes(), r2 = p2(p3, t2, d3.attributes);
      if (r2) s2.push(r2);
      else {
        if (this._assignObjectId(t2, d3.attributes), d3.attributes = t2, null != d3.uid) {
          const t3 = d3.attributes[o2];
          e.uidToObjectId[d3.uid] = t3;
        }
        if (null != d3.geometry) {
          const e2 = d3.geometry.spatialReference ?? l;
          d3.geometry = j(y(d3.geometry, e2), e2, l);
        }
        c2.push(d3), s2.push(d2(d3.attributes[o2]));
      }
    }
    u.addMany(et([], c2, i4, a, r, o2));
  }
  _applyUpdateEdits({
    updateResults: e
  }, t) {
    const {
      geometryType: s2,
      hasM: i4,
      hasZ: r,
      objectIdField: a,
      spatialReference: o2,
      featureStore: l,
      fieldsIndex: u
    } = this._queryEngine;
    for (const d3 of t) {
      const {
        attributes: t2,
        geometry: m2
      } = d3, y2 = t2?.[a];
      if (null == y2) {
        e.push(f(`Identifier field ${a} missing`));
        continue;
      }
      if (!l.has(y2)) {
        e.push(f(`Feature with object id ${y2} missing`));
        continue;
      }
      const f2 = nt(l.getFeature(y2), s2, r, i4);
      if (null != m2) {
        if (s2 !== p(m2)) {
          e.push(f("Incorrect geometry type."));
          continue;
        }
        const t3 = m2.spatialReference ?? o2;
        f2.geometry = j(y(m2, t3), t3, o2);
      }
      if (t2) {
        const s3 = p2(u, f2.attributes, t2);
        if (s3) {
          e.push(s3);
          continue;
        }
      }
      l.add(tt(f2, s2, r, i4, a)), e.push(d2(y2));
    }
  }
  _createObjectIdGenerator(e, t) {
    const s2 = e.fieldsIndex.get(e.objectIdField);
    if ("esriFieldTypeString" === s2.type) return () => s2.name + "-" + Date.now().toString(16);
    let i4 = Number.NEGATIVE_INFINITY;
    for (const r of t) r.objectId && (i4 = Math.max(i4, r.objectId));
    return i4 = Math.max(0, i4) + 1, () => i4++;
  }
  _assignObjectId(e, t, s2 = false) {
    const i4 = this._queryEngine.objectIdField;
    e[i4] = s2 && i4 in t ? t[i4] : this._objectIdGenerator();
  }
  _checkProjection(e) {
    return __async(this, null, function* () {
      try {
        yield x(g, e);
      } catch {
        throw new s("geojson-layer", "Projection not supported");
      }
    });
  }
};
export {
  Q as default
};
//# sourceMappingURL=GeoJSONSourceWorker-VVREB6U5.js.map
