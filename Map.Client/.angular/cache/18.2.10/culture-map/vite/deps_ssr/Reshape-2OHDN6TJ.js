import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  h as h5
} from "./chunk-SMONMTHO.js";
import {
  U
} from "./chunk-PW6RRNPT.js";
import {
  i as i3
} from "./chunk-4VYDNFW7.js";
import {
  h as h4
} from "./chunk-YJ3POSXJ.js";
import {
  e as e5
} from "./chunk-BUA2HOYZ.js";
import {
  f
} from "./chunk-3XDLGHCQ.js";
import {
  i,
  p as p3
} from "./chunk-GV2UXRKF.js";
import {
  G,
  T,
  V as V2,
  u as u2
} from "./chunk-S5TDQEKK.js";
import {
  i as i2
} from "./chunk-YE26MSDV.js";
import {
  h as h3,
  r
} from "./chunk-7B3BAV5J.js";
import "./chunk-L2VTN5PI.js";
import {
  l as l2
} from "./chunk-R3ALLGC4.js";
import "./chunk-HIZXJ32N.js";
import "./chunk-JGJES5EN.js";
import "./chunk-7J24PH7A.js";
import "./chunk-ZZE2XHDC.js";
import "./chunk-5E5FRWDI.js";
import {
  c as c3,
  m as m3
} from "./chunk-PVR7HFZS.js";
import "./chunk-DYMQWLSL.js";
import {
  e as e4
} from "./chunk-Q23C3NFQ.js";
import "./chunk-2I3RVFNX.js";
import "./chunk-MH54QISY.js";
import {
  R
} from "./chunk-JEWURWPQ.js";
import "./chunk-7HWP2QWI.js";
import "./chunk-DUZT23UA.js";
import "./chunk-ZEZCWQFR.js";
import {
  E2 as E,
  P as P2
} from "./chunk-VC76DE2W.js";
import "./chunk-6NBMJUQX.js";
import "./chunk-RFURERTV.js";
import "./chunk-MDOKECP3.js";
import "./chunk-IVVINOEJ.js";
import {
  p as p2
} from "./chunk-DUSY4H5O.js";
import "./chunk-XUM2DDAI.js";
import "./chunk-WQIJCG2D.js";
import "./chunk-BZGBXDFF.js";
import "./chunk-LUORW76W.js";
import {
  _ as _2
} from "./chunk-62PN4TEW.js";
import "./chunk-OPXEKSUB.js";
import "./chunk-P6I54QB7.js";
import "./chunk-NDXKLAFE.js";
import "./chunk-WYPPXVX7.js";
import {
  h as h2
} from "./chunk-T2SCEBLQ.js";
import {
  h
} from "./chunk-XP4RC2MQ.js";
import "./chunk-MXW2KGHZ.js";
import "./chunk-O7RCHW3H.js";
import "./chunk-LVERV6OU.js";
import "./chunk-HKAONIBH.js";
import "./chunk-2H3S7IXI.js";
import "./chunk-2B3WLK32.js";
import "./chunk-SNHVHW2N.js";
import "./chunk-5RF6XDV4.js";
import "./chunk-Q47GASPN.js";
import "./chunk-B63XAMYJ.js";
import "./chunk-THUD7LGO.js";
import "./chunk-B76NC7GX.js";
import "./chunk-EFLOBCAZ.js";
import "./chunk-QRWQ6QBB.js";
import "./chunk-ZSJNH2BT.js";
import "./chunk-ZFES27RA.js";
import "./chunk-XP2AJZUL.js";
import "./chunk-44ZUWZXU.js";
import "./chunk-NHYYZMJR.js";
import {
  l
} from "./chunk-GNCXYHNE.js";
import "./chunk-CSK4VZQ7.js";
import "./chunk-2TNGEJGS.js";
import "./chunk-OYGNGIHQ.js";
import "./chunk-GSG4T2KM.js";
import "./chunk-BZHHBBFX.js";
import "./chunk-GK5M6FUR.js";
import "./chunk-Y7SJWJAL.js";
import "./chunk-YGAXDKHF.js";
import "./chunk-4TOSJLKR.js";
import "./chunk-X36BR2QB.js";
import "./chunk-RGG3YJQA.js";
import {
  d as d3
} from "./chunk-NVOJILW6.js";
import "./chunk-KYPTWEOO.js";
import "./chunk-WVFB3H4O.js";
import "./chunk-C7BQE556.js";
import "./chunk-ZREJ3Y2F.js";
import "./chunk-IR6CVPPC.js";
import "./chunk-BBUQOCRA.js";
import "./chunk-YBUJLIWZ.js";
import "./chunk-DL2B6IFJ.js";
import "./chunk-VOOO6FU5.js";
import "./chunk-IUPJR3FF.js";
import {
  y as y2
} from "./chunk-TGZW6QWO.js";
import "./chunk-OYIDHTXG.js";
import "./chunk-KUBMHTYA.js";
import "./chunk-42ZAWY2C.js";
import "./chunk-TVHVZK5G.js";
import "./chunk-P2MUOE6G.js";
import "./chunk-VSQZQLTQ.js";
import "./chunk-K43CZ3M5.js";
import "./chunk-6EIBUVMG.js";
import "./chunk-S4XQLN73.js";
import "./chunk-YCXNHEGB.js";
import "./chunk-CSATD3VX.js";
import "./chunk-NXXQ35YM.js";
import "./chunk-LM3JDV4W.js";
import "./chunk-34V2CLL5.js";
import "./chunk-7V4JSBFA.js";
import "./chunk-EO2EW5KR.js";
import "./chunk-JEFPXTYT.js";
import "./chunk-MVS2BECH.js";
import "./chunk-UZ7IOCF3.js";
import "./chunk-TPLUZX3A.js";
import "./chunk-BGLJ2FAH.js";
import "./chunk-2EJFYNM7.js";
import "./chunk-DC5LRNPY.js";
import "./chunk-ASCK5HJ5.js";
import "./chunk-5X5U7R6O.js";
import "./chunk-XNLAOXPY.js";
import "./chunk-ZT7V2AVD.js";
import "./chunk-C2OXE4NQ.js";
import "./chunk-KOI252FF.js";
import "./chunk-I2TVVMQ6.js";
import "./chunk-5EGQYY2H.js";
import "./chunk-JKPUNUQA.js";
import "./chunk-SR7PRON4.js";
import "./chunk-HGHPYGKP.js";
import "./chunk-4DSGTDZJ.js";
import {
  c as c2
} from "./chunk-VYTPFEL2.js";
import "./chunk-RLGDH6IY.js";
import {
  m2
} from "./chunk-MRPCXIVS.js";
import {
  c,
  e as e3,
  m
} from "./chunk-YTKVV2Y3.js";
import "./chunk-GCVQXAS4.js";
import "./chunk-UFQD6AL4.js";
import "./chunk-HEG4CVDM.js";
import "./chunk-UVQYXHKM.js";
import "./chunk-M5N6UHWJ.js";
import "./chunk-EBCBYN6Y.js";
import "./chunk-ODFKYX74.js";
import "./chunk-EGBDRLCX.js";
import "./chunk-THZPD5CT.js";
import "./chunk-OBCA6CWH.js";
import "./chunk-2JI245BP.js";
import "./chunk-N34BRXVM.js";
import "./chunk-KETDH2J4.js";
import "./chunk-7QV7DHWN.js";
import "./chunk-4L4Y34YK.js";
import "./chunk-BXONKQKI.js";
import "./chunk-2HDBQXAR.js";
import "./chunk-RNF7VOCU.js";
import {
  _
} from "./chunk-TIRJMGGG.js";
import "./chunk-ZDRQSPB6.js";
import "./chunk-DCXDXGAR.js";
import "./chunk-BCCDYCTQ.js";
import "./chunk-AYL3HQHD.js";
import "./chunk-66YQWHHE.js";
import "./chunk-QGBMZIP4.js";
import "./chunk-AOEBZVTA.js";
import "./chunk-2OZSYJDX.js";
import "./chunk-MZM4INJV.js";
import "./chunk-J4GMQHGL.js";
import "./chunk-MHPE4SZA.js";
import "./chunk-6SSA7P3A.js";
import "./chunk-FQBTLEUI.js";
import "./chunk-GS7Y3YOG.js";
import "./chunk-Y2HYKTTT.js";
import "./chunk-XLEC46FY.js";
import "./chunk-4AZPIP7K.js";
import "./chunk-JSKTDZU2.js";
import "./chunk-G73HQZEL.js";
import {
  A,
  C,
  P,
  d as d2,
  p
} from "./chunk-LZSLQ24Q.js";
import {
  V
} from "./chunk-U3RHUXYK.js";
import "./chunk-7DBI6LQG.js";
import {
  d
} from "./chunk-AUUN7RFQ.js";
import {
  o as o2
} from "./chunk-JAMSDYD6.js";
import "./chunk-PH6NPTP7.js";
import {
  e as e2
} from "./chunk-NUICEVIH.js";
import "./chunk-NXK752PZ.js";
import {
  y
} from "./chunk-UVNLCXWD.js";
import "./chunk-PNUA7JOS.js";
import "./chunk-OR2FKGUM.js";
import {
  a3 as a
} from "./chunk-UDMPWVPF.js";
import "./chunk-XJNKCEWL.js";
import "./chunk-AIZ3T7E3.js";
import {
  o
} from "./chunk-6UEMNP3E.js";
import {
  e,
  n as n2,
  u
} from "./chunk-6WGE3IUL.js";
import "./chunk-MLYB2YW4.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-6JFGZTLU.js";
import "./chunk-2ZJE6ZFX.js";
import "./chunk-L4CMR4WM.js";
import "./chunk-7JIACICA.js";
import "./chunk-IE4UBD3F.js";
import "./chunk-IAO6HACY.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-XBPEBUD5.js";

// ../../../node_modules/@arcgis/core/views/interactive/tooltip/infos/TranslateVertexTooltipInfo.js
var i4 = class extends r {
  constructor(t) {
    super(t), this.type = "translate-vertex", this.distance = h2, this.elevation = null, this.area = null, this.totalLength = null;
  }
  clear() {
    this.distance = h2, this.elevation = null, this.area = null, this.totalLength = null;
  }
};
e2([y()], i4.prototype, "type", void 0), e2([y()], i4.prototype, "distance", void 0), e2([y()], i4.prototype, "elevation", void 0), e2([y()], i4.prototype, "area", void 0), e2([y()], i4.prototype, "totalLength", void 0), i4 = e2([a("esri.views.interactive.tooltip.infos.TranslateVertexTooltipInfo")], i4);

// ../../../node_modules/@arcgis/core/views/draw/support/reshapeTooltipUtils.js
function h6(t) {
  const e6 = {
    sketchOptions: t,
    viewType: "2d"
  };
  return {
    movePoint: new i(e6),
    selectedVertex: new p3(e6),
    translateGraphic: new i2(e6),
    translateVertices: new i4(e6)
  };
}
function d4(e6, r2) {
  let c4 = false;
  function a2() {
    const t = r2(), e7 = t.sketchOptions.tooltips.effectiveEnabled ? t.activeTooltipInfo : null;
    return __spreadProps(__spreadValues({}, t), {
      activeTooltipInfo: e7
    });
  }
  return o([d2(() => {
    const t = a2();
    return {
      context: t,
      geometry: t.graphic?.geometry,
      vertexGeometry: t.selectedVertex?.geometry
    };
  }, ({
    context: t
  }) => {
    c4 = true, x(t), e6.info = t.activeTooltipInfo, c4 = false;
  }, A), d2(() => {
    const t = a2(), {
      activeTooltipInfo: e7
    } = t;
    if (e7 && "key" in e7) return {
      context: t,
      key: e7.key
    };
  }, (t, e7) => {
    t && !c4 && e7 && t.key !== e7.key && w(t.context);
  }, C), T(e6)]);
}
function x(t) {
  const e6 = t.activeTooltipInfo;
  if (e6) {
    switch (e6?.type) {
      case "move-point":
        return T2(e6, t);
      case "selected-vertex":
        return j(e6, t);
    }
    e6.sketchOptions = t.sketchOptions;
  }
}
function T2(t, {
  graphic: e6
}) {
  k(t, e6, e6?.geometry);
}
function j(t, {
  graphic: e6,
  selectedVertex: o3
}) {
  k(t, e6, o3?.geometry);
  const n3 = e6?.geometry;
  switch (n3?.type) {
    case "polygon":
      t.geometryType = "polygon", t.totalLength.visible = false, t.area.actual = u2(n3);
      break;
    case "polyline":
      t.geometryType = "polyline", t.totalLength.actual = c3(n3), t.area.visible = false;
  }
}
function k(t, e6, o3) {
  e6 && "point" === o3?.type && (t.setLocationFromPoint(o3), t.elevation.actual = R(o3), t.elevation.visible = !!e6.geometry?.hasZ, t.elevation.readOnly = false, t.elevation.showAsZ = true);
}
function w(t) {
  function e6(e7, o4) {
    const n4 = o4?.geometry;
    if (!n4 || "point" !== n4.type) return;
    const {
      dx: i6,
      dy: r2,
      dz: s2
    } = V2(e7, n4);
    if (0 === i6 && 0 === r2 && 0 === s2) return;
    const {
      x: l3,
      y: p4,
      z: m4,
      m: f2,
      spatialReference: u3
    } = n4, y3 = new _({
      x: l3 + i6,
      y: p4 + r2,
      z: null != m4 ? m4 + s2 : void 0,
      m: f2,
      spatialReference: u3
    });
    t.updateGeometry(o4, y3, n4, i6, r2);
  }
  const {
    activeTooltipInfo: o3,
    graphic: n3,
    selectedVertex: i5
  } = t;
  switch (o3?.type) {
    case "move-point":
      return e6(o3, n3);
    case "selected-vertex":
      return e6(o3, i5);
  }
}
function I(t, e6, o3) {
  t.clear(), V3(t, e6, o3);
}
function U2(t, e6, o3, n3) {
  t.clear(), "polygon" === o3?.type ? t.area = u2(o3) : "polyline" === o3?.type && (t.totalLength = c3(o3)), V3(t, e6, n3);
}
function V3(t, o3, n3) {
  if (!n3) return;
  const {
    x: i5,
    y: c4
  } = n3.origin, s2 = o3.toMap(n3), a2 = o3.toMap(c2(i5, c4)), l3 = m3(a2, s2);
  t.distance = null != l3 ? l3 : h2;
}

// ../../../node_modules/@arcgis/core/views/draw/support/Reshape.js
var F = class {
  constructor(e6, t, i5) {
    this.graphic = e6, this.mover = t, this.selected = i5, this.type = "reshape-start";
  }
};
var P3 = class {
  constructor(e6, t, i5) {
    this.graphic = e6, this.mover = t, this.selected = i5, this.type = "reshape";
  }
};
var Z = class {
  constructor(e6, t, i5) {
    this.graphic = e6, this.mover = t, this.selected = i5, this.type = "reshape-stop";
  }
};
var X = class {
  constructor(e6, t, i5) {
    this.mover = e6, this.dx = t, this.dy = i5, this.type = "move-start";
  }
};
var Y = class {
  constructor(e6, t, i5) {
    this.mover = e6, this.dx = t, this.dy = i5, this.type = "move";
  }
};
var K = class {
  constructor(e6, t, i5) {
    this.mover = e6, this.dx = t, this.dy = i5, this.type = "move-stop";
  }
};
var N = class {
  constructor(e6) {
    this.added = e6, this.type = "vertex-select";
  }
};
var q = class {
  constructor(e6) {
    this.removed = e6, this.type = "vertex-deselect";
  }
};
var B = class {
  constructor(e6, t, i5, s2) {
    this.added = e6, this.graphic = t, this.oldGraphic = i5, this.vertices = s2, this.type = "vertex-add";
  }
};
var J = class {
  constructor(e6, t, i5, s2) {
    this.removed = e6, this.graphic = t, this.oldGraphic = i5, this.vertices = s2, this.type = "vertex-remove";
  }
};
var Q = h5.reshapeGraphics;
var W = {
  vertices: {
    default: new y2({
      style: "circle",
      size: Q.vertex.size,
      color: Q.vertex.color,
      outline: {
        color: Q.vertex.outlineColor,
        width: 1
      }
    }),
    hover: new y2({
      style: "circle",
      size: Q.vertex.hoverSize,
      color: Q.vertex.hoverColor,
      outline: {
        color: Q.vertex.hoverOutlineColor,
        width: 1
      }
    }),
    selected: new y2({
      style: "circle",
      size: Q.selected.size,
      color: Q.selected.color,
      outline: {
        color: Q.selected.outlineColor,
        width: 1
      }
    })
  },
  midpoints: {
    default: new y2({
      style: "circle",
      size: Q.midpoint.size,
      color: Q.midpoint.color,
      outline: {
        color: Q.midpoint.outlineColor,
        width: 1
      }
    }),
    hover: new y2({
      style: "circle",
      size: Q.midpoint.size,
      color: Q.midpoint.color,
      outline: {
        color: Q.midpoint.outlineColor,
        width: 1
      }
    })
  }
};
var $ = class extends o2.EventedAccessor {
  constructor(e6) {
    super(e6), this._activeOperationInfo = null, this._editGeometryOperations = null, this._graphicAttributes = {
      esriSketchTool: "box"
    }, this._mover = null, this._snappingContext = null, this._snappingGraphicsLayer = null, this._hoverGraphic = null, this._snappingTask = null, this._stagedVertex = null, this.tooltip = null, this.activeTooltipInfo = null, this.callbacks = {
      onReshapeStart() {
      },
      onReshape() {
      },
      onReshapeStop() {
      },
      onMoveStart() {
      },
      onMove() {
      },
      onMoveStop() {
      },
      onGraphicClick() {
      }
    }, this.enableMidpoints = true, this.enableMovement = true, this.enableVertices = true, this.graphic = null, this.layer = null, this.midpointGraphics = new V(), this.midpointSymbol = new y2({
      style: "circle",
      size: 6,
      color: [200, 200, 200],
      outline: {
        color: [100, 100, 100],
        width: 1
      }
    }), this.selectedVertices = new V(), this.snappingManager = null, this.symbols = W, this.sketchOptions = new l2(), this.type = "reshape", this.vertexGraphics = new V(), this.view = null;
  }
  initialize() {
    const e6 = this.view;
    this._highlightHelper = new h4({
      view: e6
    }), this._setup(), this.tooltip = new h3({
      view: this.view
    }), this.tooltipInfos = h6(this.sketchOptions), this.addHandles([p(() => e6?.ready, () => {
      const {
        layer: e7,
        view: t
      } = this;
      e5(t, e7), this.addHandles(t.on("key-down", (e8) => this._keyDownHandler(e8), _2.TOOL));
    }, {
      once: true,
      initial: true
    }), d2(() => this.graphic, () => this.refresh()), d2(() => this.layer, (e7, t) => {
      t && (this._clearSelection(), this._resetGraphics(t)), this.refresh();
    }), d2(() => this.enableMidpoints, () => this.refresh()), d4(this.tooltip, () => this._tooltipsContext), d2(() => this.view.effectiveTheme.accentColor, () => this._updateSymbolsForTheme(), P)]), this._updateTooltip();
  }
  destroy() {
    this._reset(), this._mover?.destroy(), this._mover = null, this.tooltip = u(this.tooltip);
  }
  get _coordinateHelper() {
    return this._editGeometryOperations?.data.coordinateHelper ?? P2(!!this.graphic.geometry?.hasZ, !!this.graphic.geometry?.hasM, this.view.spatialReference);
  }
  get _selectedVertex() {
    return 1 === this.selectedVertices.length ? this.selectedVertices.at(0) : void 0;
  }
  get _tooltipsContext() {
    return {
      sketchOptions: this.sketchOptions,
      activeTooltipInfo: this.activeTooltipInfo,
      graphic: this.graphic,
      selectedVertex: this._selectedVertex,
      updateGeometry: (e6, t, i5, s2, o3) => {
        this._setUpGeometryHelper();
        const r2 = e6 === this.graphic;
        r2 ? this._emitMoveStartEvent(0, 0) : this._emitReshapeStartEvent(e6);
        const n3 = true;
        if (this._syncGeometryAfterVertexMove(e6, t, s2, o3, n3), r2) {
          const {
            view: e7
          } = this, s3 = e7.toScreen(i5), o4 = e7.toScreen(t), r3 = (o4?.x ?? 0) - (s3?.x ?? 0), n4 = (o4?.y ?? 0) - (s3?.y ?? 0);
          this._emitMoveEvent(r3, n4), this._emitMoveStopEvent(r3, n4);
        } else this._emitReshapeEvent(e6), this._emitReshapeStopEvent(e6);
        this._editGeometryOperations = u(this._editGeometryOperations);
      }
    };
  }
  set highlightsEnabled(e6) {
    this._highlightHelper?.removeAll(), this._set("highlightsEnabled", e6), this._setUpHighlights();
  }
  get state() {
    const e6 = this.view.ready, t = !(!this.graphic || !this.layer);
    return e6 && t ? "active" : e6 ? "ready" : "disabled";
  }
  isUIGraphic(e6) {
    const t = [];
    return this.graphic && t.push(this.graphic), t.concat(this.vertexGraphics.items, this.midpointGraphics.items), t.length > 0 && t.includes(e6);
  }
  refresh() {
    this._reset(), this._setup();
  }
  reset() {
    this.graphic = null;
  }
  clearSelection() {
    this._clearSelection();
  }
  removeSelectedVertices() {
    const {
      selectedVertices: e6
    } = this;
    e6.length && this._removeVertices(e6);
  }
  _setup() {
    const {
      graphic: e6,
      layer: t
    } = this;
    if (!t || null == e6?.geometry) return;
    const i5 = e6.geometry;
    "mesh" !== i5.type && "extent" !== i5.type ? ("polygon" === i5.type && m(i5), this._setUpHighlights(), this._setupGraphics(), this._setupMover()) : this._logGeometryTypeError();
  }
  _setUpHighlights() {
    this.highlightsEnabled && this.graphic && this._highlightHelper?.add(this.graphic);
  }
  _setUpGeometryHelper() {
    const e6 = this.graphic.geometry;
    if (null == e6 || "mesh" === e6.type || "extent" === e6.type) return void this._logGeometryTypeError();
    const t = "multipoint" === e6.type ? new m2({
      paths: e6.points,
      spatialReference: e6.spatialReference
    }) : e6;
    this._editGeometryOperations = E.fromGeometry(t, l.Local);
  }
  _saveSnappingContextForHandle(e6, t) {
    this._snappingGraphicsLayer = new h({
      listMode: "hide",
      internal: true,
      title: "Reshape snapping layer"
    }), this.view.map.layers.add(this._snappingGraphicsLayer);
    const i5 = this._editGeometryOperations;
    n2(i5), this._snappingContext = new e4({
      editGeometryOperations: i5,
      elevationInfo: {
        mode: "on-the-ground",
        offset: 0
      },
      pointer: t.viewEvent?.pointerType || "mouse",
      excludeFeature: this.graphic,
      feature: this.graphic,
      visualizer: new f(this._snappingGraphicsLayer),
      vertexHandle: this._getVertexFromEditGeometry(e6)
    });
  }
  _reset() {
    this._clearSelection(), this._highlightHelper?.removeAll(), this._updateTooltip(), this._resetGraphics(), this._resetSnappingStateVars(), this._activeOperationInfo = null, this._mover && this._mover.destroy(), this._mover = null, this.view.cursor = "default";
  }
  _resetSnappingStateVars() {
    null != this.snappingManager && this.snappingManager.doneSnapping(), null != this._snappingGraphicsLayer && (this.view?.map && this.view.map.layers.remove(this._snappingGraphicsLayer), this._snappingGraphicsLayer.destroy()), this._editGeometryOperations = u(this._editGeometryOperations), this._snappingTask = e(this._snappingTask), this._snappingTask = null, this._snappingContext = null, this._stagedVertex = null;
  }
  _resetGraphics(e6) {
    this._removeMidpointGraphics(e6), this._removeVertexGraphics(e6), this.selectedVertices.removeAll(), this._updateTooltip();
  }
  _removeMidpointGraphics(e6) {
    const t = e6 || this.layer;
    t && t.removeMany(this.midpointGraphics.items), this.midpointGraphics.items.forEach((e7) => e7.destroy()), this.midpointGraphics.removeAll();
  }
  _removeVertexGraphics(e6) {
    const t = e6 || this.layer;
    t && t.removeMany(this.vertexGraphics.items), this.vertexGraphics.items.forEach((e7) => e7.destroy()), this.vertexGraphics.removeAll();
  }
  _setupGraphics() {
    const e6 = this.graphic.geometry;
    if (null != e6 && ("polyline" === e6.type || "polygon" === e6.type)) {
      const t = ee(e6);
      this.enableMidpoints && this._setUpMidpointGraphics(t), this.enableVertices && this._setUpVertexGraphics(t);
    }
  }
  _setUpMidpointGraphics(e6) {
    this._removeMidpointGraphics();
    const t = this._createMidpointGraphics(e6);
    this.midpointGraphics.addMany(t), this.layer.addMany(t);
  }
  _setUpVertexGraphics(e6) {
    this._removeVertexGraphics();
    const t = this._createVertexGraphics(e6);
    this.vertexGraphics.addMany(t), this._storeRelatedVertexIndices(), this.layer.addMany(t);
  }
  _createVertexGraphics(e6) {
    const {
      _graphicAttributes: i5,
      symbols: s2
    } = this, o3 = [];
    return e6?.forEach((e7, r2) => {
      e7.forEach((e8, n3) => {
        o3.push(new d3({
          geometry: this._coordinateHelper.arrayToPoint(e8),
          symbol: s2?.vertices?.default,
          attributes: __spreadProps(__spreadValues({}, i5), {
            pathIndex: r2,
            pointIndex: n3
          })
        }));
      });
    }), o3;
  }
  _createMidpointGraphics(e6) {
    const {
      _graphicAttributes: i5,
      symbols: s2
    } = this, o3 = [];
    for (let r2 = 0; r2 < e6.length; r2++) {
      const n3 = e6[r2];
      for (let e7 = 0; e7 < n3.length; e7++) {
        const h7 = (e7 + 1) % n3.length;
        if ("polyline" === this.graphic.geometry?.type && 0 === h7) continue;
        const p4 = n3[e7], a2 = n3[h7], c4 = this._getMidpoint(p4, a2);
        o3.push(new d3({
          geometry: c4,
          symbol: s2.midpoints.default,
          attributes: __spreadProps(__spreadValues({}, i5), {
            pathIndex: r2,
            pointIndexStart: e7,
            pointIndexEnd: h7
          })
        }));
      }
    }
    return o3;
  }
  _updateSymbolsForTheme() {
    const e6 = this.view.effectiveTheme.accentColor;
    this.symbols = {
      vertices: __spreadProps(__spreadValues({}, this.symbols.vertices), {
        default: this.symbols.vertices.default.clone().set("color", e6),
        hover: this.symbols.vertices.hover?.clone().set("color", e6)
      }),
      midpoints: __spreadValues({}, this.symbols.midpoints)
    };
    for (const t of this.vertexGraphics) this._isSelected(t) ? t.symbol = this.symbols.vertices.selected : this._hoverGraphic === t ? t.symbol = this.symbols.vertices.hover : t.symbol = this.symbols.vertices.default;
  }
  _storeRelatedVertexIndices() {
    const e6 = this.vertexGraphics.items;
    if (!e6) return;
    const t = e6.map(({
      geometry: e7
    }) => ({
      x: e7.x,
      y: e7.y
    }));
    for (let i5 = 0; i5 < t.length; i5++) {
      const s2 = [];
      for (let e7 = 0; e7 < t.length; e7++) {
        if (i5 === e7) continue;
        const o3 = t[i5], r2 = t[e7];
        o3.x === r2.x && o3.y === r2.y && s2.push(e7);
      }
      e6[i5].attributes.relatedGraphicIndices = s2;
    }
  }
  _setupMover() {
    const {
      enableMovement: e6,
      graphic: t,
      midpointGraphics: i5,
      vertexGraphics: s2,
      view: o3
    } = this, r2 = s2.concat(i5).items;
    e6 && r2.push(t), this._mover = new U({
      enableMoveAllGraphics: false,
      highlightsEnabled: false,
      indicatorsEnabled: false,
      graphics: r2,
      view: o3,
      callbacks: {
        onGraphicClick: (e7) => this._onGraphicClickCallback(e7),
        onGraphicMoveStart: (e7) => this._onGraphicMoveStartCallback(e7),
        onGraphicMove: (e7) => this._onGraphicMoveCallback(e7),
        onGraphicMoveStop: (e7) => this._onGraphicMoveStopCallback(e7),
        onGraphicPointerOver: (e7) => this._onGraphicPointerOverCallback(e7),
        onGraphicPointerOut: (e7) => this._onGraphicPointerOutCallback(e7)
      }
    });
  }
  _onGraphicClickCallback(e6) {
    e6.viewEvent.stopPropagation();
    const t = e6.graphic;
    if (t === this.graphic) this.clearSelection(), this.emit("graphic-click", e6), this.callbacks.onGraphicClick?.(e6);
    else if (this._isMidpoint(t)) {
      if (2 === e6.viewEvent.button) return;
      const i5 = this.graphic.clone(), s2 = this._createVertexFromMidpoint(t);
      this.refresh(), this._emitVertexAddEvent([t], i5, s2);
    } else if (this._isVertex(t)) if (e6.viewEvent.stopPropagation(), 2 === e6.viewEvent.button) this._removeVertices(t);
    else {
      e6.viewEvent.native.shiftKey || this._clearSelection(), this.selectedVertices.includes(t) ? this._removeFromSelection(t, true) : this._addToSelection(t);
    }
  }
  _setUpOperation(e6) {
    const {
      graphic: t,
      dx: i5,
      dy: s2
    } = e6, o3 = t === this.graphic;
    this._resetSnappingStateVars(), this._setUpGeometryHelper(), this._saveSnappingContextForHandle(t, e6), this._activeOperationInfo = {
      target: this.graphic,
      mover: t,
      operationType: o3 ? "move" : "reshape",
      totalDx: i5,
      totalDy: s2
    };
  }
  _onGraphicMoveStartCallback(e6) {
    const {
      dx: t,
      dy: i5,
      graphic: s2
    } = e6;
    if (s2 === this.graphic) {
      const {
        geometry: o3
      } = s2;
      return this._setUpOperation(e6), this._emitMoveStartEvent(t, i5), void (null != o3 && "point" === o3.type && this._onHandleMove(s2, t, i5, e6, () => {
        this._updateTooltip(this.graphic, e6.viewEvent), this._emitMoveEvent(t, i5);
      }));
    }
    if (!this.selectedVertices.includes(s2)) {
      if (this._clearSelection(), this._isMidpoint(s2)) {
        const e7 = this.graphic.clone(), t2 = this._createVertexFromMidpoint(s2);
        this._emitVertexAddEvent([s2], e7, t2);
      }
      this._addToSelection(s2);
    }
    this._setUpOperation(e6), this._emitReshapeStartEvent(s2), this._onHandleMove(s2, t, i5, e6, () => {
      this._updateTooltip(s2, e6.viewEvent), this._emitReshapeEvent(s2);
    });
  }
  _onGraphicMoveCallback(e6) {
    const t = this._activeOperationInfo;
    if (!t) return;
    const {
      dx: i5,
      dy: s2,
      graphic: o3
    } = e6;
    t.totalDx += i5, t.totalDy += s2;
    const {
      operationType: r2
    } = t, {
      geometry: n3
    } = o3;
    if (null != n3) {
      if ("move" !== r2) this._onHandleMove(o3, i5, s2, e6, () => {
        this._updateTooltip(o3, e6.viewEvent), this._emitReshapeEvent(o3);
      });
      else if ("point" === n3.type) this._onHandleMove(o3, i5, s2, e6, () => {
        this._updateTooltip(this.graphic, e6.viewEvent), this._emitMoveEvent(i5, s2);
      });
      else if ("polyline" === n3.type || "polygon" === n3.type) {
        const t2 = ee(n3);
        this._updateVertexGraphicLocations(t2), this._updateTooltip(this.graphic, e6.viewEvent), this._emitMoveEvent(i5, s2);
      }
    }
  }
  _onGraphicMoveStopCallback(e6) {
    const t = this._activeOperationInfo;
    if (!t) return;
    const {
      dx: i5,
      dy: s2,
      graphic: o3
    } = e6, {
      operationType: r2
    } = t;
    t.totalDx += i5, t.totalDy += s2, this._onHandleMove(o3, i5, s2, e6, () => "move" === r2 ? this._emitMoveStopEvent() : this._emitReshapeStopEvent(o3)), this._isMidpoint(o3) ? this.refresh() : (this._updateTooltip(this._isVertex(o3) ? o3 : null), this._resetSnappingStateVars(), this._activeOperationInfo = null);
  }
  _updateVertexGraphicLocations(e6) {
    const {
      _coordinateHelper: t
    } = this;
    for (const i5 of this.vertexGraphics) {
      const {
        pathIndex: s2,
        pointIndex: o3
      } = i5.attributes;
      i5.geometry = t.arrayToPoint(e6[s2][o3]);
    }
    this._updateMidpointGraphicLocations(e6);
  }
  _updateMidpointGraphicLocations(e6) {
    for (const t of this.midpointGraphics) {
      const {
        pathIndex: i5,
        pointIndexStart: s2,
        pointIndexEnd: o3
      } = t.attributes, r2 = e6[i5];
      t.geometry = this._getMidpoint(r2[s2], r2[o3]);
    }
  }
  _getMidpoint(e6, t) {
    const {
      _coordinateHelper: i5
    } = this, s2 = i5.arrayToVector(e6), o3 = i5.arrayToVector(t), r2 = i5.toXYZ(s2), n3 = i5.toXYZ(o3), [h7, p4, a2] = c(r2, n3), c4 = i5.hasM() ? 0 : void 0;
    return new _({
      x: h7,
      y: p4,
      z: a2,
      m: c4,
      spatialReference: i5.spatialReference
    });
  }
  _getVertexFromEditGeometry(e6) {
    const [t, i5] = te(e6);
    return n2(this._editGeometryOperations), this._editGeometryOperations.data.components[t].vertices[i5];
  }
  _onHandleMove(e6, t, s2, o3, r2) {
    e(this._snappingTask);
    const n3 = this._snappingContext;
    if (!n3) return;
    const h7 = e6.geometry, p4 = "graphic-move-stop" === o3.type;
    if (null != this.snappingManager && this.selectedVertices.length < 2 && !p4) {
      const o4 = this.snappingManager;
      this._stagedVertex = o4.update({
        point: h7,
        context: n3
      }), this._syncGeometryAfterVertexMove(e6, new _(this._stagedVertex), t, s2, p4), r2(), this._snappingTask = d((i5) => __async(this, null, function* () {
        const a2 = yield o4.snap({
          point: h7,
          context: n3,
          signal: i5
        });
        a2.valid && (this._stagedVertex = a2.apply(), this._syncGeometryAfterVertexMove(e6, new _(this._stagedVertex), t, s2, p4), r2());
      }));
    } else {
      const i5 = null != this._stagedVertex ? new _(this._stagedVertex) : h7;
      this._syncGeometryAfterVertexMove(e6, i5, t, s2, p4), r2();
    }
  }
  _syncGeometryAfterVertexMove(e6, t, i5, s2, o3 = false) {
    const r2 = this._editGeometryOperations?.data.geometry;
    if (r2) if ("point" === r2.type) e6.geometry = t;
    else if ("mesh" === r2.type) e6.geometry = r2.centerAt(t);
    else {
      const {
        _coordinateHelper: n3
      } = this, [h7, p4] = te(e6);
      let a2 = e3(r2);
      const c4 = a2[h7].length - 1, l3 = n3.pointToArray(t);
      a2[h7][p4] = l3, "polygon" === r2.type && (0 === p4 ? a2[h7][c4] = l3 : p4 === c4 && (a2[h7][0] = l3)), this._isVertex(e6) && (a2 = this._moveRelatedCoordinates(a2, e6, l3), a2 = this._moveSelectedHandleCoordinates(a2, e6, i5, s2, "polygon" === r2.type), this._updateMidpointGraphicLocations(a2)), this.graphic.geometry = r2.clone();
      const d5 = n3.pointToVector(t), m4 = this._getVertexFromEditGeometry(e6), v = n3.getZ(d5), y3 = d5[0] - m4.pos[0], _3 = d5[1] - m4.pos[1], u3 = null != v ? v - m4.pos[2] : 0;
      this._editGeometryOperations?.moveVertices([m4], y3, _3, u3), o3 && (this._mover ? this._mover.updateGeometry(this._mover.graphics.indexOf(e6), t) : e6.geometry = t);
    }
  }
  _moveRelatedCoordinates(e6, t, i5) {
    const {
      relatedGraphicIndices: s2
    } = t.attributes;
    for (const o3 of s2) {
      const s3 = this.vertexGraphics.at(o3), {
        pathIndex: r2,
        pointIndex: n3
      } = s3.attributes;
      e6[r2][n3] = i5, s3.geometry = t.geometry;
    }
    return e6;
  }
  _moveSelectedHandleCoordinates(e6, t, i5, s2, o3) {
    for (const r2 of this.selectedVertices) if (r2 !== t) {
      const {
        pathIndex: t2,
        pointIndex: n3,
        relatedGraphicIndices: h7
      } = r2.attributes, p4 = i3(r2.geometry, i5, s2, this.view), a2 = e3(p4), c4 = e6[t2].length - 1;
      e6[t2][n3] = a2, r2.geometry = p4, o3 && (0 === n3 ? e6[t2][c4] = a2 : n3 === c4 && (e6[t2][0] = a2));
      for (const i6 of h7) {
        const t3 = this.vertexGraphics.at(i6), {
          pathIndex: s3,
          pointIndex: o4
        } = t3.attributes;
        e6[s3][o4] = a2, t3.geometry = p4;
      }
    }
    return e6;
  }
  _onGraphicPointerOverCallback(e6) {
    const t = e6.graphic;
    this._hoverGraphic = t;
    const i5 = this._isVertex(t);
    i5 && !this._isSelected(t) && (t.symbol = this.symbols.vertices.hover), this._updateTooltip(i5 ? t : null), this._updateHoverCursor(t);
  }
  _onGraphicPointerOutCallback(e6) {
    const t = e6.graphic;
    this._hoverGraphic = null, this._isVertex(t) && !this._isSelected(t) && (t.symbol = this.symbols.vertices.default), this.view.cursor = "default", this._updateTooltip();
  }
  _createVertexFromMidpoint(e6) {
    const {
      _graphicAttributes: t,
      graphic: i5
    } = this, s2 = i5.geometry;
    if (null == s2 || "polygon" !== s2.type && "polyline" !== s2.type) return [];
    const o3 = s2.clone(), r2 = [], {
      pathIndex: n3,
      pointIndexStart: h7,
      pointIndexEnd: p4
    } = e6.attributes, a2 = e3(e6.geometry), c4 = 0 === p4 ? h7 + 1 : p4, l3 = e3(o3);
    return l3[n3].splice(c4, 0, a2), e6.attributes = __spreadProps(__spreadValues({}, t), {
      pathIndex: n3,
      pointIndex: c4,
      relatedGraphicIndices: []
    }), r2.push({
      coordinates: l3[n3][c4],
      componentIndex: n3,
      vertexIndex: c4
    }), this.graphic.geometry = o3, r2;
  }
  _addToSelection(e6) {
    e6.symbol = this.symbols.vertices.selected, this.selectedVertices.add(e6), this._emitSelectEvent([e6]), this._updateTooltip(e6);
  }
  _removeFromSelection(e6, t) {
    const {
      vertices: i5
    } = this.symbols, s2 = t ? i5.hover : i5.default;
    this.selectedVertices.remove(e6), e6.symbol = s2, this._emitDeselectEvent([e6]), this._updateTooltip();
  }
  _clearSelection() {
    const e6 = this.selectedVertices.toArray();
    if (e6.length > 0) {
      for (const t of e6) t.set("symbol", this.symbols.vertices.default);
      this.selectedVertices.removeAll(), this._emitDeselectEvent(e6), this._updateTooltip();
    }
  }
  _keyDownHandler(e6) {
    null == this._activeOperationInfo && G(e6, this.tooltip) || p2.delete.includes(e6.key) && !e6.repeat && this.selectedVertices.length && this._removeVertices(this.selectedVertices);
  }
  _removeVertices(e6) {
    const t = this.graphic.geometry;
    if (null == t || "polygon" !== t.type && "polyline" !== t.type) return;
    if ("polygon" === t.type && this.vertexGraphics.length < 4 || this.vertexGraphics.length < 3) return;
    const i5 = this.graphic.clone(), s2 = t.clone();
    let o3 = e3(s2);
    const r2 = [], n3 = ie(e6);
    for (const h7 of n3) {
      const {
        x: e7,
        y: t2
      } = h7.geometry;
      for (let i6 = 0; i6 < o3.length; i6++) {
        const s3 = o3[i6];
        for (let n4 = 0; n4 < s3.length; n4++) {
          const [h8, p4] = s3[n4];
          e7 === h8 && t2 === p4 && (r2.push({
            coordinates: o3[i6][n4],
            componentIndex: i6,
            vertexIndex: n4
          }), o3[i6].splice(Number(n4), 1));
        }
      }
    }
    if ("polygon" === s2.type) o3 = o3.filter((e7) => {
      if (e7.length < 2) return false;
      const [t2, i6] = e7[0], [s3, o4] = e7[e7.length - 1];
      return (2 !== e7.length || t2 !== s3 || i6 !== o4) && (t2 === s3 && i6 === o4 || e7.push(e7[0]), true);
    }), s2.rings = o3;
    else {
      for (const e7 of o3) 1 === e7.length && o3.splice(o3.indexOf(e7), 1);
      s2.paths = o3;
    }
    this.graphic.geometry = s2, this.refresh(), this._emitVertexRemoveEvent(n3, i5, r2);
  }
  _isVertex(e6) {
    return this.vertexGraphics.includes(e6);
  }
  _isSelected(e6) {
    return this._isVertex(e6) && this.selectedVertices.includes(e6);
  }
  _isMidpoint(e6) {
    return this.midpointGraphics.includes(e6);
  }
  _updateHoverCursor(e6) {
    this.view.cursor = this._isMidpoint(e6) ? "copy" : "move";
  }
  _updateTooltip(e6, t) {
    let i5 = null;
    const {
      graphic: s2,
      view: o3,
      tooltipInfos: r2
    } = this, n3 = s2?.geometry;
    "point" === n3?.type ? i5 = r2.movePoint : this._selectedVertex ? i5 = r2.selectedVertex : e6 === this.graphic ? (i5 = r2.translateGraphic, I(i5, o3, t)) : e6 && this.selectedVertices.length > 1 && (i5 = r2.translateVertices, U2(i5, o3, n3, t)), this.activeTooltipInfo = i5;
  }
  _emitMoveStartEvent(e6, t) {
    const i5 = new X(this.graphic, e6, t);
    this.emit("move-start", i5), this.callbacks.onMoveStart?.(i5);
  }
  _emitMoveEvent(e6, t) {
    const i5 = new Y(this.graphic, e6, t);
    this.emit("move", i5), this.callbacks.onMove?.(i5);
  }
  _emitMoveStopEvent(e6, t) {
    if (null == e6 || null == t) {
      const i6 = this._activeOperationInfo;
      if (!i6) return;
      e6 = i6.totalDx, t = i6.totalDy;
    }
    const i5 = new K(this.graphic, e6, t);
    this.emit("move-stop", i5), this.callbacks.onMoveStop?.(i5);
  }
  _emitReshapeStartEvent(e6) {
    const t = new F(this.graphic, e6, this.selectedVertices.toArray());
    this.emit("reshape-start", t), this.callbacks.onReshapeStart?.(t);
  }
  _emitReshapeEvent(e6) {
    const t = new P3(this.graphic, e6, this.selectedVertices.toArray());
    this.emit("reshape", t), this.callbacks.onReshape?.(t);
  }
  _emitReshapeStopEvent(e6) {
    const t = new Z(this.graphic, e6, this.selectedVertices.toArray());
    this.emit("reshape-stop", t), this.callbacks.onReshapeStop?.(t);
  }
  _emitSelectEvent(e6) {
    const t = new N(e6);
    this.emit("select", t), this.callbacks.onVertexSelect?.(t);
  }
  _emitDeselectEvent(e6) {
    const t = new q(e6);
    this.emit("deselect", t), this.callbacks.onVertexDeselect?.(t);
  }
  _emitVertexAddEvent(e6, t, i5) {
    const s2 = new B(e6, this.graphic, t, i5);
    this.emit("vertex-add", s2), this.callbacks.onVertexAdd?.(s2);
  }
  _emitVertexRemoveEvent(e6, t, i5) {
    const s2 = new J(e6, this.graphic, t, i5);
    this.emit("vertex-remove", s2), this.callbacks.onVertexRemove?.(s2);
  }
  _logGeometryTypeError() {
    n.getLogger(this).error(new s("reshape:invalid-geometry", "Reshape operation not supported for the provided graphic. The geometry type is not supported."));
  }
};
function ee(e6) {
  const t = e3(e6.clone());
  if ("polygon" === e6.type) for (const i5 of t) {
    const e7 = i5[i5.length - 1];
    i5[0][0] === e7[0] && i5[0][1] === e7[1] && i5.length > 2 && i5.pop();
  }
  return t;
}
function te({
  attributes: e6
}) {
  return [e6?.pathIndex || 0, e6?.pointIndex || 0];
}
function ie(e6) {
  return e6 instanceof d3 ? [e6] : [...e6];
}
e2([y()], $.prototype, "_activeOperationInfo", void 0), e2([y()], $.prototype, "_coordinateHelper", null), e2([y()], $.prototype, "_editGeometryOperations", void 0), e2([y()], $.prototype, "tooltip", void 0), e2([y()], $.prototype, "tooltipInfos", void 0), e2([y()], $.prototype, "activeTooltipInfo", void 0), e2([y()], $.prototype, "_selectedVertex", null), e2([y()], $.prototype, "_tooltipsContext", null), e2([y()], $.prototype, "callbacks", void 0), e2([y()], $.prototype, "enableMidpoints", void 0), e2([y()], $.prototype, "enableMovement", void 0), e2([y()], $.prototype, "enableVertices", void 0), e2([y()], $.prototype, "graphic", void 0), e2([y({
  value: true
})], $.prototype, "highlightsEnabled", null), e2([y()], $.prototype, "layer", void 0), e2([y({
  readOnly: true
})], $.prototype, "midpointGraphics", void 0), e2([y()], $.prototype, "midpointSymbol", void 0), e2([y({
  readOnly: true
})], $.prototype, "selectedVertices", void 0), e2([y()], $.prototype, "snappingManager", void 0), e2([y({
  readOnly: true
})], $.prototype, "state", null), e2([y()], $.prototype, "symbols", void 0), e2([y({
  type: l2
})], $.prototype, "sketchOptions", void 0), e2([y({
  readOnly: true
})], $.prototype, "type", void 0), e2([y({
  readOnly: true
})], $.prototype, "vertexGraphics", void 0), e2([y()], $.prototype, "view", void 0), $ = e2([a("esri.views.draw.support.Reshape")], $);
var se = $;
export {
  se as default
};
//# sourceMappingURL=Reshape-2OHDN6TJ.js.map
