{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/smartMapping/support/utils.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { convertDateFormatToIntlOptions as t, formatDate as e, formatTimestamp as r, formatTimeOnly as i, formatDateOnly as n } from \"../../intl/date.js\";\nimport { isDateField as s, isDateOnlyField as o, isTimestampOffsetField as a } from \"../../layers/support/fieldUtils.js\";\nimport { loadArcade as c } from \"../../support/arcadeOnDemand.js\";\nimport { getWellKnownBasemapId as l } from \"../../support/basemapUtils.js\";\nimport { getTimeZoneFormattingOptions as g, utc as d } from \"../../time/timeZoneUtils.js\";\nconst m = \",\",\n  u = {\n    light: [\"streets\", \"gray\", \"topo\", \"terrain\", \"oceans\", \"osm\", \"gray-vector\", \"streets-vector\", \"topo-vector\", \"streets-relief-vector\", \"streets-navigation-vector\", \"topo-3d\", \"navigation-3d\", \"streets-3d\", \"osm-3d\", \"gray-3d\", \"arcgis-light-gray\", \"arcgis-navigation\", \"arcgis-streets\", \"arcgis-streets-relief\", \"arcgis-topographic\", \"arcgis-oceans\", \"osm-standard\", \"osm-standard-relief\", \"osm-streets\", \"osm-streets-relief\", \"osm-light-gray\", \"arcgis-terrain\", \"arcgis-charted-territory\", \"arcgis-community\", \"arcgis-colored-pencil\", \"arcgis-modern-antique\", \"arcgis-midcentury\", \"arcgis-newspaper\", \"arcgis-hillshade-light\"],\n    dark: [\"satellite\", \"hybrid\", \"dark-gray\", \"dark-gray-vector\", \"streets-night-vector\", \"navigation-dark-3d\", \"streets-dark-3d\", \"dark-gray-3d\", \"arcgis-imagery\", \"arcgis-imagery-standard\", \"arcgis-dark-gray\", \"arcgis-navigation-night\", \"arcgis-streets-night\", \"osm-dark-gray\", \"arcgis-nova\", \"arcgis-hillshade-dark\"]\n  },\n  f = \"percent-of-total\",\n  p = \"field\",\n  y = {\n    years: 365,\n    months: 30,\n    days: 1,\n    hours: 1 / 24,\n    minutes: 1 / 1440,\n    seconds: 1 / 86400,\n    milliseconds: 1 / 864e5\n  },\n  h = new Set([\"integer\", \"small-integer\"]);\nlet v = null;\nconst T = [\"date\", \"date-only\", \"timestamp-offset\"];\nfunction Z(t) {\n  return s(t) || o(t) || a(t);\n}\nasync function $(t) {\n  const {\n    field: e,\n    field2: r,\n    field3: i,\n    normalizationField: n,\n    valueExpression: s\n  } = t;\n  let o = [];\n  if (s) {\n    if (!v) {\n      const {\n        arcadeUtils: t\n      } = await c();\n      v = t;\n    }\n    o = v.extractFieldNames(s);\n  }\n  return e && o.push(e), r && o.push(r), i && o.push(i), n && o.push(n), o;\n}\nfunction w(t) {\n  let e = t.normalizationType;\n  return e || (t.normalizationField ? e = p : null != t.normalizationTotal && (e = f)), e ?? void 0;\n}\nfunction U(t) {\n  return String(t).padStart(2, \"0\");\n}\nfunction k(t, e, r) {\n  let i;\n  if (\"date\" === e || \"number\" === e) {\n    \"number\" === e && (t = new Date(t));\n    i = `TIMESTAMP'${r ? t.getFullYear() : t.getUTCFullYear()}-${U((r ? t.getMonth() : t.getUTCMonth()) + 1)}-${U(r ? t.getDate() : t.getUTCDate())} ${U(r ? t.getHours() : t.getUTCHours())}:${U(r ? t.getMinutes() : t.getUTCMinutes())}:${U(r ? t.getSeconds() : t.getUTCSeconds())}'`;\n  } else i = t;\n  return i;\n}\nfunction D(t, e, r, i) {\n  const {\n      hasQueryEngine: n\n    } = t,\n    s = `(${k(r, S(t, r), n)} - ${k(e, S(t, e), n)})`;\n  let o = y[i],\n    a = \"/\";\n  o < 1 && (o = 1 / o, a = \"*\");\n  return {\n    sqlExpression: 1 === o ? s : `(${s} ${a} ${o})`,\n    sqlWhere: null\n  };\n}\nfunction S(t, e) {\n  if (e instanceof Date) return \"date\";\n  if (\"number\" == typeof e) return \"number\";\n  if (\"string\" == typeof e) {\n    const r = t.getField(e);\n    if (\"<now>\" === e.toLowerCase()) return;\n    if (s(r)) return \"field\";\n  }\n}\nfunction C(t, e = u) {\n  for (const r in e) if (e[r].includes(t)) return r;\n}\nfunction F(t, e, r = !0) {\n  let i = null;\n  return t && (\"string\" == typeof t ? e.includes(t) && (i = t) : i = l(t)), r ? i || \"gray\" : i;\n}\nfunction b(t, e) {\n  const r = e && t.getField(e);\n  return !!r && h.has(r.type);\n}\nfunction M(t) {\n  return `cast(${t} as float)`;\n}\nfunction N(s, o) {\n  const {\n    format: a,\n    timeZoneOptions: c,\n    fieldType: l\n  } = o ?? {};\n  let m, u;\n  if (c && ({\n    timeZone: m,\n    timeZoneName: u\n  } = g(c.layerTimeZone, c.datesInUnknownTimezone, c.viewTimeZone, t(a || \"short-date-short-time\"), l)), \"string\" == typeof s && isNaN(Date.parse(\"time-only\" === l ? `1970-01-01T${s}Z` : s))) return s;\n  switch (l) {\n    case \"date-only\":\n      {\n        const r = t(a || \"short-date\");\n        return \"string\" == typeof s ? n(s, {\n          ...r\n        }) : e(s, {\n          ...r,\n          timeZone: d\n        });\n      }\n    case \"time-only\":\n      {\n        const r = t(a || \"short-time\");\n        return \"string\" == typeof s ? i(s, r) : e(s, {\n          ...r,\n          timeZone: d\n        });\n      }\n    case \"timestamp-offset\":\n      {\n        if (!m && \"string\" == typeof s && new Date(s).toISOString() !== s) return s;\n        const i = a || c ? t(a || \"short-date-short-time\") : void 0,\n          n = i ? {\n            ...i,\n            timeZone: m,\n            timeZoneName: u\n          } : void 0;\n        return \"string\" == typeof s ? r(s, n) : e(s, n);\n      }\n    default:\n      {\n        const r = a || c ? t(a || \"short-date-short-time\") : void 0;\n        return e(\"string\" == typeof s ? new Date(s) : s, r ? {\n          ...r,\n          timeZone: m,\n          timeZoneName: u\n        } : void 0);\n      }\n  }\n}\nexport { M as castIntegerFieldToFloat, T as dateTypes, u as defaultBasemapGroups, m as fieldDelimiter, N as formatAnyDate, C as getBasemapGroup, F as getBasemapId, D as getDateDiffSQL, S as getDateType, $ as getFieldsList, w as getNormalizationType, Z as isAnyDateField, b as isIntegerField, y as unitValueInDays };"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;AASA,IAOE,IAAI;AAAA,EACF,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO,IAAI;AAAA,EACX,SAAS,IAAI;AAAA,EACb,SAAS,IAAI;AAAA,EACb,cAAc,IAAI;AACpB;AAIF,SAAS,EAAE,GAAG;AACZ,SAAO,GAAE,CAAC,KAAK,GAAE,CAAC,KAAK,GAAE,CAAC;AAC5B;AAwEA,SAAS,EAAE,GAAG,GAAG;AACf,QAAM;AAAA,IACJ,QAAQ;AAAA,IACR,iBAAiB;AAAA,IACjB,WAAW;AAAA,EACb,IAAI,KAAK,CAAC;AACV,MAAI,GAAG;AACP,MAAI,MAAM;AAAA,IACR,UAAU;AAAA,IACV,cAAc;AAAA,EAChB,IAAI,EAAE,EAAE,eAAe,EAAE,wBAAwB,EAAE,cAAc,EAAE,KAAK,uBAAuB,GAAG,CAAC,IAAI,YAAY,OAAO,KAAK,MAAM,KAAK,MAAM,gBAAgB,IAAI,cAAc,CAAC,MAAM,CAAC,CAAC,EAAG,QAAO;AACrM,UAAQ,GAAG;AAAA,IACT,KAAK,aACH;AACE,YAAM,IAAI,EAAE,KAAK,YAAY;AAC7B,aAAO,YAAY,OAAO,IAAI,EAAE,GAAG,mBAC9B,EACJ,IAAI,EAAE,GAAG,iCACL,IADK;AAAA,QAER,UAAU;AAAA,MACZ,EAAC;AAAA,IACH;AAAA,IACF,KAAK,aACH;AACE,YAAM,IAAI,EAAE,KAAK,YAAY;AAC7B,aAAO,YAAY,OAAO,IAAI,EAAE,GAAG,CAAC,IAAI,EAAE,GAAG,iCACxC,IADwC;AAAA,QAE3C,UAAU;AAAA,MACZ,EAAC;AAAA,IACH;AAAA,IACF,KAAK,oBACH;AACE,UAAI,CAAC,KAAK,YAAY,OAAO,KAAK,IAAI,KAAK,CAAC,EAAE,YAAY,MAAM,EAAG,QAAO;AAC1E,YAAMA,KAAI,KAAK,IAAI,EAAE,KAAK,uBAAuB,IAAI,QACnD,IAAIA,KAAI,iCACHA,KADG;AAAA,QAEN,UAAU;AAAA,QACV,cAAc;AAAA,MAChB,KAAI;AACN,aAAO,YAAY,OAAO,IAAI,EAAE,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC;AAAA,IAChD;AAAA,IACF,SACE;AACE,YAAM,IAAI,KAAK,IAAI,EAAE,KAAK,uBAAuB,IAAI;AACrD,aAAO,EAAE,YAAY,OAAO,IAAI,IAAI,KAAK,CAAC,IAAI,GAAG,IAAI,iCAChD,IADgD;AAAA,QAEnD,UAAU;AAAA,QACV,cAAc;AAAA,MAChB,KAAI,MAAM;AAAA,IACZ;AAAA,EACJ;AACF;",
  "names": ["i"]
}
