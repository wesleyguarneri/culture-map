{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/IntegerDrawUniform.js", "../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/collections/Component/Material/shader/ComponentData.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { Uniform as r } from \"./Uniform.js\";\nimport { BindType as e } from \"../shaderTechnique/BindType.js\";\nclass o extends r {\n  constructor(r, o) {\n    super(r, \"int\", e.Draw, (e, s, i) => e.setUniform1i(r, o(s, i)));\n  }\n}\nexport { o as IntegerDrawUniform };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { neverReached as o } from \"../../../../../../../core/compilerUtils.js\";\nimport { packFloatRGBA as e } from \"../../../../../../../core/floatRGBA.js\";\nimport has from \"../../../../../../../core/has.js\";\nimport { DecodeSymbolColor as r } from \"./DecodeSymbolColor.glsl.js\";\nimport { ShaderOutput as t } from \"../../../../core/shaderLibrary/ShaderOutput.js\";\nimport { RgbaFloatEncoding as n } from \"../../../../core/shaderLibrary/util/RgbaFloatEncoding.glsl.js\";\nimport { Float4DrawUniform as a } from \"../../../../core/shaderModules/Float4DrawUniform.js\";\nimport { IntegerDrawUniform as d } from \"../../../../core/shaderModules/IntegerDrawUniform.js\";\nimport { glsl as l } from \"../../../../core/shaderModules/interfaces.js\";\nimport { Texture2DDrawUniform as c } from \"../../../../core/shaderModules/Texture2DDrawUniform.js\";\nimport { VertexAttribute as i } from \"../../../../lib/VertexAttribute.js\";\nvar s;\n!function (o) {\n  o[o.Uniform = 0] = \"Uniform\", o[o.Varying = 1] = \"Varying\", o[o.COUNT = 2] = \"COUNT\";\n}(s || (s = {}));\nconst x = 429496.7296;\nfunction C(o, r) {\n  e(o / x * .5 + .5, r);\n}\nfunction m(e, r) {\n  switch (r.componentData) {\n    case s.Varying:\n      return f(e, r);\n    case s.Uniform:\n      return u(e, r);\n    case s.COUNT:\n      return;\n    default:\n      o(r.componentData);\n  }\n}\nfunction f(o, e) {\n  const {\n    vertex: a,\n    fragment: d\n  } = o;\n  a.include(n), a.uniforms.add(new c(\"componentColorTex\", o => o.componentParameters.texture.texture)), o.attributes.add(i.COMPONENTINDEX, \"float\"), o.varyings.add(\"vExternalColorMixMode\", \"mediump float\"), o.varyings.add(\"vExternalColor\", \"vec4\");\n  const s = e.output === t.ObjectAndLayerIdColor;\n  s && o.varyings.add(\"vObjectAndLayerIdColor\", \"vec4\"), o.include(r), a.constants.add(\"elevationScale\", \"float\", 2 * x), a.constants.add(\"stride\", \"float\", has(\"enable-feature:objectAndLayerId-rendering\") ? 3 : 2), a.code.add(l`vec2 getComponentTextureCoordinates(float componentIndex, float typeOffset) {\nfloat index = componentIndex * stride + typeOffset;\nfloat texSize = float(textureSize(componentColorTex, 0).x);\nfloat coordX = mod(index, texSize);\nfloat coordY = floor(index / texSize);\nreturn vec2(coordX, coordY) + 0.5;\n}`), a.code.add(l`\n  vec4 _readComponentColor() {\n    vec2 textureCoordinates = getComponentTextureCoordinates(componentIndex, 0.0);\n\n    return texelFetch(componentColorTex, ivec2(textureCoordinates), 0);\n   }\n\n   float readElevationOffset() {\n    vec2 textureCoordinates = getComponentTextureCoordinates(componentIndex, 1.0);\n\n    vec4 encodedElevation = texelFetch(componentColorTex, ivec2(textureCoordinates), 0);\n    return (rgba2float(encodedElevation) - 0.5) * elevationScale;\n  }\n\n  ${s ? l`\n          void forwardObjectAndLayerIdColor() {\n            vec2 textureCoordinates = getComponentTextureCoordinates(componentIndex, 2.0);\n\n            vObjectAndLayerIdColor = texelFetch(componentColorTex, ivec2(textureCoordinates), 0);\n          }` : l`void forwardObjectAndLayerIdColor() {}`}\n\n  vec4 forwardExternalColor(out bool castShadows) {\n    vec4 componentColor = _readComponentColor() * 255.0;\n\n    float shadowFlag = mod(componentColor.b * 255.0, 2.0);\n    componentColor.b -= shadowFlag;\n    castShadows = shadowFlag >= 1.0;\n\n    int decodedColorMixMode;\n    vExternalColor = decodeSymbolColor(componentColor, decodedColorMixMode) * 0.003921568627451; // = 1/255;\n    vExternalColorMixMode = float(decodedColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\n\n    return vExternalColor;\n  }\n`), d.code.add(l`\n  void readExternalColor(out vec4 externalColor, out int externalColorMixMode) {\n    externalColor = vExternalColor;\n    externalColorMixMode = int(vExternalColorMixMode);\n  }\n\n  void outputObjectAndLayerIdColor() {\n     ${s ? l`fragColor = vObjectAndLayerIdColor;` : \"\"}\n  }\n`);\n}\nfunction u(o, e) {\n  const {\n    vertex: r,\n    fragment: n\n  } = o;\n  r.uniforms.add(new a(\"externalColor\", o => o.componentParameters.externalColor)), n.uniforms.add(new d(\"externalColorMixMode\", o => o.componentParameters.externalColorMixMode)), o.varyings.add(\"vExternalColor\", \"vec4\"), r.code.add(l`float readElevationOffset() {\nreturn 0.0;\n}\nvoid forwardObjectAndLayerIdColor() {}\nvec4 forwardExternalColor(out bool castShadows) {\nvExternalColor = externalColor;\ncastShadows = true;\nreturn externalColor;\n}`);\n  const c = e.output === t.ObjectAndLayerIdColor;\n  n.code.add(l`\n  void readExternalColor(out vec4 color, out int colorMixMode) {\n    color = vExternalColor;\n    colorMixMode = externalColorMixMode;\n  }\n\n  void outputObjectAndLayerIdColor() {\n    ${c ? l`fragColor = vec4(0,0,0,0);` : \"\"}\n }\n`);\n}\nexport { m as ComponentData, s as ComponentDataType, C as encodeElevationOffset, x as maxElevationOffset };"],
  "mappings": "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",
  "names": ["o", "a", "e", "s", "s", "o", "e", "a", "n"]
}
