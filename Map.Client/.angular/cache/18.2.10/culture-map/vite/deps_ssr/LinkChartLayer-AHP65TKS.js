import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  D,
  I,
  M,
  T2 as T,
  ae,
  b,
  h,
  w as w2
} from "./chunk-AEKZSVKX.js";
import "./chunk-PGTI2BU4.js";
import {
  R
} from "./chunk-BHMMT4R2.js";
import "./chunk-HP5U6UA4.js";
import "./chunk-6A4CZ4JY.js";
import "./chunk-BYXMUOMW.js";
import "./chunk-YEWOBDQB.js";
import "./chunk-FWEBARAB.js";
import "./chunk-RHUWRAPT.js";
import "./chunk-VY63YX6I.js";
import "./chunk-EXKCGLRO.js";
import "./chunk-WRLGLGM6.js";
import "./chunk-47DYJR3W.js";
import "./chunk-NE35ZNG6.js";
import "./chunk-ZLSZAC2I.js";
import "./chunk-QRWQ6QBB.js";
import "./chunk-TFW6WS6R.js";
import {
  ot
} from "./chunk-X5QZGB37.js";
import "./chunk-T5C2TZNO.js";
import "./chunk-AOGKNBDG.js";
import "./chunk-F4FQ67JP.js";
import "./chunk-FDI2X6GO.js";
import "./chunk-3XHDZQO5.js";
import "./chunk-2BLQXT54.js";
import {
  e as e2
} from "./chunk-JSWVKNBA.js";
import "./chunk-LL33G4DK.js";
import "./chunk-CILHMGNK.js";
import "./chunk-2BOKEEZV.js";
import "./chunk-XUSZNRTW.js";
import "./chunk-W26QF64E.js";
import "./chunk-D3XX7CQS.js";
import "./chunk-Q6OCJ3NG.js";
import "./chunk-DD6UQHSS.js";
import "./chunk-FALQTRQL.js";
import "./chunk-GGTDLTZW.js";
import "./chunk-2W7YKBRA.js";
import "./chunk-GLFGRGCP.js";
import "./chunk-VFQA3B5S.js";
import "./chunk-NOH3NLJ5.js";
import "./chunk-LX5BT6XP.js";
import "./chunk-PLGJMWC5.js";
import "./chunk-UGFQYEND.js";
import "./chunk-KXVPQVTB.js";
import "./chunk-ARN5GJBK.js";
import "./chunk-MPLS4PY6.js";
import "./chunk-AGBPYPP3.js";
import "./chunk-VMZV7772.js";
import "./chunk-3FR2T2I2.js";
import "./chunk-LOZRWPGI.js";
import "./chunk-GZ64OOAB.js";
import "./chunk-WR2NVDOI.js";
import "./chunk-EPLJRYUV.js";
import "./chunk-VYRCS5VR.js";
import "./chunk-OOK3QTWF.js";
import "./chunk-UUQ5O7GK.js";
import "./chunk-6XY35LS7.js";
import "./chunk-JTDKNK44.js";
import "./chunk-RR7OQLEK.js";
import "./chunk-NAG6YX7T.js";
import "./chunk-WFNAKG2H.js";
import "./chunk-EKHRAAS6.js";
import "./chunk-IEB4ZCRH.js";
import "./chunk-7QOUHKW5.js";
import "./chunk-NHYYZMJR.js";
import "./chunk-WVSTX2NW.js";
import "./chunk-ORYC4PVJ.js";
import "./chunk-DXIKKLD7.js";
import "./chunk-VQNXE43R.js";
import "./chunk-VZ37C3ID.js";
import "./chunk-5R3HARKC.js";
import "./chunk-BKSTWG4S.js";
import "./chunk-FSG7HOZQ.js";
import "./chunk-Q5TIVVER.js";
import "./chunk-ZPMUEGLK.js";
import "./chunk-GNFDYYU3.js";
import "./chunk-X36BR2QB.js";
import "./chunk-RGG3YJQA.js";
import "./chunk-GBJYL7OX.js";
import "./chunk-GHKVDSKU.js";
import "./chunk-NVOJILW6.js";
import "./chunk-KYPTWEOO.js";
import "./chunk-WVFB3H4O.js";
import "./chunk-C7BQE556.js";
import "./chunk-ZREJ3Y2F.js";
import "./chunk-IR6CVPPC.js";
import "./chunk-BBUQOCRA.js";
import "./chunk-YBUJLIWZ.js";
import "./chunk-DL2B6IFJ.js";
import "./chunk-VOOO6FU5.js";
import "./chunk-IUPJR3FF.js";
import "./chunk-TGZW6QWO.js";
import "./chunk-OYIDHTXG.js";
import "./chunk-KUBMHTYA.js";
import "./chunk-NU4K6CTR.js";
import "./chunk-42ZAWY2C.js";
import "./chunk-TVHVZK5G.js";
import "./chunk-P2MUOE6G.js";
import "./chunk-CRYYUS4E.js";
import "./chunk-V33IUWAS.js";
import "./chunk-E5NWFBZG.js";
import "./chunk-FP37456K.js";
import "./chunk-VSQZQLTQ.js";
import "./chunk-K43CZ3M5.js";
import "./chunk-6EIBUVMG.js";
import "./chunk-YCXNHEGB.js";
import "./chunk-CSATD3VX.js";
import "./chunk-NXXQ35YM.js";
import "./chunk-LM3JDV4W.js";
import "./chunk-34V2CLL5.js";
import "./chunk-7V4JSBFA.js";
import "./chunk-REIMIECM.js";
import {
  l
} from "./chunk-EO2EW5KR.js";
import "./chunk-JEFPXTYT.js";
import "./chunk-MVS2BECH.js";
import {
  t
} from "./chunk-UZ7IOCF3.js";
import "./chunk-3B5GODXR.js";
import "./chunk-NKXXHQDD.js";
import "./chunk-7TBQUMV3.js";
import {
  f
} from "./chunk-TPLUZX3A.js";
import "./chunk-BGLJ2FAH.js";
import "./chunk-2EJFYNM7.js";
import "./chunk-DC5LRNPY.js";
import "./chunk-ASCK5HJ5.js";
import "./chunk-5X5U7R6O.js";
import "./chunk-XNLAOXPY.js";
import "./chunk-ZT7V2AVD.js";
import "./chunk-C2OXE4NQ.js";
import "./chunk-KOI252FF.js";
import "./chunk-I2TVVMQ6.js";
import "./chunk-5EGQYY2H.js";
import "./chunk-JKPUNUQA.js";
import "./chunk-SR7PRON4.js";
import "./chunk-HGHPYGKP.js";
import "./chunk-4DSGTDZJ.js";
import "./chunk-VYTPFEL2.js";
import "./chunk-RLGDH6IY.js";
import {
  m2 as m
} from "./chunk-MRPCXIVS.js";
import "./chunk-YTKVV2Y3.js";
import "./chunk-GCVQXAS4.js";
import "./chunk-UFQD6AL4.js";
import "./chunk-THZPD5CT.js";
import "./chunk-OBCA6CWH.js";
import "./chunk-2JI245BP.js";
import "./chunk-CBOFHWPI.js";
import "./chunk-ABIG6PT5.js";
import "./chunk-ZEZ3LI2L.js";
import "./chunk-N34BRXVM.js";
import "./chunk-KETDH2J4.js";
import "./chunk-7QV7DHWN.js";
import "./chunk-4L4Y34YK.js";
import "./chunk-BXONKQKI.js";
import "./chunk-2HDBQXAR.js";
import {
  w
} from "./chunk-RNF7VOCU.js";
import {
  _
} from "./chunk-TIRJMGGG.js";
import "./chunk-ZDRQSPB6.js";
import "./chunk-DCXDXGAR.js";
import "./chunk-BCCDYCTQ.js";
import "./chunk-AYL3HQHD.js";
import "./chunk-66YQWHHE.js";
import "./chunk-QGBMZIP4.js";
import "./chunk-AOEBZVTA.js";
import "./chunk-2OZSYJDX.js";
import "./chunk-MZM4INJV.js";
import "./chunk-J4GMQHGL.js";
import "./chunk-MHPE4SZA.js";
import "./chunk-6SSA7P3A.js";
import "./chunk-FQBTLEUI.js";
import {
  n as n2
} from "./chunk-GS7Y3YOG.js";
import "./chunk-Y2HYKTTT.js";
import "./chunk-XLEC46FY.js";
import "./chunk-4AZPIP7K.js";
import "./chunk-G73HQZEL.js";
import "./chunk-LZSLQ24Q.js";
import {
  V
} from "./chunk-U3RHUXYK.js";
import "./chunk-7DBI6LQG.js";
import "./chunk-AUUN7RFQ.js";
import "./chunk-JAMSDYD6.js";
import "./chunk-PH6NPTP7.js";
import {
  e
} from "./chunk-NUICEVIH.js";
import "./chunk-NXK752PZ.js";
import {
  y
} from "./chunk-UVNLCXWD.js";
import "./chunk-PNUA7JOS.js";
import "./chunk-OR2FKGUM.js";
import {
  a3 as a,
  r2 as r
} from "./chunk-UDMPWVPF.js";
import "./chunk-XJNKCEWL.js";
import {
  s as s2
} from "./chunk-AIZ3T7E3.js";
import "./chunk-6UEMNP3E.js";
import "./chunk-6WGE3IUL.js";
import "./chunk-MLYB2YW4.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-6JFGZTLU.js";
import "./chunk-2ZJE6ZFX.js";
import {
  __async,
  __spreadValues
} from "./chunk-XBPEBUD5.js";

// ../../../node_modules/@arcgis/core/layers/knowledgeGraph/IdealEdgeLengthTypeOptions.js
var e3;
!function(e5) {
  e5.MULTIPLIER = "multiplier", e5.ABSOLUTE = "absoluteValue";
}(e3 || (e3 = {}));

// ../../../node_modules/@arcgis/core/libs/linkchartlayout/LinkChartLayout.js
var e4;
var r2 = null;
function n3() {
  return e4 || (e4 = import("./lclayout-RV5FDPEP.js").then((t2) => t2.l).then(({
    default: e5
  }) => e5({
    locateFile: (e6) => n2(`esri/libs/linkchartlayout/${e6}`)
  })).then((t2) => {
    s3(t2);
  }), e4);
}
function s3(t2) {
  r2 = t2;
}
var u;
var o;
function l2(t2, e5, a2, n4, s4, u2) {
  const o2 = a2.length, l3 = s4.length, y3 = Float64Array.BYTES_PER_ELEMENT, i2 = Uint32Array.BYTES_PER_ELEMENT, c2 = Uint8Array.BYTES_PER_ELEMENT, E2 = 16, f3 = E2 + o2 * (c2 + 2 * y3) + l3 * (2 * i2), p2 = r2._malloc(f3);
  try {
    const c3 = p2 + E2 - p2 % E2, f4 = c3 + o2 * y3, A2 = f4 + o2 * y3, _3 = A2 + l3 * i2, P3 = _3 + l3 * i2, b3 = () => [r2.HEAPF64.subarray(c3 >> 3, (c3 >> 3) + o2), r2.HEAPF64.subarray(f4 >> 3, (f4 >> 3) + o2), r2.HEAPU32.subarray(A2 >> 2, (A2 >> 2) + l3), r2.HEAPU32.subarray(_3 >> 2, (_3 >> 2) + l3), r2.HEAPU8.subarray(P3, P3 + o2)], [g2, H2, L, h2, d] = b3();
    g2.set(a2), H2.set(n4), L.set(s4), h2.set(u2), d.set(e5);
    let C = t2(o2, P3, c3, f4, l3, A2, _3), F = null, m2 = null;
    if (C) {
      const t3 = r2.getLayoutLinksTypes(), e6 = r2.getLayoutLinksVerticesEndIndices(), a3 = r2.getLayoutLinksVertices(), n5 = r2.countLayoutLinksVertices();
      !l3 || t3 && e6 ? n5 && !a3 ? C = false : (F = {
        types: new Uint8Array(r2.HEAPU8.subarray(t3, t3 + l3)),
        vertexEndIndex: new Uint32Array(r2.HEAPU32.subarray(e6 >> 2, (e6 >> 2) + l3)),
        vertices: new Float64Array(r2.HEAPF64.subarray(a3 >> 3, (a3 >> 3) + 2 * n5))
      }, m2 = r2.getAuxiliaryGraphicElements()) : C = false;
    }
    const [R2, T2, U, B, v] = b3();
    return a2.set(R2), n4.set(T2), s4.set(U), u2.set(B), e5.set(v), {
      success: C,
      links: F,
      graphics: m2
    };
  } finally {
    r2._free(p2), r2.cleanupLayout();
  }
}
!function(t2) {
  t2[t2.None = 0] = "None", t2[t2.IsMovable = 1] = "IsMovable", t2[t2.IsGeographic = 2] = "IsGeographic", t2[t2.IsRoot = 4] = "IsRoot";
}(u || (u = {})), function(t2) {
  t2[t2.Regular = 0] = "Regular", t2[t2.Orthogonal = 1] = "Orthogonal", t2[t2.Curved = 2] = "Curved", t2[t2.Recursive = 3] = "Recursive";
}(o || (o = {}));
var y2 = 2;
var i = 1;
var c = -1;
var E;
var f2;
var p;
var A;
var _2;
var P;
var b2;
var g;
var H;
!function(t2) {
  function e5() {
    return r2.getMinIdealEdgeLength();
  }
  function a2(t3, e6, a3, n4, s4, u2 = y2, o2 = i, E2 = c) {
    return l2((t4, e7, a4, n5, s5, l3, y3) => r2.applyForceDirectedLayout(t4, e7, a4, n5, s5, l3, y3, u2, o2, E2), t3, e6, a3, n4, s4);
  }
  t2.getMinIdealEdgeLength = e5, t2.apply = a2;
}(E || (E = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4, u2 = y2, o2 = i, E2 = c) {
    return l2((t4, e7, a3, n5, s5, l3, y3) => r2.applyCommunityLayout(t4, e7, a3, n5, s5, l3, y3, u2, o2, E2), t3, e6, a2, n4, s4);
  }
  t2.apply = e5;
}(f2 || (f2 = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4) {
    return l2(r2.applySimpleLayout, t3, e6, a2, n4, s4);
  }
  t2.apply = e5;
}(p || (p = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4) {
    return l2(r2.applyHierarchicalLayout, t3, e6, a2, n4, s4);
  }
  t2.apply = e5;
}(A || (A = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4) {
    return l2(r2.applyRadialTreeLayout, t3, e6, a2, n4, s4);
  }
  t2.apply = e5;
}(_2 || (_2 = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4) {
    return l2(r2.applySmartTreeLayout, t3, e6, a2, n4, s4);
  }
  t2.apply = e5;
}(P || (P = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4, u2, o2, y3, i2) {
    return l2((t4, e7, a3, u3, o3, l3, c2) => {
      if (n4.length !== t4) return false;
      if (s4.length !== t4) return false;
      if (y3.length !== o3) return false;
      if (i2.length !== o3) return false;
      const E2 = Float64Array.BYTES_PER_ELEMENT, f3 = 16, p2 = r2._malloc(f3 + t4 * E2), A2 = r2._malloc(f3 + t4 * E2), _3 = r2._malloc(f3 + o3 * E2), P3 = r2._malloc(f3 + o3 * E2), b3 = p2 + f3 - p2 % f3, g2 = A2 + f3 - A2 % f3, H2 = _3 + f3 - _3 % f3, L = P3 + f3 - P3 % f3;
      try {
        return r2.HEAPF64.subarray(b3 >> 3, (b3 >> 3) + t4).set(n4), r2.HEAPF64.subarray(g2 >> 3, (g2 >> 3) + t4).set(s4), r2.HEAPF64.subarray(H2 >> 3, (H2 >> 3) + o3).set(y3), r2.HEAPF64.subarray(L >> 3, (L >> 3) + o3).set(i2), r2.applyChronologicalLayout(t4, e7, a3, u3, b3, g2, o3, l3, c2, H2, L);
      } finally {
        r2._free(p2), r2._free(A2), r2._free(_3), r2._free(P3);
      }
    }, t3, e6, a2, u2, o2);
  }
  t2.apply = e5;
}(b2 || (b2 = {})), function(t2) {
  t2[t2.Undirected = 0] = "Undirected", t2[t2.Directed = 1] = "Directed", t2[t2.Reversed = 2] = "Reversed";
}(g || (g = {})), function(t2) {
  t2[t2.ByCC_Raw = 0] = "ByCC_Raw", t2[t2.ByCC_NormalizeGlobally = 1] = "ByCC_NormalizeGlobally", t2[t2.ByCC_NormalizeByCC = 2] = "ByCC_NormalizeByCC";
}(H || (H = {}));

// ../../../node_modules/@arcgis/core/layers/LinkChartLayer.js
var j = class extends l(t(f)) {
  constructor(e5) {
    if (super(e5), this.dataPreloadedInLocalCache = false, this.defaultLinkChartConfig = null, this._currentLinkChartConfig = {
      layoutMode: "RADIAL_TREE"
    }, this._graphTypeLookup = /* @__PURE__ */ new Map(), this.dataManager = null, this.knowledgeGraph = null, this.layers = new V(), this.entityLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.relationshipLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.linkChartExtent = new w({
      xmin: -1e-7,
      ymin: -1e-7,
      xmax: 1e-7,
      ymax: 1e-7
    }), this.memberEntityTypes = null, this.memberRelationshipTypes = null, this.sublayerIdsCache = /* @__PURE__ */ new Map(), this.tables = new V(), this.type = "link-chart", this._originalInclusionList = e5.inclusionModeDefinition, e5.dataPreloadedInLocalCache && !e5.inclusionModeDefinition) throw new s("knowledge-graph:linkchart-layer-constructor", "If creating a link chart composite layer and configured that data is already loaded in the cache, you must specify an inclusion list so the Composite Layer knows what records belong to it");
  }
  normalizeCtorArgs(e5) {
    return {
      url: e5.url,
      title: e5.title,
      dataPreloadedInLocalCache: e5.dataPreloadedInLocalCache,
      defaultLinkChartConfig: e5.defaultLinkChartConfig
    };
  }
  _initializeLayerProperties(e5) {
    if (!this.title && this.url) {
      const e6 = this.url.split("/");
      this.title = e6[e6.length - 2];
    }
    const t2 = /* @__PURE__ */ new Set();
    let n4 = [], s4 = [];
    if (e5.inclusionModeDefinition && (!e5.inclusionModeDefinition.namedTypeDefinitions || e5.inclusionModeDefinition.namedTypeDefinitions.size < 1)) throw new s("knowledge-graph:composite-layer-constructor", "If an explicit inclusion definition is defined, at least one namedTypeDefinition must also be defined");
    e5.knowledgeGraph.dataModel.entityTypes?.forEach((e6) => {
      e6.name && this._graphTypeLookup.set(e6.name, e6);
    }), e5.knowledgeGraph.dataModel.relationshipTypes?.forEach((e6) => {
      e6.name && this._graphTypeLookup.set(e6.name, e6);
    }), e5.inclusionModeDefinition?.generateAllSublayers ? (n4 = e5.knowledgeGraph.dataModel.entityTypes ?? [], s4 = e5.knowledgeGraph.dataModel.relationshipTypes ?? []) : e5.inclusionModeDefinition?.namedTypeDefinitions && e5.inclusionModeDefinition?.namedTypeDefinitions.size > 0 ? e5.inclusionModeDefinition?.namedTypeDefinitions.forEach((a2, o3) => {
      const r3 = this._graphTypeLookup.get(o3);
      if (!r3) return n.getLogger(this).warn(`A named type, ${o3}, was in the inclusion list that wasn't in the data model and will be removed`), void e5.inclusionModeDefinition?.namedTypeDefinitions.delete(o3);
      "relationship" === r3.type ? t2.has(o3) || (t2.add(o3), s4.push(r3)) : "entity" === r3.type ? t2.has(o3) || (t2.add(o3), n4.push(r3)) : (n.getLogger(this).warn(`A named type, ${o3}, was in the inclusion list that wasn't properly modeled and will be removed`), e5.inclusionModeDefinition?.namedTypeDefinitions.delete(o3));
    }) : (n4 = e5.knowledgeGraph.dataModel.entityTypes ?? [], s4 = e5.knowledgeGraph.dataModel.relationshipTypes ?? []);
    const o2 = new M({
      knowledgeGraph: e5.knowledgeGraph,
      inclusionModeDefinition: e5.inclusionModeDefinition
    });
    this.knowledgeGraph = e5.knowledgeGraph, this.memberEntityTypes = n4, this.memberRelationshipTypes = s4, this.dataManager = o2;
  }
  load(e5) {
    return this.addResolvingPromise(new Promise((t2) => {
      R(this.url).then((a2) => {
        if (this._initializeLayerProperties({
          knowledgeGraph: a2,
          inclusionModeDefinition: this._originalInclusionList
        }), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.size || (this.dataManager.inclusionModeDefinition = {
          generateAllSublayers: false,
          namedTypeDefinitions: /* @__PURE__ */ new Map()
        }, this.dataManager.knowledgeGraph.dataModel.entityTypes?.forEach((e6) => {
          e6.name && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(e6.name, {
            useAllData: true
          });
        }), this.dataManager.knowledgeGraph.dataModel.relationshipTypes?.forEach((e6) => {
          e6.name && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(e6.name, {
            useAllData: true
          });
        })), this.dataPreloadedInLocalCache) this.loadLayerAssumingLocalCache(), this.dataManager.inclusionModeDefinition && (this.dataManager.inclusionModeDefinition.generateAllSublayers = false), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach((e6) => {
          e6.useAllData = false, e6.members?.forEach((e7) => {
            let t3;
            t3 = e7.linkChartLocation instanceof e2 ? e7.linkChartLocation : e7.linkChartLocation ? ot(e7.linkChartLocation) : null, t3 && 2 === t3.coords.length && 0 === t3.lengths.length ? this.entityLinkChartDiagramLookup.set(e7.id, t3) : this.relationshipLinkChartDiagramLookup.set(e7.id, t3);
          }), this.addResolvingPromise(this._initializeDiagram().then(() => __async(this, null, function* () {
            this.layers.forEach((e7) => __async(this, null, function* () {
              yield e7.refreshCachedQueryEngine();
            })), this.tables.forEach((e7) => __async(this, null, function* () {
              yield e7.refreshCachedQueryEngine();
            }));
          })));
        });
        else {
          const t3 = "GEOGRAPHIC" === this.defaultLinkChartConfig?.layoutMode;
          this.addResolvingPromise(this.dataManager.refreshCacheContent(void 0, false, t3, true).then(() => __async(this, null, function* () {
            s2(e5);
            const t4 = [], a3 = [];
            this.loadLayerAssumingLocalCache(), this.dataManager.inclusionModeDefinition && (this.dataManager.inclusionModeDefinition.generateAllSublayers = false, this.dataManager.inclusionModeDefinition.namedTypeDefinitions.forEach((e6) => {
              e6.useAllData = false;
            })), yield this._initializeDiagram(), this.layers.forEach((e6) => {
              a3.push(e6.refreshCachedQueryEngine()), t4.push(new Promise((t5) => {
                e6.on("layerview-create", () => {
                  t5(null);
                });
              }));
            }), this.tables.forEach((e6) => {
              a3.push(e6.refreshCachedQueryEngine());
            }), yield Promise.all(a3);
          })));
        }
        t2(null);
      });
    })), Promise.resolve(this);
  }
  addRecords(e5, t2) {
    return __async(this, null, function* () {
      let a2 = [];
      t2?.cascadeAddRelationshipEndNodes && this.dataManager.knowledgeGraph.dataModel && (a2 = yield h(e5, this.dataManager.knowledgeGraph));
      const i2 = e5.concat(a2).filter((e6) => !this.sublayerIdsCache.get(e6.typeName)?.has(e6.id));
      yield this._handleNewRecords(i2);
    });
  }
  removeRecords(_0) {
    return __async(this, arguments, function* (e5, {
      cascadeRemoveRelationships: t2 = true,
      recalculateLayout: a2 = false
    } = {
      cascadeRemoveRelationships: true,
      recalculateLayout: false
    }) {
      let i2 = [];
      for (const s4 of e5) false === this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(s4.typeName)?.useAllData && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(s4.typeName)?.members?.has(s4.id) && i2.push(s4);
      if (t2) {
        const e6 = /* @__PURE__ */ new Set(), t3 = [];
        for (const a3 of i2) if (this.dataManager.nodeConnectionsLookup.has(a3.id)) for (const t4 of this.dataManager.nodeConnectionsLookup.get(a3.id)) e6.add(t4);
        for (const a3 of e6) if (this.dataManager.memberIdTypeLookup.has(a3)) for (const e7 of this.dataManager.memberIdTypeLookup.get(a3)) this.dataManager.relationshipTypeNames.has(e7) && t3.push({
          id: a3,
          typeName: e7
        });
        i2 = i2.concat(t3);
      }
      this.dataManager.removeFromLayer(i2);
      for (const s4 of i2) this.sublayerIdsCache.get(s4.typeName)?.delete(s4.id), this.dataManager.relationshipTypeNames.has(s4.typeName) ? this.relationshipLinkChartDiagramLookup.delete(s4.id) : this.entityLinkChartDiagramLookup.delete(s4.id);
      a2 && (yield this.calculateLinkChartLayout(this._currentLinkChartConfig.layoutMode, this._currentLinkChartConfig.layoutOptions));
      const n4 = [];
      return this.layers.forEach((e6) => {
        n4.push(e6.refreshCachedQueryEngine());
      }), yield Promise.all(n4), this._refreshNamedTypes(), i2;
    });
  }
  expand(e5, t2) {
    return __async(this, null, function* () {
      const a2 = yield this.dataManager.getConnectedRecordIds(e5, t2), i2 = a2.filter((e6) => !this.sublayerIdsCache.get(e6.typeName)?.has(e6.id));
      return yield this._handleNewRecords(a2), {
        records: i2
      };
    });
  }
  loadLayerAssumingLocalCache() {
    this.memberRelationshipTypes.forEach((e5) => {
      const t2 = new ae({
        objectType: e5,
        parentCompositeLayer: this,
        graphType: "relationship",
        title: e5.name
      });
      t2.geometryType ? this.layers.push(t2) : this.tables.push(t2), this.dataManager.sublayerCaches.has(e5.name) || this.dataManager.sublayerCaches.set(e5.name, /* @__PURE__ */ new Map());
    }), this.memberEntityTypes.forEach((e5) => {
      const t2 = new ae({
        objectType: e5,
        parentCompositeLayer: this,
        graphType: "entity",
        title: e5.name
      });
      t2.geometryType ? this.layers.push(t2) : this.tables.push(t2), this.dataManager.sublayerCaches.has(e5.name) || this.dataManager.sublayerCaches.set(e5.name, /* @__PURE__ */ new Map());
    }), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach((e5, t2) => {
      const a2 = r(this.sublayerIdsCache, t2, () => /* @__PURE__ */ new Set());
      e5.members?.forEach((e6) => {
        if (a2.add(e6.id), e6.linkChartLocation) if (e6.linkChartLocation instanceof e2) this.dataManager.relationshipTypeNames.has(t2) ? this.relationshipLinkChartDiagramLookup.set(e6.id, e6.linkChartLocation) : this.entityLinkChartDiagramLookup.set(e6.id, e6.linkChartLocation);
        else {
          const a3 = ot(e6.linkChartLocation);
          this.dataManager.relationshipTypeNames.has(t2) ? this.relationshipLinkChartDiagramLookup.set(e6.id, e6.linkChartLocation ? a3 : null) : this.entityLinkChartDiagramLookup.set(e6.id, e6.linkChartLocation ? a3 : null);
        }
      });
    });
  }
  calculateLinkChartLayout(e5 = "RADIAL_TREE", t2) {
    return __async(this, null, function* () {
      const n4 = [], s4 = [], o2 = [];
      this.dataManager.sublayerCaches.forEach((e6, t3) => {
        this.dataManager.entityTypeNames.has(t3) ? e6.forEach((e7) => {
          n4.push({
            typeName: t3,
            feature: e7
          });
        }) : this.dataManager.relationshipTypeNames.has(t3) && e6.forEach((e7) => {
          s4.push({
            typeName: t3,
            feature: e7
          });
        });
      }), this.entityLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.relationshipLinkChartDiagramLookup = /* @__PURE__ */ new Map();
      const r3 = /* @__PURE__ */ new Map(), h2 = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map(), p2 = /* @__PURE__ */ new Map(), u2 = new Uint8Array(n4.length), L = new Float64Array(n4.length), C = new Float64Array(n4.length), k = new Uint32Array(s4.length), M2 = new Uint32Array(s4.length), I2 = [], j2 = "FORCE_DIRECTED", P3 = new w({
        xmin: -1e-7,
        ymin: -1e-7,
        xmax: 1e-7,
        ymax: 1e-7
      });
      let S, O = "FORCE_DIRECTED", z = 0, U = 0;
      switch (O = "GEOGRAPHIC" === e5 ? j2 : e5, O) {
        case "FORCE_DIRECTED":
          S = E.apply;
          break;
        case "COMMUNITY":
          S = f2.apply;
          break;
        case "HIERARCHICAL":
          S = A.apply;
          break;
        case "RADIAL_TREE":
          S = _2.apply;
          break;
        case "SMART_TREE":
          S = P.apply;
          break;
        default:
          S = p.apply;
      }
      n4.forEach(({
        typeName: a2,
        feature: i2
      }) => {
        if (t2?.lockedNodeLocations?.has(i2.attributes[w2])) {
          "GEOGRAPHIC" === e5 && this.dataManager.geographicLookup.has(a2) ? u2[z] = u.IsGeographic : u2[z] = u.None;
          const n5 = t2.lockedNodeLocations.get(i2.attributes[w2]);
          L[z] = n5.x, C[z] = n5.y;
        } else if ("GEOGRAPHIC" === e5 && this.dataManager.geographicLookup.has(a2)) {
          u2[z] = u.IsGeographic;
          let e6 = null;
          const t3 = i2.attributes[this.dataManager.geographicLookup.get(a2).name], n5 = this.dataManager.geographicLookup.get(a2)?.geometryType;
          switch (n5) {
            case "esriGeometryPoint":
              L[z] = t3?.x, C[z] = t3?.y;
              break;
            case "esriGeometryPolygon":
              e6 = t3?.centroid, null != e6?.x && null != e6?.y ? (L[z] = e6.x, C[z] = e6.y) : u2[z] = u.IsMovable;
              break;
            case "esriGeometryPolyline":
            case "esriGeometryMultipoint":
              e6 = t3?.extent?.center, null != e6?.x && null != e6?.y ? (L[z] = e6.x, C[z] = e6.y) : u2[z] = u.IsMovable;
              break;
            default:
              u2[z] = u.IsMovable;
          }
          (null == L[z] || null == C[z] || Number.isNaN(L[z]) || Number.isNaN(C[z])) && (u2[z] = u.IsMovable, L[z] = 0, C[z] = 0);
        } else u2[z] = u.IsMovable, L[z] = 0, C[z] = 0;
        p2.set(i2.attributes[w2], z), I2[z] = {
          feature: i2,
          typeName: a2
        }, z++;
      });
      let H2 = false;
      const B = /* @__PURE__ */ new Map();
      s4.forEach((e6) => {
        const t3 = e6.feature.attributes[b], a2 = e6.feature.attributes[T], i2 = p2.get(t3), n5 = p2.get(a2);
        if (void 0 !== i2 && void 0 !== n5) {
          const s5 = t3 + "-" + a2, r4 = B.get(s5), h3 = r4?.has(e6.typeName);
          h3 || (k[U] = i2, M2[U] = n5, void 0 === r4 ? B.set(s5, /* @__PURE__ */ new Map([[e6.typeName, U]])) : r4.set(e6.typeName, U), U++), o2.push(e6);
        } else H2 = true, this.relationshipLinkChartDiagramLookup.set(t3, null);
      }), H2 && n.getLogger(this).warn("A relationship is a member of this layer that has either origin or destination entity nodes that are not members. The diagram geometry will be set to null");
      const F = this._validateLayoutSettings(e5, t2), Q = this._convertLayoutSettingsToCalculationSettings(F);
      yield n3();
      const {
        success: K,
        links: Y
      } = S(u2, L, C, k.subarray(0, U), M2.subarray(0, U), Q.computationBudgetTime, Q.idealEdgeLengthMultiplier, Q.repulsionRadiusMultiplier);
      if (!K) throw new s("knowledge-graph:layout-failed", "Attempting to arrange the records in the specified layout failed");
      for (let a2 = 0; a2 < I2.length; a2++) {
        if (C[a2] > 84.9999 ? C[a2] = 84.9999 : C[a2] < -84.9999 && (C[a2] = -84.9999), L[a2] > 179.9999 ? L[a2] = 179.9999 : L[a2] < -179.9999 && (L[a2] = -179.9999), I2[a2].feature.attributes[D] = new _(L[a2], C[a2]), r3.has(I2[a2].typeName)) {
          const e7 = r3.get(I2[a2].typeName);
          e7?.set(I2[a2].feature.attributes[w2], I2[a2].feature);
        } else {
          const e7 = /* @__PURE__ */ new Map();
          e7.set(I2[a2].feature.attributes[w2], I2[a2].feature), r3.set(I2[a2].typeName, e7);
        }
        d.set(I2[a2].feature.attributes[w2], I2[a2].feature);
        const e6 = ot(I2[a2].feature.attributes[D]);
        this.entityLinkChartDiagramLookup.set(I2[a2].feature.attributes[w2], I2[a2].feature.attributes[D] ? e6 : null), I2[a2].feature.attributes[D].x < P3.xmin && (P3.xmin = I2[a2].feature.attributes[D].x), I2[a2].feature.attributes[D].x > P3.xmax && (P3.xmax = I2[a2].feature.attributes[D].x), I2[a2].feature.attributes[D].y < P3.ymin && (P3.ymin = I2[a2].feature.attributes[D].y), I2[a2].feature.attributes[D].y > P3.ymax && (P3.ymax = I2[a2].feature.attributes[D].y);
      }
      if (this.linkChartExtent.xmin = P3.xmin, this.linkChartExtent.xmax = P3.xmax, this.linkChartExtent.ymin = P3.ymin, this.linkChartExtent.ymax = P3.ymax, !Y) throw new s("knowledge-graph:layout-failed", "Attempting to retrieve link geometry from diagram engine failed");
      const $ = /* @__PURE__ */ new Map(), W = /* @__PURE__ */ new Map(), q = /* @__PURE__ */ new Map(), J = /* @__PURE__ */ new Set();
      for (let a2 = 0; a2 < o2.length; a2++) {
        const e6 = [], t3 = o2[a2], n5 = t3.feature.attributes[b], s5 = t3.feature.attributes[T], r4 = n5 + "-" + s5, u3 = B.get(r4).get(t3.typeName), f3 = 0 === u3 ? 0 : Y?.vertexEndIndex[u3 - 1];
        if (!J.has(u3)) {
          if (J.add(u3), Y.types[u3] === o.Recursive) {
            const t5 = [Y.vertices[2 * f3], Y.vertices[2 * f3 + 1]], a4 = [Y.vertices[2 * (f3 + 1)], Y.vertices[2 * (f3 + 1) + 1]], i2 = [0.5 * (t5[0] + a4[0]), 0.5 * (t5[1] + a4[1])], n6 = [i2[0] - t5[0], i2[1] - t5[1]], s6 = [i2[0] + n6[1], i2[1] - n6[0]], o3 = [i2[0] - n6[1], i2[1] + n6[0]];
            e6.push(t5), e6.push(s6), e6.push(a4), e6.push(o3), e6.push(t5);
          } else {
            if (Y.types[u3] !== o.Regular) {
              n.getLogger(this).warn("A relationship generated an unsupported link geometry type.  It will not be rendered");
              continue;
            }
            for (let t5 = f3; t5 < Y.vertexEndIndex[u3]; t5++) e6.push([Y.vertices[2 * t5], Y.vertices[2 * t5 + 1]]);
          }
          const t4 = I2[p2.get(n5)]?.feature.attributes[D], a3 = I2[p2.get(s5)]?.feature.attributes[D];
          e6[0][0] === t4.x && e6[0][1] === t4.y || (e6[0] = [t4.x, t4.y]), e6[e6.length - 1][0] === a3.x && e6[e6.length - 1][1] === a3.y || (e6[e6.length - 1] = [a3.x, a3.y]);
          for (let i2 = 1; i2 < e6.length - 1; i2++) e6[i2][1] > 85.5 ? e6[i2][1] = 85.5 : e6[i2][1] < -85.5 && (e6[i2][1] = -85.5), e6[i2][0] > 179.9999 ? e6[i2][0] = 179.9999 : e6[i2][0] < -179.9999 && (e6[i2][0] = -179.9999);
          $.has(r4) ? $.get(r4).push(e6) : $.set(r4, [e6]);
        }
        const L2 = $.get(r4);
        W.has(r4) || (W.set(r4, /* @__PURE__ */ new Map()), q.set(r4, /* @__PURE__ */ new Map()));
        const C2 = W.get(r4), k2 = q.get(r4);
        C2.has(t3.typeName) || (C2.set(t3.typeName, L2.shift()), k2.set(t3.typeName, 0));
        const M3 = C2.get(t3.typeName);
        k2.set(t3.typeName, k2.get(t3.typeName) + 1);
        const w3 = new m({
          paths: M3
        });
        if (t3.feature.attributes[D] = w3, h2.has(t3.typeName)) {
          const e7 = h2.get(t3.typeName);
          e7?.set(t3.feature.attributes[w2], t3.feature);
        } else {
          const e7 = /* @__PURE__ */ new Map();
          e7.set(t3.feature.attributes[w2], t3.feature), h2.set(t3.typeName, e7);
        }
        d.set(t3.feature.attributes[w2], t3.feature);
        const b3 = ot(t3.feature.attributes[D]);
        this.relationshipLinkChartDiagramLookup.set(t3.feature.attributes[w2], t3.feature.attributes[D] ? b3 : null);
      }
      for (const a2 of o2) a2.feature.attributes[I] = q.get(a2.feature.attributes[b] + "-" + a2.feature.attributes[T])?.get(a2.typeName) ?? null;
      return this._currentLinkChartConfig = {
        layoutMode: e5,
        layoutOptions: F
      }, {
        nodes: r3,
        links: h2,
        idMap: d
      };
    });
  }
  applyNewLinkChartLayout(e5 = "RADIAL_TREE", t2) {
    return __async(this, null, function* () {
      const a2 = [];
      yield this.calculateLinkChartLayout(e5, t2), this.layers.forEach((e6) => {
        a2.push(e6.refreshCachedQueryEngine());
      }), yield Promise.all(a2), this._refreshNamedTypes();
    });
  }
  getCurrentNodeLocations() {
    const e5 = /* @__PURE__ */ new Map();
    return this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((t2) => {
      t2?.members?.forEach((t3) => {
        const a2 = t3.linkChartLocation;
        let i2;
        const n4 = t3.id;
        a2 && (i2 = "x" in a2 ? {
          x: a2.x,
          y: a2.y
        } : {
          x: a2.coords[0],
          y: a2.coords[1]
        }, e5.set(n4, new _({
          x: i2.x,
          y: i2.y
        })));
      });
    }), e5;
  }
  synchronizeInclusionListWithCache() {
    return __async(this, null, function* () {
      return new Promise((e5) => {
        this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach((e6, t2) => {
          if (e6.useAllData = false, e6.members && e6.members.size > 0) {
            if (!this.dataManager.sublayerCaches.get(t2)) return;
            const a2 = new Set(Array.from(this.dataManager.sublayerCaches.get(t2).keys()));
            Array.from(e6.members.keys()).filter((e7) => !a2.has(e7)).forEach((t3) => {
              e6.members?.delete(t3);
            });
          }
        }), e5();
      });
    });
  }
  refreshLinkChartCache(e5) {
    return __async(this, null, function* () {
      yield this.dataManager.refreshCacheContent(e5);
      const t2 = [];
      this.layers.forEach((e6) => {
        t2.push(e6.refreshCachedQueryEngine());
      }), yield Promise.all(t2), this._refreshNamedTypes();
    });
  }
  connectEntities(e5) {
    return __async(this, null, function* () {
      let t2 = [];
      for (const i2 of this.dataManager.relationshipTypeNames) {
        const e6 = this.sublayerIdsCache.get(i2);
        e6 && (t2 = t2.concat(Array.from(e6.keys())));
      }
      const a2 = yield this.dataManager.getAttachedRelationships(e5, t2);
      return yield this._handleNewRecords(a2), {
        records: a2
      };
    });
  }
  _handleNewRecords(e5) {
    return __async(this, null, function* () {
      const t2 = [];
      this.dataManager.addToLayer(e5);
      for (const i2 of e5) this.sublayerIdsCache.has(i2.typeName) || (this.sublayerIdsCache.set(i2.typeName, /* @__PURE__ */ new Set()), t2.push(i2.typeName)), this.sublayerIdsCache.get(i2.typeName).add(i2.id);
      for (const i2 of t2) {
        const e6 = this._graphTypeLookup.get(i2);
        if (e6) {
          const t3 = new ae({
            objectType: e6,
            parentCompositeLayer: this,
            graphType: e6.type,
            title: i2
          });
          "entity" === e6.type ? this.dataManager.entityTypeNames.add(i2) : this.dataManager.relationshipTypeNames.add(i2), t3.geometryType ? this.layers.push(t3) : this.tables.push(t3), this.dataManager.sublayerCaches.set(i2, /* @__PURE__ */ new Map());
        }
      }
      yield this.dataManager.refreshCacheContent(e5.map((e6) => e6.id));
      const a2 = Object.assign({}, this._currentLinkChartConfig.layoutOptions);
      a2.lockedNodeLocations = this.getCurrentNodeLocations(), yield this.applyNewLinkChartLayout(this._currentLinkChartConfig.layoutMode, a2);
    });
  }
  _initializeDiagram() {
    return __async(this, null, function* () {
      this.defaultLinkChartConfig ? this.defaultLinkChartConfig.doNotRecalculateLayout ? (this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((e5, t2) => {
        e5?.members?.forEach((e6) => {
          const a2 = e6.linkChartLocation;
          let i2;
          const n4 = e6.id;
          if (!a2) return;
          i2 = "x" in a2 ? {
            x: a2.x,
            y: a2.y
          } : {
            x: a2.coords[0],
            y: a2.coords[1]
          };
          const s4 = ot(i2);
          this.dataManager.relationshipTypeNames.has(t2) ? this.relationshipLinkChartDiagramLookup.set(n4, s4) : this.entityLinkChartDiagramLookup.set(n4, s4), this.linkChartExtent.xmin > i2.x && (this.linkChartExtent.xmin = i2.x), this.linkChartExtent.xmax < i2.x && (this.linkChartExtent.xmax = i2.x), this.linkChartExtent.ymin > i2.y && (this.linkChartExtent.ymin = i2.y), this.linkChartExtent.ymax < i2.y && (this.linkChartExtent.ymax = i2.y);
        });
      }), this.memberRelationshipTypes.forEach((e5) => {
        e5.name && this.dataManager.sublayerCaches.get(e5.name)?.forEach((e6) => {
          const t2 = this.relationshipLinkChartDiagramLookup.get(e6.attributes[b]), a2 = this.relationshipLinkChartDiagramLookup.get(e6.attributes[T]);
          if (t2 && a2) {
            const i2 = ot(new m({
              paths: [[t2.coords[0], t2.coords[1]], [a2.coords[0], a2.coords[1]]]
            }));
            this.relationshipLinkChartDiagramLookup.set(e6.attributes[w2], i2);
          } else this.relationshipLinkChartDiagramLookup.set(e6.attributes[w2], null);
        });
      })) : yield this.calculateLinkChartLayout(this.defaultLinkChartConfig.layoutMode, __spreadValues({
        lockedNodeLocations: this.getCurrentNodeLocations()
      }, this.defaultLinkChartConfig.layoutOptions || {})) : yield this.calculateLinkChartLayout("RADIAL_TREE", {
        lockedNodeLocations: this.getCurrentNodeLocations()
      });
    });
  }
  _refreshNamedTypes() {
    for (const e5 of this.layers) e5.emit("refresh", {
      dataChanged: true
    });
    for (const e5 of this.tables) e5.emit("refresh", {
      dataChanged: true
    });
  }
  _validateLayoutSettings(e5, t2) {
    const a2 = (e6) => "number" == typeof e6 && !isNaN(e6), n4 = (e6) => a2(e6) && e6 >= 1, s4 = (e6) => a2(e6) && e6 >= 1, o2 = (e6) => Object.values(e3).includes(e6), r3 = (e6) => a2(e6) && e6 >= 0, h2 = /* @__PURE__ */ new Set(["FORCE_DIRECTED", "COMMUNITY", "GEOGRAPHIC"]), l3 = {};
    if (!h2.has(e5) || !t2) return !h2.has(e5) && t2 && n.getLogger(this).warn("Layout mode options were given for a layout mode that does not utilize them, settings will be ignored"), l3;
    const {
      computationBudgetTime: d,
      repulsionRadiusMultiplier: u2,
      idealEdgeLength: c2,
      idealEdgeLengthType: y3
    } = t2;
    s4(d) ? l3.computationBudgetTime = d : void 0 !== d && n.getLogger(this).warn("Invalid layout computationBudgetTime setting, will revert to default setting"), n4(u2) ? l3.repulsionRadiusMultiplier = u2 : void 0 !== u2 && n.getLogger(this).warn("Invalid layout repulsionRadiusMultiplier setting, will revert to default setting");
    const g2 = void 0 !== c2 || void 0 !== y3;
    return "GEOGRAPHIC" !== e5 && g2 ? n.getLogger(this).warn("Ideal edge length settings were specified for an incompatible layout mode, and will be ignored") : "GEOGRAPHIC" === e5 && g2 && (o2(y3) ? l3.idealEdgeLengthType = y3 : void 0 !== y3 && n.getLogger(this).warn('Invalid layout idealEdgeLengthType setting, will revert to "multiplier" setting'), r3(c2) ? l3.idealEdgeLength = c2 : void 0 !== c2 && n.getLogger(this).warn("Invalid layout idealEdgeLength setting, will revert to default setting")), l3;
  }
  _convertLayoutSettingsToCalculationSettings(e5) {
    let t2 = e5.idealEdgeLength;
    return e5.idealEdgeLengthType === e3.ABSOLUTE && (void 0 === t2 ? t2 = -1 : t2 *= -1), {
      computationBudgetTime: e5.computationBudgetTime,
      repulsionRadiusMultiplier: e5.repulsionRadiusMultiplier,
      idealEdgeLengthMultiplier: t2
    };
  }
};
e([y()], j.prototype, "dataPreloadedInLocalCache", void 0), e([y()], j.prototype, "defaultLinkChartConfig", void 0), e([y()], j.prototype, "dataManager", void 0), e([y()], j.prototype, "knowledgeGraph", void 0), e([y()], j.prototype, "layers", void 0), e([y()], j.prototype, "entityLinkChartDiagramLookup", void 0), e([y()], j.prototype, "relationshipLinkChartDiagramLookup", void 0), e([y()], j.prototype, "linkChartExtent", void 0), e([y()], j.prototype, "memberEntityTypes", void 0), e([y()], j.prototype, "memberRelationshipTypes", void 0), e([y()], j.prototype, "sublayerIdsCache", void 0), e([y()], j.prototype, "tables", void 0), e([y({
  json: {
    read: false
  }
})], j.prototype, "type", void 0), j = e([a("esri.layers.LinkChartLayer")], j);
var P2 = j;
export {
  P2 as default
};
//# sourceMappingURL=LinkChartLayer-AHP65TKS.js.map
