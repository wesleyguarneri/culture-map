import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  g as g3,
  h as h6,
  j as j4,
  m as m3,
  p as p2
} from "./chunk-G3GRFYNY.js";
import {
  e as e7
} from "./chunk-YQGPDXSM.js";
import {
  e as e6
} from "./chunk-K2LPE2X5.js";
import {
  c as c4
} from "./chunk-BGVXUZD4.js";
import {
  k
} from "./chunk-ZZE2XHDC.js";
import "./chunk-5E5FRWDI.js";
import {
  _ as _5,
  f as f7,
  m as m2
} from "./chunk-A3Y2HRWK.js";
import "./chunk-K2PGE3SJ.js";
import {
  g as g2
} from "./chunk-2I3RVFNX.js";
import "./chunk-MH54QISY.js";
import {
  h as h5,
  l as l4
} from "./chunk-JEWURWPQ.js";
import "./chunk-CP2IGGT7.js";
import {
  f as f5,
  r as r9,
  u as u4
} from "./chunk-ZEZCWQFR.js";
import {
  s as s4
} from "./chunk-AOVKCTSO.js";
import {
  t as t6
} from "./chunk-DVWZMNZY.js";
import {
  f as f6
} from "./chunk-FJ65I6KE.js";
import {
  a as a7
} from "./chunk-F2LQGEBE.js";
import "./chunk-7RXQQ22H.js";
import {
  E2 as E4,
  P as P3,
  a as a6,
  p
} from "./chunk-VC76DE2W.js";
import "./chunk-IVVINOEJ.js";
import "./chunk-XUM2DDAI.js";
import {
  h as h4
} from "./chunk-IRKNVCIL.js";
import "./chunk-VTFYXQEG.js";
import {
  a as a5
} from "./chunk-INUNNFZT.js";
import "./chunk-NF2MOJH5.js";
import "./chunk-JP4VYCP3.js";
import {
  f as f4
} from "./chunk-IQWWKVQ4.js";
import {
  e as e5
} from "./chunk-FSYMZVRK.js";
import "./chunk-T4DTOVU4.js";
import "./chunk-TO2KOAJE.js";
import "./chunk-DTMLHZFB.js";
import "./chunk-WYPPXVX7.js";
import {
  a as a4,
  l as l3,
  s as s3
} from "./chunk-T2SCEBLQ.js";
import "./chunk-O7RCHW3H.js";
import {
  r as r5
} from "./chunk-K7U66W6G.js";
import {
  I as I2
} from "./chunk-WQMUOLHB.js";
import {
  S as S2
} from "./chunk-LVERV6OU.js";
import "./chunk-3FFTEL3W.js";
import {
  E as E3
} from "./chunk-4WON4QDF.js";
import "./chunk-45GTM6LF.js";
import {
  c as c3,
  f as f3,
  l as l2,
  s as s2
} from "./chunk-XUZTWNKD.js";
import "./chunk-Q5PBA64J.js";
import {
  t as t5
} from "./chunk-TIAWSZQK.js";
import "./chunk-KWHFMZEB.js";
import "./chunk-FBMJVQWQ.js";
import "./chunk-WUTM5T74.js";
import {
  r as r6,
  r2 as r7,
  t as t4
} from "./chunk-22UDIQGJ.js";
import {
  t as t3
} from "./chunk-Z5ZLX3BE.js";
import "./chunk-D3VQCVGJ.js";
import "./chunk-TSTMST4X.js";
import "./chunk-I47GCEJP.js";
import {
  r as r8
} from "./chunk-LA4GCRJY.js";
import "./chunk-ZTMARHUQ.js";
import "./chunk-P5MJSFMN.js";
import "./chunk-HMPRRFR4.js";
import {
  h as h3,
  u2 as u3
} from "./chunk-UE7ZYRIH.js";
import "./chunk-W24M6HII.js";
import "./chunk-FWGI52X4.js";
import {
  O
} from "./chunk-E5RXQH35.js";
import {
  o as o3
} from "./chunk-62ZEBDPC.js";
import "./chunk-ZFMS3XGM.js";
import "./chunk-QWQJOAVR.js";
import "./chunk-YLQMUXQA.js";
import "./chunk-4U7LUZFD.js";
import "./chunk-T257OY4U.js";
import "./chunk-BMO2W6EC.js";
import "./chunk-QA265FYQ.js";
import {
  S as S3,
  _ as _4,
  l,
  o as o4
} from "./chunk-HUOFTIIK.js";
import "./chunk-ZDFN6OZC.js";
import "./chunk-KSOKDIBG.js";
import "./chunk-3NWWTJOW.js";
import "./chunk-TRF6JO5N.js";
import "./chunk-ZHVMMFTW.js";
import "./chunk-HKAONIBH.js";
import "./chunk-EPIUUGS2.js";
import "./chunk-TMXHZTIG.js";
import "./chunk-FIQ7DCCC.js";
import "./chunk-SNHVHW2N.js";
import "./chunk-QATJRB5Q.js";
import "./chunk-7Z4UWMRU.js";
import "./chunk-Q47GASPN.js";
import "./chunk-LQUVB46M.js";
import "./chunk-GHPF24X4.js";
import "./chunk-UC4DX4SE.js";
import {
  t as t2
} from "./chunk-44O4APOL.js";
import "./chunk-LCPLUSDH.js";
import {
  R as R2
} from "./chunk-KYLW5XXS.js";
import "./chunk-YSJVVDDH.js";
import "./chunk-DLWZ3HVT.js";
import {
  m,
  o as o2,
  r as r4
} from "./chunk-B76NC7GX.js";
import "./chunk-EFLOBCAZ.js";
import "./chunk-ZSJNH2BT.js";
import {
  n as n5
} from "./chunk-ZFES27RA.js";
import "./chunk-XP2AJZUL.js";
import "./chunk-CZA7RDJP.js";
import "./chunk-3PPEJ4QJ.js";
import "./chunk-ZEOLGKXL.js";
import {
  i
} from "./chunk-HITI6WDM.js";
import "./chunk-IS4RJOPJ.js";
import "./chunk-XK3CKE5Q.js";
import "./chunk-AMH7CZMY.js";
import "./chunk-7GHUVMBI.js";
import "./chunk-Q5JLNMWZ.js";
import "./chunk-AABDXAD3.js";
import "./chunk-LGS63R4F.js";
import {
  _ as _3
} from "./chunk-L6FG3WIC.js";
import "./chunk-6ZLH7XBS.js";
import "./chunk-44ZUWZXU.js";
import {
  E as E2,
  F,
  G as G2,
  R,
  q as q2
} from "./chunk-NAG6YX7T.js";
import "./chunk-U4EMQMDC.js";
import {
  t
} from "./chunk-MNBTLVRM.js";
import "./chunk-GNCXYHNE.js";
import "./chunk-2TNGEJGS.js";
import {
  b,
  d as d2,
  j as j3
} from "./chunk-OYGNGIHQ.js";
import "./chunk-GSG4T2KM.js";
import {
  e as e4
} from "./chunk-D7C26LZP.js";
import {
  n as n6,
  r as r3
} from "./chunk-BZHHBBFX.js";
import {
  c as c2
} from "./chunk-GK5M6FUR.js";
import {
  a as a3
} from "./chunk-Y7SJWJAL.js";
import "./chunk-A2FDYA6M.js";
import {
  e as e3
} from "./chunk-YGAXDKHF.js";
import "./chunk-4TOSJLKR.js";
import "./chunk-C7BQE556.js";
import "./chunk-VOOO6FU5.js";
import "./chunk-KUBMHTYA.js";
import {
  n as n4,
  r as r2
} from "./chunk-VSQZQLTQ.js";
import {
  E,
  a as a2
} from "./chunk-K43CZ3M5.js";
import "./chunk-S4XQLN73.js";
import {
  H,
  J as J2
} from "./chunk-LM3JDV4W.js";
import "./chunk-34V2CLL5.js";
import "./chunk-2EJFYNM7.js";
import "./chunk-5X5U7R6O.js";
import {
  I,
  q
} from "./chunk-KOI252FF.js";
import "./chunk-SR7PRON4.js";
import "./chunk-HGHPYGKP.js";
import "./chunk-4DSGTDZJ.js";
import "./chunk-VYTPFEL2.js";
import "./chunk-RLGDH6IY.js";
import "./chunk-MRPCXIVS.js";
import "./chunk-YTKVV2Y3.js";
import {
  D,
  f as f2
} from "./chunk-GCVQXAS4.js";
import {
  n as n3
} from "./chunk-UFQD6AL4.js";
import "./chunk-EBCBYN6Y.js";
import "./chunk-ODFKYX74.js";
import "./chunk-THZPD5CT.js";
import {
  h
} from "./chunk-OBCA6CWH.js";
import "./chunk-2JI245BP.js";
import "./chunk-N34BRXVM.js";
import "./chunk-7QV7DHWN.js";
import "./chunk-4L4Y34YK.js";
import "./chunk-2HDBQXAR.js";
import {
  G
} from "./chunk-RNF7VOCU.js";
import {
  _
} from "./chunk-TIRJMGGG.js";
import "./chunk-ZDRQSPB6.js";
import "./chunk-DCXDXGAR.js";
import "./chunk-BCCDYCTQ.js";
import {
  f
} from "./chunk-AYL3HQHD.js";
import "./chunk-66YQWHHE.js";
import "./chunk-QGBMZIP4.js";
import "./chunk-AOEBZVTA.js";
import {
  c,
  h as h2
} from "./chunk-2OZSYJDX.js";
import {
  P as P2,
  _ as _2,
  e as e2,
  g,
  j as j2,
  r,
  u as u2,
  x,
  z
} from "./chunk-MZM4INJV.js";
import {
  n as n2
} from "./chunk-J4GMQHGL.js";
import "./chunk-MHPE4SZA.js";
import {
  A3 as A2,
  J,
  K,
  Z,
  j,
  s3 as s,
  se,
  v
} from "./chunk-6SSA7P3A.js";
import "./chunk-FQBTLEUI.js";
import "./chunk-GS7Y3YOG.js";
import "./chunk-Y2HYKTTT.js";
import "./chunk-XLEC46FY.js";
import "./chunk-4AZPIP7K.js";
import "./chunk-JSKTDZU2.js";
import "./chunk-G73HQZEL.js";
import {
  A,
  C,
  P,
  d
} from "./chunk-LZSLQ24Q.js";
import "./chunk-U3RHUXYK.js";
import "./chunk-7DBI6LQG.js";
import "./chunk-AUUN7RFQ.js";
import {
  o
} from "./chunk-JAMSDYD6.js";
import "./chunk-PH6NPTP7.js";
import {
  e
} from "./chunk-NUICEVIH.js";
import {
  S
} from "./chunk-NXK752PZ.js";
import {
  y
} from "./chunk-UVNLCXWD.js";
import "./chunk-PNUA7JOS.js";
import "./chunk-OR2FKGUM.js";
import {
  a3 as a
} from "./chunk-UDMPWVPF.js";
import "./chunk-XJNKCEWL.js";
import "./chunk-AIZ3T7E3.js";
import "./chunk-6UEMNP3E.js";
import {
  u
} from "./chunk-6WGE3IUL.js";
import "./chunk-MLYB2YW4.js";
import {
  n2 as n
} from "./chunk-6JFGZTLU.js";
import "./chunk-2ZJE6ZFX.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-XBPEBUD5.js";

// ../../../node_modules/@arcgis/core/geometry/projection/projectDirection.js
function f8(t7, f9, a8, n8, p4) {
  r(i2, t7), u2(m4, t7, f9), n5(i2, a8, i2, p4), n5(m4, a8, m4, p4), e2(n8, m4, i2), z(n8, n8);
}
var i2 = n2();
var m4 = n2();

// ../../../node_modules/@arcgis/core/views/3d/analysis/AreaMeasurement/support/MeasurementData.js
var J3 = class {
  get numVertices() {
    return this._length;
  }
  get hasStagedVertex() {
    return this._hasCursorPoint;
  }
  constructor(e8) {
    this.validMeasurement = false, this.positionsWorld = [], this.positionsRender = [], this.positionsFittedWorld = [], this.positionsFittedRender = [], this.positionsGeodesic = [], this.positionsSpherical = [], this.positionsStereographic = [], this.pathSegmentLengths = [], this.geodesicPathSegmentLengths = [], this.perimeterSegmentLengths = [], this.intersectingSegments = /* @__PURE__ */ new Set(), this.geodesicIntersectingSegments = /* @__PURE__ */ new Set(), this.triangleIndices = null, this.geodesicTriangleIndices = null, this.areaCentroidWorldCoords = n2(), this.areaCentroidRenderCoords = n2(), this.geodesicAreaCentroidRenderCoords = n2(), this.fittingMode = null, this.area = null, this.geodesicArea = null, this.pathLength = null, this.geodesicPathLength = null, this.perimeterLength = null, this._length = 0, this._centroidRenderCoords = n2(), this._planeWorldCoords = n4(), this._worldUp = n2(), this._worldTangent = n2(), this._frame = [n2(), n2(), n2()], this._pathVersion = -1, this._hasCursorPoint = false, this._mode = null, this._tempU = n2(), this._tempV = n2(), this._tempVec3 = n2(), this._tempSphere = _3(), this._sceneView = e8;
    const t7 = l4(e8.spatialReference);
    this._measurementSR = t7, this._lengthMeasurementUnit = Z(t7) ?? "meters", this._areaMeasurementUnit = se(t7) ?? "square-meters";
  }
  update(e8, t7, s5, i3, o5, n8) {
    const r11 = null != t7, h8 = this._pathVersion === e8.version, a8 = this._hasCursorPoint === r11, l5 = this._mode === o5;
    return !(h8 && !n8 && a8 && l5 && e8.isValidPolygon) && (this._pathVersion = e8.version, this._hasCursorPoint = r11, this._updateCursorSegmentLength(e8, t7), this._update(e8, t7, s5, i3, o5), true);
  }
  _update(e8, s5, i3, o5, n8) {
    const r11 = this._sceneView.renderSpatialReference, h8 = this._measurementSR, a8 = i3.spatialReference;
    let l5 = e8.numVertices;
    const d3 = !(null == s5 || s5.equals(e8.lastPoint) || l5 > 2 && s5.equals(e8.firstPoint));
    d3 && (l5 += 1);
    const g6 = !e8.polygonIsClosed && l5 > 2, c6 = e8.polygonIsClosed || g6;
    this._resize(l5);
    const p4 = a3(a8), m7 = null != a8 && r9(a8) ? a8 : null, u6 = null != m7 && J2(a8, p4), {
      positionsGeodesic: _8,
      positionsWorld: S4,
      positionsRender: L,
      positionsSpherical: C2
    } = this, P4 = (e9, t7) => {
      K2(i3.elevationProvider, e9), c2(e9, S4[t7], h8), c2(e9, L[t7], r11), u6 && (c2(e9, _8[t7], m7), c2(e9, C2[t7], p4), z(C2[t7], C2[t7]));
    };
    e8.forEachVertexPosition((e9, t7) => P4(e9, t7)), d3 && P4(s5, l5 - 1);
    const U2 = this._updatePathLengths(c6);
    if (this.pathLength = this._length > 1 ? a4(U2, this._lengthMeasurementUnit) : null, u6) {
      const e9 = this._updateGeodesicPathLengths(c6, m7);
      this.geodesicPathLength = null != e9 && this._length > 1 ? e9 : null;
    } else this.geodesicPathLength = null;
    if (this._updateMode(n8), !c6) return this.area = null, this.geodesicArea = null, this.perimeterLength = null, this.triangleIndices = null, this.geodesicTriangleIndices = null, this.intersectingSegments.clear(), this.geodesicIntersectingSegments.clear(), void (this.validMeasurement = false);
    this._updateAreaAndPerimeterLength(i3, r11, h8, o5), u6 && this._updateGeodesicArea(i3, m7), this.validMeasurement = true;
  }
  getData() {
    return {
      validMeasurement: this.validMeasurement,
      numVertices: this.numVertices,
      hasStagedVertex: this.hasStagedVertex,
      positionsRender: this.positionsRender,
      positionsFittedWorld: this.positionsFittedWorld,
      positionsFittedRender: this.positionsFittedRender,
      intersectingSegments: this.intersectingSegments,
      geodesicIntersectingSegments: this.geodesicIntersectingSegments,
      triangleIndices: this.triangleIndices,
      geodesicTriangleIndices: this.geodesicTriangleIndices,
      areaCentroidRenderCoords: this.areaCentroidRenderCoords,
      geodesicAreaCentroidRenderCoords: this.geodesicAreaCentroidRenderCoords,
      area: this.area,
      geodesicArea: this.geodesicArea,
      pathLength: this.pathLength,
      geodesicPathLength: this.geodesicPathLength,
      perimeterLength: this.perimeterLength,
      actualMeasurementMode: this.actualMeasurementMode
    };
  }
  _resize(e8) {
    for (e8 < this._length && (this.positionsWorld.length = e8, this.positionsRender.length = e8, this.positionsFittedWorld.length = e8, this.positionsFittedRender.length = e8, this.positionsGeodesic.length = e8, this.positionsSpherical.length = e8, this.positionsStereographic.length = e8, this.pathSegmentLengths.length = e8, this.geodesicPathSegmentLengths.length = e8, this.perimeterSegmentLengths.length = e8, this._length = e8); this._length < e8; ) this.positionsWorld.push(n2()), this.positionsRender.push(n2()), this.positionsFittedWorld.push(n6()), this.positionsFittedRender.push(n2()), this.positionsGeodesic.push(n2()), this.positionsSpherical.push(n2()), this.positionsStereographic.push(n6()), this.pathSegmentLengths.push(0), this.geodesicPathSegmentLengths.push(0), this.perimeterSegmentLengths.push(0), ++this._length;
  }
  _updatePathLengths(e8) {
    const t7 = this.positionsWorld, s5 = this.pathSegmentLengths;
    let i3 = 0;
    const o5 = this._length;
    for (let n8 = 0; n8 < o5; ++n8) {
      const r11 = s5[n8] = x(t7[n8], t7[(n8 + 1) % o5]);
      (n8 < o5 - 1 || e8) && (i3 += r11);
    }
    return i3;
  }
  _updateGeodesicPathLengths(e8, i3) {
    const o5 = this.positionsGeodesic, n8 = this.geodesicPathSegmentLengths;
    let r11 = 0;
    const h8 = this._length;
    for (let t7 = 0; t7 < h8; ++t7) {
      const a8 = u4(o5[t7], o5[(t7 + 1) % h8], i3);
      if (null == a8) return null;
      const l5 = s3(a8, "meters").value, d3 = n8[t7] = l5;
      (t7 < h8 - 1 || e8) && (r11 += d3);
    }
    return a4(r11, "meters");
  }
  _updateAreaAndPerimeterLength(e8, t7, s5, i3) {
    const o5 = e8.renderCoordsHelper, n8 = this.positionsWorld, h8 = this.positionsRender, a8 = this.positionsFittedWorld, l5 = this.positionsFittedRender, f9 = this._planeWorldCoords, S4 = this._centroidRenderCoords;
    d2(h8, S4), o5.worldUpAtPosition(S4, this._worldUp), o5.worldBasisAtPosition(S4, n3.X, this._worldTangent), f8(S4, this._worldUp, t7, this._worldUp, s5), f8(S4, this._worldTangent, t7, this._worldTangent, s5), n8.length > 2 && h6(n8, f9), this.fittingMode = this._selectFittingMode(f9, n8, this._worldUp, i3);
    let L = 0;
    if ("horizontal" === this.fittingMode) {
      let e9 = -1 / 0;
      h8.forEach((t8, s6) => {
        const i4 = o5.getAltitude(h8[s6]);
        i4 > e9 && (e9 = i4, L = s6);
      });
    }
    const C2 = n8[L];
    let M = f9, j5 = this._worldTangent;
    "horizontal" === this.fittingMode ? M = this._worldUp : "vertical" === this.fittingMode && (M = this._tempVec3, j5 = this._worldUp, b(f9, this._worldUp, M)), r(this._frame[2], M), b(j5, M, this._frame[0]), _2(this._frame[1], this._frame[0], this._frame[2]), j2(this._frame[1], this._frame[1]);
    const R3 = this._tempVec3, v2 = this._tempU, V = this._tempV;
    for (let d3 = 0; d3 < this._length; ++d3) {
      const e9 = a8[d3], i4 = l5[d3];
      e2(R3, n8[d3], C2), o2(e9, P2(this._frame[0], R3), P2(this._frame[1], R3)), g(v2, this._frame[0], e9[0]), g(V, this._frame[1], e9[1]), u2(R3, v2, V), u2(R3, R3, C2), n5(R3, s5, i4, t7);
    }
    this.perimeterLength = this._length > 0 ? this._updatePerimeterLengths() : null, d2(l5, this.areaCentroidRenderCoords), n5(this.areaCentroidRenderCoords, t7, this.areaCentroidWorldCoords, s5), this._updateIntersectingSegments(), this.area = 0 === this.intersectingSegments.size ? this._computeArea() : null;
  }
  _updateGeodesicArea(e8, t7) {
    const {
      renderCoordsHelper: s5,
      spatialReference: i3
    } = e8, {
      positionsSpherical: o5,
      positionsStereographic: n8
    } = this, h8 = this._tempVec3, a8 = j4(o5, h8);
    if (!a8) return void (this.geodesicArea = null);
    const l5 = this._tempU, d3 = this._tempV;
    j3(h8, l5, d3);
    for (let g6 = 0; g6 < this._length; ++g6) {
      const e9 = P2(o5[g6], l5), t8 = P2(o5[g6], d3), s6 = P2(o5[g6], h8);
      o2(n8[g6], e9 / s6, t8 / s6);
    }
    g(h8, h8, s(i3).radius), s5.toRenderCoords(h8, a3(i3), this.geodesicAreaCentroidRenderCoords), this._updateGeodesicIntersectingSegments(), this.geodesicArea = a8 && 0 === this.geodesicIntersectingSegments.size ? this._computeGeodesicArea(t7) : null;
  }
  _updatePerimeterLengths() {
    const e8 = this.positionsFittedWorld, s5 = this.perimeterSegmentLengths;
    let i3 = 0;
    for (let t7 = 0; t7 < this._length; ++t7) {
      i3 += s5[t7] = m(e8[t7], e8[(t7 + 1) % this._length]);
    }
    return a4(i3, this._lengthMeasurementUnit);
  }
  _updateIntersectingSegments() {
    const e8 = this.positionsFittedWorld, t7 = this.intersectingSegments;
    t7.clear();
    for (let s5 = 0; s5 < this._length; ++s5) for (let i3 = s5 + 2; i3 < this._length; ++i3) {
      if ((i3 + 1) % this._length === s5) continue;
      const o5 = e8[s5], n8 = e8[(s5 + 1) % this._length], r11 = e8[i3], h8 = e8[(i3 + 1) % this._length];
      G(o5, n8, r11, h8) && (t7.add(s5), t7.add(i3));
    }
  }
  _computeArea() {
    const e8 = this.positionsFittedWorld, t7 = this.triangleIndices = t2(k(e8));
    let s5 = 0;
    for (let i3 = 0; i3 < t7.length; i3 += 3) s5 += S2(e8[t7[i3]], e8[t7[i3 + 1]], e8[t7[i3 + 2]]);
    return l3(s5, this._areaMeasurementUnit);
  }
  _updateGeodesicIntersectingSegments() {
    const e8 = this.positionsStereographic, t7 = this.geodesicIntersectingSegments;
    t7.clear();
    for (let s5 = 0; s5 < this._length; ++s5) for (let i3 = s5 + 2; i3 < this._length; ++i3) {
      if ((i3 + 1) % this._length === s5) continue;
      const o5 = e8[s5], n8 = e8[(s5 + 1) % this._length], r11 = e8[i3], h8 = e8[(i3 + 1) % this._length];
      G(o5, n8, r11, h8) && (t7.add(s5), t7.add(i3));
    }
  }
  _computeGeodesicArea(e8) {
    const t7 = this.positionsGeodesic, o5 = this.positionsStereographic, n8 = this.geodesicTriangleIndices = t2(k(o5));
    let r11 = 0;
    for (let i3 = 0; i3 < n8.length; i3 += 3) {
      const o6 = m3(t7[n8[i3]], t7[n8[i3 + 1]], t7[n8[i3 + 2]], e8);
      if (null == o6) return null;
      r11 += s3(o6, "square-meters").value;
    }
    return l3(r11, "square-meters");
  }
  _selectFittingMode(t7, s5, i3, o5) {
    const n8 = s5.map((e8) => Math.abs(p2(t7, e8))).reduce((e8, t8) => Math.max(e8, t8), 0);
    g3(s5, this._tempSphere);
    const r11 = n8 / (2 * this._tempSphere[3]), h8 = r11 < o5.maxRelativeErrorCoplanar, a8 = r11 < o5.maxRelativeErrorAlmostCoplanar;
    let l5 = "horizontal";
    if (h8) l5 = "oblique";
    else if (a8) {
      l5 = Math.abs(P2(i3, t7)) > Math.cos(h2(o5.verticalAngleThreshold)) ? "horizontal" : "vertical";
    }
    return l5;
  }
  _updateCursorSegmentLength(e8, t7) {
    const s5 = e8.lastPoint;
    e8.isValidPolygon || null == s5 || null == t7 ? (this.geodesicStagedSegmentLength = null, this.stagedSegmentLength = null) : (this.geodesicStagedSegmentLength = f5(s5, t7), this.stagedSegmentLength = h5(s5, t7)?.direct);
  }
  _updateMode(e8) {
    if (e8 === e7.Auto) {
      this.actualMeasurementMode = "euclidean";
      let e9 = 0;
      null != this.geodesicPathLength && (e9 += this.geodesicPathLength.value), e9 > N && (this.actualMeasurementMode = "geodesic");
    } else this.actualMeasurementMode = e8 === e7.Euclidean ? "euclidean" : "geodesic";
    null == this.geodesicPathLength && (this.actualMeasurementMode = "euclidean"), this._mode = e8;
  }
};
function K2(e8, t7) {
  t7.hasZ || (t7.z = a5(e8, t7, "ground") ?? 0);
}
var N = 1e5;

// ../../../node_modules/@arcgis/core/views/3d/analysis/AreaMeasurement/support/AreaMeasurementController.js
var n7 = class extends S {
  constructor(t7) {
    super(t7);
  }
  initialize() {
    this._measurementDataManager = new J3(this.view), this.addHandles([this.analysisViewData.path.on("change", () => this._update()), d(() => this.analysisViewData.stagedPoint, () => this._update(), C), d(() => this.analysisViewData.mode, () => this._update(), C)]), this._update();
  }
  _update(t7 = false) {
    const {
      analysisViewData: a8,
      view: e8
    } = this, s5 = {
      maxRelativeErrorCoplanar: 5e-3,
      maxRelativeErrorAlmostCoplanar: 0.01,
      verticalAngleThreshold: 80
    };
    this._measurementDataManager.update(a8.path, a8.stagedPoint, e8, s5, a8.mode, t7) && (a8.measurementData = this._measurementDataManager.getData());
  }
};
e([y({
  constructOnly: true
})], n7.prototype, "view", void 0), e([y({
  constructOnly: true
})], n7.prototype, "analysis", void 0), e([y({
  constructOnly: true
})], n7.prototype, "analysisViewData", void 0), n7 = e([a("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementController")], n7);

// ../../../node_modules/@arcgis/core/views/3d/analysis/AreaMeasurement/support/AreaMeasurementPathHelper.js
var g4 = class extends o.EventedAccessor {
  constructor(e8 = {}) {
    super(e8), this._version = 0, this._internalGeometryChange = false, this._extent = D();
  }
  set areaMeasurement(e8) {
    this._set("areaMeasurement", e8), null != e8 && null != this.view && this._initialize(e8, this.view);
  }
  set view(e8) {
    this._set("view", e8), null != e8 && null != this.areaMeasurement && this._initialize(this.areaMeasurement, e8);
  }
  get constructed() {
    return null != this.areaMeasurement && null != this.view;
  }
  get version() {
    return this._version;
  }
  get isEmptyPolygon() {
    return !this.constructed || 0 === this._editGeometry.components.length;
  }
  get isValidPolygon() {
    return this.constructed && this.polygonIsClosed;
  }
  get extent() {
    if (this.constructed && this._editGeometry.components.length > 0 && this._editGeometry.components[0].vertices.length > 0) {
      const e8 = D(this._extent);
      return this.forEachVertex((t7) => {
        f2(e8, t7.pos);
      }), e8;
    }
    return null;
  }
  get spatialReference() {
    return this.constructed ? this._editGeometry.coordinateHelper.spatialReference : null;
  }
  _initialize(e8, t7) {
    this.removeAllHandles(), this.addHandles(d(() => e8.geometry, () => {
      this._updateEditGeometryFromModelGeometry(e8, t7);
    }, A)), this._makeDirty(true);
  }
  _makeDirty(e8 = false) {
    this.notifyChange("polygonIsClosed"), this.notifyChange("isValidPolygon"), this.notifyChange("initialized"), this.notifyChange("extent"), e8 && this.notifyChange("numVertices");
  }
  _updateEditGeometryFromModelGeometry(e8, t7) {
    if (this._version++, this._internalGeometryChange) return;
    this.removeHandles("EditGeometry");
    let r11 = e8.geometry;
    if (null != r11) {
      const i3 = H(r11, t7.spatialReference);
      null == i3 && t6(e8, r11.spatialReference, n.getLogger(this)), r11 = i3;
    }
    this._editGeometryOperations = null != r11 ? E4.fromGeometry(r11, t7.state.viewingMode) : new E4(new p("polygon", P3(true, false, t7.spatialReference)), t7.state.viewingMode), this._makeDirty(true), this.emit("change"), this.addHandles(this._editGeometry.on("change", (t8) => {
      this._makeDirty(null != t8.addedVertices || null != t8.removedVertices), this._internalGeometryChange = true, e8.geometry = this.numVertices > 0 ? this._editGeometry.geometry : null, this._internalGeometryChange = false;
    }), "EditGeometry");
  }
  get _editGeometry() {
    return this._editGeometryOperations.data;
  }
  get vertices() {
    const e8 = [];
    return this.forEachVertex((t7) => {
      e8.push(t7);
    }), e8;
  }
  get numVertices() {
    return this.constructed && this._editGeometry.components.length > 0 ? this._editGeometry.components[0].vertices.length : 0;
  }
  get polygonIsClosed() {
    return this._editGeometry.components.length > 0 && this._editGeometry.components[0].isClosed();
  }
  get firstPoint() {
    if (this.constructed && this._editGeometry.components.length > 0) {
      const e8 = this._editGeometry.components[0].getFirstVertex();
      if (null != e8) return this._editGeometry.coordinateHelper.vectorToPoint(e8.pos);
    }
    return null;
  }
  get lastPoint() {
    if (this.constructed && this._editGeometry.components.length > 0) {
      const e8 = this._editGeometry.components[0].getLastVertex();
      if (null != e8) return this._editGeometry.coordinateHelper.vectorToPoint(e8.pos);
    }
    return null;
  }
  getVertex(e8) {
    if (!this.constructed || 0 === this._editGeometry.components.length || 0 === this._editGeometry.components[0].vertices.length) return null;
    const t7 = this._editGeometry.components[0].vertices[0];
    let o5 = t7;
    do {
      if (o5.index === e8) return o5;
      o5 = o5.rightEdge.rightVertex;
    } while (o5 !== t7 && null != o5);
    return null;
  }
  getVertexPositionAsPoint(e8) {
    return this._editGeometry.coordinateHelper.vectorToPoint(e8.pos);
  }
  getVertexPositionAsPointFromIndex(e8) {
    return this._editGeometry.coordinateHelper.vectorToPoint(this.getVertex(e8).pos);
  }
  forEachVertex(e8) {
    this.constructed && this._editGeometry.components.length > 0 && this._editGeometry.components[0].iterateVertices(e8);
  }
  forEachVertexPosition(e8) {
    const t7 = this._editGeometry.coordinateHelper;
    this.forEachVertex((o5, r11) => {
      t7.vectorToPoint(o5.pos, _6), e8(_6, r11);
    });
  }
  clear() {
    null != this.areaMeasurement && (this.areaMeasurement.geometry = null);
  }
  add(e8) {
    if (!this.constructed) return null;
    if (0 === this._editGeometry.components.length) {
      const e9 = this.view;
      this._editGeometry.components.push(new a6(e9.spatialReference, e9.state.viewingMode));
    }
    const t7 = this._editGeometryOperations.appendVertex(this._editGeometry.coordinateHelper.pointToVector(e8));
    return this.emit("change"), t7;
  }
  close() {
    if (!this.constructed || 0 === this._editGeometry.components.length) return null;
    const e8 = this._editGeometryOperations.closeComponent(this._editGeometry.components[0]);
    return this.emit("change"), e8;
  }
  ensureContains(e8, t7 = "") {
    let o5 = false;
    if (this._editGeometry.components.forEach((t8) => {
      t8.iterateVertices((t9) => {
        t9 === e8 && (o5 = true);
      });
    }), !o5) throw new Error(`vertex doesnt exist ${t7}`);
    return o5;
  }
  setVertexPosition(e8, t7) {
    if (!this.constructed) return null;
    const o5 = this._editGeometryOperations.setVertexPosition(e8, this._editGeometry.coordinateHelper.pointToVector(t7));
    return this.emit("change"), o5;
  }
  equals(e8) {
    if (this.numVertices !== e8.numVertices) return false;
    let t7 = true;
    return this.forEachVertexPosition((o5, r11) => {
      const i3 = e8.getVertexPositionAsPointFromIndex(r11);
      o5.equals(i3) || (t7 = false);
    }), !!t7;
  }
};
e([y({
  value: null
})], g4.prototype, "areaMeasurement", null), e([y({
  value: null
})], g4.prototype, "view", null), e([y()], g4.prototype, "isEmptyPolygon", null), e([y()], g4.prototype, "isValidPolygon", null), e([y()], g4.prototype, "extent", null), e([y()], g4.prototype, "spatialReference", null), e([y()], g4.prototype, "numVertices", null), e([y()], g4.prototype, "polygonIsClosed", null), g4 = e([a("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementPathHelper")], g4);
var _6 = new _();

// ../../../node_modules/@arcgis/core/views/3d/webgl-engine/shaders/CheckerBoardTechnique.js
var h7 = class _h extends r6 {
  initializeProgram(e8) {
    return new r7(e8.rctx, _h.shader.get().build(this.configuration), O);
  }
  _setPipelineState(e8) {
    const r11 = this.configuration, t7 = e8 === o3.NONE, a8 = e8 === o3.FrontFace;
    return S3({
      blending: r11.transparent ? t7 ? b2 : c3(e8) : null,
      depthTest: {
        func: f3(e8)
      },
      depthWrite: t7 ? r11.writeDepth ? o4 : null : l2(e8),
      drawBuffers: s2(e8),
      colorWrite: _4,
      polygonOffset: t7 || a8 ? r11.polygonOffset ? g5 : null : {
        factor: -1,
        units: -25
      }
    });
  }
  initializePipeline() {
    return this._setPipelineState(this.configuration.transparencyPassType);
  }
};
h7.shader = new t4(c4, () => import("./CheckerBoard.glsl-GWXEQA3N.js"));
var g5 = {
  factor: 0,
  units: -25
};
var b2 = l(R2.SRC_ALPHA, R2.ONE, R2.ONE_MINUS_SRC_ALPHA, R2.ONE_MINUS_SRC_ALPHA);

// ../../../node_modules/@arcgis/core/views/3d/webgl-engine/shaders/CheckerBoardTechniqueConfiguration.js
var r10 = class extends t5 {
  constructor() {
    super(...arguments), this.transparencyPassType = o3.NONE, this.transparent = false, this.writeDepth = true, this.polygonOffset = false, this.multipassEnabled = false, this.cullAboveGround = false;
  }
};
e([r8({
  count: o3.COUNT
})], r10.prototype, "transparencyPassType", void 0), e([r8()], r10.prototype, "transparent", void 0), e([r8()], r10.prototype, "writeDepth", void 0), e([r8()], r10.prototype, "polygonOffset", void 0), e([r8()], r10.prototype, "multipassEnabled", void 0), e([r8()], r10.prototype, "cullAboveGround", void 0), e([r8({
  constValue: false
})], r10.prototype, "occlusionPass", void 0);

// ../../../node_modules/@arcgis/core/views/3d/webgl-engine/materials/CheckerBoardMaterial.js
var u5 = class extends e5 {
  constructor(r11) {
    super(r11, new m5()), this.produces = /* @__PURE__ */ new Map([[E3.OPAQUE_MATERIAL, (r12) => i(r12) && !this.parameters.transparent], [E3.TRANSPARENT_MATERIAL, (r12) => i(r12) && this.parameters.transparent && this.parameters.writeDepth], [E3.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL, (r12) => i(r12) && this.parameters.transparent && !this.parameters.writeDepth]]), this._configuration = new r10();
  }
  getConfiguration(r11, t7) {
    return this._configuration.transparent = this.parameters.transparent, this._configuration.writeDepth = this.parameters.writeDepth, this._configuration.polygonOffset = this.parameters.polygonOffset, this._configuration.transparencyPassType = t7.transparencyPassType, this._configuration.multipassEnabled = t7.multipassEnabled, this._configuration.cullAboveGround = t7.multipassTerrain.cullAboveGround, this._configuration;
  }
  createGLMaterial(r11) {
    return new c5(r11);
  }
  createBufferWriter() {
    return new r5(f4);
  }
};
var c5 = class extends t3 {
  beginSlot(r11) {
    return this.ensureTechnique(h7, r11);
  }
};
var m5 = class extends u3 {
  constructor() {
    super(...arguments), this.size = r3(1, 1), this.color1 = r2(0.75, 0.75, 0.75, 1), this.color2 = r2(0.5, 0.5, 0.5, 1), this.transparent = false, this.writeDepth = true, this.polygonOffset = false;
  }
};

// ../../../node_modules/@arcgis/core/views/3d/interactive/visualElements/MeasurementAreaVisualElement.js
var _7 = class extends a7 {
  constructor(e8) {
    super(e8), this._checkerBoardMaterial = null, this._renderOccluded = h3.OccludeAndTransparent, this._geometry = null, this._size = r3(1, 1), this._color1 = r2(1, 0.5, 0, 0.5), this._color2 = r2(1, 1, 1, 0.5), this.applyProperties(e8);
  }
  get renderOccluded() {
    return this._renderOccluded;
  }
  set renderOccluded(e8) {
    e8 !== this._renderOccluded && (this._renderOccluded = e8, this._updateMaterial());
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(e8) {
    this._geometry = e8, this.recreateGeometry();
  }
  get size() {
    return this._size;
  }
  set size(e8) {
    r4(this._size, e8), this._updateMaterial();
  }
  get color1() {
    return this._color1;
  }
  set color1(e8) {
    E(e8, this._color1) || (a2(this._color1, e8), this._updateMaterial());
  }
  get color2() {
    return this._color2;
  }
  set color2(e8) {
    E(e8, this._color2) || (a2(this._color2, e8), this._updateMaterial());
  }
  _updateMaterial() {
    null != this._checkerBoardMaterial && this._checkerBoardMaterial.setParameters({
      size: this._size,
      color1: this._color1,
      color2: this._color2,
      renderOccluded: this._renderOccluded
    });
  }
  createExternalResources() {
    this._checkerBoardMaterial = new u5({
      size: this._size,
      color1: this._color1,
      color2: this._color2,
      transparent: true,
      writeDepth: false,
      polygonOffset: true,
      renderOccluded: h3.OccludeAndTransparent,
      isDecoration: this.isDecoration
    });
  }
  destroyExternalResources() {
    this._checkerBoardMaterial = null;
  }
  forEachExternalMaterial(e8) {
    null != this._checkerBoardMaterial && e8(this._checkerBoardMaterial);
  }
  createGeometries(r11) {
    if (null == this._geometry || null == this._checkerBoardMaterial) return;
    const t7 = p3;
    I(t7, this.transform);
    const s5 = this._geometry, c6 = [], a8 = n2();
    s5.position.forEach((e8) => {
      e2(a8, e8, t7), c6.push(a8[0], a8[1], a8[2]);
    });
    const l5 = [];
    s5.uv.forEach((e8) => {
      l5.push(e8[0], e8[1]);
    });
    const d3 = new I2(this._checkerBoardMaterial, [[e4.POSITION, new t(c6, s5.triangleIndices, 3, true)], [e4.UV0, new t(l5, s5.triangleIndices, 2, true)]]);
    r11.addGeometry(d3);
  }
};
var p3 = n2();

// ../../../node_modules/@arcgis/core/views/3d/analysis/AreaMeasurement/support/AreaMeasurementVisualization.js
var F2 = class extends S {
  get _parameters() {
    const {
      accentColor: e8,
      textColor: t7
    } = this.view.effectiveTheme, o5 = E2(e8), l5 = F(e8, 0.5), c6 = F(G2(e8), 0.5), m7 = G2(t7, q2.Low);
    return {
      accentColor: o5,
      transparentAccentColor: l5,
      transparentContrastColor: c6,
      intersectingLineColor: [1, 0.2, 0, 1],
      textColor: t7,
      textBackgroundColor: R(m7, 0.6),
      textCalloutColor: R(m7, 0.5),
      pathLineWidth: 3,
      perimeterLineWidth: 2,
      projectionLineWidth: 2,
      projectionLineStippleSize: 5,
      labelDistance: 25
    };
  }
  get visible() {
    return this.analysisViewData.visible;
  }
  get _renderUnits() {
    const e8 = this.view.renderCoordsHelper.spatialReference;
    return Z(e8) ?? "meters";
  }
  get testData() {
  }
  constructor(e8) {
    super(e8), this._path = null, this._intersectedPath = null, this._perimeter = null, this._intersectedPerimeter = null, this._projectionLines = null, this._measurementArea = null, this._areaLabel = null, this._perimeterLengthLabel = null, this._pathSegments = [], this._perimeterSegments = [], this._origin = n2(), this._originTransform = e3(), this.messages = null, this.viewData = B, this.areaLabel = null, this.perimeterLengthLabel = null, this.loadingMessages = true;
  }
  initialize() {
    const {
      analysisViewData: e8,
      _parameters: t7,
      view: i3
    } = this;
    this._path = new f6({
      view: i3,
      attached: true,
      width: t7.pathLineWidth,
      polygonOffset: true,
      renderOccluded: h3.OccludeAndTransparent,
      isDecoration: true
    }), this._intersectedPath = new f6({
      view: i3,
      attached: true,
      width: t7.pathLineWidth,
      polygonOffset: true,
      renderOccluded: h3.OccludeAndTransparent,
      isDecoration: true
    }), this._perimeter = new f6({
      view: i3,
      attached: true,
      width: t7.perimeterLineWidth,
      polygonOffset: true,
      renderOccluded: h3.OccludeAndTransparent,
      isDecoration: true
    }), this._intersectedPerimeter = new f6({
      view: i3,
      attached: true,
      width: t7.perimeterLineWidth,
      color: t7.intersectingLineColor,
      polygonOffset: true,
      renderOccluded: h3.OccludeAndTransparent,
      isDecoration: true
    }), this._projectionLines = new f6({
      view: i3,
      attached: true,
      width: t7.projectionLineWidth,
      stipplePattern: h4(t7.projectionLineStippleSize),
      polygonOffset: true,
      renderOccluded: h3.OccludeAndTransparent,
      isDecoration: true
    }), this._measurementArea = new _7({
      view: i3,
      attached: true,
      isDecoration: true
    });
    const s5 = {
      attached: true,
      view: i3,
      isDecoration: true
    };
    this._areaLabel = new f7(__spreadProps(__spreadValues({}, s5), {
      fontSize: G3.Large
    })), this._perimeterLengthLabel = new f7(__spreadProps(__spreadValues({}, s5), {
      fontSize: G3.Small
    })), this.addHandles([d(() => [e8.mode, this.visible, e8.unit, e8.measurementData, e8.stagedPoint], () => this._update(), A), d(() => i3.state?.camera, () => this._updateLabels(), A), f(() => this._updateMessageBundle()), d(() => this._parameters, ({
      accentColor: e9,
      transparentAccentColor: t8,
      transparentContrastColor: i4,
      textColor: s6,
      textBackgroundColor: r11,
      textCalloutColor: n8
    }) => {
      const {
        _path: a8,
        _intersectedPath: o5,
        _perimeter: l5,
        _projectionLines: c6,
        _measurementArea: m7,
        _areaLabel: h8,
        _perimeterLengthLabel: d3
      } = this;
      a8.color = e9, o5.color = e9, l5.color = e9, c6.color = e9, m7.color1 = t8, m7.color2 = i4, h8.textColor = s6, h8.backgroundColor = r11, h8.calloutColor = n8, d3.textColor = s6, d3.backgroundColor = r11, d3.calloutColor = n8;
    }, P)]), this._updateMessageBundle();
  }
  destroy() {
    this._measurementArea = u(this._measurementArea), this._path = u(this._path), this._intersectedPath = u(this._intersectedPath), this._perimeter = u(this._perimeter), this._intersectedPerimeter = u(this._intersectedPerimeter), this._areaLabel = u(this._areaLabel), this._perimeterLengthLabel = u(this._perimeterLengthLabel), this._projectionLines = u(this._projectionLines), this.set("view", null);
  }
  _update() {
    if (this.destroyed || !this.view.ready || !this.view.renderCoordsHelper) return;
    const {
      analysisViewData: {
        measurementData: e8
      },
      analysisViewData: t7
    } = this;
    null != e8 && (this._updateViewData(e8, t7.path), this._updateOrigin(), this._updatePathSegments(), this._updatePerimeterSegments(), this._updateArea(), this._updateProjectionLines(), this._updateLabels());
  }
  _updateViewData(e8, t7) {
    const i3 = e8.validMeasurement, s5 = "geodesic" === e8.actualMeasurementMode, r11 = s5 ? e8.geodesicArea : e8.area;
    let n8 = 1;
    if (r11) {
      const e9 = I3(r11, this.analysisViewData.unit);
      n8 = c(Math.sqrt(e9.value) / Math.sqrt(300)), n8 *= Math.sqrt(j(1, e9.unit, "square-meters")), n8 = j(n8, "meters", this._renderUnits);
    }
    const a8 = {
      validMeasurement: i3,
      numVertices: e8.numVertices,
      hasStagedVertex: e8.hasStagedVertex,
      path: t7,
      mode: e8.actualMeasurementMode,
      positionsRender: e8.positionsRender,
      positionsFittedWorld: e8.positionsFittedWorld,
      positionsFittedRender: e8.positionsFittedRender,
      intersectingSegments: s5 ? e8.geodesicIntersectingSegments : e8.intersectingSegments,
      triangleIndices: s5 ? e8.geodesicTriangleIndices : e8.triangleIndices,
      areaCentroid: s5 ? e8.geodesicAreaCentroidRenderCoords : e8.areaCentroidRenderCoords,
      perimeterLengthLabelSegmentIndex: 0,
      area: s5 ? e8.geodesicArea : e8.area,
      pathLength: s5 ? e8.geodesicPathLength : e8.pathLength,
      perimeterLength: e8.perimeterLength,
      checkerSize: n8
    };
    this._set("viewData", a8);
  }
  _updateOrigin() {
    const e8 = this.viewData;
    d2(e8.positionsRender, this._origin), q(this._originTransform, this._origin), this._measurementArea.transform = this._originTransform, this._projectionLines.transform = this._originTransform;
  }
  _createSegments(e8) {
    const t7 = this.viewData, i3 = this.view.renderCoordsHelper.spatialReference, s5 = t7.mode, r11 = [], n8 = [], a8 = [], o5 = t7.numVertices, l5 = t7.validMeasurement ? o5 : o5 - 1;
    for (let m7 = 0; m7 < l5; ++m7) {
      const l6 = t7[e8][m7], c7 = t7[e8][(m7 + 1) % o5];
      let h8 = null;
      switch (s5) {
        case "euclidean":
          h8 = new m2(l6, c7);
          break;
        case "geodesic":
          h8 = new _5(l6, c7, i3);
      }
      t7.intersectingSegments.has(m7) ? a8.push(h8) : n8.push(h8), r11.push(h8);
    }
    let c6 = null;
    return t7.validMeasurement && t7.hasStagedVertex && l5 >= 2 ? c6 = r11[r11.length - 2] : t7.hasStagedVertex && l5 >= 1 && (c6 = r11[r11.length - 1]), {
      all: r11,
      nonIntersecting: n8,
      intersecting: a8,
      stagedSegment: c6
    };
  }
  _updatePathSegments() {
    const {
      visible: e8
    } = this, t7 = this._createSegments("positionsRender");
    this._path.setGeometryFromSegments(t7.nonIntersecting, this._origin), this._path.visible = e8, this._intersectedPath.setGeometryFromSegments(t7.intersecting, this._origin), this._intersectedPath.visible = e8, this._pathSegments = t7.all;
  }
  _updatePerimeterSegments() {
    const e8 = this.visible && "euclidean" === this.viewData.mode, t7 = this._createSegments("positionsFittedRender");
    this._perimeter.setGeometryFromSegments(t7.nonIntersecting, this._origin), this._perimeter.visible = e8, this._intersectedPerimeter.setGeometryFromSegments(t7.intersecting, this._origin), this._intersectedPerimeter.visible = e8, this._perimeterSegments = t7.all;
  }
  _updateArea() {
    const e8 = this.viewData;
    switch (e8.mode) {
      case "euclidean":
        this._updateAreaEuclidean(e8);
        break;
      case "geodesic":
        this._updateAreaGeodesic();
    }
  }
  _updateAreaEuclidean(e8) {
    const t7 = this.visible;
    e8.validMeasurement && 0 === e8.intersectingSegments.size && e8.triangleIndices ? (this._measurementArea.geometry = {
      uv: e8.positionsFittedWorld,
      position: e8.positionsFittedRender,
      triangleIndices: e8.triangleIndices
    }, this._measurementArea.size = [e8.checkerSize, e8.checkerSize], this._measurementArea.visible = t7) : this._measurementArea.visible = false;
  }
  _updateAreaGeodesic() {
    this._measurementArea.visible = false;
  }
  _updateProjectionLines() {
    const e8 = this.viewData, t7 = this.visible, i3 = e8.mode, s5 = e8.numVertices;
    if (s5 > 0 && e8.validMeasurement && "euclidean" === i3) {
      const i4 = [];
      for (let t8 = 0; t8 < s5; ++t8) {
        const s6 = n2();
        e2(s6, e8.positionsRender[t8], this._origin);
        const r11 = n2();
        e2(r11, e8.positionsFittedRender[t8], this._origin), i4.push([s6, r11]);
      }
      this._projectionLines.geometry = i4, this._projectionLines.visible = t7;
    } else this._projectionLines.geometry = null, this._projectionLines.visible = false;
  }
  _updateLabels() {
    if (this.destroyed) return;
    const {
      viewData: e8
    } = this, {
      area: t7,
      path: i3
    } = e8;
    if (!i3) return;
    const s5 = this.visible, r11 = z2(this.messages, t7, this.analysisViewData.unit);
    if (null != r11 ? (this._areaLabel.geometry = {
      type: "point",
      point: e8.areaCentroid
    }, this._areaLabel.text = r11, this._areaLabel.visible = e8.validMeasurement && 0 === e8.intersectingSegments.size && s5) : this._areaLabel.visible = false, this._set("areaLabel", r11), e8.validMeasurement && 0 === e8.intersectingSegments.size) {
      const t8 = "geodesic" === e8.mode || !e8.validMeasurement, i4 = t8 ? e8.pathLength : e8.perimeterLength, r12 = W(this.messages, i4, this.analysisViewData.unit);
      this._set("perimeterLengthLabel", r12), this._perimeterLengthLabel.distance = this._parameters.labelDistance, this._perimeterLengthLabel.anchor = "top", this._perimeterLengthLabel.text = r12, this._perimeterLengthLabel.visible = true;
      let n8 = true;
      for (let s6 = 0; s6 < e8.numVertices; ++s6) {
        const i5 = (e8.perimeterLengthLabelSegmentIndex + s6) % e8.numVertices, r13 = t8 ? this._pathSegments[i5] : this._perimeterSegments[i5];
        if (n8 = true, this._perimeterLengthLabel.geometry = {
          type: "segment",
          segment: r13,
          sampleLocation: "center"
        }, !this._perimeterLengthLabel.overlaps(this._areaLabel)) break;
        n8 = false;
      }
      this._perimeterLengthLabel.visible = n8 && s5;
    } else this._perimeterLengthLabel.visible = false;
  }
  _updateMessageBundle() {
    this.loadingMessages = true, h("esri/core/t9n/Units").then((e8) => {
      this.messages = e8, this.view && this._update();
    }).finally(() => {
      this.loadingMessages = false;
    });
  }
};
function z2(e8, t7, i3) {
  return e8 && t7 && g2(e8, t7, U(t7, i3));
}
function I3(e8, t7) {
  return s3(e8, U(e8, t7));
}
function U(e8, t7) {
  switch (t7) {
    case "metric":
      return K(e8.value, e8.unit);
    case "imperial":
      return A2(e8.value, e8.unit);
    default:
      return t7;
  }
}
function W(e8, t7, i3) {
  return e8 && t7 && g2(e8, t7, T(t7, i3));
}
function T(e8, t7) {
  const i3 = E5(t7);
  switch (i3) {
    case "metric":
      return v(e8.value, e8.unit);
    case "imperial":
      return J(e8.value, e8.unit);
    default:
      return i3;
  }
}
function E5(e8) {
  switch (e8) {
    case "metric":
    case "ares":
    case "hectares":
      return "metric";
    case "imperial":
    case "acres":
      return "imperial";
    case "square-inches":
      return "inches";
    case "square-feet":
      return "feet";
    case "square-yards":
      return "yards";
    case "square-miles":
      return "miles";
    case "square-us-feet":
      return "us-feet";
    case "square-millimeters":
      return "millimeters";
    case "square-centimeters":
      return "centimeters";
    case "square-decimeters":
      return "decimeters";
    case "square-meters":
      return "meters";
    case "square-kilometers":
      return "kilometers";
  }
  throw new Error("unhandled area unit");
}
var G3;
e([y()], F2.prototype, "_parameters", null), e([y()], F2.prototype, "view", void 0), e([y()], F2.prototype, "messages", void 0), e([y()], F2.prototype, "analysis", void 0), e([y()], F2.prototype, "viewData", void 0), e([y()], F2.prototype, "analysisViewData", void 0), e([y({
  readOnly: true
})], F2.prototype, "areaLabel", void 0), e([y({
  readOnly: true
})], F2.prototype, "perimeterLengthLabel", void 0), e([y()], F2.prototype, "loadingMessages", void 0), e([y()], F2.prototype, "visible", null), e([y()], F2.prototype, "_renderUnits", null), F2 = e([a("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementVisualization")], F2), function(e8) {
  e8[e8.Small = 12] = "Small", e8[e8.Large = 16] = "Large";
}(G3 || (G3 = {}));
var B = {
  validMeasurement: false,
  numVertices: 0,
  hasStagedVertex: false,
  path: null,
  mode: null,
  positionsRender: null,
  positionsFittedWorld: null,
  positionsFittedRender: null,
  intersectingSegments: null,
  triangleIndices: null,
  areaCentroid: null,
  perimeterLengthLabelSegmentIndex: null,
  checkerSize: null,
  area: null,
  pathLength: null,
  perimeterLength: null
};

// ../../../node_modules/@arcgis/core/views/3d/analysis/AreaMeasurementAnalysisView3D.js
var m6 = class extends s4(S) {
  constructor(e8) {
    super(e8), this.type = "area-measurement-view-3d", this.analysis = null, this.measurementData = null, this.lastDraggedVertex = null, this.stagedPoint = null, this.mode = e7.Auto;
  }
  initialize() {
    const {
      analysis: e8,
      view: t7
    } = this;
    this.path = new g4({
      view: t7,
      areaMeasurement: e8
    }), this.analysisVisualization = new F2({
      view: t7,
      analysis: e8,
      analysisViewData: this
    }), this.analysisController = new n7({
      view: t7,
      analysis: e8,
      analysisViewData: this
    });
  }
  destroy() {
    this.analysisController = u(this.analysisController), this.analysisVisualization = u(this.analysisVisualization), this.path.destroy();
  }
  get updating() {
    return !!this.analysisVisualization?.loadingMessages;
  }
  get result() {
    const {
      measurementData: e8
    } = this;
    return null == e8 ? {
      area: null,
      mode: null,
      perimeter: null
    } : "euclidean" === e8.actualMeasurementMode ? {
      area: e8.area,
      perimeter: e8.perimeterLength,
      mode: "euclidean"
    } : {
      area: e8.geodesicArea,
      perimeter: e8.pathLength,
      mode: "geodesic"
    };
  }
  get viewData() {
    return this.analysisVisualization.viewData;
  }
  get validMeasurement() {
    return this.path.isValidPolygon;
  }
  get unit() {
    return this.analysis.unit ?? this._defaultUnit;
  }
  get testData() {
  }
};
e([y({
  readOnly: true
})], m6.prototype, "type", void 0), e([y({
  constructOnly: true,
  nonNullable: true
})], m6.prototype, "analysis", void 0), e([y()], m6.prototype, "updating", null), e([y()], m6.prototype, "analysisVisualization", void 0), e([y()], m6.prototype, "analysisController", void 0), e([y()], m6.prototype, "result", null), e([y()], m6.prototype, "measurementData", void 0), e([y()], m6.prototype, "viewData", null), e([y()], m6.prototype, "validMeasurement", null), e([y()], m6.prototype, "path", void 0), e([y()], m6.prototype, "lastDraggedVertex", void 0), e([y()], m6.prototype, "stagedPoint", void 0), e([y()], m6.prototype, "mode", void 0), e([y()], m6.prototype, "unit", null), e([y(e6)], m6.prototype, "_defaultUnit", void 0), m6 = e([a("esri.views.3d.analysis.AreaMeasurementAnalysisView3D")], m6);
var y2 = m6;
export {
  y2 as default
};
//# sourceMappingURL=AreaMeasurementAnalysisView3D-PZFERW27.js.map
