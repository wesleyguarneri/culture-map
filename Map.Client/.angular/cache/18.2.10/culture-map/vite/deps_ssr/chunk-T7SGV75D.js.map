{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4sDrawUniform.js", "../../../../../../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { Uniform as r } from \"./Uniform.js\";\nimport { BindType as e } from \"../shaderTechnique/BindType.js\";\nclass o extends r {\n  constructor(r, o, s) {\n    super(r, \"mat4\", e.Draw, (e, s, t, i) => e.setUniformMatrix4fv(r, o(s, t, i)), s);\n  }\n}\nexport { o as Matrix4sDrawUniform };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { IDENTITY as e } from \"../../../../../../core/libs/gl-matrix-2/factories/mat4f64.js\";\nimport { create as s } from \"../../../../../../core/libs/gl-matrix-2/factories/vec3f64.js\";\nimport { Rgba4FloatEncoding as a } from \"../util/RgbaFloat16Encoding.glsl.js\";\nimport { Float4PassUniform as t } from \"../../shaderModules/Float4PassUniform.js\";\nimport { IntegerPassUniform as o } from \"../../shaderModules/IntegerPassUniform.js\";\nimport { NoParameters as i, glsl as r } from \"../../shaderModules/interfaces.js\";\nimport { Matrix4sDrawUniform as c } from \"../../shaderModules/Matrix4sDrawUniform.js\";\nimport { Matrix4sPassUniform as d } from \"../../shaderModules/Matrix4sPassUniform.js\";\nimport { Texture2DPassUniform as p } from \"../../shaderModules/Texture2DPassUniform.js\";\nclass n extends i {\n  constructor() {\n    super(...arguments), this.origin = s();\n  }\n}\nclass l extends n {}\nclass v extends i {\n  constructor() {\n    super(...arguments), this.modelTransformation = e;\n  }\n}\nclass h extends v {\n  constructor() {\n    super(...arguments), this.origin = s();\n  }\n}\nfunction m(e, s) {\n  s.receiveShadows && (e.fragment.uniforms.add(new d(\"shadowMapMatrix\", (e, s) => s.shadowMap.getShadowMapMatrices(e.origin), 4)), f(e));\n}\nfunction x(e, s) {\n  s.receiveShadows && (e.fragment.uniforms.add(new c(\"shadowMapMatrix\", (e, s) => s.shadowMap.getShadowMapMatrices(e.origin), 4)), f(e));\n}\nfunction f(e) {\n  const s = e.fragment;\n  s.include(a), s.uniforms.add(new p(\"shadowMap\", (e, s) => s.shadowMap.depthTexture), new o(\"numCascades\", (e, s) => s.shadowMap.numCascades), new t(\"cascadeDistances\", (e, s) => s.shadowMap.cascadeDistances)), s.code.add(r`int chooseCascade(float depth, out mat4 mat) {\nvec4 distance = cascadeDistances;\nint i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;\nmat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];\nreturn i;\n}\nvec3 lightSpacePosition(vec3 _vpos, mat4 mat) {\nvec4 lv = mat * vec4(_vpos, 1.0);\nlv.xy /= lv.w;\nreturn 0.5 * lv.xyz + vec3(0.5);\n}\nvec2 cascadeCoordinates(int i, ivec2 textureSize, vec3 lvpos) {\nfloat xScale = float(textureSize.y) / float(textureSize.x);\nreturn vec2((float(i) + lvpos.x) * xScale, lvpos.y);\n}\nfloat readShadowMapDepth(ivec2 uv, sampler2D _depthTex) {\nreturn rgba4ToFloat(texelFetch(_depthTex, uv, 0));\n}\nfloat posIsInShadow(ivec2 uv, vec3 lvpos, sampler2D _depthTex) {\nreturn readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;\n}\nfloat filterShadow(vec2 uv, vec3 lvpos, ivec2 texSize, sampler2D _depthTex) {\nvec2 st = fract(uv * vec2(texSize) + vec2(0.5));\nivec2 base = ivec2(uv * vec2(texSize) - vec2(0.5));\nfloat s00 = posIsInShadow(ivec2(base.x, base.y), lvpos, _depthTex);\nfloat s10 = posIsInShadow(ivec2(base.x + 1, base.y), lvpos, _depthTex);\nfloat s11 = posIsInShadow(ivec2(base.x + 1, base.y + 1), lvpos, _depthTex);\nfloat s01 = posIsInShadow(ivec2(base.x, base.y + 1), lvpos, _depthTex);\nreturn mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\n}\nfloat readShadowMap(const in vec3 _vpos, float _linearDepth) {\nmat4 mat;\nint i = chooseCascade(_linearDepth, mat);\nif (i >= numCascades) { return 0.0; }\nvec3 lvpos = lightSpacePosition(_vpos, mat);\nif (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }\nivec2 size = textureSize(shadowMap, 0);\nvec2 uv = cascadeCoordinates(i, size, lvpos);\nreturn filterShadow(uv, lvpos, size, shadowMap);\n}`);\n}\nexport { x as ReadShadowMapDraw, l as ReadShadowMapDrawParameters, v as ReadShadowMapParameters, m as ReadShadowMapPass, h as ReadShadowMapPassParameters };"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA,IAAMA,KAAN,cAAgBC,GAAE;AAAA,EAChB,YAAY,GAAGD,IAAGE,IAAG;AACnB,UAAM,GAAG,QAAQ,EAAE,MAAM,CAACC,IAAGD,IAAG,GAAG,MAAMC,GAAE,oBAAoB,GAAGH,GAAEE,IAAG,GAAG,CAAC,CAAC,GAAGA,EAAC;AAAA,EAClF;AACF;;;ACSA,IAAM,IAAN,cAAgBE,GAAE;AAAA,EAChB,cAAc;AACZ,UAAM,GAAG,SAAS,GAAG,KAAK,sBAAsB;AAAA,EAClD;AACF;AACA,IAAM,IAAN,cAAgB,EAAE;AAAA,EAChB,cAAc;AACZ,UAAM,GAAG,SAAS,GAAG,KAAK,SAAS,EAAE;AAAA,EACvC;AACF;AACA,SAAS,EAAEC,IAAGC,IAAG;AACf,EAAAA,GAAE,mBAAmBD,GAAE,SAAS,SAAS,IAAI,IAAIA,GAAE,mBAAmB,CAACA,IAAGC,OAAMA,GAAE,UAAU,qBAAqBD,GAAE,MAAM,GAAG,CAAC,CAAC,GAAG,EAAEA,EAAC;AACtI;AACA,SAAS,EAAEA,IAAGC,IAAG;AACf,EAAAA,GAAE,mBAAmBD,GAAE,SAAS,SAAS,IAAI,IAAIE,GAAE,mBAAmB,CAACF,IAAGC,OAAMA,GAAE,UAAU,qBAAqBD,GAAE,MAAM,GAAG,CAAC,CAAC,GAAG,EAAEA,EAAC;AACtI;AACA,SAAS,EAAEA,IAAG;AACZ,QAAMC,KAAID,GAAE;AACZ,EAAAC,GAAE,QAAQE,EAAC,GAAGF,GAAE,SAAS,IAAI,IAAI,EAAE,aAAa,CAACD,IAAGC,OAAMA,GAAE,UAAU,YAAY,GAAG,IAAI,EAAE,eAAe,CAACD,IAAGC,OAAMA,GAAE,UAAU,WAAW,GAAG,IAAID,GAAE,oBAAoB,CAACA,IAAGC,OAAMA,GAAE,UAAU,gBAAgB,CAAC,GAAGA,GAAE,KAAK,IAAIC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuC7N;AACF;",
  "names": ["o", "a", "s", "e", "n", "e", "s", "o", "a"]
}
