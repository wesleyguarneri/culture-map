{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/views/support/geodesicMeasurementUtils.js", "../../../../../../node_modules/@arcgis/core/views/support/geodesicLengthMeasurementUtils.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { isSupported as o } from \"../../geometry/support/geodesicUtils.js\";\nimport { isGeographic as t, isWebMercator as e } from \"../../geometry/support/spatialReferenceUtils.js\";\nfunction r(r) {\n  return t(r) && o(r) || e(r);\n}\nfunction p(r, p, i, ...n) {\n  return t(r) && o(r) ? p.apply(void 0, n) : e(r) ? i.apply(void 0, n) : null;\n}\nconst i = 1e5;\nexport { i as geodesicDistanceThreshold, p as geodesicMeasure, r as supportsGeodesicMeasurement };", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { createLength as e } from \"../../core/quantityUtils.js\";\nimport { create as t } from \"../../core/libs/gl-matrix-2/factories/vec3f64.js\";\nimport { geodesicLength as r } from \"../../geometry/geometryEngine.js\";\nimport { inverseGeodeticSolver as n, geodesicLengths as s, InverseGeodeticSolverResult as o } from \"../../geometry/support/geodesicUtils.js\";\nimport { equals as i } from \"../../geometry/support/spatialReferenceUtils.js\";\nimport { geodesicMeasure as c } from \"./geodesicMeasurementUtils.js\";\nfunction m(e) {\n  const {\n    spatialReference: t\n  } = e;\n  return c(t, l, g, e);\n}\nfunction f(e, t) {\n  if (!i(e.spatialReference, t.spatialReference)) return null;\n  const {\n    spatialReference: r\n  } = e;\n  return R[0] = e.x, R[1] = e.y, R[2] = e.hasZ ? e.z : 0, d[0] = t.x, d[1] = t.y, d[2] = t.hasZ ? t.z : 0, u(R, d, r);\n}\nfunction u(e, t, r) {\n  return c(r, a, p, e, t, r);\n}\nfunction a(t, r, s) {\n  return e(n(j, t, r, s).distance, \"meters\");\n}\nfunction p(t, n, s) {\n  return e(r(y(t, n, s), \"meters\"), \"meters\");\n}\nfunction l(t) {\n  return e(s([t], \"meters\")[0], \"meters\");\n}\nfunction g(t) {\n  return e(r(t, \"meters\"), \"meters\");\n}\nfunction y(e, t, r) {\n  return {\n    type: \"polyline\",\n    spatialReference: r,\n    paths: [[[...e], [...t]]]\n  };\n}\nconst j = new o(),\n  R = t(),\n  d = t();\nexport { u as geodesicDistance, f as geodesicDistanceBetweenPoints, m as geodesicLength };"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAMA,SAAS,EAAEA,IAAG;AACZ,SAAO,EAAEA,EAAC,KAAKC,GAAED,EAAC,KAAK,EAAEA,EAAC;AAC5B;AACA,SAAS,EAAEA,IAAGE,IAAGC,OAAMC,IAAG;AACxB,SAAO,EAAEJ,EAAC,KAAKC,GAAED,EAAC,IAAIE,GAAE,MAAM,QAAQE,EAAC,IAAI,EAAEJ,EAAC,IAAIG,GAAE,MAAM,QAAQC,EAAC,IAAI;AACzE;AACA,IAAM,IAAI;;;ACFV,SAAS,EAAE,GAAG;AACZ,QAAM;AAAA,IACJ,kBAAkB;AAAA,EACpB,IAAI;AACJ,SAAO,EAAE,GAAG,GAAG,GAAG,CAAC;AACrB;AACA,SAAS,EAAE,GAAG,GAAG;AACf,MAAI,CAAC,EAAE,EAAE,kBAAkB,EAAE,gBAAgB,EAAG,QAAO;AACvD,QAAM;AAAA,IACJ,kBAAkBC;AAAA,EACpB,IAAI;AACJ,SAAO,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,GAAG,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,GAAG,EAAE,GAAG,GAAGA,EAAC;AACpH;AACA,SAAS,EAAE,GAAG,GAAGA,IAAG;AAClB,SAAO,EAAEA,IAAGC,IAAGC,IAAG,GAAG,GAAGF,EAAC;AAC3B;AACA,SAASC,GAAE,GAAGD,IAAG,GAAG;AAClB,SAAO,EAAE,EAAEG,IAAG,GAAGH,IAAG,CAAC,EAAE,UAAU,QAAQ;AAC3C;AACA,SAASE,GAAE,GAAGE,IAAG,GAAG;AAClB,SAAO,EAAE,EAAE,EAAE,GAAGA,IAAG,CAAC,GAAG,QAAQ,GAAG,QAAQ;AAC5C;AACA,SAAS,EAAE,GAAG;AACZ,SAAO,EAAE,EAAE,CAAC,CAAC,GAAG,QAAQ,EAAE,CAAC,GAAG,QAAQ;AACxC;AACA,SAAS,EAAE,GAAG;AACZ,SAAO,EAAE,EAAE,GAAG,QAAQ,GAAG,QAAQ;AACnC;AACA,SAAS,EAAE,GAAG,GAAGJ,IAAG;AAClB,SAAO;AAAA,IACL,MAAM;AAAA,IACN,kBAAkBA;AAAA,IAClB,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAAA,EAC1B;AACF;AACA,IAAMG,KAAI,IAAI,EAAE;AAAhB,IACE,IAAI,EAAE;AADR,IAEE,IAAI,EAAE;",
  "names": ["r", "w", "p", "i", "n", "r", "a", "p", "j", "n"]
}
