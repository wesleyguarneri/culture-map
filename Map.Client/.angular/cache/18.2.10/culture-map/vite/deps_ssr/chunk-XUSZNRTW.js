import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  p as p2,
  t
} from "./chunk-W26QF64E.js";
import {
  x
} from "./chunk-D3XX7CQS.js";
import {
  C as C2
} from "./chunk-VFQA3B5S.js";
import {
  m,
  o as o4
} from "./chunk-KXVPQVTB.js";
import {
  U
} from "./chunk-VMZV7772.js";
import {
  p
} from "./chunk-GZ64OOAB.js";
import {
  j
} from "./chunk-WR2NVDOI.js";
import {
  b
} from "./chunk-EPLJRYUV.js";
import {
  a as a4
} from "./chunk-VYRCS5VR.js";
import {
  k
} from "./chunk-KYPTWEOO.js";
import {
  M
} from "./chunk-ZREJ3Y2F.js";
import {
  i
} from "./chunk-DL2B6IFJ.js";
import {
  y as y2
} from "./chunk-TGZW6QWO.js";
import {
  o as o2
} from "./chunk-6EIBUVMG.js";
import {
  l,
  s as s2
} from "./chunk-3B5GODXR.js";
import {
  a as a3
} from "./chunk-NKXXHQDD.js";
import {
  o as o3
} from "./chunk-VYTPFEL2.js";
import {
  o
} from "./chunk-DCXDXGAR.js";
import {
  r
} from "./chunk-BCCDYCTQ.js";
import {
  f
} from "./chunk-4AZPIP7K.js";
import {
  C,
  d
} from "./chunk-LZSLQ24Q.js";
import {
  e as e2
} from "./chunk-NUICEVIH.js";
import {
  y
} from "./chunk-UVNLCXWD.js";
import {
  a3 as a2
} from "./chunk-UDMPWVPF.js";
import {
  a,
  e,
  n2 as n,
  s2 as s
} from "./chunk-6JFGZTLU.js";
import {
  has
} from "./chunk-2ZJE6ZFX.js";

// ../../../node_modules/@arcgis/core/layers/support/ExpressionInfo.js
var p3 = class extends i(f) {
  constructor(r2) {
    super(r2), this.expression = null, this.title = null, this.returnType = null;
  }
};
e2([y({
  type: String,
  json: {
    write: true
  }
})], p3.prototype, "expression", void 0), e2([y({
  type: String,
  json: {
    write: true
  }
})], p3.prototype, "title", void 0), e2([y({
  type: String,
  json: {
    write: true
  }
})], p3.prototype, "returnType", void 0), p3 = e2([a2("esri.layers.support.ExpressionInfo")], p3);
var i2 = p3;

// ../../../node_modules/@arcgis/core/layers/support/AggregateField.js
var p4;
var n2 = p4 = class extends f {
  constructor(t2) {
    super(t2), this.isAutoGenerated = false, this.name = null, this.alias = null, this.onStatisticField = null, this.onStatisticExpression = null, this.statisticType = null;
  }
  clone() {
    return new p4({
      name: this.name,
      alias: this.alias,
      isAutoGenerated: this.isAutoGenerated,
      onStatisticExpression: a(this.onStatisticExpression),
      onStatisticField: this.onStatisticField,
      statisticType: this.statisticType
    });
  }
};
e2([y({
  type: Boolean,
  json: {
    write: true
  }
})], n2.prototype, "isAutoGenerated", void 0), e2([y({
  type: String,
  json: {
    write: true
  }
})], n2.prototype, "name", void 0), e2([y({
  type: String,
  json: {
    write: true
  }
})], n2.prototype, "alias", void 0), e2([y({
  type: String,
  json: {
    write: true
  }
})], n2.prototype, "onStatisticField", void 0), e2([y({
  type: i2,
  json: {
    write: true
  }
})], n2.prototype, "onStatisticExpression", void 0), e2([y({
  type: String,
  json: {
    write: true
  }
})], n2.prototype, "statisticType", void 0), n2 = p4 = e2([a2("esri.layers.support.AggregateField")], n2);
var a5 = n2;

// ../../../node_modules/@arcgis/core/layers/support/FeatureReductionBinning.js
var h;
var g = h = class extends t {
  constructor(e3) {
    super(e3), this.type = "binning", this.binType = "geohash", this.fixedBinLevel = null, this.labelingInfo = null, this.labelsVisible = true, this.maxScale = 0, this.popupEnabled = true, this.popupTemplate = null, this.size = o3("12px"), this.fields = [], this.renderer = null;
  }
  writeFields(e3, r2, o6) {
    const t2 = e3.filter((e4) => "avg_angle" !== e4.statisticType).map((e4) => e4.toJSON());
    e(o6, t2, r2);
  }
  readRenderer(e3, r2, t2) {
    const s3 = r2.drawingInfo?.renderer;
    return s3 ? o4(s3, r2, t2) ?? void 0 : U(r2, t2);
  }
  clone() {
    return new h({
      fields: a(this.fields),
      fixedBinLevel: this.fixedBinLevel,
      labelingInfo: a(this.labelingInfo),
      labelsVisible: this.labelsVisible,
      maxScale: this.maxScale,
      popupEnabled: this.popupEnabled,
      popupTemplate: a(this.popupTemplate),
      renderer: a(this.renderer),
      binType: a(this.binType),
      size: this.size
    });
  }
};
e2([o2({
  binning: "binning"
})], g.prototype, "type", void 0), e2([o2({
  geohash: "geohash",
  square: "square"
}), y({
  type: ["geohash", "square"]
})], g.prototype, "binType", void 0), e2([y({
  type: Number,
  json: {
    write: true
  }
})], g.prototype, "fixedBinLevel", void 0), e2([y({
  type: [C2],
  json: {
    read: {
      source: "drawingInfo.labelingInfo"
    },
    write: {
      target: "drawingInfo.labelingInfo"
    }
  }
})], g.prototype, "labelingInfo", void 0), e2([y(l)], g.prototype, "labelsVisible", void 0), e2([y({
  type: Number,
  json: {
    default: 0,
    name: "visibilityInfo.maxScale"
  }
})], g.prototype, "maxScale", void 0), e2([y(s2)], g.prototype, "popupEnabled", void 0), e2([y({
  type: k,
  json: {
    name: "popupInfo",
    write: true
  }
})], g.prototype, "popupTemplate", void 0), e2([y({
  type: Number,
  cast: (e3) => "auto" === e3 ? e3 : o3(e3)
})], g.prototype, "size", void 0), e2([y({
  type: [a5],
  json: {
    write: true
  }
})], g.prototype, "fields", void 0), e2([r("fields")], g.prototype, "writeFields", null), e2([y({
  types: m,
  json: {
    write: {
      target: "drawingInfo.renderer"
    }
  }
})], g.prototype, "renderer", void 0), e2([o("renderer", ["drawingInfo.renderer"])], g.prototype, "readRenderer", null), g = h = e2([a2("esri.layers.support.FeatureReductionBinning")], g);
var v = g;

// ../../../node_modules/@arcgis/core/layers/support/FeatureReductionCluster.js
var g2;
function S(e3) {
  return "simple" === e3.type && !e3.visualVariables?.length;
}
var w = g2 = class extends f {
  constructor(e3) {
    super(e3), this.type = "cluster", this.clusterRadius = o3("80px"), this.clusterMinSize = o3("12px"), this.clusterMaxSize = o3("50px"), this.maxScale = 0, this.popupEnabled = true, this.popupTemplate = null, this.renderer = null, this.symbol = null, this.labelingInfo = null, this.labelsVisible = true, this.fields = [];
  }
  readRenderer(e3, r2, t2) {
    const s3 = r2.drawingInfo?.renderer;
    return s3?.authoringInfo?.isAutoGenerated ? null : s3 ? S(s3) ? null : o4(s3, r2, t2) ?? void 0 : U(r2, t2);
  }
  readSymbol(e3, r2, t2) {
    const s3 = r2.drawingInfo?.renderer;
    if (s3?.authoringInfo?.isAutoGenerated) return null;
    if (s3 && S(s3)) {
      const e4 = o4(s3, r2, t2);
      return e4?.symbol;
    }
    return null;
  }
  writeSymbol(e3, r2, o6, s3) {
    const i3 = this.renderer?.authoringInfo?.isAutoGenerated;
    if (!this.renderer || i3) {
      const o7 = new p({
        symbol: e3
      });
      r2.drawingInfo = {
        renderer: o7.write({}, s3)
      };
    }
  }
  writeFields(e3, r2, t2) {
    const o6 = e3.filter((e4) => "avg_angle" !== e4.statisticType).map((e4) => e4.toJSON());
    e(t2, o6, r2);
  }
  readFields(e3, r2, t2) {
    return e3.filter((e4) => !e4.isAutoGenerated).map((e4) => a5.fromJSON(e4));
  }
  clone() {
    return new g2({
      clusterRadius: this.clusterRadius,
      clusterMinSize: this.clusterMinSize,
      clusterMaxSize: this.clusterMaxSize,
      labelingInfo: a(this.labelingInfo),
      labelsVisible: this.labelsVisible,
      fields: a(this.fields),
      maxScale: this.maxScale,
      renderer: a(this.renderer),
      symbol: a(this.symbol),
      popupEnabled: this.popupEnabled,
      popupTemplate: a(this.popupTemplate)
    });
  }
};
e2([y({
  type: ["cluster"],
  readOnly: true,
  json: {
    write: true
  }
})], w.prototype, "type", void 0), e2([y({
  type: Number,
  cast: (e3) => "auto" === e3 ? e3 : o3(e3),
  json: {
    write: true
  }
})], w.prototype, "clusterRadius", void 0), e2([y({
  type: Number,
  cast: o3,
  json: {
    write: true
  }
})], w.prototype, "clusterMinSize", void 0), e2([y({
  type: Number,
  cast: o3,
  json: {
    write: true
  }
})], w.prototype, "clusterMaxSize", void 0), e2([y({
  type: Number,
  json: {
    default: 0,
    name: "visibilityInfo.maxScale"
  }
})], w.prototype, "maxScale", void 0), e2([y(s2)], w.prototype, "popupEnabled", void 0), e2([y({
  type: k,
  json: {
    read: {
      source: "popupInfo"
    },
    write: {
      target: "popupInfo"
    }
  }
})], w.prototype, "popupTemplate", void 0), e2([y({
  types: m,
  json: {
    write: {
      target: "drawingInfo.renderer"
    }
  }
})], w.prototype, "renderer", void 0), e2([o("renderer", ["drawingInfo.renderer"])], w.prototype, "readRenderer", null), e2([y({
  types: M
})], w.prototype, "symbol", void 0), e2([o("symbol", ["drawingInfo.renderer"])], w.prototype, "readSymbol", null), e2([r("symbol")], w.prototype, "writeSymbol", null), e2([y({
  type: [C2],
  json: {
    read: {
      source: "drawingInfo.labelingInfo"
    },
    write: {
      target: "drawingInfo.labelingInfo"
    }
  }
})], w.prototype, "labelingInfo", void 0), e2([y(l)], w.prototype, "labelsVisible", void 0), e2([y({
  type: [a5],
  json: {
    write: true
  }
})], w.prototype, "fields", void 0), e2([r("fields")], w.prototype, "writeFields", null), e2([o("fields")], w.prototype, "readFields", null), w = g2 = e2([a2("esri.layers.support.FeatureReductionCluster")], w);
var I = w;

// ../../../node_modules/@arcgis/core/layers/support/featureReductionUtils.js
var o5 = {
  key: "type",
  base: t,
  typeMap: {
    cluster: I,
    binning: v
  }
};
var p5 = {
  types: {
    key: "type",
    base: t,
    typeMap: {
      selection: p2,
      cluster: I,
      binning: v
    }
  },
  json: {
    name: "layerDefinition.featureReduction",
    write: {
      allowNull: true
    },
    origins: {
      "web-map": {
        types: o5
      },
      "portal-item": {
        types: o5
      },
      "web-scene": {
        types: {
          key: "type",
          base: t,
          typeMap: {
            selection: p2
          }
        },
        name: "layerDefinition.featureReduction",
        write: {
          layerContainerTypes: a3
        }
      }
    }
  }
};

// ../../../node_modules/@arcgis/core/views/2d/layers/support/clusterUtils.js
var l2 = () => n.getLogger("esri.views.2d.layers.support.clusterUtils");
has.add("esri-cluster-arcade-enabled", true);
var u = has("esri-cluster-arcade-enabled");
var p6 = /* @__PURE__ */ new Set(["simple-line", "simple-fill", "picture-fill"]);
function d2(r2, s3) {
  let n3 = s3.clone();
  if (!c(n3)) return n3;
  if (s3.getSymbols().some((e3) => p6.has(e3.type)) && (n3 = new p({
    symbol: new y2()
  })), n3.authoringInfo || (n3.authoringInfo = new j()), n3.authoringInfo.isAutoGenerated = true, "visualVariables" in n3) {
    const e3 = (n3.visualVariables || []).filter((e4) => "$view.scale" !== e4.valueExpression);
    e3.forEach((e4) => {
      "rotation" === e4.type ? e4.field ? e4.field = g3(r2, e4.field, "avg_angle", "number") : e4.valueExpression && (e4.field = b2(r2, e4.valueExpression, "avg_angle", "number"), e4.valueExpression = null) : e4.normalizationField ? (e4.field = g3(r2, e4.field, "avg_norm", "number", e4.normalizationField), e4.normalizationField = null) : e4.field ? e4.field = g3(r2, e4.field, "avg", "number") : e4.valueExpression && (e4.field = b2(r2, e4.valueExpression, "avg", "number"), e4.valueExpression = null);
    }), n3.visualVariables = e3;
  }
  switch (n3.type) {
    case "simple":
      break;
    case "pie-chart":
      for (const e3 of n3.attributes) e3.field ? e3.field = g3(r2, e3.field, "sum", "number") : e3.valueExpression && (e3.field = b2(r2, e3.valueExpression, "sum", "number"), e3.valueExpression = null);
      break;
    case "unique-value":
      n3.field ? n3.field = g3(r2, n3.field, "mode", "string") : n3.valueExpression && (n3.field = b2(r2, n3.valueExpression, "mode", "string"), n3.valueExpression = null);
      break;
    case "class-breaks":
      n3.normalizationField ? (n3.field = g3(r2, n3.field, "avg_norm", "number", n3.normalizationField), n3.normalizationField = null) : n3.field ? n3.field = g3(r2, n3.field, "avg", "number") : n3.valueExpression && (n3.field = b2(r2, n3.valueExpression, "avg", "number"), n3.valueExpression = null);
  }
  return n3;
}
var c = (e3) => {
  const r2 = (r3) => l2().error(new s("Unsupported-renderer", r3, {
    renderer: e3
  }));
  if (!e3) return false;
  switch (e3.type) {
    case "unique-value":
      if (e3.field2 || e3.field3) return r2("FeatureReductionCluster does not support multi-field UniqueValueRenderers"), false;
      break;
    case "class-breaks":
      if (e3.normalizationField) {
        const s3 = e3.normalizationType;
        if ("field" !== s3) return r2(`FeatureReductionCluster does not support a normalizationType of ${s3}`), false;
      }
      break;
    case "simple":
    case "pie-chart":
      break;
    default:
      return r2(`FeatureReductionCluster does not support renderers of type ${e3.type}`), false;
  }
  if (!u) {
    if ("valueExpression" in e3 && e3.valueExpression) return r2("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"), false;
    if (("visualVariables" in e3 && e3.visualVariables || []).some((e4) => !(!("valueExpression" in e4) || !e4.valueExpression))) return r2("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"), false;
  }
  return true;
};
function v2(e3, r2, s3) {
  switch (e3) {
    case "sum":
      return `cluster_sum_${r2}`;
    case "avg":
    case "avg_angle":
      return `cluster_avg_${r2}`;
    case "mode":
      return `cluster_type_${r2}`;
    case "avg_norm": {
      const e4 = s3, i3 = "field", t2 = r2.toLowerCase() + ",norm:" + i3 + "," + e4.toLowerCase();
      return "cluster_avg_" + x(t2);
    }
  }
}
function b2(e3, r2, s3, o6) {
  const a6 = x(r2), l3 = "mode" === s3 ? `cluster_type_${a6}` : "sum" === s3 ? `cluster_sum_${a6}` : `cluster_avg_${a6}`;
  return e3.some((e4) => e4.name === l3) || e3.push(new a5({
    name: l3,
    isAutoGenerated: true,
    onStatisticExpression: new i2({
      expression: r2,
      returnType: o6
    }),
    statisticType: s3
  })), l3;
}
function g3(e3, r2, s3, n3, o6) {
  if ("cluster_count" === r2 || e3.some((e4) => e4.name === r2)) return r2;
  const a6 = v2(s3, r2, o6);
  return e3.some((e4) => e4.name === a6) || ("avg_norm" === s3 ? e3.push(new a5({
    name: a6,
    isAutoGenerated: true,
    onStatisticExpression: new i2({
      expression: `$feature.${r2} / $feature.${o6}`,
      returnType: n3
    }),
    statisticType: "avg"
  })) : e3.push(new a5({
    name: a6,
    isAutoGenerated: true,
    onStatisticField: r2,
    statisticType: s3
  }))), a6;
}

// ../../../node_modules/@arcgis/core/layers/mixins/FeatureReductionLayer.js
var c2 = (c3) => {
  let p7 = class extends c3 {
    constructor(...e3) {
      super(...e3), this.addHandles(d(() => this.renderer, () => {
        if (this.featureReduction) {
          const e4 = this._normalizeFeatureReduction(this.featureReduction);
          this._set("featureReduction", e4);
        }
      }, C));
    }
    set featureReduction(e3) {
      const r2 = this._normalizeFeatureReduction(e3);
      this._set("featureReduction", r2);
    }
    set renderer(e3) {
    }
    _withClusterVariable(e3, r2, s3) {
      const t2 = e3.clone();
      if ("visualVariables" in t2) {
        t2.visualVariables || (t2.visualVariables = []);
        t2.visualVariables.some((e4) => "size" === e4.type) || t2.visualVariables.push(new b({
          field: "cluster_count",
          stops: [new a4({
            value: 1
          }), new a4({
            useMinValue: true,
            size: r2
          }), new a4({
            useMaxValue: true,
            size: s3
          })]
        }));
      }
      return t2;
    }
    _normalizeFeatureReduction(e3) {
      if ("cluster" !== e3?.type) return e3;
      const s3 = e3.clone(), t2 = [new a5({
        name: "cluster_count",
        isAutoGenerated: true,
        statisticType: "count"
      })], i3 = (s3.fields ?? []).filter((e4) => !e4.isAutoGenerated), n3 = e3.renderer && !e3.renderer.authoringInfo?.isAutoGenerated, {
        clusterMinSize: a6,
        clusterMaxSize: u2
      } = s3;
      if (n3) {
        s3.fields = [...t2, ...i3];
        const e4 = this._withClusterVariable(s3.renderer, a6, u2);
        return s3.effectiveFeatureRenderer = e4, s3.effectiveClusterRenderer = e4, s3;
      }
      if (e3.symbol) {
        if (s3.fields = [...t2, ...i3], s3.renderer = null, !this.renderer) return s3.effectiveFeatureRenderer = null, s3.effectiveClusterRenderer = null, s3;
        const n4 = d2(t2, this.renderer), o6 = this._withClusterVariable(n4, a6, u2), l4 = "visualVariables" in o6 && o6.visualVariables ? o6.visualVariables : [], c5 = new p({
          symbol: e3.symbol,
          visualVariables: l4
        });
        return s3.fields = [...t2, ...i3], s3.effectiveFeatureRenderer = o6, s3.effectiveClusterRenderer = c5, s3;
      }
      if (!this.renderer) return e3;
      const l3 = d2(t2, this.renderer);
      s3.fields = [...t2, ...i3], s3.renderer = l3;
      const c4 = this._withClusterVariable(l3, a6, u2);
      return s3.effectiveFeatureRenderer = c4, s3.effectiveClusterRenderer = c4, s3;
    }
  };
  return e2([y(p5)], p7.prototype, "featureReduction", null), p7 = e2([a2("esri.layers.mixins.FeatureReductionLayer")], p7), p7;
};

export {
  p5 as p,
  c2 as c
};
//# sourceMappingURL=chunk-XUSZNRTW.js.map
