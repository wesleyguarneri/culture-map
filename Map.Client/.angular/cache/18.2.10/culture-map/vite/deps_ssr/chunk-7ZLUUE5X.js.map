{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/chunks/LaserlinePath.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { translate as e } from \"../core/libs/gl-matrix-2/math/mat4.js\";\nimport { create as i } from \"../core/libs/gl-matrix-2/factories/mat4f64.js\";\nimport { set as o } from \"../core/libs/gl-matrix-2/math/vec2.js\";\nimport { create as t } from \"../core/libs/gl-matrix-2/factories/vec2f64.js\";\nimport { Laserline as r } from \"../views/3d/webgl-engine/core/shaderLibrary/Laserline.glsl.js\";\nimport { Float2PassUniform as a } from \"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";\nimport { FloatPassUniform as s } from \"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";\nimport { glsl as l } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { Matrix4PassUniform as n } from \"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js\";\nimport { ShaderBuilder as d } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { VertexAttribute as c } from \"../views/3d/webgl-engine/lib/VertexAttribute.js\";\nfunction v(i) {\n  const t = new d();\n  t.include(r, i);\n  const {\n    vertex: v,\n    fragment: w\n  } = t;\n  return v.uniforms.add(new n(\"modelView\", (i, {\n    camera: o\n  }) => e(p, o.viewMatrix, i.origin)), new n(\"proj\", (e, {\n    camera: i\n  }) => i.projectionMatrix), new s(\"glowWidth\", (e, {\n    camera: i\n  }) => e.glowWidth * i.pixelRatio), new a(\"pixelToNDC\", (e, {\n    camera: i\n  }) => o(m, 2 / i.fullViewport[2], 2 / i.fullViewport[3]))), t.attributes.add(c.START, \"vec3\"), t.attributes.add(c.END, \"vec3\"), t.attributes.add(c.UP, \"vec3\"), t.attributes.add(c.EXTRUDE, \"vec2\"), t.varyings.add(\"uv\", \"vec2\"), t.varyings.add(\"vViewStart\", \"vec3\"), t.varyings.add(\"vViewEnd\", \"vec3\"), t.varyings.add(\"vViewPlane\", \"vec4\"), v.code.add(l`void main() {\nvec3 pos = mix(start, end, extrude.x);\nvec4 viewPos = modelView * vec4(pos, 1);\nvec4 projPos = proj * viewPos;\nvec2 ndcPos = projPos.xy / projPos.w;\nvec3 viewUp = (modelView * vec4(extrude.y * up, 0)).xyz;\nvec4 projPosUp = proj * vec4(viewPos.xyz + viewUp, 1);\nvec2 projExtrudeDir = normalize(projPosUp.xy / projPosUp.w - ndcPos);\nvec2 lxy = abs(sign(projExtrudeDir) - ndcPos);\nndcPos += length(lxy) * projExtrudeDir;\nvec3 worldPlaneNormal = normalize(cross(up, normalize(end - start)));\nvec3 viewPlaneNormal = (modelView * vec4(worldPlaneNormal, 0)).xyz;\nvViewStart = (modelView * vec4(start, 1)).xyz;\nvViewEnd = (modelView * vec4(end, 1)).xyz;\nvViewPlane = vec4(viewPlaneNormal, -dot(viewPlaneNormal, vViewStart));\nfloat xPaddingPixels = sign(dot(viewPlaneNormal, viewPos.xyz)) * (extrude.x * 2.0 - 1.0) * glowWidth;\nndcPos.x += xPaddingPixels * pixelToNDC.x;\nuv = ndcPos * 0.5 + 0.5;\ngl_Position = vec4(ndcPos, 0, 1);\n}`), w.uniforms.add(new s(\"perScreenPixelRatio\", (e, i) => i.camera.perScreenPixelRatio)), w.code.add(l`float planeDistancePixels(vec4 plane, vec3 pos, vec3 start, vec3 end) {\nvec3 origin = mix(start, end, 0.5);\nvec3 basis = end - origin;\nvec3 posAtOrigin = pos - origin;\nfloat x = dot(normalize(basis), posAtOrigin);\nfloat y = dot(plane.xyz, posAtOrigin);\nfloat dx = max(abs(x) - length(basis), 0.0);\nfloat dy = y;\nfloat dist = length(vec2(dx, dy));\nfloat width = fwidth(y);\nfloat maxPixelDistance = length(pos) * perScreenPixelRatio * 2.0;\nfloat pixelDist = dist / min(width, maxPixelDistance);\nreturn abs(pixelDist);\n}\nvoid main() {\nvec3 dEndStart = vViewEnd - vViewStart;\nif (dot(dEndStart, dEndStart) < 1e-5) {\ndiscard;\n}\nvec3 pos;\nvec3 normal;\nfloat angleCutoffAdjust;\nfloat depthDiscontinuityAlpha;\nif (!laserlineReconstructFromDepth(pos, normal, angleCutoffAdjust, depthDiscontinuityAlpha)) {\ndiscard;\n}\nfloat distance = planeDistancePixels(vViewPlane, pos, vViewStart, vViewEnd);\nvec4 color = laserlineProfile(distance);\nfloat alpha = (1.0 - smoothstep(0.995 - angleCutoffAdjust, 0.999 - angleCutoffAdjust, abs(dot(normal, vViewPlane.xyz))));\nfragColor = laserlineOutput(color * alpha * depthDiscontinuityAlpha);\n}`), t;\n}\nconst m = t(),\n  p = i(),\n  w = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    build: v\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  }));\nexport { w as L, v as b };"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAeA,SAAS,EAAEA,IAAG;AACZ,QAAM,IAAI,IAAIC,GAAE;AAChB,IAAE,QAAQC,IAAGF,EAAC;AACd,QAAM;AAAA,IACJ,QAAQG;AAAA,IACR,UAAUC;AAAA,EACZ,IAAI;AACJ,SAAOD,GAAE,SAAS,IAAI,IAAIE,GAAE,aAAa,CAACL,IAAG;AAAA,IAC3C,QAAQC;AAAA,EACV,MAAM,EAAE,GAAGA,GAAE,YAAYD,GAAE,MAAM,CAAC,GAAG,IAAIK,GAAE,QAAQ,CAACA,IAAG;AAAA,IACrD,QAAQL;AAAA,EACV,MAAMA,GAAE,gBAAgB,GAAG,IAAIC,GAAE,aAAa,CAACI,IAAG;AAAA,IAChD,QAAQL;AAAA,EACV,MAAMK,GAAE,YAAYL,GAAE,UAAU,GAAG,IAAIK,GAAE,cAAc,CAACA,IAAG;AAAA,IACzD,QAAQL;AAAA,EACV,MAAMC,GAAE,GAAG,IAAID,GAAE,aAAa,CAAC,GAAG,IAAIA,GAAE,aAAa,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,WAAW,IAAIK,GAAE,OAAO,MAAM,GAAG,EAAE,WAAW,IAAIA,GAAE,KAAK,MAAM,GAAG,EAAE,WAAW,IAAIA,GAAE,IAAI,MAAM,GAAG,EAAE,WAAW,IAAIA,GAAE,SAAS,MAAM,GAAG,EAAE,SAAS,IAAI,MAAM,MAAM,GAAG,EAAE,SAAS,IAAI,cAAc,MAAM,GAAG,EAAE,SAAS,IAAI,YAAY,MAAM,GAAG,EAAE,SAAS,IAAI,cAAc,MAAM,GAAGF,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmB9V,GAAGC,GAAE,SAAS,IAAI,IAAIH,GAAE,uBAAuB,CAACI,IAAGL,OAAMA,GAAE,OAAO,mBAAmB,CAAC,GAAGI,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA8BpG,GAAG;AACL;AACA,IAAM,IAAI,EAAE;AAAZ,IACE,IAAI,EAAE;AADR,IAEE,IAAI,OAAO,OAAO,OAAO,eAAe;AAAA,EACtC,WAAW;AAAA,EACX,OAAO;AACT,GAAG,OAAO,aAAa;AAAA,EACrB,OAAO;AACT,CAAC,CAAC;",
  "names": ["i", "o", "n", "v", "w", "e"]
}
