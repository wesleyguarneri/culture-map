import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  a as a4
} from "./chunk-7QB35HXN.js";
import {
  o as o2
} from "./chunk-VFGVKYD2.js";
import {
  i
} from "./chunk-HRIGBQ5I.js";
import {
  l as l3
} from "./chunk-NOH3NLJ5.js";
import "./chunk-LX5BT6XP.js";
import "./chunk-PLGJMWC5.js";
import {
  d as d2
} from "./chunk-NVOJILW6.js";
import {
  k
} from "./chunk-KYPTWEOO.js";
import "./chunk-WVFB3H4O.js";
import "./chunk-ZREJ3Y2F.js";
import "./chunk-IR6CVPPC.js";
import "./chunk-BBUQOCRA.js";
import "./chunk-YBUJLIWZ.js";
import "./chunk-DL2B6IFJ.js";
import "./chunk-VOOO6FU5.js";
import "./chunk-IUPJR3FF.js";
import "./chunk-TGZW6QWO.js";
import "./chunk-OYIDHTXG.js";
import "./chunk-KUBMHTYA.js";
import "./chunk-6EIBUVMG.js";
import {
  l
} from "./chunk-KLK34CGP.js";
import {
  j
} from "./chunk-BD24XM4D.js";
import "./chunk-NXXQ35YM.js";
import "./chunk-3BXPVUY5.js";
import "./chunk-LM3JDV4W.js";
import "./chunk-34V2CLL5.js";
import {
  b as b2
} from "./chunk-CXNERL22.js";
import "./chunk-7V4JSBFA.js";
import {
  t as t2
} from "./chunk-ACSTKBET.js";
import {
  f as f3
} from "./chunk-REIMIECM.js";
import {
  l as l2
} from "./chunk-EO2EW5KR.js";
import "./chunk-JEFPXTYT.js";
import "./chunk-MVS2BECH.js";
import {
  t
} from "./chunk-UZ7IOCF3.js";
import {
  b as b3
} from "./chunk-OS542PQQ.js";
import {
  p,
  y as y2
} from "./chunk-3B5GODXR.js";
import "./chunk-NKXXHQDD.js";
import {
  S as S2,
  m
} from "./chunk-7TBQUMV3.js";
import {
  f as f2
} from "./chunk-TPLUZX3A.js";
import "./chunk-BGLJ2FAH.js";
import "./chunk-2EJFYNM7.js";
import "./chunk-DC5LRNPY.js";
import {
  s as s4
} from "./chunk-ASCK5HJ5.js";
import "./chunk-5X5U7R6O.js";
import "./chunk-XNLAOXPY.js";
import "./chunk-ZT7V2AVD.js";
import "./chunk-C2OXE4NQ.js";
import "./chunk-KOI252FF.js";
import "./chunk-I2TVVMQ6.js";
import "./chunk-5EGQYY2H.js";
import "./chunk-JKPUNUQA.js";
import "./chunk-SR7PRON4.js";
import "./chunk-HGHPYGKP.js";
import "./chunk-4DSGTDZJ.js";
import "./chunk-VYTPFEL2.js";
import "./chunk-RLGDH6IY.js";
import "./chunk-MRPCXIVS.js";
import "./chunk-YTKVV2Y3.js";
import "./chunk-GCVQXAS4.js";
import "./chunk-UFQD6AL4.js";
import "./chunk-THZPD5CT.js";
import "./chunk-OBCA6CWH.js";
import "./chunk-2JI245BP.js";
import {
  DateTime,
  FixedOffsetZone
} from "./chunk-N34BRXVM.js";
import "./chunk-KETDH2J4.js";
import "./chunk-7QV7DHWN.js";
import "./chunk-4L4Y34YK.js";
import "./chunk-BXONKQKI.js";
import "./chunk-2HDBQXAR.js";
import {
  w
} from "./chunk-RNF7VOCU.js";
import "./chunk-TIRJMGGG.js";
import {
  f
} from "./chunk-ZDRQSPB6.js";
import {
  o
} from "./chunk-DCXDXGAR.js";
import {
  r
} from "./chunk-BCCDYCTQ.js";
import "./chunk-AYL3HQHD.js";
import {
  s as s3
} from "./chunk-66YQWHHE.js";
import "./chunk-QGBMZIP4.js";
import "./chunk-AOEBZVTA.js";
import "./chunk-2OZSYJDX.js";
import "./chunk-MZM4INJV.js";
import "./chunk-J4GMQHGL.js";
import "./chunk-MHPE4SZA.js";
import {
  G
} from "./chunk-6SSA7P3A.js";
import "./chunk-FQBTLEUI.js";
import "./chunk-GS7Y3YOG.js";
import {
  n
} from "./chunk-Y2HYKTTT.js";
import {
  Et,
  I,
  S,
  U,
  x
} from "./chunk-XLEC46FY.js";
import {
  g
} from "./chunk-4AZPIP7K.js";
import "./chunk-G73HQZEL.js";
import {
  C,
  d,
  v
} from "./chunk-LZSLQ24Q.js";
import {
  V
} from "./chunk-U3RHUXYK.js";
import "./chunk-7DBI6LQG.js";
import "./chunk-AUUN7RFQ.js";
import "./chunk-JAMSDYD6.js";
import "./chunk-PH6NPTP7.js";
import {
  e
} from "./chunk-NUICEVIH.js";
import "./chunk-NXK752PZ.js";
import {
  y
} from "./chunk-UVNLCXWD.js";
import "./chunk-PNUA7JOS.js";
import "./chunk-OR2FKGUM.js";
import {
  N,
  a3,
  b
} from "./chunk-UDMPWVPF.js";
import "./chunk-XJNKCEWL.js";
import {
  a as a2
} from "./chunk-AIZ3T7E3.js";
import "./chunk-6UEMNP3E.js";
import "./chunk-6WGE3IUL.js";
import "./chunk-MLYB2YW4.js";
import {
  a,
  s,
  s2
} from "./chunk-6JFGZTLU.js";
import {
  O
} from "./chunk-2ZJE6ZFX.js";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-XBPEBUD5.js";

// ../../../node_modules/@arcgis/core/layers/support/WMSSublayer.js
var h;
var c = 0;
var m2 = h = class extends s4(m) {
  constructor(e2) {
    super(e2), this.description = null, this.dimensions = null, this.fullExtent = null, this.fullExtents = null, this.legendUrl = null, this.legendEnabled = true, this.layer = null, this.maxScale = 0, this.minScale = 0, this.name = null, this.parent = null, this.popupEnabled = false, this.queryable = false, this.sublayers = null, this.spatialReferences = null, this.title = null, this.addHandles([v(() => this.sublayers, "after-add", ({
      item: e3
    }) => {
      e3.parent = this, e3.layer = this.layer;
    }, C), v(() => this.sublayers, "after-remove", ({
      item: e3
    }) => {
      e3.layer = e3.parent = null;
    }, C), d(() => this.sublayers, (e3, t3) => {
      if (t3) for (const r2 of t3) r2.layer = r2.parent = null;
      if (e3) for (const r2 of e3) r2.parent = this, r2.layer = this.layer;
    }, C), d(() => this.layer, (e3) => {
      if (this.sublayers) for (const t3 of this.sublayers) t3.layer = e3;
    }, C)]);
  }
  get id() {
    const e2 = this._get("id");
    return e2 ?? c++;
  }
  set id(e2) {
    this._set("id", e2);
  }
  readLegendUrl(e2, t3) {
    return t3.legendUrl ?? t3.legendURL ?? null;
  }
  get effectiveScaleRange() {
    const {
      minScale: e2,
      maxScale: t3
    } = this;
    return {
      minScale: e2,
      maxScale: t3
    };
  }
  castSublayers(e2) {
    return b(V.ofType(h), e2);
  }
  set visible(e2) {
    this._setAndNotifyLayer("visible", e2);
  }
  clone() {
    const e2 = new h();
    return this.hasOwnProperty("description") && (e2.description = this.description), this.hasOwnProperty("fullExtent") && (e2.fullExtent = this.fullExtent.clone()), this.hasOwnProperty("fullExtents") && (e2.fullExtents = this.fullExtents?.map((e3) => e3.clone()) ?? null), this.hasOwnProperty("legendUrl") && (e2.legendUrl = this.legendUrl), this.hasOwnProperty("legendEnabled") && (e2.legendEnabled = this.legendEnabled), this.hasOwnProperty("layer") && (e2.layer = this.layer), this.hasOwnProperty("name") && (e2.name = this.name), this.hasOwnProperty("parent") && (e2.parent = this.parent), this.hasOwnProperty("queryable") && (e2.queryable = this.queryable), this.hasOwnProperty("sublayers") && (e2.sublayers = this.sublayers?.map((e3) => e3.clone())), this.hasOwnProperty("spatialReferences") && (e2.spatialReferences = this.spatialReferences?.map((e3) => e3)), this.hasOwnProperty("visible") && (e2.visible = this.visible), this.hasOwnProperty("title") && (e2.title = this.title), e2;
  }
  _setAndNotifyLayer(e2, t3) {
    const r2 = this.layer;
    this._get(e2) !== t3 && (this._set(e2, t3), r2 && r2.emit("wms-sublayer-update", {
      propertyName: e2,
      id: this.id
    }));
  }
};
e([y()], m2.prototype, "description", void 0), e([y({
  readOnly: true
})], m2.prototype, "dimensions", void 0), e([y({
  type: w,
  json: {
    name: "extent"
  }
})], m2.prototype, "fullExtent", void 0), e([y()], m2.prototype, "fullExtents", void 0), e([y({
  type: Number,
  json: {
    write: {
      enabled: false,
      overridePolicy: () => ({
        ignoreOrigin: true,
        enabled: true
      })
    }
  }
})], m2.prototype, "id", null), e([y({
  type: String,
  json: {
    name: "legendUrl",
    write: {
      ignoreOrigin: true
    }
  }
})], m2.prototype, "legendUrl", void 0), e([o("legendUrl", ["legendUrl", "legendURL"])], m2.prototype, "readLegendUrl", null), e([y({
  type: Boolean,
  json: {
    name: "showLegend",
    origins: {
      "web-map": {
        read: false,
        write: false
      },
      "web-scene": {
        read: false,
        write: false
      }
    }
  }
})], m2.prototype, "legendEnabled", void 0), e([y()], m2.prototype, "layer", void 0), e([y()], m2.prototype, "maxScale", void 0), e([y()], m2.prototype, "minScale", void 0), e([y({
  readOnly: true
})], m2.prototype, "effectiveScaleRange", null), e([y({
  type: String,
  json: {
    write: {
      ignoreOrigin: true
    }
  }
})], m2.prototype, "name", void 0), e([y()], m2.prototype, "parent", void 0), e([y({
  type: Boolean,
  json: {
    read: {
      source: "showPopup"
    },
    write: {
      ignoreOrigin: true,
      target: "showPopup"
    }
  }
})], m2.prototype, "popupEnabled", void 0), e([y({
  type: Boolean,
  json: {
    write: {
      ignoreOrigin: true
    }
  }
})], m2.prototype, "queryable", void 0), e([y()], m2.prototype, "sublayers", void 0), e([s3("sublayers")], m2.prototype, "castSublayers", null), e([y({
  type: [Number],
  json: {
    read: {
      source: "spatialReferences"
    }
  }
})], m2.prototype, "spatialReferences", void 0), e([y({
  type: String,
  json: {
    write: {
      ignoreOrigin: true
    }
  }
})], m2.prototype, "title", void 0), e([y({
  type: Boolean,
  value: true,
  json: {
    read: {
      source: "defaultVisibility"
    }
  }
})], m2.prototype, "visible", null), m2 = h = e([a3("esri.layers.support.WMSSublayer")], m2);
var f4 = m2;

// ../../../node_modules/@arcgis/core/layers/support/wmsUtils.js
var u = {
  84: 4326,
  83: 4269,
  27: 4267
};
function a5(n2) {
  if (!n2) return null;
  const i2 = {
    idCounter: -1
  };
  if ("string" == typeof n2) {
    n2 = new DOMParser().parseFromString(n2, "text/xml");
  }
  const s5 = n2.documentElement;
  if ("ServiceExceptionReport" === s5.nodeName) {
    const e2 = Array.prototype.slice.call(s5.childNodes).map((e3) => e3.textContent).join("\r\n");
    throw new s2("wmslayer:wms-capabilities-xml-is-not-valid", "The server returned errors when the WMS capabilities were requested.", e2);
  }
  const o3 = x2("Capability", s5), l4 = x2("Service", s5), u2 = o3 && x2("Request", o3);
  if (!o3 || !l4 || !u2) return null;
  const a6 = x2("Layer", o3);
  if (!a6) return null;
  const c3 = "WMS_Capabilities" === s5.nodeName || "WMT_MS_Capabilities" === s5.nodeName ? s5.getAttribute("version") : "1.3.0", d4 = g2("Title", l4, "") || g2("Name", l4, ""), p3 = g2("AccessConstraints", l4, ""), h3 = /^none$/i.test(p3) ? "" : p3, N3 = g2("Abstract", l4, ""), A2 = parseInt(g2("MaxWidth", l4, "5000"), 10), w3 = parseInt(g2("MaxHeight", l4, "5000"), 10), L = b4(u2, "GetMap"), F2 = y3(u2, "GetMap"), M = S3(a6, c3, i2);
  if (!M) return null;
  let T2, I3 = 0;
  const v3 = Array.prototype.slice.call(o3.childNodes), R2 = M.sublayers ?? [], U3 = (e2) => {
    null != e2 && R2.push(e2);
  };
  v3.forEach((e2) => {
    "Layer" === e2.nodeName && (0 === I3 ? T2 = e2 : 1 === I3 ? (M.name && (M.name = "", U3(S3(T2, c3, i2))), U3(S3(e2, c3, i2))) : U3(S3(e2, c3, i2)), I3++);
  });
  let V4 = M.sublayers, O3 = M.extent;
  const _2 = M.fullExtents ?? [];
  if (V4 || (V4 = []), 0 === V4.length && V4.push(M), !O3) {
    const e2 = new w(V4[0].extent);
    M.extent = e2.toJSON(), O3 = M.extent;
  }
  const B2 = M.spatialReferences.length > 0 ? M.spatialReferences : m3(M), j3 = y3(u2, "GetFeatureInfo"), k3 = j3 ? b4(u2, "GetFeatureInfo") : null, q2 = f5(V4), X3 = M.minScale || 0, D2 = M.maxScale || 0, $ = M.dimensions ?? [], G2 = q2.reduce((e2, t3) => e2.concat(t3.dimensions ?? []), []), W = $.concat(G2).filter(C2);
  let P = null;
  if (W.length) {
    const t3 = W.map((e2) => {
      const {
        extent: t4
      } = e2;
      return E(t4) ? t4.map((e3) => e3.getTime()) : t4?.map((e3) => [e3.min.getTime(), e3.max.getTime()]);
    }).flat(2).filter(O);
    P = {
      startTimeField: null,
      endTimeField: null,
      trackIdField: void 0,
      timeExtent: [Math.min(...t3), Math.max(...t3)]
    };
  }
  return {
    copyright: h3,
    description: N3,
    dimensions: $,
    extent: O3,
    fullExtents: _2,
    featureInfoFormats: k3,
    featureInfoUrl: j3,
    mapUrl: F2,
    maxWidth: A2,
    maxHeight: w3,
    maxScale: D2,
    minScale: X3,
    layers: q2,
    spatialReferences: B2,
    supportedImageFormatTypes: L,
    timeInfo: P,
    title: d4,
    version: c3
  };
}
function c2(e2) {
  const t3 = e2.filter((e3) => e3.popupEnabled && e3.name && e3.queryable);
  return t3.length ? t3.map(({
    name: e3
  }) => e3).join() : null;
}
function m3(e2) {
  if (e2.spatialReferences.length > 0) return e2.spatialReferences;
  if (e2.sublayers) for (const t3 of e2.sublayers) {
    const e3 = m3(t3);
    if (e3.length > 0) return e3;
  }
  return [];
}
function f5(e2) {
  let t3 = [];
  for (const n2 of e2) t3.push(n2), n2.sublayers?.length && (t3 = t3.concat(f5(n2.sublayers)), delete n2.sublayers);
  return t3;
}
function d3(e2, t3, n2) {
  return t3.getAttribute(e2) ?? n2;
}
function p2(e2, t3, n2, r2) {
  const i2 = x2(e2, n2);
  return i2 ? d3(t3, i2, r2) : r2;
}
function x2(e2, t3) {
  for (let n2 = 0; n2 < t3.childNodes.length; n2++) {
    const r2 = t3.childNodes[n2];
    if (w2(r2) && r2.nodeName === e2) return r2;
  }
  return null;
}
function h2(e2, t3) {
  if (null == t3) return [];
  const n2 = [];
  for (let r2 = 0; r2 < t3.childNodes.length; r2++) {
    const i2 = t3.childNodes[r2];
    w2(i2) && i2.nodeName === e2 && n2.push(i2);
  }
  return n2;
}
function g2(e2, t3, n2) {
  return x2(e2, t3)?.textContent ?? n2;
}
function N2(e2, t3, n2) {
  if (!e2) return null;
  const s5 = parseFloat(e2.getAttribute("minx")), o3 = parseFloat(e2.getAttribute("miny")), l4 = parseFloat(e2.getAttribute("maxx")), u2 = parseFloat(e2.getAttribute("maxy"));
  let a6, c3, m4, f6;
  n2 ? (a6 = isNaN(o3) ? -Number.MAX_VALUE : o3, c3 = isNaN(s5) ? -Number.MAX_VALUE : s5, m4 = isNaN(u2) ? Number.MAX_VALUE : u2, f6 = isNaN(l4) ? Number.MAX_VALUE : l4) : (a6 = isNaN(s5) ? -Number.MAX_VALUE : s5, c3 = isNaN(o3) ? -Number.MAX_VALUE : o3, m4 = isNaN(l4) ? Number.MAX_VALUE : l4, f6 = isNaN(u2) ? Number.MAX_VALUE : u2);
  const d4 = new f({
    wkid: t3
  });
  return new w({
    xmin: a6,
    ymin: c3,
    xmax: m4,
    ymax: f6,
    spatialReference: d4
  });
}
function y3(e2, t3) {
  const n2 = x2(t3, e2);
  if (n2) {
    const e3 = x2("DCPType", n2);
    if (e3) {
      const t4 = x2("HTTP", e3);
      if (t4) {
        const e4 = x2("Get", t4);
        if (e4) {
          let t5 = p2("OnlineResource", "xlink:href", e4, null);
          if (t5) return t5.indexOf("&") === t5.length - 1 && (t5 = t5.substring(0, t5.length - 1)), T(t5, ["service", "request"]);
        }
      }
    }
  }
  return null;
}
function b4(t3, n2) {
  const r2 = h2("Operation", t3);
  if (!r2.length) {
    return h2("Format", x2(n2, t3)).map(({
      textContent: e2
    }) => e2).filter(O);
  }
  const i2 = [];
  for (const e2 of r2) if (e2.getAttribute("name") === n2) {
    const t4 = h2("Format", e2);
    for (const {
      textContent: e3
    } of t4) null != e3 && i2.push(e3);
  }
  return i2;
}
function A(e2, t3, n2) {
  const r2 = x2(t3, e2);
  if (!r2) return n2;
  const {
    textContent: i2
  } = r2;
  if (null == i2 || "" === i2) return n2;
  const s5 = Number(i2);
  return isNaN(s5) ? n2 : s5;
}
function S3(e2, t3, n2) {
  if (!e2) return null;
  const o3 = {
    id: n2.idCounter++,
    fullExtents: [],
    parentLayerId: null,
    queryable: "1" === e2.getAttribute("queryable"),
    spatialReferences: [],
    sublayers: null
  }, l4 = x2("LatLonBoundingBox", e2), a6 = x2("EX_GeographicBoundingBox", e2);
  let c3 = null;
  l4 && (c3 = N2(l4, 4326)), a6 && (c3 = new w(0, 0, 0, 0, new f({
    wkid: 4326
  })), c3.xmin = parseFloat(g2("westBoundLongitude", a6, "0")), c3.ymin = parseFloat(g2("southBoundLatitude", a6, "0")), c3.xmax = parseFloat(g2("eastBoundLongitude", a6, "0")), c3.ymax = parseFloat(g2("northBoundLatitude", a6, "0"))), l4 || a6 || (c3 = new w(-180, -90, 180, 90, new f({
    wkid: 4326
  }))), o3.minScale = A(e2, "MaxScaleDenominator", 0), o3.maxScale = A(e2, "MinScaleDenominator", 0);
  const m4 = ["1.0.0", "1.1.0", "1.1.1"].includes(t3) ? "SRS" : "CRS";
  return Array.prototype.slice.call(e2.childNodes).forEach((e3) => {
    if ("Name" === e3.nodeName) o3.name = e3.textContent || "";
    else if ("Title" === e3.nodeName) o3.title = e3.textContent || "";
    else if ("Abstract" === e3.nodeName) o3.description = e3.textContent || "";
    else if ("BoundingBox" === e3.nodeName) {
      const n3 = e3.getAttribute(m4);
      if (n3 && 0 === n3.indexOf("EPSG:")) {
        const r3 = parseInt(n3.substring(5), 10);
        0 === r3 || isNaN(r3) || c3 || (c3 = "1.3.0" === t3 ? N2(e3, r3, o2(r3)) : N2(e3, r3));
      }
      const r2 = n3?.indexOf(":");
      if (r2 && r2 > -1) {
        let i2 = parseInt(n3.substring(r2 + 1, n3.length), 10);
        0 === i2 || isNaN(i2) || (i2 = u[i2] ?? i2);
        const l5 = "1.3.0" === t3 ? N2(e3, i2, o2(i2)) : N2(e3, i2);
        l5 && o3.fullExtents && o3.fullExtents.push(l5);
      }
    } else if (e3.nodeName === m4) {
      (e3.textContent?.split(" ") ?? []).forEach((e4) => {
        const t4 = e4.includes(":") ? parseInt(e4.split(":")[1], 10) : parseInt(e4, 10);
        if (0 !== t4 && !isNaN(t4)) {
          const e5 = u[t4] ?? t4;
          o3.spatialReferences.includes(e5) || o3.spatialReferences.push(e5);
        }
      });
    } else if ("Style" !== e3.nodeName || o3.legendUrl) {
      if ("Layer" === e3.nodeName) {
        const r2 = S3(e3, t3, n2);
        r2 && (r2.parentLayerId = o3.id, o3.sublayers || (o3.sublayers = []), o3.sublayers.push(r2));
      }
    } else {
      const t4 = x2("LegendURL", e3);
      if (t4) {
        const e4 = x2("OnlineResource", t4);
        e4 && (o3.legendUrl = e4.getAttribute("xlink:href"));
      }
    }
  }), o3.extent = c3?.toJSON(), o3.dimensions = h2("Dimension", e2).filter((e3) => e3.getAttribute("name") && e3.getAttribute("units") && e3.textContent).map((e3) => {
    const t4 = e3.getAttribute("name"), n3 = e3.getAttribute("units"), r2 = e3.textContent, i2 = e3.getAttribute("unitSymbol") ?? void 0, s5 = e3.getAttribute("default") ?? void 0, o4 = "0" !== d3("default", e3, "0"), l5 = "0" !== d3("nearestValue", e3, "0"), u2 = "0" !== d3("current", e3, "0");
    if (C2({
      name: t4,
      units: n3
    })) {
      return {
        name: "time",
        units: "ISO8601",
        extent: R(r2),
        default: R(s5),
        multipleValues: o4,
        nearestValue: l5,
        current: u2
      };
    }
    if (F({
      name: t4,
      units: n3
    })) {
      return {
        name: "elevation",
        units: n3,
        extent: I2(r2),
        unitSymbol: i2,
        default: I2(s5),
        multipleValues: o4,
        nearestValue: l5
      };
    }
    return {
      name: t4,
      units: n3,
      extent: v2(r2),
      unitSymbol: i2,
      default: v2(s5),
      multipleValues: o4,
      nearestValue: l5
    };
  }), o3;
}
function E(e2) {
  return Array.isArray(e2) && e2.length > 0 && e2[0] instanceof Date;
}
function w2(e2) {
  return e2.nodeType === Node.ELEMENT_NODE;
}
function F(e2) {
  return /^elevation$/i.test(e2.name) && /^(epsg|crs):\d+$/i.test(e2.units);
}
function C2(e2) {
  return /^time$/i.test(e2.name) && /^iso8601$/i.test(e2.units);
}
function T(e2, t3) {
  const r2 = [], i2 = I(e2);
  for (const n2 in i2.query) i2.query.hasOwnProperty(n2) && (t3.includes(n2.toLowerCase()) || r2.push(n2 + "=" + i2.query[n2]));
  return i2.path + (r2.length ? "?" + r2.join("&") : "");
}
function I2(t3) {
  if (!t3) return;
  const n2 = t3.includes("/"), r2 = t3.split(",");
  return n2 ? r2.map((e2) => {
    const t4 = e2.split("/");
    if (t4.length < 2) return null;
    return {
      min: parseFloat(t4[0]),
      max: parseFloat(t4[1]),
      resolution: t4.length >= 3 && "0" !== t4[2] ? parseFloat(t4[2]) : void 0
    };
  }).filter(O) : r2.map((e2) => parseFloat(e2));
}
function v2(t3) {
  if (!t3) return;
  const n2 = t3.includes("/"), r2 = t3.split(",");
  return n2 ? r2.map((e2) => {
    const t4 = e2.split("/");
    if (t4.length < 2) return null;
    return {
      min: t4[0],
      max: t4[1],
      resolution: t4.length >= 3 && "0" !== t4[2] ? t4[2] : void 0
    };
  }).filter(O) : r2;
}
function R(t3) {
  if (!t3) return;
  const n2 = t3.includes("/"), r2 = t3.split(",");
  return n2 ? r2.map((e2) => {
    const t4 = e2.split("/");
    if (t4.length < 2) return null;
    return {
      min: U2(t4[0]),
      max: U2(t4[1]),
      resolution: t4.length >= 3 && "0" !== t4[2] ? V2(t4[2]) : void 0
    };
  }).filter(O) : r2.map((e2) => U2(e2));
}
function U2(e2) {
  return DateTime.fromISO(e2, {
    zone: FixedOffsetZone.utcInstance
  }).toJSDate();
}
function V2(e2) {
  const t3 = /(?:p(\d+y|\d+(?:\.|,)\d+y)?(\d+m|\d+(?:\.|,)\d+m)?(\d+d|\d+(?:\.|,)\d+d)?)?(?:t(\d+h|\d+(?:\.|,)\d+h)?(\d+m|\d+(?:\.|,)\d+m)?(\d+s|\d+(?:\.|,)\d+s)?)?/i, n2 = e2.match(t3);
  if (!n2) return null;
  return {
    years: O2(n2[1]),
    months: O2(n2[2]),
    days: O2(n2[3]),
    hours: O2(n2[4]),
    minutes: O2(n2[5]),
    seconds: O2(n2[6])
  };
}
function O2(e2) {
  if (!e2) return 0;
  const t3 = /(?:\d+(?:\.|,)\d+|\d+)/, n2 = e2.match(t3);
  if (!n2) return 0;
  const r2 = n2[0].replace(",", ".");
  return Number(r2);
}
function _(e2) {
  return e2.toISOString().replace(/\.[0-9]{3}/, "");
}
var B = "0000-01-01T00:00:00Z";
var j2 = "9999-12-31T23:59:59Z";
function k2(e2) {
  if (!e2 || e2.isAllTime || e2.isEmpty) return;
  const {
    start: t3,
    end: n2
  } = e2;
  if (t3 && n2 && t3.getTime() === n2.getTime()) return `${_(t3)}`;
  return `${t3 ? _(t3) : B}/${n2 ? _(n2) : j2}`;
}
var q = /* @__PURE__ */ new Set([102100, 3857, 102113, 900913]);
var X = /* @__PURE__ */ new Set([3395, 54004]);
function D(e2, t3) {
  let n2 = e2.wkid;
  return null == t3 ? n2 : (null != n2 && t3.includes(n2) || !e2.latestWkid || (n2 = e2.latestWkid), null != n2 && q.has(n2) ? t3.find((e3) => q.has(e3)) || t3.find((e3) => X.has(e3)) || 102100 : n2);
}

// ../../../node_modules/@arcgis/core/layers/WMSLayer.js
var J = new n({
  bmp: "image/bmp",
  gif: "image/gif",
  jpg: "image/jpeg",
  png: "image/png",
  svg: "image/svg+xml"
}, {
  ignoreUnknown: false
});
function V3(e2) {
  return "text/html" === e2;
}
function z(e2) {
  return "text/plain" === e2;
}
var Q = class extends l2(l3(f3(t(b3(j(S2(f2))))))) {
  constructor(...e2) {
    super(...e2), this.allSublayers = new l({
      getCollections: () => [this.sublayers],
      getChildrenFunction: (e3) => e3.sublayers
    }), this.customParameters = null, this.customLayerParameters = null, this.copyright = null, this.description = null, this.dimensions = null, this.fullExtent = null, this.fullExtents = null, this.featureInfoFormats = null, this.featureInfoUrl = null, this.fetchFeatureInfoFunction = null, this.imageFormat = null, this.imageMaxHeight = 2048, this.imageMaxWidth = 2048, this.imageTransparency = true, this.legendEnabled = true, this.mapUrl = null, this.isReference = null, this.operationalLayerType = "WMS", this.spatialReference = null, this.spatialReferences = null, this.sublayers = null, this.type = "wms", this.version = null, this.addHandles([v(() => this.sublayers, "after-add", ({
      item: e3
    }) => {
      e3.parent = e3.layer = this;
    }, C), v(() => this.sublayers, "after-remove", ({
      item: e3
    }) => {
      e3.layer = e3.parent = null;
    }, C), d(() => this.sublayers, (e3, t3) => {
      if (t3) for (const r2 of t3) r2.layer = r2.parent = null;
      if (e3) for (const r2 of e3) r2.parent = r2.layer = this;
    }, C)]);
  }
  normalizeCtorArgs(e2, t3) {
    return "string" == typeof e2 ? __spreadValues({
      url: e2
    }, t3) : e2;
  }
  destroy() {
    this.allSublayers.destroy();
  }
  load(e2) {
    const t3 = null != e2 ? e2.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({
      supportedTypes: ["WMS"]
    }, e2).catch(a2).then(() => this._fetchService(t3))), Promise.resolve(this);
  }
  readFullExtentFromItemOrMap(e2, t3) {
    const r2 = t3.extent;
    return r2 ? new w({
      xmin: r2[0][0],
      ymin: r2[0][1],
      xmax: r2[1][0],
      ymax: r2[1][1]
    }) : null;
  }
  writeFullExtent(e2, t3) {
    t3.extent = [[e2.xmin, e2.ymin], [e2.xmax, e2.ymax]];
  }
  get featureInfoFormat() {
    return null == this.featureInfoFormats ? null : this.featureInfoFormats.find(V3) ?? this.featureInfoFormats.find(z) ?? null;
  }
  set featureInfoFormat(e2) {
    null == e2 ? (this.revert("featureInfoFormat", "service"), this._clearOverride("featureInfoFormat")) : (V3(e2) || z(e2)) && this._override("featureInfoFormat", e2);
  }
  readImageFormat(e2, t3) {
    const r2 = t3.supportedImageFormatTypes;
    return r2 && r2.includes("image/png") ? "image/png" : r2 && r2[0];
  }
  readSpatialReferenceFromItemOrDocument(e2, t3) {
    return new f(t3.spatialReferences[0]);
  }
  writeSpatialReferences(e2, t3) {
    const r2 = this.spatialReference?.wkid;
    e2 && r2 ? (t3.spatialReferences = e2.filter((e3) => e3 !== r2), t3.spatialReferences.unshift(r2)) : t3.spatialReferences = e2;
  }
  readSublayersFromItemOrMap(e2, t3, r2) {
    return X2(t3.layers, r2, t3.visibleLayers);
  }
  readSublayers(e2, t3, r2) {
    return X2(t3.layers, r2);
  }
  writeSublayers(e2, t3, r2, o3) {
    t3.layers = [];
    const s5 = /* @__PURE__ */ new Map(), i2 = e2.flatten(({
      sublayers: e3
    }) => e3 ?? []);
    for (const a6 of i2) if ("number" == typeof a6.parent?.id) {
      const e3 = s5.get(a6.parent.id);
      null != e3 ? e3.push(a6.id) : s5.set(a6.parent.id, [a6.id]);
    }
    for (const a6 of i2) {
      const e3 = __spreadValues({
        sublayer: a6
      }, o3), r3 = a6.write({
        parentLayerId: "number" == typeof a6.parent?.id ? a6.parent.id : -1
      }, e3);
      if (s5.has(a6.id) && (r3.sublayerIds = s5.get(a6.id)), !a6.sublayers && a6.name) {
        const r4 = a6.write({}, e3);
        delete r4.id, t3.layers.push(r4);
      }
    }
    t3.visibleLayers = i2.filter(({
      visible: e3,
      sublayers: t4
    }) => e3 && !t4).map(({
      name: e3
    }) => e3).toArray();
  }
  set url(e2) {
    if (!e2) return void this._set("url", e2);
    const {
      path: t3,
      query: r2
    } = I(e2);
    for (const s5 in r2) /^(request|service)$/i.test(s5) && delete r2[s5];
    const o3 = Et(t3, r2 ?? {});
    this._set("url", o3);
  }
  createExportImageParameters(e2, t3, r2, o3) {
    const s5 = o3?.pixelRatio ?? 1, i2 = i({
      extent: e2,
      width: t3
    }) * s5, a6 = new a4({
      layer: this,
      scale: i2
    }), {
      xmin: n2,
      ymin: l4,
      xmax: p3,
      ymax: m4,
      spatialReference: u2
    } = e2, c3 = D(u2, this.spatialReferences), f6 = "1.3.0" === this.version && o2(c3) ? `${l4},${n2},${m4},${p3}` : `${n2},${l4},${p3},${m4}`, y4 = a6.toJSON(), d4 = "1.3.0" === this.version ? "crs" : "srs";
    return __spreadValues({
      bbox: f6,
      [d4]: null == c3 || isNaN(c3) ? void 0 : "EPSG:" + c3
    }, y4);
  }
  fetchImage(e2, t3, r2, o3) {
    return __async(this, null, function* () {
      const i2 = this.mapUrl, a6 = this.createExportImageParameters(e2, t3, r2, o3);
      if (!a6.layers) {
        const e3 = document.createElement("canvas");
        return e3.width = t3, e3.height = r2, e3;
      }
      const n2 = k2(o3?.timeExtent), l4 = {
        responseType: "image",
        query: this._mixCustomParameters(__spreadValues(__spreadProps(__spreadValues({
          width: t3,
          height: r2
        }, a6), {
          time: n2
        }), this.refreshParameters)),
        signal: o3?.signal
      };
      return U(i2 ?? "", l4).then((e3) => e3.data);
    });
  }
  fetchImageBitmap(e2, t3, r2, o3) {
    return __async(this, null, function* () {
      const i2 = this.mapUrl ?? "", a6 = this.createExportImageParameters(e2, t3, r2, o3);
      if (!a6.layers) {
        const e3 = document.createElement("canvas");
        return e3.width = t3, e3.height = r2, e3;
      }
      const n2 = k2(o3?.timeExtent), l4 = {
        responseType: "blob",
        query: this._mixCustomParameters(__spreadValues(__spreadProps(__spreadValues({
          width: t3,
          height: r2
        }, a6), {
          time: n2
        }), this.refreshParameters)),
        signal: o3?.signal
      }, {
        data: p3
      } = yield U(i2, l4);
      return t2(p3, i2, o3?.signal);
    });
  }
  fetchFeatureInfo(e2, t3, r2, o3, s5) {
    const i2 = i({
      extent: e2,
      width: t3
    }), a6 = new a4({
      layer: this,
      scale: i2
    }), n2 = c2(a6.visibleSublayers);
    if (null == this.featureInfoUrl || null == n2) return Promise.resolve([]);
    if (null == this.fetchFeatureInfoFunction && null == this.featureInfoFormat) return Promise.resolve([]);
    const l4 = "1.3.0" === this.version ? {
      I: o3,
      J: s5
    } : {
      x: o3,
      y: s5
    }, p3 = __spreadValues({
      query_layers: n2,
      request: "GetFeatureInfo",
      info_format: this.featureInfoFormat,
      feature_count: 25,
      width: t3,
      height: r2
    }, l4), m4 = __spreadValues(__spreadValues({}, this.createExportImageParameters(e2, t3, r2)), p3), u2 = this._mixCustomParameters(m4);
    return null != this.fetchFeatureInfoFunction ? this.fetchFeatureInfoFunction(u2) : this._defaultFetchFeatureInfoFunction(Et(this.featureInfoUrl, u2));
  }
  findSublayerById(e2) {
    return this.allSublayers.find((t3) => t3.id === e2);
  }
  findSublayerByName(e2) {
    return this.allSublayers.find((t3) => t3.name === e2);
  }
  serviceSupportsSpatialReference(e2) {
    return b2(this.url) || null != this.spatialReferences && this.spatialReferences.some((t3) => {
      const r2 = 900913 === t3 ? f.WebMercator : new f({
        wkid: t3
      });
      return G(r2, e2);
    });
  }
  _defaultFetchFeatureInfoFunction(e2) {
    const t3 = document.createElement("iframe");
    t3.src = S(e2), t3.style.border = "none", t3.style.margin = "0", t3.style.width = "100%", t3.setAttribute("sandbox", "");
    const s5 = new k({
      title: this.title,
      content: t3
    }), i2 = new d2({
      sourceLayer: this,
      popupTemplate: s5
    });
    return Promise.resolve([i2]);
  }
  _fetchService(e2) {
    return __async(this, null, function* () {
      if (!this.resourceInfo && this.parsedUrl?.path) {
        const {
          path: t3,
          query: r2
        } = this.parsedUrl, {
          data: o3
        } = yield U(t3, {
          query: __spreadValues(__spreadValues({
            SERVICE: "WMS",
            REQUEST: "GetCapabilities"
          }, r2), this.customParameters),
          responseType: "xml",
          signal: e2
        });
        this.resourceInfo = a5(o3);
      }
      if (this.parsedUrl) {
        const e3 = new x(this.parsedUrl.path), {
          httpsDomains: r2
        } = s.request;
        "https" !== e3.scheme || e3.port && "443" !== e3.port || !e3.host || r2.includes(e3.host) || r2.push(e3.host);
      }
      this.read(this.resourceInfo, {
        origin: "service"
      });
    });
  }
  _mixCustomParameters(e2) {
    if (!this.customLayerParameters && !this.customParameters) return e2;
    const t3 = __spreadValues(__spreadValues({}, this.customParameters), this.customLayerParameters);
    for (const r2 in t3) e2[r2.toLowerCase()] = t3[r2];
    return e2;
  }
};
function K(e2, t3) {
  return e2.some((e3) => {
    for (const r2 in e3) if (g(e3, r2, null, t3)) return true;
    return false;
  });
}
function X2(e2, t3, r2) {
  e2 = e2 ?? [];
  const o3 = /* @__PURE__ */ new Map();
  e2.every((e3) => null == e3.id) && (e2 = a(e2)).forEach((e3, t4) => e3.id = t4);
  for (const i2 of e2) {
    const e3 = new f4();
    e3.read(i2, t3), r2 && !r2.includes(e3.name) && (e3.visible = false), o3.set(e3.id, e3);
  }
  const s5 = [];
  for (const a6 of e2) {
    const e3 = null != a6.id ? o3.get(a6.id) : null;
    if (e3) if (null != a6.parentLayerId && a6.parentLayerId >= 0) {
      const t4 = o3.get(a6.parentLayerId);
      if (!t4) continue;
      t4.sublayers || (t4.sublayers = new V()), t4.sublayers.push(e3);
    } else s5.push(e3);
  }
  return s5;
}
e([y({
  readOnly: true
})], Q.prototype, "allSublayers", void 0), e([y({
  json: {
    type: Object,
    write: true
  }
})], Q.prototype, "customParameters", void 0), e([y({
  json: {
    type: Object,
    write: true
  }
})], Q.prototype, "customLayerParameters", void 0), e([y({
  type: String,
  json: {
    write: true
  }
})], Q.prototype, "copyright", void 0), e([y()], Q.prototype, "description", void 0), e([y({
  readOnly: true
})], Q.prototype, "dimensions", void 0), e([y({
  json: {
    type: [[Number]],
    read: {
      source: "extent"
    },
    write: {
      target: "extent"
    },
    origins: {
      "web-document": {
        write: {
          ignoreOrigin: true
        }
      },
      "portal-item": {
        write: {
          ignoreOrigin: true
        }
      }
    }
  }
})], Q.prototype, "fullExtent", void 0), e([o(["web-document", "portal-item"], "fullExtent", ["extent"])], Q.prototype, "readFullExtentFromItemOrMap", null), e([r(["web-document", "portal-item"], "fullExtent", {
  extent: {
    type: [[Number]]
  }
})], Q.prototype, "writeFullExtent", null), e([y()], Q.prototype, "fullExtents", void 0), e([y({
  type: String,
  json: {
    write: {
      ignoreOrigin: true
    }
  }
})], Q.prototype, "featureInfoFormat", null), e([y({
  type: [String],
  readOnly: true
})], Q.prototype, "featureInfoFormats", void 0), e([y({
  type: String,
  json: {
    write: {
      ignoreOrigin: true
    }
  }
})], Q.prototype, "featureInfoUrl", void 0), e([y()], Q.prototype, "fetchFeatureInfoFunction", void 0), e([y({
  type: String,
  json: {
    origins: {
      "web-document": {
        default: "image/png",
        type: J.jsonValues,
        read: {
          reader: J.read,
          source: "format"
        },
        write: {
          writer: J.write,
          target: "format"
        }
      }
    }
  }
})], Q.prototype, "imageFormat", void 0), e([o("imageFormat", ["supportedImageFormatTypes"])], Q.prototype, "readImageFormat", null), e([y({
  type: Number,
  json: {
    read: {
      source: "maxHeight"
    },
    write: {
      target: "maxHeight"
    }
  }
})], Q.prototype, "imageMaxHeight", void 0), e([y({
  type: Number,
  json: {
    read: {
      source: "maxWidth"
    },
    write: {
      target: "maxWidth"
    }
  }
})], Q.prototype, "imageMaxWidth", void 0), e([y()], Q.prototype, "imageTransparency", void 0), e([y(y2)], Q.prototype, "legendEnabled", void 0), e([y({
  type: ["show", "hide", "hide-children"]
})], Q.prototype, "listMode", void 0), e([y({
  type: String,
  json: {
    write: {
      ignoreOrigin: true
    }
  }
})], Q.prototype, "mapUrl", void 0), e([y({
  type: Boolean,
  json: {
    read: false,
    write: {
      enabled: true,
      overridePolicy: () => ({
        enabled: false
      })
    }
  }
})], Q.prototype, "isReference", void 0), e([y({
  type: ["WMS"]
})], Q.prototype, "operationalLayerType", void 0), e([y()], Q.prototype, "resourceInfo", void 0), e([y({
  type: f,
  json: {
    origins: {
      service: {
        read: {
          source: "extent.spatialReference"
        }
      }
    },
    write: false
  }
})], Q.prototype, "spatialReference", void 0), e([o(["web-document", "portal-item"], "spatialReference", ["spatialReferences"])], Q.prototype, "readSpatialReferenceFromItemOrDocument", null), e([y({
  type: [N],
  json: {
    read: false,
    origins: {
      service: {
        read: true
      },
      "web-document": {
        read: false,
        write: {
          ignoreOrigin: true
        }
      },
      "portal-item": {
        read: false,
        write: {
          ignoreOrigin: true
        }
      }
    }
  }
})], Q.prototype, "spatialReferences", void 0), e([r(["web-document", "portal-item"], "spatialReferences")], Q.prototype, "writeSpatialReferences", null), e([y({
  type: V.ofType(f4),
  json: {
    write: {
      target: "layers",
      overridePolicy(e2, t3, r2) {
        if (K(this.allSublayers, r2)) return {
          ignoreOrigin: true
        };
      }
    }
  }
})], Q.prototype, "sublayers", void 0), e([o(["web-document", "portal-item"], "sublayers", ["layers", "visibleLayers"])], Q.prototype, "readSublayersFromItemOrMap", null), e([o("service", "sublayers", ["layers"])], Q.prototype, "readSublayers", null), e([r("sublayers", {
  layers: {
    type: [f4]
  },
  visibleLayers: {
    type: [String]
  }
})], Q.prototype, "writeSublayers", null), e([y({
  json: {
    read: false
  },
  readOnly: true,
  value: "wms"
})], Q.prototype, "type", void 0), e([y(p)], Q.prototype, "url", null), e([y({
  type: String,
  json: {
    write: {
      ignoreOrigin: true
    }
  }
})], Q.prototype, "version", void 0), Q = e([a3("esri.layers.WMSLayer")], Q);
var Y = Q;
export {
  Y as default
};
//# sourceMappingURL=WMSLayer-SLMUHAHG.js.map
