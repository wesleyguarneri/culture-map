{
  "version": 3,
  "sources": ["../../../../../../node_modules/@arcgis/core/chunks/EdgeDetect.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.30/esri/copyright.txt for details.\n*/\nimport { ScreenSpacePass as e } from \"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js\";\nimport { glsl as t } from \"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";\nimport { ShaderBuilder as o } from \"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";\nimport { Texture2DPassUniform as a } from \"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";\nconst r = {\n  threshold: .05,\n  localConstrastAdaption: 2\n};\nfunction l() {\n  const l = new o();\n  return l.include(e), l.fragment.uniforms.add(new a(\"colorTexture\", e => e.color)), l.outputs.add(\"fragEdges\", \"vec2\"), l.fragment.code.add(t`\n    float absMax3(vec3 v) {\n      vec3 t = abs(v);\n      return max(max(t.r, t.g), t.b);\n    }\n\n    void main() {\n      vec2 resolution = 1.0 / vec2(textureSize(colorTexture, 0));\n      vec4 offsets[3];\n      offsets[0] = vec4(uv.x - resolution.x, uv.y, uv.x, uv.y + resolution.y);\n      offsets[1] = vec4(uv.x + resolution.x, uv.y, uv.x, uv.y - resolution.y);\n      offsets[2] = vec4(uv.x - 2.0 * resolution.x, uv.y, uv.x, uv.y + 2.0 * resolution.y);\n\n      // Calculate color deltas:\n      vec4 delta;\n      vec3 C = texture(colorTexture, uv).rgb;\n\n      vec3 Cleft = texture(colorTexture, offsets[0].xy).rgb;\n      delta.x = absMax3(C - Cleft);\n\n      vec3 Ctop = texture(colorTexture, offsets[0].zw).rgb;\n      delta.y = absMax3(C - Ctop);\n\n      vec2 edges = step(vec2(${t.float(r.threshold)}), delta.xy);\n\n      // discard if there is no edge:\n      if (dot(edges, vec2(1.0)) == 0.0) {\n        discard;\n      }\n\n      // Calculate right and bottom deltas:\n      vec3 Cright = texture(colorTexture, offsets[1].xy).rgb;\n      delta.z = absMax3(C - Cright);\n\n      vec3 Cbottom  = texture(colorTexture, offsets[1].zw).rgb;\n      delta.w = absMax3(C - Cbottom);\n\n      // Calculate the maximum delta in the direct neighborhood:\n      float maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);\n\n      // Calculate left-left and top-top deltas:\n      vec3 Cleftleft  = texture(colorTexture, offsets[2].xy).rgb;\n      delta.z = absMax3(C - Cleftleft);\n\n      vec3 Ctoptop = texture(colorTexture, offsets[2].zw).rgb;\n      delta.w = absMax3(C - Ctoptop);\n\n      // Calculate the final maximum delta:\n      maxDelta = max(max(maxDelta, delta.z), delta.w);\n\n      // Local contrast adaptation in action:\n      edges *= step(maxDelta, float(${t.float(r.localConstrastAdaption)}) * delta.xy);\n\n      fragEdges = edges;\n    }\n  `), l;\n}\nconst s = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  build: l\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nexport { s as E, l as b };"],
  "mappings": ";;;;;;;;;;;;;;;AAQA,IAAM,IAAI;AAAA,EACR,WAAW;AAAA,EACX,wBAAwB;AAC1B;AACA,SAAS,IAAI;AACX,QAAMA,KAAI,IAAIC,GAAE;AAChB,SAAOD,GAAE,QAAQC,EAAC,GAAGD,GAAE,SAAS,SAAS,IAAI,IAAI,EAAE,gBAAgB,OAAK,EAAE,KAAK,CAAC,GAAGA,GAAE,QAAQ,IAAI,aAAa,MAAM,GAAGA,GAAE,SAAS,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAuB9G,EAAE,MAAM,EAAE,SAAS,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sCA4Bb,EAAE,MAAM,EAAE,sBAAsB,CAAC;AAAA;AAAA;AAAA;AAAA,GAIpE,GAAGA;AACN;AACA,IAAME,KAAI,OAAO,OAAO,OAAO,eAAe;AAAA,EAC5C,WAAW;AAAA,EACX,OAAO;AACT,GAAG,OAAO,aAAa;AAAA,EACrB,OAAO;AACT,CAAC,CAAC;",
  "names": ["l", "o", "s"]
}
